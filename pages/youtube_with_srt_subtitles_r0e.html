---
layout: apps
title: YouTube with SRT Subtitles
version: r0e
permalink: /pages/youtube_with_srt_subtitles.html
note: 1. Vibe Coding with Grok 3, 2. with URL parameters videoUrl and subtitleUrl 3. Add Embedded URL generation. 4. Display loaded subtitle filename and add download button. 5. Display base filename below video. 6. Subtitle editing with timestamp control and clip playback and edited subtitle download.
licenced by: Cyber O͘-hîm
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>YouTube with SRT Subtitles</title>
    <link href="https://fonts.googleapis.com/css2?family=Iansui&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #f0f0f0;
            min-height: 100vh;
            padding-bottom: 40px;
        }
        #video-container {
            position: relative;
            width: 100vw;
            height: calc(100vw * 9 / 16);
            max-height: 80vh;
            background-color: #000;
        }
        #player {
            width: 100%;
            height: 100%;
        }
        #subtitle {
            font-size: 24px;
            text-align: center;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            width: 80%;
            max-width: 640px;
            margin: 0 auto;
            border-radius: 5px;
            font-family: 'Iansui', sans-serif;
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            min-height: 1.5em;
            box-sizing: border-box;
        }
        #baseSubtitleNameDisplay {
            font-size: 20px;
            text-align: center;
            color: #444;
            padding: 5px 10px;
            width: 80%;
            max-width: 640px;
            margin: 8px auto 0 auto;
            font-family: 'Iansui', sans-serif;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            display: none;
        }
        #controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 100%;
            max-width: 640px;
            padding: 0 10px;
            box-sizing: border-box;
        }
        .input-group, .srt-group, .url-group, .loaded-subtitle-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            align-items: center;
            width: 100%;
            justify-content: center;
        }
        input[type="text"], input[type="number"] {
            padding: 10px;
            font-size: 16px;
            border: 2px solid #ccc;
            border-radius: 5px;
            outline: none;
            transition: border-color 0.3s;
            box-sizing: border-box;
        }
        input[type="text"] {
            flex-grow: 1;
            min-width: 200px;
            max-width: 300px;
        }
        input[type="number"] {
            width: 80px;
        }
        input[type="text"]:focus, input[type="number"]:focus {
            border-color: #007bff;
        }
        button {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 140px;
            box-sizing: border-box;
            flex-shrink: 0;
        }
        button:hover {
            background-color: #0056b3;
        }
        #srtFile {
            display: none;
        }
        .custom-file-button, .url-upload-button, #downloadSubtitleButton {
            padding: 10px 20px;
            font-size: 16px;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            transition: background-color 0.3s;
            width: 140px;
        }
        .custom-file-button:hover, .url-upload-button:hover, #downloadSubtitleButton:hover {
            background-color: #218838;
        }
        #downloadSubtitleButton {
            background-color: #17a2b8;
            width: auto;
            padding: 10px 15px;
            display: none;
            min-width: 140px;
        }
        #downloadSubtitleButton:hover {
            background-color: #138496;
        }
        #srtFileName {
            padding: 10px;
            font-size: 16px;
            color: #333;
            border: 2px solid #ccc;
            border-radius: 5px;
            flex-grow: 1;
            min-width: 200px;
            max-width: 300px;
            text-align: center;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
            box-sizing: border-box;
            height: 40px;
            line-height: 20px;
            background-color: #eee;
        }
        #embeddedUrlContainer {
            margin-top: 10px;
            width: 100%;
            background-color: #e9ecef;
            padding: 15px;
            border-radius: 5px;
            display: none;
            flex-direction: column;
            align-items: stretch;
            box-sizing: border-box;
        }
        #embeddedUrlTitleContainer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        #embeddedUrlTitle {
            font-size: 16px;
            font-weight: bold;
            color: #333;
        }
        #copyUrlButton {
            padding: 5px 10px;
            font-size: 14px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
            width: auto;
            min-width: 60px;
        }
        #copyUrlButton:hover {
            background-color: #5a6268;
        }
        #copyUrlButton:active {
            background-color: #4e555b;
        }
        #copyUrlButton.copied {
            background-color: #28a745;
        }
        #embeddedUrlTextarea {
            width: 100%;
            padding: 8px;
            font-size: 14px;
            font-family: monospace;
            border: 1px solid #ccc;
            border-radius: 4px;
            background-color: #f8f9fa;
            color: #333;
            resize: none;
            box-sizing: border-box;
            min-height: 60px;
            line-height: 1.4;
            word-wrap: break-word;
            word-break: break-all;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            cursor: default;
        }
        #loadedSubtitleInfoContainer {
            margin-top: 0px;
            width: 100%;
            padding: 10px 0;
            border-radius: 5px;
            display: none;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            box-sizing: border-box;
        }
        #loadedSubtitleFilenameText {
            font-size: 15px;
            color: #333;
            padding: 5px 10px;
            background-color: #f8f9fa;
            border: 1px solid #ccc;
            border-radius: 4px;
            text-align: center;
            overflow-wrap: break-word;
            word-break: break-all;
            max-width: 90%;
            box-sizing: border-box;
        }
        #subtitle-editor-container {
            width: 100%;
            max-width: 640px;
            margin-top: 20px;
            display: none;
            flex-direction: column;
            box-sizing: border-box;
        }
        #subtitle-editor-header {
            padding: 10px 15px;
            background-color: #e9ecef;
            border-radius: 5px 5px 0 0;
            display: flex;
            align-items: center;
            gap: 10px;
            flex-wrap: wrap;
        }
        #subtitle-editor-header span {
            font-size: 16px;
            font-weight: bold;
            flex-grow: 1;
        }
        #subtitle-editor-toggle {
            padding: 5px 10px;
            font-size: 14px;
            background-color: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            width: auto;
            min-width: 100px;
        }
        #subtitle-editor-toggle:hover {
            background-color: #5a6268;
        }
        #subtitle-editor {
            background-color: #fff;
            border-radius: 0 0 5px 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            display: none;
            flex-direction: column;
            box-sizing: border-box;
        }
        #subtitle-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 10px;
        }
        .subtitle-item {
            display: flex;
            align-items: center;
            padding: 8px;
            border-bottom: 1px solid #eee;
            gap: 10px;
            flex-wrap: wrap;
        }
        .subtitle-item input[type="text"] {
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 120px;
        }
        .subtitle-item textarea {
            padding: 5px;
            font-size: 14px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 100%;
            max-width: 400px;
            resize: vertical;
            min-height: 40px;
            box-sizing: border-box;
        }
        .subtitle-item button {
            padding: 5px 10px;
            font-size: 14px;
            width: auto;
            min-width: 60px;
        }
        #subtitle-editor-footer {
            padding: 10px 15px;
            background-color: #e9ecef;
            border-top: 1px solid #ccc;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }
        #download-edited-subtitles {
            background-color: #28a745;
        }
        #download-edited-subtitles:hover {
            background-color: #218838;
        }
        #offset-controls {
            display: flex;
            gap: 15px;
            padding: 10px 15px;
            flex-wrap: wrap;
        }
        .offset-group {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .offset-group label {
            font-size: 14px;
            color: #333;
        }
        details {
            margin-top: 30px;
            margin-bottom: 20px;
            padding: 0;
            background-color: #fff;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
            width: 90%;
            max-width: 640px;
            margin-left: auto;
            margin-right: auto;
        }
        details summary {
            padding: 15px 20px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            list-style: none;
            outline: none;
        }
        details summary::-webkit-details-marker {
            display: none;
        }
        details summary::before {
            content: '► ';
            margin-right: 5px;
        }
        details[open] summary::before {
            content: '▼ ';
        }
        #help {
            padding: 0 20px 20px 20px;
            font-size: 14px;
            line-height: 1.5;
            text-align: left;
        }
        #help h3 {
            margin-top: 0;
            font-size: 16px;
        }
        #help pre {
            background-color: #f8f9fa;
            padding: 10px;
            border-radius: 5px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body>
    <div id="video-container">
        <div id="player"></div>
        <div id="subtitle"></div>
    </div>
    <div id="baseSubtitleNameDisplay"></div>

    <div id="controls">
        <div class="input-group">
            <input type="text" id="youtubeUrl" placeholder="Enter YouTube URL" />
            <button onclick="loadVideo()">Load YT Video</button>
        </div>
        <div class="srt-group">
            <span id="srtFileName">No file selected</span>
            <input type="file" id="srtFile" accept=".srt,.txt" />
            <button class="custom-file-button" onclick="document.getElementById('srtFile').click()">Subtitle from Local</button>
        </div>
        <div class="url-group">
            <input type="text" id="subtitleUrl" placeholder="Enter Subtitle URL (.srt or .txt)" />
            <button class="url-upload-button" onclick="loadSubtitleFromUrl()">Subtitle from URL</button>
        </div>
        <div id="embeddedUrlContainer">
            <div id="embeddedUrlTitleContainer">
                <span id="embeddedUrlTitle">Embedded URL</span>
                <button id="copyUrlButton">Copy</button>
            </div>
            <textarea id="embeddedUrlTextarea" rows="3" readonly title="Visually readable URL (may not function correctly when copied)"></textarea>
        </div>
        <div id="loadedSubtitleInfoContainer">
            <span id="loadedSubtitleFilenameText"></span>
            <button id="downloadSubtitleButton" onclick="downloadOriginalSubtitle()">Download Subtitle</button>
        </div>
    </div>

    <div id="subtitle-editor-container">
        <div id="subtitle-editor-header">
            <span>Subtitle Editor</span>
            <button id="subtitle-editor-toggle">Hide Editor</button>
        </div>
        <div id="subtitle-editor">
            <div id="offset-controls">
                <div class="offset-group">
                    <label for="preview-start-offset">Start Offset:</label>
                    <input type="number" id="preview-start-offset" min="0" step="0.1" value="1" title="Seconds before start time" />
                </div>
                <div class="offset-group">
                    <label for="preview-end-offset">End Offset:</label>
                    <input type="number" id="preview-end-offset" min="0" step="0.1" value="1" title="Seconds after end time" />
                </div>
            </div>
            <div id="subtitle-list"></div>
            <div id="subtitle-editor-footer">
                <button id="download-edited-subtitles">Download Edited Subtitle</button>
            </div>
        </div>
    </div>

    <details>
        <summary>User Guide and Examples</summary>
        <div id="help">
            <h2>[ YouTube with SRT Subtitles ]</h2>
            <h3>Subtitle format is automatically detected from file extension (.txt or .srt).</h3>
            <h3>The subtitle file can be downloaded, corrected, edited in-app, and re-uploaded by you.</h3>
            <h3>
            <strong>URL for Test</strong>
            <pre>
    Video: https://youtu.be/PTJ8yizhoIY?si=JvaNRX3D1idI84Lu
    .txt subtitle: https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/refs/heads/main/assets/test/PTJ8yizhoIY_transcript.txt
    .srt subtitle: https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/refs/heads/main/assets/test/PTJ8yizhoIY_transcript.srt
            </pre>
            <strong>Embedded URL with URL parameters</strong>
            <pre>
    An embedded URL incorporated with a video URL and subtitle URL will be generated automatically once two URLs are input.

    Format: https://cyberoohim.github.io/pages/youtube_with_srt_subtitles.html?videoUrl={YouTube URL}&subtitleUrl={Subtitle URL}

    Example (showing readable parameters):
    https://cyberoohim.github.io/pages/youtube_with_srt_subtitles.html?videoUrl=https://youtu.be/PTJ8yizhoIY?si=JvaNRX3D1idI84Lu&subtitleUrl=https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/refs/heads/main/assets/test/PTJ8yizhoIY_transcript.srt
            </pre>
            <strong>.txt (with timestamps)</strong>
            <pre>
[0:00] welcome back to the AI Daily Brief every
[0:02] day it feels like a million new cool AI
[0:04] startups launch so much so that it's
[0:07] actually pretty rare that we dig deep
[0:08] and cover brand new companies on this
            </pre>
            <strong>.srt</strong>
            <pre>
1
00:00:00,000 --> 00:00:02,000
welcome back to the AI Daily Brief every

2
00:00:02,000 --> 00:00:04,000
day it feels like a million new cool AI
            </pre>
            </h3>
        </div>
    </details>

    <script src="https://www.youtube.com/iframe_api"></script>
    <script>
        let player;
        let subtitles = [];
        const BASE_EMBED_URL = "https://cyberoohim.github.io/pages/youtube_with_srt_subtitles.html";
        let copyTimeout = null;
        let originalSubtitleContent = null;
        let originalSubtitleFilename = null;
        let subtitleSourceType = null;
        let subtitleFormat = null;
        let PREVIEW_START_OFFSET = 1;
        let PREVIEW_END_OFFSET = 1;
        let playbackInterval = null;

        function onYouTubeIframeAPIReady() {
            loadFromUrlParams();
        }

        function loadVideo() {
            const url = document.getElementById('youtubeUrl').value.trim();
            if (!url) { alert('Please enter a YouTube URL'); return; }
            const videoId = extractVideoId(url);
            if (!videoId) { alert('Invalid YouTube URL'); return; }

            if (player) {
                player.loadVideoById(videoId);
            } else {
                player = new YT.Player('player', {
                    height: '100%', width: '100%', videoId: videoId,
                    playerVars: { 'playsinline': 1 },
                    events: { 'onReady': onPlayerReady, 'onStateChange': onPlayerStateChange }
                });
            }
            updateEmbeddedUrlDisplay();
        }

        function extractVideoId(url) {
            let videoId = null;
            const patterns = [
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/watch\?.*v=([^&]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtu\.be\/([^?]+)/,
                /(?:https?:\/\/)?(?:www\.)?youtube\.com\/embed\/([^?]+)/
            ];
            for (const pattern of patterns) {
                const match = url.match(pattern);
                if (match && match[1]) { videoId = match[1]; break; }
            }
            if (videoId && videoId.length >= 11) {
                videoId = videoId.split('&')[0];
                if (/^[a-zA-Z0-9_-]+$/.test(videoId)) { return videoId; }
            }
            return null;
        }

        function onPlayerReady(event) { setInterval(updateSubtitles, 100); }
        function onPlayerStateChange(event) {}

        function parseSRT(srtContent) {
            subtitles = [];
            const lines = srtContent.replace(/\r/g, '').trim().split('\n\n');
            for (const block of lines) {
                const blockParts = block.split('\n');
                if (blockParts.length >= 3) {
                    const time = blockParts[1];
                    const textLines = blockParts.slice(2);
                    const timeMatch = time.match(/(\d{2}:\d{2}:\d{2}[,.]\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2}[,.]\d{3})/);
                    if (timeMatch) {
                        const [_, start, end] = timeMatch;
                        subtitles.push({ start: timeToSeconds(start), end: timeToSeconds(end), text: textLines.join(' ').trim() });
                    } else { console.warn("Skipping invalid SRT time format:", time); }
                } else if (block.trim()) { console.warn("Skipping invalid SRT block:", block); }
            }
            console.log(`Parsed ${subtitles.length} subtitle entries.`);
            updateLoadedSubtitleDisplay();
            updateBaseSubtitleNameDisplay();
            renderSubtitleEditor();
        }

        function convertTxtToSrt(txtContent) {
            subtitles = [];
            const pattern = /\[(\d{1,2}):(\d{2})(?:[.,](\d{1,3}))?\]\s*(.*)/g;
            const matches = [...txtContent.matchAll(pattern)];
            let lastEndTimeSeconds = -1;
            for (let i = 0; i < matches.length; i++) {
                const [_, minutes, seconds, ms, text] = matches[i];
                const currentStartTimeSeconds = parseInt(minutes) * 60 + parseInt(seconds) + (ms ? parseInt(ms.padEnd(3, '0')) / 1000 : 0);
                if (currentStartTimeSeconds < lastEndTimeSeconds && i > 0) {
                    console.warn(`Timestamp out of order or overlapping, skipping: ${matches[i][0]}`);
                    continue;
                }
                let endTimeSeconds;
                if (i < matches.length - 1) {
                    const [nextFull, nextMin, nextSec, nextMs] = matches[i + 1];
                    const nextStartTimeSeconds = parseInt(nextMin) * 60 + parseInt(nextSec) + (nextMs ? parseInt(nextMs.padEnd(3, '0')) / 1000 : 0);
                    endTimeSeconds = nextStartTimeSeconds > currentStartTimeSeconds ? nextStartTimeSeconds : currentStartTimeSeconds + 2.0;
                } else {
                    endTimeSeconds = currentStartTimeSeconds + 5;
                }
                if (endTimeSeconds <= currentStartTimeSeconds) {
                    endTimeSeconds = currentStartTimeSeconds + 0.1;
                }
                subtitles.push({ start: currentStartTimeSeconds, end: endTimeSeconds, text: text.trim() });
                lastEndTimeSeconds = endTimeSeconds;
            }
            console.log(`Parsed ${subtitles.length} subtitle entries from TXT.`);
            updateLoadedSubtitleDisplay();
            updateBaseSubtitleNameDisplay();
            renderSubtitleEditor();
        }

        function timeToSeconds(time) {
            if (time.startsWith('[')) {
                const match = time.match(/\[(\d+):(\d{2})(?:[.,](\d{1,3}))?\]/);
                if (match) {
                    const [_, minutes, seconds, ms] = match;
                    return parseInt(minutes) * 60 + parseInt(seconds) + (ms ? parseInt(ms.padEnd(3, '0')) / 1000 : 0);
                }
            } else {
                const parts = time.replace(',', '.').split(':');
                if (parts.length === 3) {
                    const [hours, minutes, seconds] = parts;
                    return parseInt(hours) * 3600 + parseInt(minutes) * 60 + parseFloat(seconds);
                }
            }
            return 0;
        }

        function secondsToTime(seconds, format = 'srt') {
            if (format === 'txt') {
                const minutes = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `[${minutes}:${String(secs).padStart(2, '0')}]`;
            } else {
                const hours = Math.floor(seconds / 3600);
                const minutes = Math.floor((seconds % 3600) / 60);
                const secs = Math.floor(seconds % 60);
                const milliseconds = Math.round((seconds - Math.floor(seconds)) * 1000);
                return `${String(hours).padStart(2, '0')}:${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')},${String(milliseconds).padStart(3, '0')}`;
            }
        }

        function updateSubtitles() {
            if (!player || typeof player.getCurrentTime !== 'function' || !subtitles.length) {
                document.getElementById('subtitle').textContent = '';
                return;
            }
            try {
                const currentTime = player.getCurrentTime();
                const currentSubtitle = subtitles.find(s => currentTime >= s.start && currentTime <= s.end);
                document.getElementById('subtitle').textContent = currentSubtitle ? currentSubtitle.text : '';
            } catch (error) {
                if (error.message !== "Cannot read properties of null (reading 'getCurrentTime')" &&
                    !error.message.includes("player.getCurrentTime is not a function")) {
                    console.error("Error updating subtitles:", error);
                }
                document.getElementById('subtitle').textContent = '';
            }
        }

        function clearSubtitles(isFileUpload = false) {
            subtitles = [];
            originalSubtitleContent = null;
            originalSubtitleFilename = null;
            subtitleSourceType = null;
            subtitleFormat = null;
            document.getElementById('subtitle').textContent = '';
            if (!isFileUpload) { document.getElementById('subtitleUrl').value = ''; }
            document.getElementById('srtFileName').textContent = 'No file selected';
            document.getElementById('srtFile').value = null;
            updateEmbeddedUrlDisplay();
            updateLoadedSubtitleDisplay();
            updateBaseSubtitleNameDisplay();
            document.getElementById('subtitle-editor-container').style.display = 'none';
            document.getElementById('subtitle-editor').style.display = 'none';
        }

        document.getElementById('srtFile').addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                clearSubtitles(true);
                document.getElementById('srtFileName').textContent = `Processing: ${file.name}`;
                document.getElementById('subtitleUrl').value = '';

                originalSubtitleFilename = file.name;
                subtitleSourceType = 'local';
                subtitleFormat = detectSubtitleFormat(file.name);

                const reader = new FileReader();
                reader.onload = (e) => {
                    originalSubtitleContent = e.target.result;
                    try {
                        if (subtitleFormat === 'txt') {
                            convertTxtToSrt(originalSubtitleContent);
                        } else if (subtitleFormat === 'srt') {
                            parseSRT(originalSubtitleContent);
                        } else {
                            throw new Error('Unsupported file format. Please use .srt or .txt');
                        }
                        if (!subtitles.length && originalSubtitleContent.trim()) {
                            throw new Error("Could not parse any valid subtitle entries from the file.");
                        }
                        document.getElementById('srtFileName').textContent = 'Loaded from Local';
                    } catch (parseError) {
                        alert(`Error processing file "${file.name}":\n${parseError.message}`);
                        console.error(parseError);
                        clearSubtitles(true);
                    } finally {
                        updateEmbeddedUrlDisplay(true);
                        updateLoadedSubtitleDisplay();
                        updateBaseSubtitleNameDisplay();
                    }
                };
                reader.onerror = (e) => {
                    alert(`Error reading file: ${e.target.error}`);
                    clearSubtitles(true);
                };
                reader.readAsText(file);
            }
        });

        function loadSubtitleFromUrl() {
            const url = document.getElementById('subtitleUrl').value.trim();
            if (!url) { alert('Please enter a subtitle URL'); return; }
            try { new URL(url); } catch (_) { alert('Invalid Subtitle URL format.'); return; }
            clearSubtitles();
            document.getElementById('subtitleUrl').value = url;
            loadSubtitleFromUrlInternal(url);
        }

        function loadSubtitleFromUrlInternal(url) {
            document.getElementById('srtFileName').textContent = `Fetching: ${url.substring(url.lastIndexOf('/') + 1)}`;
            originalSubtitleFilename = url;
            subtitleSourceType = 'url';
            subtitleFormat = detectSubtitleFormat(url);

            fetch(url)
                .then(response => {
                    if (!response.ok) { throw new Error(`HTTP error! Status: ${response.status}`); }
                    return response.text();
                })
                .then(content => {
                    originalSubtitleContent = content;
                    if (!originalSubtitleContent || originalSubtitleContent.trim() === '') {
                        throw new Error("Fetched content is empty or whitespace only.");
                    }
                    document.getElementById('srtFileName').textContent = 'Loaded from URL';
                    try {
                        if (subtitleFormat === 'txt') {
                            convertTxtToSrt(originalSubtitleContent);
                        } else if (subtitleFormat === 'srt') {
                            parseSRT(originalSubtitleContent);
                        } else {
                            console.warn("Unknown subtitle format from URL, attempting to parse as SRT.");
                            parseSRT(originalSubtitleContent);
                        }
                        if (!subtitles.length && originalSubtitleContent.trim()) {
                            throw new Error("Could not parse any valid subtitle entries from the URL content.");
                        }
                        updateEmbeddedUrlDisplay();
                    } catch (parseError) {
                        alert(`Error processing subtitle from URL "${url}":\n${parseError.message}`);
                        console.error(parseError);
                        clearSubtitles();
                    }
                    updateLoadedSubtitleDisplay();
                    updateBaseSubtitleNameDisplay();
                })
                .catch(error => {
                    alert(`Error fetching or processing subtitle URL:\n${error.message}`);
                    console.error(error);
                    clearSubtitles();
                });
        }

        function detectSubtitleFormat(filenameOrUrl) {
            if (!filenameOrUrl) return null;
            const lower = filenameOrUrl.toLowerCase();
            const path = lower.split('?')[0];
            if (path.endsWith('.srt')) return 'srt';
            if (path.endsWith('.txt')) return 'txt';
            return null;
        }

        function updateLoadedSubtitleDisplay() {
            const container = document.getElementById('loadedSubtitleInfoContainer');
            const textElement = document.getElementById('loadedSubtitleFilenameText');
            const downloadButton = document.getElementById('downloadSubtitleButton');

            if (originalSubtitleFilename && subtitleSourceType && originalSubtitleContent) {
                const prefix = subtitleSourceType === 'local' ? '[Local] ' : '[URL] ';
                let displayFilename = originalSubtitleFilename;
                if (subtitleSourceType === 'url') {
                    try {
                        const urlParts = displayFilename.split('?')[0].split('/');
                        displayFilename = urlParts[urlParts.length - 1] || displayFilename.replace(/^https?:\/\//, '');
                    } catch (e) {
                        console.error("Error extracting filename from URL:", e);
                        displayFilename = displayFilename.replace(/^https?:\/\//, '');
                    }
                }
                textElement.textContent = prefix + displayFilename;
                textElement.title = prefix + originalSubtitleFilename;
                downloadButton.style.display = 'inline-block';
                container.style.display = 'flex';
            } else {
                textElement.textContent = '';
                textElement.title = '';
                downloadButton.style.display = 'none';
                container.style.display = 'none';
            }
        }

        function updateBaseSubtitleNameDisplay() {
            const displayElement = document.getElementById('baseSubtitleNameDisplay');
            if (originalSubtitleFilename && subtitleSourceType) {
                try {
                    let filename = originalSubtitleFilename;
                    if (subtitleSourceType === 'url') {
                        const urlParts = filename.split('?')[0].split('/');
                        filename = urlParts[urlParts.length - 1];
                    }
                    const baseName = filename.replace(/\.(srt|txt)$/i, '');
                    displayElement.textContent = baseName || '[Subtitle Loaded]';
                    displayElement.title = baseName;
                    displayElement.style.display = 'block';
                } catch (e) {
                    console.error("Error extracting base filename:", e);
                    displayElement.textContent = '[Subtitle Loaded]';
                    displayElement.style.display = 'block';
                }
            } else {
                displayElement.textContent = '';
                displayElement.style.display = 'none';
            }
        }

        function downloadOriginalSubtitle() {
            if (!originalSubtitleContent || !originalSubtitleFilename) {
                alert("No subtitle content available to download.");
                return;
            }
            try {
                const blob = new Blob([originalSubtitleContent], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = originalSubtitleFilename.split('/').pop();
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (e) {
                alert("Error creating download link: " + e.message);
                console.error("Download error:", e);
            }
        }

        function updateEmbeddedUrlDisplay(isLocalFile = false) {
            const videoUrlInput = document.getElementById('youtubeUrl');
            const subtitleUrlInput = document.getElementById('subtitleUrl');
            const container = document.getElementById('embeddedUrlContainer');
            const textarea = document.getElementById('embeddedUrlTextarea');
            const copyButton = document.getElementById('copyUrlButton');

            const videoUrlValue = videoUrlInput.value.trim();
            const subtitleUrlValue = subtitleUrlInput.value.trim();

            if (!isLocalFile && videoUrlValue && subtitleUrlValue && extractVideoId(videoUrlValue) && subtitleSourceType === 'url') {
                try {
                    new URL(subtitleUrlValue);
                    const readableEmbedUrl = `${BASE_EMBED_URL}?videoUrl=${videoUrlValue}&subtitleUrl=${subtitleUrlValue}`;
                    textarea.value = readableEmbedUrl;
                    container.style.display = 'flex';
                    container.style.display = 'flex';
                    copyButton.disabled = false;
                } catch (_) {
                    container.style.display = 'none';
                    textarea.value = '';
                    copyButton.disabled = true;
                }
            } else {
                container.style.display = 'none';
                textarea.value = '';
                copyButton.disabled = true;
            }
            resetCopyButtonState(copyButton);
        }

        function copyUrlToClipboard() {
            const textarea = document.getElementById('embeddedUrlTextarea');
            const copyButton = document.getElementById('copyUrlButton');
            const videoUrlValue = document.getElementById('youtubeUrl').value.trim();
            const subtitleUrlValue = document.getElementById('subtitleUrl').value.trim();

            if (!videoUrlValue || !subtitleUrlValue || !navigator.clipboard) {
                alert("Cannot copy URL. Video or Subtitle URL missing, or Clipboard API not available.");
                return;
            }

            const encodedVideoUrl = encodeURIComponent(videoUrlValue);
            const encodedSubtitleUrl = encodeURIComponent(subtitleUrlValue);
            const urlToCopy = `${BASE_EMBED_URL}?videoUrl=${encodedVideoUrl}&subtitleUrl=${encodedSubtitleUrl}`;

            navigator.clipboard.writeText(urlToCopy).then(() => {
                console.log('Encoded URL copied to clipboard!', urlToCopy);
                copyButton.textContent = 'Copied!';
                copyButton.classList.add('copied');
                copyButton.disabled = true;
                clearTimeout(copyTimeout);
                copyTimeout = setTimeout(() => { resetCopyButtonState(copyButton); }, 2000);
            }).catch(err => {
                console.error('Failed to copy URL: ', err);
                alert('Failed to copy URL. Please try copying manually.');
                resetCopyButtonState(copyButton);
            });
        }

        function resetCopyButtonState(button) {
            button.textContent = 'Copy';
            button.classList.remove('copied');
            button.disabled = (document.getElementById('embeddedUrlContainer').style.display === 'none');
        }

        function loadFromUrlParams() {
            const urlParams = new URLSearchParams(window.location.search);
            const videoUrlParam = urlParams.get('videoUrl');
            const subtitleUrlParam = urlParams.get('subtitleUrl');
            let videoIsLoading = false;

            if (videoUrlParam) {
                const decodedVideoUrl = decodeURIComponent(videoUrlParam);
                document.getElementById('youtubeUrl').value = decodedVideoUrl;
                const videoId = extractVideoId(decodedVideoUrl);
                if (videoId) {
                    videoIsLoading = true;
                    const loadSubtitleAfterVideo = () => {
                        if (subtitleUrlParam) {
                            const decodedSubtitleUrl = decodeURIComponent(subtitleUrlParam);
                            document.getElementById('subtitleUrl').value = decodedSubtitleUrl;
                            loadSubtitleFromUrlInternal(decodedSubtitleUrl);
                        } else {
                            updateEmbeddedUrlDisplay();
                            updateLoadedSubtitleDisplay();
                            updateBaseSubtitleNameDisplay();
                        }
                    };

                    if (!player) {
                        player = new YT.Player('player', {
                            height: '100%', width: '100%', videoId: videoId,
                            playerVars: { 'playsinline': 1 },
                            events: {
                                'onReady': () => {
                                    onPlayerReady();
                                    loadSubtitleAfterVideo();
                                },
                                'onStateChange': onPlayerStateChange
                            }
                        });
                    } else {
                        player.loadVideoById(videoId);
                        loadSubtitleAfterVideo();
                    }
                } else {
                    console.warn("Invalid videoUrl parameter:", decodedVideoUrl);
                    alert("Invalid video URL in page parameters.");
                    videoIsLoading = false;
                }
            }

            if (subtitleUrlParam && !videoIsLoading) {
                const decodedSubtitleUrl = decodeURIComponent(subtitleUrlParam);
                document.getElementById('subtitleUrl').value = decodedSubtitleUrl;
                clearSubtitles();
                loadSubtitleFromUrlInternal(decodedSubtitleUrl);
            }

            if (!videoUrlParam && !subtitleUrlParam) {
                updateEmbeddedUrlDisplay();
                updateLoadedSubtitleDisplay();
                updateBaseSubtitleNameDisplay();
            } else if (videoUrlParam && !subtitleUrlParam && !videoIsLoading) {
                updateEmbeddedUrlDisplay();
                updateLoadedSubtitleDisplay();
                updateBaseSubtitleNameDisplay();
            }
        }

        // Subtitle Editor Functions
        function renderSubtitleEditor() {
            const subtitleList = document.getElementById('subtitle-list');
            subtitleList.innerHTML = '';
            subtitles.forEach((subtitle, index) => {
                const item = document.createElement('div');
                item.className = 'subtitle-item';
                item.innerHTML = `
                    <input type="text" value="${secondsToTime(subtitle.start, subtitleFormat)}" onchange="updateTimestamp(${index}, 'start', this.value)" placeholder="Start time">
                    <input type="text" value="${secondsToTime(subtitle.end, subtitleFormat)}" onchange="updateTimestamp(${index}, 'end', this.value)" placeholder="End time">
                    <textarea onchange="updateSubtitleText(${index}, this.value)">${subtitle.text}</textarea>
                    <button onclick="playSubtitleClip(${index})">Play</button>
                `;
                subtitleList.appendChild(item);
            });
            document.getElementById('subtitle-editor-container').style.display = subtitles.length ? 'flex' : 'none';
            document.getElementById('subtitle-editor').style.display = 'flex';
            document.getElementById('subtitle-editor-toggle').textContent = 'Hide Editor';
        }

        function updateTimestamp(index, field, value) {
            try {
                let seconds;
                if (subtitleFormat === 'txt') {
                    const match = value.match(/\[(\d+):(\d{2})(?:[.,](\d{1,3}))?\]/);
                    if (!match) throw new Error("Invalid TXT time format, use [MM:SS]");
                    const [_, minutes, secs, ms] = match;
                    seconds = parseInt(minutes) * 60 + parseInt(secs) + (ms ? parseInt(ms.padEnd(3, '0')) / 1000 : 0);
                } else {
                    seconds = timeToSeconds(value);
                }
                if (isNaN(seconds) || seconds < 0) {
                    throw new Error("Invalid time format");
                }
                subtitles[index][field] = seconds;
                // Validate timestamps
                if (field === 'start' && index < subtitles.length - 1 && seconds >= subtitles[index + 1].start) {
                    alert("Start time cannot be after or equal to the next subtitle's start time.");
                    subtitles[index].start = timeToSeconds(secondsToTime(subtitles[index].start, subtitleFormat));
                    renderSubtitleEditor();
                    return;
                }
                if (field === 'end' && seconds <= subtitles[index].start) {
                    alert("End time must be after start time.");
                    subtitles[index].end = timeToSeconds(secondsToTime(subtitles[index].end, subtitleFormat));
                    renderSubtitleEditor();
                    return;
                }
                if (field === 'start' && player) {
                    const startTime = Math.max(0, subtitles[index].start - PREVIEW_START_OFFSET);
                    player.seekTo(startTime, true);
                    player.playVideo();
                    clearInterval(playbackInterval);
                    playbackInterval = setInterval(() => {
                        if (player.getCurrentTime() >= subtitles[index].end + PREVIEW_END_OFFSET) {
                            player.pauseVideo();
                            clearInterval(playbackInterval);
                            playbackInterval = null;
                        }
                    }, 50);
                }
                subtitles.sort((a, b) => a.start - b.start);
                renderSubtitleEditor();
            } catch (e) {
                alert(`Invalid time format: ${e.message}`);
                renderSubtitleEditor();
            }
        }

        function updateSubtitleText(index, value) {
            subtitles[index].text = value.trim();
        }

        function playSubtitleClip(index) {
            if (!player) return;
            const startTime = Math.max(0, subtitles[index].start - PREVIEW_START_OFFSET);
            const endTime = index < subtitles.length - 1 ? subtitles[index].end + PREVIEW_END_OFFSET : subtitles[index].end + PREVIEW_END_OFFSET;
            player.seekTo(startTime, true);
            player.playVideo();
            clearInterval(playbackInterval);
            playbackInterval = setInterval(() => {
                if (player.getCurrentTime() >= endTime) {
                    player.pauseVideo();
                    clearInterval(playbackInterval);
                    playbackInterval = null;
                }
            }, 50);
        }

        function downloadEditedSubtitles() {
            if (!subtitles.length || !subtitleFormat) {
                alert("No subtitles available to download.");
                return;
            }
            let content = '';
            try {
                if (subtitleFormat === 'srt') {
                    subtitles.forEach((subtitle, index) => {
                        content += `${index + 1}\n${secondsToTime(subtitle.start, 'srt')} --> ${secondsToTime(subtitle.end, 'srt')}\n${subtitle.text}\n\n`;
                    });
                } else if (subtitleFormat === 'txt') {
                    subtitles.forEach(subtitle => {
                        content += `${secondsToTime(subtitle.start, 'txt')} ${subtitle.text}\n`;
                    });
                }
                if (!content.trim()) {
                    throw new Error("Generated subtitle content is empty.");
                }
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                const ext = subtitleFormat === 'srt' ? 'srt' : 'txt';
                let filenameBase = 'edited_subtitle';
                if (originalSubtitleFilename) {
                    filenameBase = originalSubtitleFilename.split('/').pop().replace(/\.(srt|txt)$/i, '');
                }
                a.download = `${filenameBase}_edited.${ext}`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (e) {
                alert(`Error downloading subtitles: ${e.message}`);
                console.error("Download error:", e);
            }
        }

        // Event Listeners for Offset Inputs
        document.addEventListener('DOMContentLoaded', () => {
            const startOffsetInput = document.getElementById('preview-start-offset');
            const endOffsetInput = document.getElementById('preview-end-offset');
            if (startOffsetInput) {
                startOffsetInput.addEventListener('change', () => {
                    const value = parseFloat(startOffsetInput.value);
                    if (!isNaN(value) && value >= 0) {
                        PREVIEW_START_OFFSET = value;
                    } else {
                        startOffsetInput.value = PREVIEW_START_OFFSET;
                        alert("Please enter a non-negative number for start offset.");
                    }
                });
            }
            if (endOffsetInput) {
                endOffsetInput.addEventListener('change', () => {
                    const value = parseFloat(endOffsetInput.value);
                    if (!isNaN(value) && value >= 0) {
                        PREVIEW_END_OFFSET = value;
                    } else {
                        endOffsetInput.value = PREVIEW_END_OFFSET;
                        alert("Please enter a non-negative number for end offset.");
                    }
                });
            }

            const toggleButton = document.getElementById('subtitle-editor-toggle');
            if (toggleButton) {
                toggleButton.addEventListener('click', () => {
                    const editor = document.getElementById('subtitle-editor');
                    const isVisible = editor.style.display === 'flex';
                    editor.style.display = isVisible ? 'none' : 'flex';
                    toggleButton.textContent = isVisible ? 'Show Editor' : 'Hide Editor';
                });
            }

            const downloadButton = document.getElementById('download-edited-subtitles');
            if (downloadButton) {
                downloadButton.addEventListener('click', downloadEditedSubtitles);
            }

            const copyButton = document.getElementById('copyUrlButton');
            if (copyButton) {
                copyButton.addEventListener('click', copyUrlToClipboard);
            }
            updateLoadedSubtitleDisplay();
            updateBaseSubtitleNameDisplay();
            updateEmbeddedUrlDisplay();
        });
    </script>
</body>
</html>