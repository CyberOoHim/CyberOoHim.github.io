---
layout: apps
title: JSON/YAML Graph Visualizer
version: v0.1
permalink: /pages/json-yaml-graph.html
---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JSON/YAML Graph Visualizer</title>
    <script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-link: #58a6ff;
            --text-accent: #238636;
            --text-danger: #f85149;
            --border-color: #30363d;
            --font-sans: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
            --font-mono: 'SFMono-Regular', Consolas, 'Liberation Mono', Menlo, monospace;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: var(--font-sans);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        .header {
            padding: 16px 24px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 12px;
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
        }

        .controls {
            display: flex;
            align-items: center;
            gap: 16px;
            flex-wrap: wrap;
        }

        select,
        button,
        input {
            padding: 8px 14px;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        select:hover,
        button:hover {
            border-color: var(--text-secondary);
        }

        button.primary {
            background: var(--text-link);
            border-color: var(--text-link);
            color: #fff;
        }

        button.primary:hover {
            background: #1f6feb;
        }

        button.success {
            background: var(--text-accent);
            border-color: var(--text-accent);
            color: #fff;
        }

        button.danger {
            background: transparent;
            border-color: var(--text-danger);
            color: var(--text-danger);
            padding: 4px 8px;
            font-size: 0.75rem;
        }

        button.danger:hover {
            background: rgba(248, 81, 73, 0.2);
        }

        .checkbox-group {
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }

        .checkbox-group input[type="checkbox"] {
            width: 16px;
            height: 16px;
            accent-color: var(--text-link);
        }

        .main {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        .panel {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-right: 1px solid var(--border-color);
            min-width: 0;
        }

        .panel:last-child {
            border-right: none;
        }

        .panel-header {
            padding: 10px 16px;
            background: var(--bg-tertiary);
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .panel-content {
            flex: 1;
            overflow: auto;
            padding: 16px;
        }

        textarea {
            width: 100%;
            height: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            border: none;
            font-family: var(--font-mono);
            font-size: 0.9rem;
            line-height: 1.5;
            resize: none;
            outline: none;
        }

        /* Graph Styles */
        .graph-container {
            padding: 20px;
        }

        .tree-node {
            margin-left: 20px;
            position: relative;
        }

        .tree-node::before {
            content: '';
            position: absolute;
            left: -14px;
            top: 0;
            height: 100%;
            border-left: 1px dashed var(--border-color);
        }

        .tree-node:last-child::before {
            height: 12px;
        }

        .node-row {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 4px 0;
            position: relative;
        }

        .node-row::before {
            content: '';
            position: absolute;
            left: -14px;
            top: 12px;
            width: 10px;
            border-top: 1px dashed var(--border-color);
        }

        .toggle-btn,
        .action-btn {
            width: 18px;
            height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            flex-shrink: 0;
            padding: 0;
        }

        .toggle-btn:hover,
        .action-btn:hover {
            background: var(--bg-secondary);
            color: var(--text-primary);
        }

        .toggle-btn.leaf {
            visibility: hidden;
        }

        .action-btn.add {
            color: var(--text-accent);
            border-color: var(--text-accent);
        }

        .action-btn.add:hover {
            background: rgba(35, 134, 54, 0.2);
        }

        .action-btn.delete {
            color: var(--text-danger);
            border-color: transparent;
            background: transparent;
        }

        .action-btn.delete:hover {
            background: rgba(248, 81, 73, 0.2);
            border-color: var(--text-danger);
        }

        .node-key {
            color: var(--text-link);
            font-weight: 600;
            font-family: var(--font-mono);
            font-size: 0.9rem;
        }

        .node-separator {
            color: var(--text-secondary);
        }

        .node-value {
            color: var(--text-accent);
            font-family: var(--font-mono);
            font-size: 0.9rem;
        }

        .node-value.string {
            color: #a5d6ff;
        }

        .node-value.number {
            color: #79c0ff;
        }

        .node-value.boolean {
            color: #ff7b72;
        }

        .node-value.null {
            color: var(--text-secondary);
            font-style: italic;
        }

        .node-type {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-left: 8px;
        }

        .children {
            display: block;
        }

        .children.collapsed {
            display: none;
        }

        .root-container>.tree-node {
            margin-left: 0;
        }

        .root-container>.tree-node::before {
            display: none;
        }

        .root-container>.tree-node>.node-row::before {
            display: none;
        }

        .error-message {
            color: #f85149;
            padding: 12px;
            background: rgba(248, 81, 73, 0.1);
            border: 1px solid rgba(248, 81, 73, 0.3);
            border-radius: 6px;
            font-family: var(--font-mono);
            font-size: 0.85rem;
        }

        .hidden {
            display: none !important;
        }

        /* Add Form Styles */
        .add-form {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            padding: 8px;
            margin: 4px 0 4px 20px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            align-items: center;
        }

        .add-form input {
            padding: 6px 10px;
            font-size: 0.85rem;
            min-width: 100px;
        }

        .add-form select {
            padding: 6px 10px;
            font-size: 0.85rem;
        }

        .add-form button {
            padding: 6px 12px;
            font-size: 0.85rem;
        }

        .add-form .form-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
        }

        /* Visual Graph Mode */
        .visual-canvas {
            position: relative;
            width: 100%;
            height: 100%;
            min-height: 600px;
            overflow: auto;
            background:
                radial-gradient(circle at 1px 1px, var(--border-color) 1px, transparent 0);
            background-size: 20px 20px;
        }

        .visual-canvas svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
        }

        .visual-canvas svg path {
            pointer-events: stroke;
            cursor: pointer;
        }

        .visual-canvas svg path:hover {
            stroke: var(--text-danger);
            stroke-width: 3;
        }

        .visual-node {
            position: absolute;
            background: var(--bg-secondary);
            border: 2px solid var(--border-color);
            border-radius: 8px;
            min-width: 120px;
            max-width: 200px;
            z-index: 10;
            cursor: grab;
            user-select: none;
            transition: box-shadow 0.2s, border-color 0.2s;
        }

        .visual-node:hover {
            border-color: var(--text-link);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }

        .visual-node.dragging {
            cursor: grabbing;
            z-index: 100;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
        }

        .visual-node-header {
            padding: 8px 10px;
            background: var(--bg-tertiary);
            border-radius: 6px 6px 0 0;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            font-weight: 600;
            color: var(--text-link);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .visual-node-content {
            padding: 8px 10px;
            font-family: var(--font-mono);
            font-size: 0.8rem;
            color: var(--text-primary);
            word-break: break-word;
        }

        .visual-node-content.string {
            color: #a5d6ff;
        }

        .visual-node-content.number {
            color: #79c0ff;
        }

        .visual-node-content.boolean {
            color: #ff7b72;
        }

        .visual-node-content.null {
            color: var(--text-secondary);
            font-style: italic;
        }

        .visual-node-content.type {
            color: var(--text-secondary);
        }

        .visual-node-actions {
            display: flex;
            gap: 4px;
        }

        .visual-node-actions button {
            width: 20px;
            height: 20px;
            padding: 0;
            font-size: 12px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .connector-dot {
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--text-link);
            border: 2px solid var(--bg-primary);
            border-radius: 50%;
            cursor: crosshair;
            z-index: 20;
        }

        .connector-dot.output {
            right: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector-dot.input {
            left: -6px;
            top: 50%;
            transform: translateY(-50%);
        }

        .connector-dot:hover {
            background: var(--text-accent);
            transform: translateY(-50%) scale(1.3);
        }

        .connection-temp {
            stroke: var(--text-link);
            stroke-width: 2;
            stroke-dasharray: 5, 5;
            fill: none;
        }

        @media (max-width: 768px) {
            .main {
                flex-direction: column;
            }

            .panel {
                border-right: none;
                border-bottom: 1px solid var(--border-color);
                min-height: 300px;
            }
        }

        .panel-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .copy-btn {
            background: transparent;
            border: 1px solid var(--border-color);
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 6px;
            font-size: 0.8rem;
            border-radius: 4px;
        }

        .copy-btn:hover {
            color: var(--text-primary);
            border-color: var(--text-primary);
            background: var(--bg-tertiary);
        }

        .visual-node-header {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .visual-toggle {
            width: 14px;
            height: 14px;
            background: var(--bg-secondary);
            border: 1px solid var(--border-color);
            border-radius: 2px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            line-height: 1;
            cursor: pointer;
            color: var(--text-secondary);
            padding-bottom: 2px;
            /* visual alignment */
        }

        .visual-toggle:hover {
            color: var(--text-primary);
            border-color: var(--text-accent);
        }
    </style>
</head>

<body>
    <div class="header">
        <h1>JSON/YAML Graph Visualizer</h1>
        <div class="controls">
            <select id="viewMode">
                <option value="json-graph">JSON ‚Üî Graph</option>
                <option value="yaml-graph">YAML ‚Üî Graph</option>
                <option value="json-yaml">JSON ‚Üî YAML</option>
                <option value="visual-graph">Visual Node Graph</option>
            </select>
            <div class="checkbox-group">
                <input type="checkbox" id="expandAll" checked>
                <label for="expandAll">Expand All</label>
            </div>
            <input type="file" id="fileUpload" accept=".json,.yaml,.yml" style="display: none;">
            <button id="uploadBtn" title="Upload JSON or YAML">‚¨Ü Upload</button>
            <button id="undoBtn" disabled title="Undo (Ctrl+Z)">‚Ü∂ Undo</button>
            <button id="redoBtn" disabled title="Redo (Ctrl+Y)">‚Ü∑ Redo</button>
            <button id="downloadJson">‚¨á JSON</button>
            <button id="downloadYaml">‚¨á YAML</button>
            <button id="downloadPng" class="primary">‚¨á PNG</button>
        </div>
    </div>

    <div class="main">
        <div class="panel" id="jsonPanel">
            <div class="panel-header">
                <span>JSON</span>
                <button class="copy-btn" data-target="jsonEditor">üìã Copy</button>
            </div>
            <div class="panel-content">
                <textarea id="jsonEditor" spellcheck="false">{
  "name": "Example Project",
  "version": "1.0.0",
  "config": {
    "enabled": true,
    "maxItems": 100,
    "features": ["auth", "api", "dashboard"]
  },
  "users": [
    { "id": 1, "name": "Alice" },
    { "id": 2, "name": "Bob" }
  ]
}</textarea>
            </div>
        </div>

        <div class="panel" id="yamlPanel">
            <div class="panel-header">
                <span>YAML</span>
                <button class="copy-btn" data-target="yamlEditor">üìã Copy</button>
            </div>
            <div class="panel-content">
                <textarea id="yamlEditor" spellcheck="false"></textarea>
            </div>
        </div>

        <div class="panel" id="graphPanel">
            <div class="panel-header">Graph</div>
            <div class="panel-content graph-container">
                <div id="graphRoot" class="root-container"></div>
            </div>
        </div>

        <div class="panel hidden" id="visualPanel" style="flex: 2;">
            <div class="panel-header">Visual Graph (drag nodes, click connections to delete)</div>
            <div class="panel-content">
                <div id="visualCanvas" class="visual-canvas">
                    <svg id="connectionsSvg"></svg>
                </div>
            </div>
        </div>
    </div>

    <script>
        const jsonEditor = document.getElementById('jsonEditor');
        const yamlEditor = document.getElementById('yamlEditor');
        const graphRoot = document.getElementById('graphRoot');
        const viewMode = document.getElementById('viewMode');
        const expandAllCheckbox = document.getElementById('expandAll');
        const jsonPanel = document.getElementById('jsonPanel');
        const yamlPanel = document.getElementById('yamlPanel');
        const graphPanel = document.getElementById('graphPanel');
        const visualPanel = document.getElementById('visualPanel');
        const visualCanvas = document.getElementById('visualCanvas');
        const connectionsSvg = document.getElementById('connectionsSvg');
        const fileUpload = document.getElementById('fileUpload');
        const uploadBtn = document.getElementById('uploadBtn');

        let currentData = null;
        let isUpdating = false;

        // History for undo/redo
        let history = [];
        let historyIndex = -1;
        const MAX_HISTORY = 50;

        // Truncation map for base64 display
        const truncationMap = new Map();

        // Visual Graph Expansion State
        const visualCollapsedPaths = new Set();
        const visualExpandedPaths = new Set();

        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');

        // Visual state for history
        let savedVisualState = null;

        // Visual graph state variables
        let visualNodes = [];
        let visualConnections = [];
        let dragState = null;
        let connectionState = null;

        // Initialize
        updateFromJson();
        updateViewMode();

        // Event Listeners
        jsonEditor.addEventListener('input', debounce(updateFromJson, 300));
        yamlEditor.addEventListener('input', debounce(updateFromYaml, 300));
        viewMode.addEventListener('change', updateViewMode);
        expandAllCheckbox.addEventListener('change', toggleExpandAll);

        document.getElementById('downloadJson').addEventListener('click', downloadJson);
        document.getElementById('downloadYaml').addEventListener('click', downloadYaml);
        document.getElementById('downloadPng').addEventListener('click', downloadPng);
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);

        uploadBtn.addEventListener('click', () => fileUpload.click());
        fileUpload.addEventListener('change', handleFileUpload);

        document.querySelectorAll('.copy-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                const targetId = btn.dataset.target;
                const textarea = document.getElementById(targetId);
                textarea.select();
                navigator.clipboard.writeText(textarea.value).then(() => {
                    const originalText = btn.textContent;
                    btn.textContent = '‚úÖ Copied!';
                    setTimeout(() => btn.textContent = originalText, 2000);
                });
            });
        });

        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'z' && !e.shiftKey) {
                e.preventDefault();
                undo();
            } else if ((e.ctrlKey || e.metaKey) && (e.key === 'y' || (e.key === 'z' && e.shiftKey))) {
                e.preventDefault();
                redo();
            }
        });

        function debounce(fn, delay) {
            let timeout;
            return function (...args) {
                clearTimeout(timeout);
                timeout = setTimeout(() => fn.apply(this, args), delay);
            };
        }

        function updateFromJson() {
            if (isUpdating) return;
            isUpdating = true;

            try {
                const raw = JSON.parse(jsonEditor.value);
                currentData = restoreData(raw);

                const displayData = truncateData(currentData);
                yamlEditor.value = jsyaml.dump(displayData, { indent: 2 });
                renderGraph(currentData);

                // Save to history with state format
                history = history.slice(0, historyIndex + 1);
                const state = {
                    data: JSON.stringify(currentData),
                    visual: getVisualState()
                };
                history.push(state);
                if (history.length > MAX_HISTORY) history.shift();
                historyIndex = history.length - 1;
                updateHistoryButtons();
            } catch (e) {
                graphRoot.innerHTML = `<div class="error-message">JSON Error: ${e.message}</div>`;
            }

            isUpdating = false;
        }

        function updateFromYaml() {
            if (isUpdating) return;
            isUpdating = true;

            try {
                const raw = jsyaml.load(yamlEditor.value);
                currentData = restoreData(raw);

                const displayData = truncateData(currentData);
                jsonEditor.value = JSON.stringify(displayData, null, 2);
                renderGraph(currentData);
            } catch (e) {
                graphRoot.innerHTML = `<div class="error-message">YAML Error: ${e.message}</div>`;
            }

            isUpdating = false;
        }

        function syncEditors(saveToHistory = true) {
            if (saveToHistory) {
                // Remove any redo history after current position
                history = history.slice(0, historyIndex + 1);
                // Save data + visual state
                const state = {
                    data: JSON.stringify(currentData),
                    visual: getVisualState()
                };
                history.push(state);
                // Limit history size
                if (history.length > MAX_HISTORY) {
                    history.shift();
                }
                historyIndex = history.length - 1;
                updateHistoryButtons();
            }

            // Truncate for display in editors
            const displayData = truncateData(currentData);
            jsonEditor.value = JSON.stringify(displayData, null, 2);
            yamlEditor.value = jsyaml.dump(displayData, { indent: 2 });
            renderGraph(currentData);

            // Re-render visual graph if in visual mode
            if (viewMode.value === 'visual-graph') {
                renderVisualGraph();
            }
        }

        function getVisualState() {
            return {
                nodes: visualNodes.map(n => ({ id: n.id, x: n.x, y: n.y })),
                connections: [...visualConnections],
                collapsedPaths: [...visualCollapsedPaths],
                expandedPaths: [...visualExpandedPaths]
            };
        }

        function restoreVisualState(state) {
            if (!state) return;
            savedVisualState = state;
            visualCollapsedPaths.clear();
            state.collapsedPaths.forEach(p => visualCollapsedPaths.add(p));
            visualExpandedPaths.clear();
            state.expandedPaths.forEach(p => visualExpandedPaths.add(p));
        }

        function updateHistoryButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                const state = history[historyIndex];
                currentData = JSON.parse(state.data);
                restoreVisualState(state.visual);
                syncEditors(false);
                updateHistoryButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                const state = history[historyIndex];
                currentData = JSON.parse(state.data);
                restoreVisualState(state.visual);
                syncEditors(false);
                updateHistoryButtons();
            }
        }

        function renderGraph(data) {
            graphRoot.innerHTML = '';
            if (data === null || data === undefined) {
                graphRoot.innerHTML = '<div class="error-message">No data to display</div>';
                return;
            }
            const node = createTreeNode('root', data, [], true);
            graphRoot.appendChild(node);
        }

        function createTreeNode(key, value, path, isRoot = false) {
            const container = document.createElement('div');
            container.className = 'tree-node';

            const row = document.createElement('div');
            row.className = 'node-row';

            const type = getType(value);
            const hasChildren = type === 'object' || type === 'array';
            const isExpanded = expandAllCheckbox.checked;
            const currentPath = isRoot ? [] : [...path, key];

            // Toggle button
            const toggleBtn = document.createElement('button');
            toggleBtn.className = 'toggle-btn' + (hasChildren ? '' : ' leaf');
            toggleBtn.textContent = isExpanded ? '‚àí' : '+';
            row.appendChild(toggleBtn);

            // Key
            if (!isRoot) {
                const keySpan = document.createElement('span');
                keySpan.className = 'node-key';
                keySpan.textContent = key;
                row.appendChild(keySpan);

                const sep = document.createElement('span');
                sep.className = 'node-separator';
                sep.textContent = ': ';
                row.appendChild(sep);
            }

            // Value or type indicator
            if (hasChildren) {
                const typeSpan = document.createElement('span');
                typeSpan.className = 'node-type';
                if (type === 'array') {
                    typeSpan.textContent = `Array[${value.length}]`;
                } else {
                    typeSpan.textContent = `Object{${Object.keys(value).length}}`;
                }
                row.appendChild(typeSpan);

                // Add button for objects/arrays
                const addBtn = document.createElement('button');
                addBtn.className = 'action-btn add';
                addBtn.textContent = '+';
                addBtn.title = 'Add item';
                addBtn.onclick = (e) => {
                    e.stopPropagation();
                    showAddForm(children, currentPath, type);
                };
                row.appendChild(addBtn);
            } else {
                const valueSpan = document.createElement('span');
                valueSpan.className = 'node-value ' + type;
                valueSpan.textContent = formatValue(value, type);
                row.appendChild(valueSpan);
            }

            // Delete button (not for root)
            if (!isRoot) {
                const deleteBtn = document.createElement('button');
                deleteBtn.className = 'action-btn delete';
                deleteBtn.textContent = '√ó';
                deleteBtn.title = 'Delete';
                deleteBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteNode(path, key);
                };
                row.appendChild(deleteBtn);
            }

            container.appendChild(row);

            // Children
            const children = document.createElement('div');
            children.className = 'children' + (isExpanded ? '' : ' collapsed');
            if (isRoot) children.classList.add('root-children');

            toggleBtn.onclick = () => toggleNode(toggleBtn, children);

            if (hasChildren) {
                if (type === 'array') {
                    value.forEach((item, i) => {
                        children.appendChild(createTreeNode(i, item, currentPath));
                    });
                } else {
                    Object.entries(value).forEach(([k, v]) => {
                        children.appendChild(createTreeNode(k, v, currentPath));
                    });
                }
            }

            container.appendChild(children);
            return container;
        }

        function showAddForm(parentElement, path, parentType) {
            // Remove any existing add forms
            document.querySelectorAll('.add-form').forEach(f => f.remove());

            const form = document.createElement('div');
            form.className = 'add-form';

            // Key input (not for arrays)
            if (parentType !== 'array') {
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.placeholder = 'Key';
                keyInput.className = 'key-input';
                form.appendChild(keyInput);
            }

            // Type selector
            const typeSelect = document.createElement('select');
            typeSelect.innerHTML = `
                <option value="string">String</option>
                <option value="number">Number</option>
                <option value="boolean">Boolean</option>
                <option value="null">Null</option>
                <option value="array">Array []</option>
                <option value="object">Object {}</option>
                <option value="image">Image üñºÔ∏è</option>
            `;
            form.appendChild(typeSelect);

            // Image file input (hidden)
            const imageInput = document.createElement('input');
            imageInput.type = 'file';
            imageInput.accept = 'image/*';
            imageInput.style.display = 'none';
            imageInput.className = 'image-input';
            form.appendChild(imageInput);

            // Image preview/button
            const imageBtn = document.createElement('button');
            imageBtn.type = 'button';
            imageBtn.textContent = 'üñºÔ∏è Choose Image';
            imageBtn.style.display = 'none';
            imageBtn.onclick = () => imageInput.click();
            form.appendChild(imageBtn);

            let imageBase64 = null;
            imageInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        imageBase64 = ev.target.result;
                        imageBtn.textContent = '‚úÖ Image Selected';
                    };
                    reader.readAsDataURL(file);
                }
            };

            // Value input (changes based on type)
            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.placeholder = 'Value';
            valueInput.className = 'value-input';
            form.appendChild(valueInput);

            typeSelect.onchange = () => {
                const t = typeSelect.value;
                if (t === 'array' || t === 'object' || t === 'null') {
                    valueInput.style.display = 'none';
                    imageBtn.style.display = 'none';
                } else if (t === 'image') {
                    valueInput.style.display = 'none';
                    imageBtn.style.display = '';
                } else if (t === 'boolean') {
                    valueInput.type = 'text';
                    valueInput.placeholder = 'true or false';
                    valueInput.style.display = '';
                    imageBtn.style.display = 'none';
                } else {
                    valueInput.type = t === 'number' ? 'number' : 'text';
                    valueInput.placeholder = 'Value';
                    valueInput.style.display = '';
                    imageBtn.style.display = 'none';
                }
            };

            // Add button
            const addBtn = document.createElement('button');
            addBtn.textContent = 'Add';
            addBtn.className = 'success';
            addBtn.onclick = () => {
                const keyInput = form.querySelector('.key-input');
                const key = parentType === 'array' ? null : (keyInput ? keyInput.value.trim() : '');

                if (parentType !== 'array' && !key) {
                    alert('Please enter a key');
                    return;
                }

                const valueType = typeSelect.value;
                let newValue;

                switch (valueType) {
                    case 'string':
                        newValue = valueInput.value;
                        break;
                    case 'number':
                        newValue = parseFloat(valueInput.value) || 0;
                        break;
                    case 'boolean':
                        newValue = valueInput.value.toLowerCase() === 'true';
                        break;
                    case 'null':
                        newValue = null;
                        break;
                    case 'array':
                        newValue = [];
                        break;
                    case 'object':
                        newValue = {};
                        break;
                    case 'image':
                        if (!imageBase64) {
                            alert('Please select an image');
                            return;
                        }
                        newValue = imageBase64;
                        break;
                }

                addNode(path, key, newValue, parentType);
                form.remove();
            };
            form.appendChild(addBtn);

            // Cancel button
            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.onclick = () => form.remove();
            form.appendChild(cancelBtn);

            parentElement.insertBefore(form, parentElement.firstChild);
        }

        function getNodeByPath(path) {
            let node = currentData;
            for (const key of path) {
                node = node[key];
            }
            return node;
        }

        function addNode(path, key, value, parentType) {
            let parent = currentData;
            for (const p of path) {
                parent = parent[p];
            }

            if (parentType === 'array') {
                parent.push(value);
            } else {
                parent[key] = value;
            }

            syncEditors();
        }

        function deleteNode(path, key) {
            if (!confirm(`Delete "${key}"?`)) return;

            let parent = currentData;
            for (const p of path) {
                parent = parent[p];
            }

            if (Array.isArray(parent)) {
                parent.splice(key, 1);
            } else {
                delete parent[key];
            }

            syncEditors();
        }

        function getType(value) {
            if (value === null) return 'null';
            if (Array.isArray(value)) return 'array';
            return typeof value;
        }

        function formatValue(value, type) {
            if (type === 'string') {
                if (value.length > 50) {
                    return `"${value.substring(0, 50)}..."`;
                }
                return `"${value}"`;
            }
            if (type === 'null') return 'null';
            return String(value);
        }

        function toggleNode(btn, children) {
            const isCollapsed = children.classList.contains('collapsed');
            children.classList.toggle('collapsed');
            btn.textContent = isCollapsed ? '‚àí' : '+';
        }

        function toggleExpandAll() {
            const isExpanded = expandAllCheckbox.checked;

            // Text Graph Toggle
            document.querySelectorAll('.children').forEach(el => {
                if (el.classList.contains('root-children')) {
                    el.classList.remove('collapsed');
                } else {
                    el.classList.toggle('collapsed', !isExpanded);
                }
            });
            document.querySelectorAll('.toggle-btn:not(.leaf)').forEach(btn => {
                btn.textContent = isExpanded ? '‚àí' : '+';
            });

            // Visual Graph Toggle
            visualCollapsedPaths.clear();
            visualExpandedPaths.clear();
            if (!isExpanded) { // If collapsing all, clear expanded paths and add all current nodes to collapsed
                visualNodes.forEach(node => {
                    if (node.id !== 'root') visualCollapsedPaths.add(node.id);
                });
            }
            if (viewMode.value === 'visual-graph') {
                renderVisualGraph();
            }
        }

        function toggleVisualNode(pathStr) {
            const isGlobalExpanded = expandAllCheckbox.checked;

            if (isGlobalExpanded) {
                if (visualCollapsedPaths.has(pathStr)) {
                    visualCollapsedPaths.delete(pathStr);
                } else {
                    visualCollapsedPaths.add(pathStr);
                }
            } else {
                if (visualExpandedPaths.has(pathStr)) {
                    visualExpandedPaths.delete(pathStr);
                } else {
                    visualExpandedPaths.add(pathStr);
                }
            }
            renderVisualGraph();
            saveVisualStateToHistory(); // Save expansion state change
        }

        function updateViewMode() {
            const mode = viewMode.value;
            jsonPanel.classList.toggle('hidden', mode === 'yaml-graph' || mode === 'visual-graph');
            yamlPanel.classList.toggle('hidden', mode === 'json-graph' || mode === 'visual-graph');
            graphPanel.classList.toggle('hidden', mode === 'json-yaml' || mode === 'visual-graph');
            visualPanel.classList.toggle('hidden', mode !== 'visual-graph');

            if (mode === 'visual-graph') {
                renderVisualGraph();
            }
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                try {
                    // Try parsing as JSON first
                    try {
                        currentData = JSON.parse(content);
                    } catch (jsonErr) {
                        // If fails, try YAML
                        currentData = jsyaml.load(content);
                    }
                    syncEditors();
                } catch (err) {
                    alert('Error parsing file: ' + err.message);
                }
                fileUpload.value = '';
            };
            reader.readAsText(file);
        }

        function downloadJson() {
            const blob = new Blob([JSON.stringify(currentData, null, 2)], { type: 'application/json' });
            downloadBlob(blob, 'data.json');
        }

        function downloadYaml() {
            const blob = new Blob([jsyaml.dump(currentData, { indent: 2 })], { type: 'text/yaml' });
            downloadBlob(blob, 'data.yaml');
        }

        function truncateData(data) {
            if (data === null || data === undefined) return data;

            if (typeof data === 'string') {
                if (data.startsWith('data:image/') && data.length > 100) {
                    const truncated = data.substring(0, 40) + ' ... [TRUNCATED] ' + data.substring(data.length - 10);
                    truncationMap.set(truncated, data);
                    return truncated;
                }
                return data;
            }

            if (Array.isArray(data)) {
                return data.map(truncateData);
            }

            if (typeof data === 'object') {
                const newObj = {};
                for (const key in data) {
                    newObj[key] = truncateData(data[key]);
                }
                return newObj;
            }

            return data;
        }

        function restoreData(data) {
            if (data === null || data === undefined) return data;

            if (typeof data === 'string') {
                if (truncationMap.has(data)) {
                    return truncationMap.get(data);
                }
                return data;
            }

            if (Array.isArray(data)) {
                return data.map(restoreData);
            }

            if (typeof data === 'object') {
                const newObj = {};
                for (const key in data) {
                    newObj[key] = restoreData(data[key]);
                }
                return newObj;
            }

            return data;
        }

        async function downloadPng() {
            let targetEl, filename;

            if (viewMode.value === 'visual-graph') {
                targetEl = document.getElementById('visualCanvas');
                filename = 'visual-graph.png';
            } else {
                targetEl = document.querySelector('.graph-container');
                filename = 'graph.png';
            }

            if (!targetEl) return;

            try {
                const options = {
                    backgroundColor: '#0d1117',
                    scale: 2
                };

                if (viewMode.value === 'visual-graph') {
                    options.width = targetEl.scrollWidth;
                    options.height = targetEl.scrollHeight;
                    options.windowWidth = targetEl.scrollWidth;
                    options.windowHeight = targetEl.scrollHeight;
                }

                const canvas = await html2canvas(targetEl, options);
                canvas.toBlob(blob => {
                    downloadBlob(blob, filename);
                });
            } catch (e) {
                alert('Error capturing graph: ' + e.message);
            }
        }

        function downloadBlob(blob, filename) {
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        // ===== VISUAL GRAPH MODE =====
        // visualNodes, visualConnections, etc are declared at top scope

        function renderVisualGraph() {
            if (!currentData) return;

            // Clear existing
            visualCanvas.querySelectorAll('.visual-node').forEach(n => n.remove());
            connectionsSvg.innerHTML = '';
            visualNodes = [];
            visualConnections = [];

            // Build node tree with positions
            const nodeTree = buildNodeTree('root', currentData, [], null); // Pass null for parent of root
            layoutNodes(nodeTree, 40, 40);

            // Restore saved visual state if available
            if (savedVisualState) {
                // Restore node positions
                savedVisualState.nodes.forEach(saved => {
                    const node = visualNodes.find(n => n.id === saved.id);
                    if (node) {
                        node.x = saved.x;
                        node.y = saved.y;
                    }
                });
                // Restore custom connections
                visualConnections = [...savedVisualState.connections];
                savedVisualState = null;
            }

            // Render nodes
            visualNodes.forEach(node => renderVisualNode(node));

            // Render connections
            updateConnections();
        }

        function saveVisualStateToHistory() {
            // Save current state to history (visual-only change)
            history = history.slice(0, historyIndex + 1);
            const state = {
                data: JSON.stringify(currentData),
                visual: getVisualState()
            };
            history.push(state);
            if (history.length > MAX_HISTORY) history.shift();
            historyIndex = history.length - 1;
            updateHistoryButtons();
        }

        function buildNodeTree(key, value, path, parent = null) {
            const type = getType(value);
            const hasChildren = type === 'object' || type === 'array';

            // Determine expansion state
            const isGlobalExpanded = expandAllCheckbox.checked;
            const pathStr = path.length ? path.join('.') : 'root';
            let isExpanded = isGlobalExpanded;

            if (isGlobalExpanded) {
                if (visualCollapsedPaths.has(pathStr)) isExpanded = false;
            } else {
                if (visualExpandedPaths.has(pathStr)) isExpanded = true;
            }
            // Always expand root
            if (path.length === 0) isExpanded = true;

            const node = {
                id: pathStr,
                key: key,
                data: { value: value }, // Store primitive value for rendering
                children: [],
                width: 180, // Approximate width
                height: hasChildren ? 40 : 80,
                expanded: isExpanded
            };
            visualNodes.push(node);

            if (parent) {
                parent.children.push(node);
                visualConnections.push({ from: parent.id, to: node.id });
            }

            if (hasChildren && isExpanded) {
                const entries = type === 'array'
                    ? value.map((v, i) => [i, v])
                    : Object.entries(value);

                entries.forEach(([k, v]) => {
                    const childPath = [...path, k];
                    buildNodeTree(k, v, childPath, node);
                });
            }

            return node; // Return the created node
        }

        function layoutNodes(nodes, startX, startY) {
            const LEVEL_WIDTH = 200;
            const NODE_HEIGHT_SPACING = 100; // Increased spacing for better visibility

            function layoutLevel(nodeList, x, yStart) {
                let y = yStart;
                nodeList.forEach(node => {
                    node.x = x;
                    node.y = y;

                    if (node.expanded && node.children.length > 0) {
                        const childY = layoutLevel(node.children, x + LEVEL_WIDTH, y);
                        // Center parent vertically among children
                        const firstChild = node.children[0];
                        const lastChild = node.children[node.children.length - 1];
                        node.y = (firstChild.y + lastChild.y) / 2;
                        y = childY;
                    } else {
                        y += NODE_HEIGHT_SPACING;
                    }
                });
                return y;
            }

            // Ensure nodes is an array for layoutLevel
            const rootNodes = Array.isArray(nodes) ? nodes : [nodes];
            layoutLevel(rootNodes, startX, startY);
        }

        function renderVisualNode(node) {
            const div = document.createElement('div');
            div.className = 'visual-node';
            div.dataset.id = node.id;
            div.style.left = node.x + 'px';
            div.style.top = node.y + 'px';

            const type = node.data ? getType(node.data.value) : 'object';
            const hasChildren = type === 'object' || type === 'array';

            // Header
            const header = document.createElement('div');
            header.className = 'visual-node-header';

            // Expand Toggle (aligned left)
            if (hasChildren) {
                const toggle = document.createElement('div');
                toggle.className = 'visual-toggle';
                toggle.textContent = node.expanded ? '‚àí' : '+';
                toggle.onclick = (e) => {
                    e.stopPropagation();
                    toggleVisualNode(node.id);
                };
                header.appendChild(toggle);
            }

            const title = document.createElement('span');
            title.textContent = node.key;
            header.appendChild(title);

            div.appendChild(header);

            // Drag handle on header
            header.onmousedown = (e) => startDrag(e, node, div);
            header.ontouchstart = (e) => startDrag(e, node, div);
            const actions = document.createElement('div'); // Re-declare actions here if needed, or remove if not used
            actions.className = 'visual-node-actions';

            if (node.id !== 'root') {
                const delBtn = document.createElement('button');
                delBtn.className = 'danger';
                delBtn.textContent = '√ó';
                delBtn.onclick = (e) => {
                    e.stopPropagation();
                    deleteVisualNode(node);
                };
                actions.appendChild(delBtn);
            }

            // Add button for objects/arrays
            if (hasChildren) {
                const addBtn = document.createElement('button');
                addBtn.className = 'success';
                addBtn.textContent = '+';
                addBtn.title = 'Add item';
                addBtn.onclick = (e) => {
                    e.stopPropagation();
                    showVisualAddForm(node, div);
                };
                actions.appendChild(addBtn);
            }
            header.appendChild(actions);
            div.appendChild(header);

            // Content
            const content = document.createElement('div');
            content.className = 'visual-node-content ' + type;
            if (hasChildren) {
                content.classList.add('type');
                content.textContent = type === 'array' ? `Array[${node.data.value.length}]` : `Object{${Object.keys(node.data.value).length}}`;
            } else {
                if (type === 'string' && node.data.value.startsWith('data:image/')) {
                    const img = document.createElement('img');
                    img.src = node.data.value;
                    img.style.maxWidth = '100%';
                    img.style.maxHeight = '140px';
                    img.style.borderRadius = '4px';
                    img.style.display = 'block';
                    content.appendChild(img);

                    const meta = document.createElement('div');
                    meta.style.fontSize = '0.7rem';
                    meta.style.color = 'var(--text-secondary)';
                    meta.style.marginTop = '4px';
                    meta.textContent = 'Base64 Image';
                    content.appendChild(meta);
                } else {
                    content.textContent = formatValue(node.data.value, type);
                }
            }

            // Make primitives editable on click
            if (!hasChildren && type !== 'null') {
                content.style.cursor = 'pointer';
                content.title = 'Click to edit';
                content.onclick = (e) => {
                    e.stopPropagation();
                    editVisualValue(node, content);
                };
            }
            div.appendChild(content);

            // Connection dots
            if (node.parent) {
                const inputDot = document.createElement('div');
                inputDot.className = 'connector-dot input';
                div.appendChild(inputDot);
            }

            if (hasChildren || node.id === 'root') {
                const outputDot = document.createElement('div');
                outputDot.className = 'connector-dot output';
                outputDot.onmousedown = (e) => startConnection(e, node);
                outputDot.ontouchstart = (e) => startConnection(e, node);
                div.appendChild(outputDot);
            }

            // Dragging
            div.onmousedown = (e) => startDrag(e, node, div);
            div.ontouchstart = (e) => startDrag(e, node, div);

            visualCanvas.appendChild(div);

        }

        function updateConnections() {
            // Resize SVG to match scrollable area
            const width = Math.max(visualCanvas.scrollWidth, visualCanvas.clientWidth);
            const height = Math.max(visualCanvas.scrollHeight, visualCanvas.clientHeight);
            connectionsSvg.style.width = width + 'px';
            connectionsSvg.style.height = height + 'px';

            connectionsSvg.innerHTML = '';

            visualConnections.forEach(conn => {
                const fromNode = visualNodes.find(n => n.id === conn.from);
                const toNode = visualNodes.find(n => n.id === conn.to);
                if (!fromNode || !toNode) return;

                const x1 = fromNode.x + fromNode.width;
                const y1 = fromNode.y + 30;
                const x2 = toNode.x;
                const y2 = toNode.y + 30;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const cx = (x1 + x2) / 2;
                path.setAttribute('d', `M ${x1} ${y1} C ${cx} ${y1}, ${cx} ${y2}, ${x2} ${y2}`);
                path.setAttribute('stroke', '#58a6ff');
                path.setAttribute('stroke-width', '2');
                path.setAttribute('fill', 'none');
                path.dataset.from = conn.from;
                path.dataset.to = conn.to;
                path.onclick = () => deleteConnection(conn);

                connectionsSvg.appendChild(path);
            });
        }

        function startDrag(e, node, div) {
            if (e.target.classList.contains('connector-dot')) return;
            // e.preventDefault() prevents input focus which might be annoying?
            // Better to prevent default only if it's a drag start
            if (e.type === 'touchstart') e.preventDefault();

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = visualCanvas.getBoundingClientRect();
            const mouseX = clientX - rect.left + visualCanvas.scrollLeft;
            const mouseY = clientY - rect.top + visualCanvas.scrollTop;

            dragState = {
                node: node,
                div: div,
                offsetX: mouseX - node.x,
                offsetY: mouseY - node.y
            };
            div.classList.add('dragging');

            document.addEventListener('mousemove', onDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', onDrag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function onDrag(e) {
            if (!dragState) return;
            if (e.type === 'touchmove') e.preventDefault(); // Prevent scrolling

            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const rect = visualCanvas.getBoundingClientRect();
            const mouseX = clientX - rect.left + visualCanvas.scrollLeft;
            const mouseY = clientY - rect.top + visualCanvas.scrollTop;

            dragState.node.x = Math.max(0, mouseX - dragState.offsetX);
            dragState.node.y = Math.max(0, mouseY - dragState.offsetY);

            dragState.div.style.left = dragState.node.x + 'px';
            dragState.div.style.top = dragState.node.y + 'px';

            updateConnections();
        }

        function endDrag() {
            if (dragState) {
                dragState.div.classList.remove('dragging');
                saveVisualStateToHistory(); // Save position change
            }
            dragState = null;
            document.removeEventListener('mousemove', onDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', onDrag);
            document.removeEventListener('touchend', endDrag);
        }

        function startConnection(e, fromNode) {
            e.stopPropagation();
            if (e.type === 'touchstart') e.preventDefault();

            connectionState = {
                from: fromNode,
                tempLine: null
            };

            // Create temp line
            const line = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            line.classList.add('connection-temp');
            connectionsSvg.appendChild(line);
            connectionState.tempLine = line;

            document.addEventListener('mousemove', onConnectionDrag);
            document.addEventListener('mouseup', endConnection);
            document.addEventListener('touchmove', onConnectionDrag, { passive: false });
            document.addEventListener('touchend', endConnection);
        }

        function onConnectionDrag(e) {
            if (!connectionState) return;
            if (e.type === 'touchmove') e.preventDefault();

            const canvasRect = visualCanvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            const x1 = connectionState.from.x + connectionState.from.width;
            const y1 = connectionState.from.y + 30;
            const x2 = clientX - canvasRect.left + visualCanvas.scrollLeft;
            const y2 = clientY - canvasRect.top + visualCanvas.scrollTop;

            const cx = (x1 + x2) / 2;
            connectionState.tempLine.setAttribute('d', `M ${x1} ${y1} C ${cx} ${y1}, ${cx} ${y2}, ${x2} ${y2}`);
        }

        function endConnection(e) {
            if (!connectionState) return;

            let target = null;
            if (e.type === 'touchend') {
                // For touch end, we need to find element at changed touch position
                const touch = e.changedTouches[0];
                target = document.elementFromPoint(touch.clientX, touch.clientY);
                if (target) target = target.closest('.visual-node');
            } else {
                target = e.target.closest('.visual-node');
            }

            if (target && target.dataset.id !== connectionState.from.id) {
                const toNodeId = target.dataset.id;
                const exists = visualConnections.some(c => c.from === connectionState.from.id && c.to === toNodeId);
                if (!exists) {
                    visualConnections.push({
                        from: connectionState.from.id,
                        to: toNodeId
                    });
                    updateConnections();
                    saveVisualStateToHistory(); // Save new connection
                }
            }

            if (connectionState.tempLine) {
                connectionState.tempLine.remove();
            }
            connectionState = null;

            document.removeEventListener('mousemove', onConnectionDrag);
            document.removeEventListener('mouseup', endConnection);
            document.removeEventListener('touchmove', onConnectionDrag);
            document.removeEventListener('touchend', endConnection);
        }

        function deleteConnection(conn) {
            if (!confirm(`Delete connection from "${conn.from}" to "${conn.to}"?`)) return;
            visualConnections = visualConnections.filter(c => c !== conn);
            updateConnections();
            saveVisualStateToHistory(); // Save connection deletion
        }

        function showVisualAddForm(node, nodeDiv) {
            // Remove any existing visual add forms
            document.querySelectorAll('.visual-add-form').forEach(f => f.remove());

            const type = getType(node.data.value);
            const isArray = type === 'array';

            const form = document.createElement('div');
            form.className = 'visual-add-form';
            form.style.cssText = 'position:absolute; left:0; right:0; top:100%; background:var(--bg-secondary); border:1px solid var(--border-color); border-radius:6px; padding:8px; z-index:100; display:flex; flex-direction:column; gap:6px;';

            // Key input (not for arrays)
            if (!isArray) {
                const keyInput = document.createElement('input');
                keyInput.type = 'text';
                keyInput.placeholder = 'Key';
                keyInput.className = 'visual-key-input';
                keyInput.style.cssText = 'padding:4px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--bg-primary); color:var(--text-primary);';
                form.appendChild(keyInput);
            }

            // Type selector
            const typeSelect = document.createElement('select');
            typeSelect.style.cssText = 'padding:4px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--bg-primary); color:var(--text-primary);';
            typeSelect.innerHTML = `
                <option value="string">String</option>
                <option value="number">Number</option>
                <option value="boolean">Boolean</option>
                <option value="null">Null</option>
                <option value="array">Array []</option>
                <option value="object">Object {}</option>
                <option value="image">Image üñºÔ∏è</option>
            `;
            form.appendChild(typeSelect);

            // Image file input (hidden)
            const imageInput = document.createElement('input');
            imageInput.type = 'file';
            imageInput.accept = 'image/*';
            imageInput.style.display = 'none';
            form.appendChild(imageInput);

            // Image button
            const imageBtn = document.createElement('button');
            imageBtn.type = 'button';
            imageBtn.textContent = 'üñºÔ∏è Choose Image';
            imageBtn.style.cssText = 'padding:4px 8px; display:none;';
            imageBtn.onclick = (e) => {
                e.stopPropagation();
                imageInput.click();
            };
            form.appendChild(imageBtn);

            let imageBase64 = null;
            imageInput.onchange = (e) => {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        imageBase64 = ev.target.result;
                        imageBtn.textContent = '‚úÖ Image Selected';
                    };
                    reader.readAsDataURL(file);
                }
            };

            // Value input
            const valueInput = document.createElement('input');
            valueInput.type = 'text';
            valueInput.placeholder = 'Value';
            valueInput.style.cssText = 'padding:4px 8px; border:1px solid var(--border-color); border-radius:4px; background:var(--bg-primary); color:var(--text-primary);';
            form.appendChild(valueInput);

            typeSelect.onchange = () => {
                const t = typeSelect.value;
                if (t === 'array' || t === 'object' || t === 'null') {
                    valueInput.style.display = 'none';
                    imageBtn.style.display = 'none';
                } else if (t === 'image') {
                    valueInput.style.display = 'none';
                    imageBtn.style.display = '';
                } else {
                    valueInput.style.display = '';
                    imageBtn.style.display = 'none';
                    if (t === 'boolean') valueInput.placeholder = 'true or false';
                    else valueInput.placeholder = 'Value';
                }
            };

            // Buttons
            const btnRow = document.createElement('div');
            btnRow.style.cssText = 'display:flex; gap:6px;';

            const addBtn = document.createElement('button');
            addBtn.textContent = 'Add';
            addBtn.className = 'success';
            addBtn.style.cssText = 'flex:1;';
            addBtn.onclick = (e) => {
                e.stopPropagation();
                const keyInput = form.querySelector('.visual-key-input');
                const key = isArray ? null : (keyInput ? keyInput.value.trim() : '');

                if (!isArray && !key) {
                    alert('Please enter a key');
                    return;
                }

                const valueType = typeSelect.value;
                let newValue;
                switch (valueType) {
                    case 'string': newValue = valueInput.value; break;
                    case 'number': newValue = parseFloat(valueInput.value) || 0; break;
                    case 'boolean': newValue = valueInput.value.toLowerCase() === 'true'; break;
                    case 'null': newValue = null; break;
                    case 'array': newValue = []; break;
                    case 'object': newValue = {}; break;
                    case 'image':
                        if (!imageBase64) {
                            alert('Please select an image');
                            return;
                        }
                        newValue = imageBase64;
                        break;
                }

                // Add to data
                const pathParts = node.id === 'root' ? [] : node.id.split('.');
                let target = currentData;
                for (const p of pathParts) {
                    const k = isNaN(p) ? p : parseInt(p);
                    target = target[k];
                }

                if (isArray) {
                    target.push(newValue);
                } else {
                    target[key] = newValue;
                }

                form.remove();
                syncEditors();
                renderVisualGraph();
            };
            btnRow.appendChild(addBtn);

            const cancelBtn = document.createElement('button');
            cancelBtn.textContent = 'Cancel';
            cancelBtn.style.cssText = 'flex:1;';
            cancelBtn.onclick = (e) => {
                e.stopPropagation();
                form.remove();
            };
            btnRow.appendChild(cancelBtn);

            form.appendChild(btnRow);

            // Prevent form clicks from triggering drag
            form.onmousedown = (e) => e.stopPropagation();
            form.ontouchstart = (e) => e.stopPropagation();

            nodeDiv.appendChild(form);
        }

        function editVisualValue(node, contentEl) {
            const type = getType(node.data.value);
            const currentValue = node.data.value;

            // Create input
            const input = document.createElement('input');
            input.type = type === 'number' ? 'number' : 'text';
            input.value = type === 'string' ? currentValue : String(currentValue);
            input.style.cssText = 'width:100%; padding:4px; border:1px solid var(--text-accent); border-radius:4px; background:var(--bg-primary); color:var(--text-primary); font-family:inherit;';

            const originalContent = contentEl.innerHTML;
            contentEl.innerHTML = '';
            contentEl.appendChild(input);
            input.focus();
            input.select();

            const save = () => {
                let newValue;
                if (type === 'number') {
                    newValue = parseFloat(input.value) || 0;
                } else if (type === 'boolean') {
                    newValue = input.value.toLowerCase() === 'true';
                } else {
                    newValue = input.value;
                }

                // Update data
                const pathParts = node.id === 'root' ? [] : node.id.split('.');
                if (pathParts.length > 0) {
                    let target = currentData;
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        const k = isNaN(pathParts[i]) ? pathParts[i] : parseInt(pathParts[i]);
                        target = target[k];
                    }
                    const lastKey = pathParts[pathParts.length - 1];
                    const k = isNaN(lastKey) ? lastKey : parseInt(lastKey);
                    target[k] = newValue;
                }

                syncEditors();
                renderVisualGraph();
            };

            const cancel = () => {
                contentEl.innerHTML = originalContent;
            };

            input.onblur = save;
            input.onkeydown = (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    input.blur();
                } else if (e.key === 'Escape') {
                    e.preventDefault();
                    input.onblur = null;
                    cancel();
                }
            };

            // Prevent drag while editing
            input.onmousedown = (e) => e.stopPropagation();
            input.ontouchstart = (e) => e.stopPropagation();
        }

        function deleteVisualNode(node) {
            if (!confirm(`Delete node "${node.key}"?`)) return;

            // Parse path from node.id (e.g. "config.features.0" -> ["config", "features", "0"])
            const pathParts = node.id === 'root' ? [] : node.id.split('.');

            if (pathParts.length > 0) {
                let parent = currentData;
                for (let i = 0; i < pathParts.length - 1; i++) {
                    const key = isNaN(pathParts[i]) ? pathParts[i] : parseInt(pathParts[i]);
                    parent = parent[key];
                }
                const lastKey = pathParts[pathParts.length - 1];
                const key = isNaN(lastKey) ? lastKey : parseInt(lastKey);
                if (Array.isArray(parent)) {
                    parent.splice(key, 1);
                } else {
                    delete parent[key];
                }
                syncEditors();
                renderVisualGraph();
            }
        }
    </script>
</body>

</html>