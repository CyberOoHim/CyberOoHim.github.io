---
layout: apps
title: Taigi POJ art
version: v0c
permalink: /pages/taigi_poj_art.html
note: refined by Grok 2.0
---
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>POJ bûn-jī gē-su̍t • Optimized</title>
    <style>
        @font-face {
            font-family: 'ChiayiCity';
            src: url('/assets/fonts/ChiayiCity.ttf') format('truetype');
        }
        @font-face {
            font-family: 'ChenYuluoyan-2.0';
            src: url('/assets/fonts/ChenYuluoyan-2.0-Thin.ttf') format('truetype');
        }
        canvas {
            border: 2px solid #00008b;
            max-width: 100%;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #fffacd;
            font-family: 'Noto Sans', system-ui, sans-serif;
            margin: 0;
        }
        h2 {
            color: #00008b;
            margin-bottom: 10px;
        }
        .button-container {
            display: flex;
            gap: 15px;
            margin: 15px 0;
            flex-wrap: wrap;
            justify-content: center;
        }
        button {
            padding: 14px 28px;
            font-size: 18px;
            background-color: #00008b;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        button:hover { background-color: #1e3a8a; }
        button:disabled { background-color: #64748b; cursor: not-allowed; }
        .controls {
            margin-top: 20px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            max-width: 420px;
            width: 100%;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
        }
        label {
            width: 180px;
            font-size: 17px;
            font-weight: 600;
            color: #1e2937;
        }
        input[type="range"] {
            flex: 1;
            min-width: 180px;
        }
        span {
            font-size: 17px;
            font-family: monospace;
            min-width: 50px;
            text-align: right;
        }
        select, textarea {
            font-size: 16px;
            padding: 6px 10px;
        }
        #customTextInput {
            width: 100%;
            height: 90px;
            font-size: 15px;
            padding: 8px;
            resize: vertical;
            border: 1px solid #64748b;
            border-radius: 6px;
        }
        .status {
            font-size: 15px;
            color: #334155;
            margin-top: 8px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans:wght@400;600&display=swap" rel="stylesheet">
</head>
<body>
    <h2>POJ bûn-jī gē-su̍t</h2>
    <p style="margin:0 0 15px; color:#475569; font-size:15px;">Taigi text art from your photo • v0c optimized</p>

    <input type="file" id="imageInput" accept="image/*" style="display:none">
    
    <canvas id="canvas" width="800" height="600"></canvas>

    <div class="button-container">
        <label for="imageInput">
            <button id="uploadButton">Choose Image</button>
        </label>
        <button id="renderButton">Render Art</button>
        <button id="downloadButton" style="display:none">Download PNG</button>
    </div>

    <div class="status" id="status">Ready</div>

    <div class="controls">
        <div class="slider-container">
            <label for="gridSize">Grid Size (2-20 even):</label>
            <input type="range" id="gridSize" min="2" max="20" step="2" value="12">
            <span id="gridSizeValue">12</span>
        </div>
        <div class="slider-container">
            <label for="wordsPerCell">Words per Cell:</label>
            <input type="range" id="wordsPerCell" min="1" max="12" value="4">
            <span id="wordsPerCellValue">4</span>
        </div>
        <div class="slider-container">
            <label for="offset">Offset (px):</label>
            <input type="range" id="offset" min="0" max="40" value="12">
            <span id="offsetValue">12</span>
        </div>
        <div class="slider-container">
            <label for="fontSize">Base Font Size:</label>
            <input type="range" id="fontSize" min="8" max="72" value="24">
            <span id="fontSizeValue">24</span>
        </div>
        <div class="slider-container">
            <label for="sizeVariation">Size Variation %:</label>
            <input type="range" id="sizeVariation" min="0" max="60" value="25">
            <span id="sizeVariationValue">25%</span>
        </div>
        <div class="slider-container">
            <label for="rotationAmount">Rotation ° (new):</label>
            <input type="range" id="rotationAmount" min="0" max="18" value="7">
            <span id="rotationValue">7°</span>
        </div>
        <div class="slider-container">
            <label for="bgOpacity">Original Bg Opacity % (new):</label>
            <input type="range" id="bgOpacity" min="0" max="35" value="14">
            <span id="bgOpacityValue">14%</span>
        </div>
        <div class="slider-container">
            <label for="strokeWidth">Stroke Width (new):</label>
            <input type="range" id="strokeWidth" min="0" max="7" value="3">
            <span id="strokeValue">3</span>
        </div>

        <div class="slider-container">
            <label for="variationMethod">Variation:</label>
            <select id="variationMethod">
                <option value="none">None</option>
                <option value="brightness">Brightness</option>
                <option value="randomness">Randomness</option>
                <option value="brightnessRandom" selected>Brightness + Random</option>
            </select>
        </div>

        <div class="slider-container">
            <label for="charLength">Max POJ Length:</label>
            <input type="range" id="charLength" min="1" max="18" value="6">
            <span id="charLengthValue">6</span>
        </div>

        <div class="slider-container">
            <label for="fontFamily">Font:</label>
            <select id="fontFamily">
                <option value="ChiayiCity" selected>ChiayiCity (best)</option>
                <option value="ChenYuluoyan-2.0">ChenYuluoyan</option>
                <option value="Noto Sans">Noto Sans</option>
                <option value="Georgia">Georgia</option>
            </select>
        </div>

        <div class="slider-container">
            <label for="customTextDelimiter">Custom Text Delimiter:</label>
            <select id="customTextDelimiter">
                <option value="space">Spaces / Newlines</option>
                <option value="comma">Commas</option>
                <option value="none" selected>None (use built-in Taigi)</option>
            </select>
        </div>

        <textarea id="customTextInput" placeholder="Paste your own Taigi words here..."></textarea>
    </div>

    <script>
        // ==================== CONSTANTS & CONFIG ====================
        const MAX_DIM = 1400;
        const MAX_FILE_SIZE = 12 * 1024 * 1024; // 12 MB
        const MAX_TOTAL_WORDS = 65000;

        const defaultTaigiWords = ['a','lán','sī','súi','ē','hó','niā','gún','lí','chîⁿ','ba̍k','o͘-pe̍h','iăn-jín','Tâi-oân','Tâi-gí','Tai-bûn','Tâi-oân-ōe','tì-sek','bí-lē-tó','âng-âng-âng'];
        
        const ASSET_PATH = '/assets/taigi_space_catch/';
        const TAIGI_WORDS = 'taigi_1280_of_700_漢字_羅馬字_v0d.csv';

        let taigiWords = [];
        let fontsLoaded = false;
        let imageData = null;
        let originalImg = null;
        let cellColors = [];
        let wordPool = [];
        let imgWidth = 0, imgHeight = 0;
        let overallColor = [255, 245, 220];

        const hanjiRegex = /[\u4E00-\u9FFF]/;

        // DOM elements
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d', { alpha: true });
        const uploadButton = document.getElementById('uploadButton');
        const renderButton = document.getElementById('renderButton');
        const downloadButton = document.getElementById('downloadButton');
        const imageInput = document.getElementById('imageInput');
        const statusEl = document.getElementById('status');

        // Sliders
        const gridSizeSlider = document.getElementById('gridSize');
        const wordsPerCellSlider = document.getElementById('wordsPerCell');
        const offsetSlider = document.getElementById('offset');
        const fontSizeSlider = document.getElementById('fontSize');
        const sizeVariationSlider = document.getElementById('sizeVariation');
        const rotationSlider = document.getElementById('rotationAmount');
        const bgOpacitySlider = document.getElementById('bgOpacity');
        const strokeSlider = document.getElementById('strokeWidth');
        const charLengthSlider = document.getElementById('charLength');
        const variationMethodSelect = document.getElementById('variationMethod');
        const fontFamilySelect = document.getElementById('fontFamily');
        const customTextDelimiterSelect = document.getElementById('customTextDelimiter');
        const customTextInput = document.getElementById('customTextInput');

        // Value displays
        const gridSizeValue = document.getElementById('gridSizeValue');
        const wordsPerCellValue = document.getElementById('wordsPerCellValue');
        const offsetValue = document.getElementById('offsetValue');
        const fontSizeValue = document.getElementById('fontSizeValue');
        const sizeVariationValue = document.getElementById('sizeVariationValue');
        const rotationValue = document.getElementById('rotationValue');
        const bgOpacityValue = document.getElementById('bgOpacityValue');
        const strokeValue = document.getElementById('strokeValue');
        const charLengthValue = document.getElementById('charLengthValue');

        // ==================== FONT LOADING ====================
        async function loadCustomFonts() {
            if (fontsLoaded) return;
            statusEl.textContent = 'Loading beautiful Taigi fonts...';
            try {
                const fonts = await Promise.all([
                    new FontFace('ChiayiCity', 'url(/assets/fonts/ChiayiCity.ttf)').load(),
                    new FontFace('ChenYuluoyan-2.0', 'url(/assets/fonts/ChenYuluoyan-2.0-Thin.ttf)').load()
                ]);
                fonts.forEach(f => document.fonts.add(f));
                fontsLoaded = true;
                console.log('✓ Custom Taigi fonts loaded');
            } catch (e) {
                console.warn('Font load failed, using system fonts');
            }
            statusEl.textContent = 'Ready';
        }

        // ==================== DATA LOADING ====================
        async function loadTaigiWords() {
            try {
                const res = await fetch(ASSET_PATH + TAIGI_WORDS);
                if (!res.ok) throw new Error('CSV missing');
                const text = await res.text();
                taigiWords = text.split('\n').slice(1)
                    .map(row => {
                        const cols = row.split(',').map(s => s.trim().replace(/^"|"$/g,''));
                        return cols[1] || '';
                    })
                    .filter(w => w && w.length <= 18 && !hanjiRegex.test(w));
                console.log(`✓ Loaded ${taigiWords.length} Taigi words`);
            } catch (e) {
                taigiWords = defaultTaigiWords;
                console.warn('Using fallback words');
            }
        }

        // ==================== UTILITIES ====================
        function getLuminance(r, g, b) {
            return 0.299 * r + 0.587 * g + 0.114 * b;
        }

        function resizeImage(img) {
            let { width, height } = img;
            if (width <= MAX_DIM && height <= MAX_DIM) return img;

            const ratio = MAX_DIM / Math.max(width, height);
            width = Math.round(width * ratio);
            height = Math.round(height * ratio);

            const temp = document.createElement('canvas');
            temp.width = width; temp.height = height;
            const tctx = temp.getContext('2d');
            tctx.drawImage(img, 0, 0, width, height);
            
            const newImg = new Image();
            newImg.src = temp.toDataURL('image/jpeg', 0.92);
            return newImg;
        }

        function precomputeCellColors(gridSize) {
            const cols = Math.ceil(imgWidth / gridSize);
            const rows = Math.ceil(imgHeight / gridSize);
            
            const temp = document.createElement('canvas');
            temp.width = cols; temp.height = rows;
            const tctx = temp.getContext('2d', { willReadFrequently: true });
            tctx.drawImage(originalImg, 0, 0, cols, rows);
            
            const data = tctx.getImageData(0, 0, cols, rows).data;
            cellColors = [];
            
            for (let j = 0; j < rows; j++) {
                for (let i = 0; i < cols; i++) {
                    const idx = (j * cols + i) * 4;
                    cellColors.push([
                        data[idx],
                        data[idx + 1],
                        data[idx + 2]
                    ]);
                }
            }
        }

        function buildWordPool() {
            const maxLen = parseInt(charLengthSlider.value);
            let list = [];
            
            if (customTextDelimiterSelect.value !== "none" && customTextInput.value.trim()) {
                const delim = customTextDelimiterSelect.value === "comma" ? /,/ : /[\s\n]+/;
                list = customTextInput.value.split(delim)
                    .map(w => w.trim())
                    .filter(w => w.length > 0 && !hanjiRegex.test(w));
            } else {
                list = taigiWords.length ? taigiWords : defaultTaigiWords;
            }
            
            wordPool = list.filter(w => w.length <= maxLen);
            if (wordPool.length === 0) wordPool = ['a', 'lán', 'sī'];
        }

        function getRandomWord() {
            return wordPool[Math.floor(Math.random() * wordPool.length)] || 'a';
        }

        function calculateFontSize(base, variation, luminance, method) {
            if (method === 'none') return base;
            
            const minFactor = 1 - variation / 100;
            const maxFactor = 1 + variation / 100;
            const minS = base * minFactor;
            const maxS = base * maxFactor;

            let size;
            if (method === 'brightness' && luminance !== null) {
                size = minS + (maxS - minS) * (luminance / 255);
            } else if (method === 'randomness') {
                size = minS + Math.random() * (maxS - minS);
            } else { // brightnessRandom
                const baseBright = minS + (maxS - minS) * (luminance / 255);
                size = baseBright + (Math.random() - 0.5) * (maxS - minS) * 0.25;
            }
            return Math.max(6, Math.min(Math.round(size), base * 1.6));
        }

        function drawWord(word, color, x, y, fontSize, fontFamily, rotationDeg, strokeW) {
            const lum = getLuminance(...color);
            const textColor = lum > 130 ? '#0f172a' : '#f8fafc';
            const strokeColor = lum > 130 ? 'rgba(255,255,255,0.75)' : 'rgba(0,0,0,0.75)';

            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(rotationDeg * Math.PI / 180);

            ctx.font = `${fontSize}px "${fontFamily}", "Noto Sans", sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            if (strokeW > 0) {
                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = strokeW;
                ctx.lineJoin = 'round';
                ctx.strokeText(word, 0, 0);
            }

            ctx.fillStyle = textColor;
            ctx.fillText(word, 0, 0);
            ctx.restore();
        }

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // ==================== MAIN RENDER ====================
        async function renderCanvas(autoDownload = true) {
            if (!originalImg) {
                alert('請先上傳圖片 / Please upload an image first');
                return;
            }

            const gridSize = parseInt(gridSizeSlider.value);
            const wordsPerCell = parseInt(wordsPerCellSlider.value);
            const offset = parseInt(offsetSlider.value);
            const baseFontSize = parseInt(fontSizeSlider.value);
            const variationPercent = parseInt(sizeVariationSlider.value);
            const rotationMax = parseInt(rotationSlider.value);
            const bgOpacity = parseInt(bgOpacitySlider.value) / 100;
            const strokeW = parseInt(strokeSlider.value);
            const fontFamily = fontFamilySelect.value;
            const variationMethod = variationMethodSelect.value;

            // Safety cap
            const cols = Math.ceil(imgWidth / gridSize);
            const rows = Math.ceil(imgHeight / gridSize);
            const totalWords = cols * rows * wordsPerCell;
            if (totalWords > MAX_TOTAL_WORDS) {
                const newWPC = Math.max(1, Math.floor(MAX_TOTAL_WORDS / (cols * rows)));
                wordsPerCellSlider.value = newWPC;
                wordsPerCellValue.textContent = newWPC;
                statusEl.textContent = `Too many words → auto-reduced to ${newWPC}/cell`;
            }

            statusEl.textContent = 'Building word pool...';
            buildWordPool();
            precomputeCellColors(gridSize);

            // Clear & background
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Faint original image
            if (bgOpacity > 0) {
                ctx.globalAlpha = bgOpacity;
                ctx.drawImage(originalImg, 0, 0, canvas.width, canvas.height);
                ctx.globalAlpha = 1;
            }

            // Light tint
            ctx.fillStyle = `rgba(${overallColor[0]},${overallColor[1]},${overallColor[2]},0.68)`;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            statusEl.textContent = 'Rendering Taigi art... (this is fast now!)';

            const wordList = [];
            let cellIndex = 0;

            for (let y = 0; y < imgHeight; y += gridSize) {
                for (let x = 0; x < imgWidth; x += gridSize) {
                    const color = cellColors[cellIndex++] || [128,128,128];
                    const lum = getLuminance(...color);

                    for (let i = 0; i < wordsPerCell; i++) {
                        const word = getRandomWord();
                        const fSize = calculateFontSize(baseFontSize, variationPercent, lum, variationMethod);
                        const baseX = x + gridSize / 2;
                        const baseY = y + gridSize / 2;
                        const posX = baseX + (Math.random() * offset * 2 - offset);
                        const posY = baseY + (Math.random() * offset * 2 - offset);
                        const rot = (Math.random() * rotationMax * 2 - rotationMax);

                        wordList.push({
                            word, color, x: posX, y: posY,
                            fontSize: fSize,
                            rotation: rot,
                            stroke: strokeW
                        });
                    }
                }
            }

            shuffle(wordList);
            
            for (const item of wordList) {
                drawWord(
                    item.word, item.color, item.x, item.y,
                    item.fontSize, fontFamily, item.rotation, item.stroke
                );
            }

            statusEl.textContent = '✓ Done! Beautiful Taigi art ready';

            if (autoDownload) {
                downloadImage();
            } else {
                downloadButton.style.display = 'inline-block';
            }
        }

        function downloadImage() {
            canvas.toBlob(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `poj_bunji_gesut_${Date.now()}.png`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => {
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }, 100);
            }, 'image/png', 0.95);
        }

        // ==================== EVENT HANDLERS ====================
        function updateSlider(slider, display, suffix = '') {
            slider.addEventListener('input', () => {
                display.textContent = slider.value + suffix;
            });
        }

        uploadButton.addEventListener('click', () => imageInput.click());

        imageInput.addEventListener('change', async e => {
            const file = e.target.files[0];
            if (!file) return;

            if (file.size > MAX_FILE_SIZE) {
                alert(`檔案太大！最大 ${MAX_FILE_SIZE/1024/1024} MB`);
                return;
            }

            statusEl.textContent = 'Loading image...';
            renderButton.disabled = true;
            uploadButton.disabled = true;

            if (!fontsLoaded) await loadCustomFonts();

            const img = new Image();
            img.onload = async () => {
                originalImg = resizeImage(img); // auto-resize

                canvas.width = originalImg.width;
                canvas.height = originalImg.height;
                imgWidth = canvas.width;
                imgHeight = canvas.height;

                ctx.drawImage(originalImg, 0, 0);
                const data = ctx.getImageData(0, 0, canvas.width, canvas.height);
                imageData = data;

                let r=0, g=0, b=0, count=0;
                for (let i = 0; i < data.data.length; i += 4) {
                    r += data.data[i]; g += data.data[i+1]; b += data.data[i+2];
                    count++;
                }
                overallColor = [
                    Math.floor(r / count),
                    Math.floor(g / count),
                    Math.floor(b / count)
                ];

                statusEl.textContent = `Image loaded (${canvas.width}×${canvas.height})`;
                renderButton.disabled = false;
                uploadButton.disabled = false;

                // Auto render once
                setTimeout(() => renderCanvas(true), 180);
            };
            img.src = URL.createObjectURL(file);
        });

        renderButton.addEventListener('click', () => {
            renderButton.disabled = true;
            renderButton.textContent = 'Rendering...';
            renderCanvas(false);
            setTimeout(() => {
                renderButton.disabled = false;
                renderButton.textContent = 'Render Again';
            }, 800);
        });

        downloadButton.addEventListener('click', downloadImage);

        // Slider live updates
        updateSlider(gridSizeSlider, gridSizeValue);
        updateSlider(wordsPerCellSlider, wordsPerCellValue);
        updateSlider(offsetSlider, offsetValue);
        updateSlider(fontSizeSlider, fontSizeValue);
        updateSlider(sizeVariationSlider, sizeVariationValue, '%');
        updateSlider(rotationSlider, rotationValue, '°');
        updateSlider(bgOpacitySlider, bgOpacityValue, '%');
        updateSlider(strokeSlider, strokeValue);
        updateSlider(charLengthSlider, charLengthValue);

        // Trigger reload on some changes
        charLengthSlider.addEventListener('change', loadTaigiWords);
        customTextDelimiterSelect.addEventListener('change', () => {});
        customTextInput.addEventListener('input', () => {});

        // Keyboard shortcut: Ctrl/Cmd + Enter = render
        document.addEventListener('keydown', e => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'Enter') {
                if (!renderButton.disabled) renderCanvas(false);
            }
        });

        // ==================== INIT ====================
        document.addEventListener('DOMContentLoaded', async () => {
            await loadTaigiWords();
            await loadCustomFonts();
            
            // Initial value displays
            sizeVariationValue.textContent = '25%';
            rotationValue.textContent = '7°';
            bgOpacityValue.textContent = '14%';

            statusEl.textContent = '✓ Everything ready — upload a photo!';
        });
    </script>
</body>
</html>
