---
layout: null
title: Blog
permalink: /blog-app
---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog</title>
    <link rel="icon" type="image/svg+xml" href="./logo.svg" />

    <!-- Preconnect to API for faster first request -->
    <link rel="preconnect" href="https://cr-next-blog-firestore-276616043493.asia-east1.run.app" crossorigin />
    <link rel="dns-prefetch" href="https://cr-next-blog-firestore-276616043493.asia-east1.run.app" />

    <style>
        @font-face {
            font-family: 'ChiayiCity';
            src: url('https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/main/assets/fonts/ChiayiCity.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
    </style>

    <!-- CDN Libraries - React only (other libs bundled for reliability) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Loading skeleton styles - displays instantly before JS loads -->
    <style>
        .skeleton-loader {
            min-height: 100vh;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            display: flex;
            flex-direction: column;
        }

        .skeleton-nav {
            height: 64px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            padding: 0 24px;
        }

        .skeleton-logo {
            width: 120px;
            height: 24px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }

        .skeleton-content {
            flex: 1;
            max-width: 1200px;
            margin: 48px auto;
            padding: 0 24px;
            width: 100%;
        }

        .skeleton-title {
            width: 60%;
            height: 32px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 6px;
            margin-bottom: 32px;
        }

        .skeleton-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 24px;
        }

        .skeleton-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .skeleton-image {
            aspect-ratio: 16/10;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-text {
            padding: 16px;
        }

        .skeleton-line {
            height: 16px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .skeleton-line:last-child {
            width: 60%;
            margin-bottom: 0;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }

        @media (prefers-color-scheme: dark) {
            .skeleton-loader {
                background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            }

            .skeleton-nav {
                background: #1e293b;
                border-color: #334155;
            }

            .skeleton-logo,
            .skeleton-title,
            .skeleton-image,
            .skeleton-line {
                background: linear-gradient(90deg, #334155 25%, #475569 50%, #334155 75%);
                background-size: 200% 100%;
                animation: shimmer 1.5s infinite;
            }

            .skeleton-card {
                background: #1e293b;
            }
        }
    </style>
    <script type="module"
        crossorigin>var e, t, n = Object.defineProperty, r = (e, t, r) => ((e, t, r) => t in e ? n(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r); !function () { const e = document.createElement("link").relList; if (!(e && e.supports && e.supports("modulepreload"))) { for (const e of document.querySelectorAll('link[rel="modulepreload"]')) t(e); new MutationObserver(e => { for (const n of e) if ("childList" === n.type) for (const e of n.addedNodes) "LINK" === e.tagName && "modulepreload" === e.rel && t(e) }).observe(document, { childList: !0, subtree: !0 }) } function t(e) { if (e.ep) return; e.ep = !0; const t = function (e) { const t = {}; return e.integrity && (t.integrity = e.integrity), e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy), "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin", t }(e); fetch(e.href, t) } }(); var s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function i(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var o = { exports: {} }, a = {}, l = React, c = l, u = Symbol.for("react.element"), h = Symbol.for("react.fragment"), d = Object.prototype.hasOwnProperty, p = c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 }; function m(e, t, n) { var r, s = {}, i = null, o = null; for (r in void 0 !== n && (i = "" + n), void 0 !== t.key && (i = "" + t.key), void 0 !== t.ref && (o = t.ref), t) d.call(t, r) && !f.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === s[r] && (s[r] = t[r]); return { $$typeof: u, type: e, key: i, ref: o, props: s, _owner: p.current } } a.Fragment = h, a.jsx = m, a.jsxs = m, o.exports = a; var g, E, T = o.exports;
/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function A() { return A = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, A.apply(this, arguments) } (E = g || (g = {})).Pop = "POP", E.Push = "PUSH", E.Replace = "REPLACE"; const _ = "popstate"; function y(e) { return void 0 === e && (e = {}), function (e, t, n, r) { void 0 === r && (r = {}); let { window: s = document.defaultView, v5Compat: i = !1 } = r, o = s.history, a = g.Pop, l = null, c = u(); function u() { return (o.state || { idx: null }).idx } function h() { a = g.Pop; let e = u(), t = null == e ? null : e - c; c = e, l && l({ action: a, location: p.location, delta: t }) } function d(e) { let t = "null" !== s.location.origin ? s.location.origin : s.location.href, n = "string" == typeof e ? e : N(e); return n = n.replace(/ $/, "%20"), b(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == c && (c = 0, o.replaceState(A({}, o.state, { idx: c }), "")); let p = { get action() { return a }, get location() { return function (e, t) { let { pathname: n = "/", search: r = "", hash: s = "" } = I(e.location.hash.substr(1)); return n.startsWith("/") || n.startsWith(".") || (n = "/" + n), C("", { pathname: n, search: r, hash: s }, t.state && t.state.usr || null, t.state && t.state.key || "default") }(s, o) }, listen(e) { if (l) throw new Error("A history only accepts one active listener"); return s.addEventListener(_, h), l = e, () => { s.removeEventListener(_, h), l = null } }, createHref: e => function (e, t) { let n = e.document.querySelector("base"), r = ""; if (n && n.getAttribute("href")) { let t = e.location.href, n = t.indexOf("#"); r = -1 === n ? t : t.slice(0, n) } return r + "#" + ("string" == typeof t ? t : N(t)) }(s, e), createURL: d, encodeLocation(e) { let t = d(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, t) { a = g.Push; let r = C(p.location, e, t); n && n(r, e), c = u() + 1; let h = k(r, c), d = p.createHref(r); try { o.pushState(h, "", d) } catch (f) { if (f instanceof DOMException && "DataCloneError" === f.name) throw f; s.location.assign(d) } i && l && l({ action: a, location: p.location, delta: 1 }) }, replace: function (e, t) { a = g.Replace; let r = C(p.location, e, t); n && n(r, e), c = u(); let s = k(r, c), h = p.createHref(r); o.replaceState(s, "", h), i && l && l({ action: a, location: p.location, delta: 0 }) }, go: e => o.go(e) }; return p }(0, 0, function (e, t) { S("/" === e.pathname.charAt(0), "relative pathnames are not supported in hash history.push(" + JSON.stringify(t) + ")") }, e) } function b(e, t) { if (!1 === e || null == e) throw new Error(t) } function S(e, t) { if (!e) try { throw new Error(t) } catch (n) { } } function k(e, t) { return { usr: e.state, key: e.key, idx: t } } function C(e, t, n, r) { return void 0 === n && (n = null), A({ pathname: "string" == typeof e ? e : e.pathname, search: "", hash: "" }, "string" == typeof t ? I(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function N(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function I(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } var O, x; function R(e, t, n) { return void 0 === n && (n = "/"), function (e, t, n) { let r = Y(("string" == typeof t ? I(t) : t).pathname || "/", n); if (null == r) return null; let s = v(e); !function (e) { e.sort((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { return e.length === t.length && e.slice(0, -1).every((e, n) => e === t[n]) ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map(e => e.childrenIndex), t.routesMeta.map(e => e.childrenIndex))) }(s); let i = null; for (let o = 0; null == i && o < s.length; ++o) { let e = z(r); i = j(s[o], e) } return i }(e, t, n) } function v(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let s = (e, s, i) => { let o = { relativePath: void 0 === i ? e.path || "" : i, caseSensitive: !0 === e.caseSensitive, childrenIndex: s, route: e }; o.relativePath.startsWith("/") && (b(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), o.relativePath = o.relativePath.slice(r.length)); let a = Q([r, o.relativePath]), l = n.concat(o); e.children && e.children.length > 0 && (b(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'), v(e.children, t, l, a)), (null != e.path || e.index) && t.push({ path: a, score: H(a, e.index), routesMeta: l }) }; return e.forEach((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of D(e.path)) s(e, t, r); else s(e, t) }), t } function D(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, s = n.endsWith("?"), i = n.replace(/\?$/, ""); if (0 === r.length) return s ? [i, ""] : [i]; let o = D(r.join("/")), a = []; return a.push(...o.map(e => "" === e ? i : [i, e].join("/"))), s && a.push(...o), a.map(t => e.startsWith("/") && "" === t ? "/" : t) } (x = O || (O = {})).data = "data", x.deferred = "deferred", x.redirect = "redirect", x.error = "error"; const L = /^:[\w-]+$/, P = 3, w = 2, M = 1, F = 10, B = -2, U = e => "*" === e; function H(e, t) { let n = e.split("/"), r = n.length; return n.some(U) && (r += B), t && (r += w), n.filter(e => !U(e)).reduce((e, t) => e + (L.test(t) ? P : "" === t ? M : F), r) } function j(e, t, n) { let { routesMeta: r } = e, s = {}, i = "/", o = []; for (let a = 0; a < r.length; ++a) { let e = r[a], n = a === r.length - 1, l = "/" === i ? t : t.slice(i.length) || "/", c = G({ path: e.relativePath, caseSensitive: e.caseSensitive, end: n }, l), u = e.route; if (!c) return null; Object.assign(s, c.params), o.push({ params: s, pathname: Q([i, c.pathname]), pathnameBase: X(Q([i, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (i = Q([i, c.pathnameBase])) } return o } function G(e, t) { "string" == typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !0), S("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), s += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? s += "\\/*$" : "" !== e && "/" !== e && (s += "(?:(?=\\/|$))"), [new RegExp(s, t ? void 0 : "i"), r] }(e.path, e.caseSensitive, e.end), s = t.match(n); if (!s) return null; let i = s[0], o = i.replace(/(.)\/+$/, "$1"), a = s.slice(1); return { params: r.reduce((e, t, n) => { let { paramName: r, isOptional: s } = t; if ("*" === r) { let e = a[n] || ""; o = i.slice(0, i.length - e.length).replace(/(.)\/+$/, "$1") } const l = a[n]; return e[r] = s && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e }, {}), pathname: i, pathnameBase: o, pattern: e } } function z(e) { try { return e.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (t) { return S(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function Y(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } const q = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i; function V(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) }), n.length > 1 ? n.join("/") : "/" } function $(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function W(e, t) { let n = function (e) { return e.filter((e, t) => 0 === t || e.route.path && e.route.path.length > 0) }(e); return t ? n.map((e, t) => t === n.length - 1 ? e.pathname : e.pathnameBase) : n.map(e => e.pathnameBase) } function K(e, t, n, r) { let s; void 0 === r && (r = !1), "string" == typeof e ? s = I(e) : (s = A({}, e), b(!s.pathname || !s.pathname.includes("?"), $("?", "pathname", "search", s)), b(!s.pathname || !s.pathname.includes("#"), $("#", "pathname", "hash", s)), b(!s.search || !s.search.includes("#"), $("#", "search", "hash", s))); let i, o = "" === e || "" === s.pathname, a = o ? "/" : s.pathname; if (null == a) i = n; else { let e = t.length - 1; if (!r && a.startsWith("..")) { let t = a.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; s.pathname = t.join("/") } i = e >= 0 ? t[e] : "/" } let l = function (e, t) { void 0 === t && (t = "/"); let n, { pathname: r, search: s = "", hash: i = "" } = "string" == typeof e ? I(e) : e; if (r) if (o = r, q.test(o)) n = r; else { if (r.includes("//")) { let e = r; r = r.replace(/\/\/+/g, "/"), S(!1, "Pathnames cannot have embedded double slashes - normalizing " + e + " -> " + r) } n = r.startsWith("/") ? V(r.substring(1), "/") : V(r, t) } else n = t; var o; return { pathname: n, search: J(s), hash: Z(i) } }(s, i), c = a && "/" !== a && a.endsWith("/"), u = (o || "." === a) && n.endsWith("/"); return l.pathname.endsWith("/") || !c && !u || (l.pathname += "/"), l } const Q = e => e.join("/").replace(/\/\/+/g, "/"), X = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), J = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", Z = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; Error; const ee = ["post", "put", "patch", "delete"]; new Set(ee); const te = ["get", ...ee];
            /**
             * React Router v6.30.2
             *
             * Copyright (c) Remix Software Inc.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE.md file in the root directory of this source tree.
             *
             * @license MIT
             */
            function ne() { return ne = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ne.apply(this, arguments) } new Set(te); const re = React.createContext(null), se = React.createContext(null), ie = React.createContext(null), oe = React.createContext(null), ae = React.createContext({ outlet: null, matches: [], isDataRoute: !1 }), le = React.createContext(null); function ce() { return null != React.useContext(oe) } function ue() { return ce() || b(!1), React.useContext(oe).location } function he(e) { React.useContext(ie).static || React.useLayoutEffect(e) } function de() { let { isDataRoute: e } = React.useContext(ae); return e ? function () { let { router: e } = function () { let e = React.useContext(re); return e || b(!1), e }(Ae.UseNavigateStable), t = ye(_e.UseNavigateStable), n = React.useRef(!1); return he(() => { n.current = !0 }), React.useCallback(function (r, s) { void 0 === s && (s = {}), n.current && ("number" == typeof r ? e.navigate(r) : e.navigate(r, ne({ fromRouteId: t }, s))) }, [e, t]) }() : function () { ce() || b(!1); let e = React.useContext(re), { basename: t, future: n, navigator: r } = React.useContext(ie), { matches: s } = React.useContext(ae), { pathname: i } = ue(), o = JSON.stringify(W(s, n.v7_relativeSplatPath)), a = React.useRef(!1); return he(() => { a.current = !0 }), React.useCallback(function (n, s) { if (void 0 === s && (s = {}), !a.current) return; if ("number" == typeof n) return void r.go(n); let l = K(n, JSON.parse(o), i, "path" === s.relative); null == e && "/" !== t && (l.pathname = "/" === l.pathname ? t : Q([t, l.pathname])), (s.replace ? r.replace : r.push)(l, s.state, s) }, [t, r, o, i, e]) }() } function pe() { let { matches: e } = React.useContext(ae), t = e[e.length - 1]; return t ? t.params : {} } function fe(e, t) { let { relative: n } = void 0 === t ? {} : t, { future: r } = React.useContext(ie), { matches: s } = React.useContext(ae), { pathname: i } = ue(), o = JSON.stringify(W(s, r.v7_relativeSplatPath)); return React.useMemo(() => K(e, JSON.parse(o), i, "path" === n), [e, o, i, n]) } function me() { let e = function () { var e; let t = React.useContext(le), n = function () { let e = React.useContext(se); return e || b(!1), e }(), r = ye(); return void 0 !== t ? t : null == (e = n.errors) ? void 0 : e[r] }(), t = function (e) { return null != e && "number" == typeof e.status && "string" == typeof e.statusText && "boolean" == typeof e.internal && "data" in e }(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null; return React.createElement(React.Fragment, null, React.createElement("h2", null, "Unexpected Application Error!"), React.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? React.createElement("pre", { style: { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" } }, n) : null, null) } const ge = React.createElement(me, null); class Ee extends React.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: void 0 !== e.error ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { } render() { return void 0 !== this.state.error ? React.createElement(ae.Provider, { value: this.props.routeContext }, React.createElement(le.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Te(e) { let { routeContext: t, match: n, children: r } = e, s = React.useContext(re); return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), React.createElement(ae.Provider, { value: t }, r) } var Ae = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(Ae || {}), _e = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(_e || {}); function ye(e) { let t = function () { let e = React.useContext(ae); return e || b(!1), e }(), n = t.matches[t.matches.length - 1]; return n.route.id || b(!1), n.route.id } const be = {}; function Se(e) { let { to: t, replace: n, state: r, relative: s } = e; ce() || b(!1); let { future: i, static: o } = React.useContext(ie), { matches: a } = React.useContext(ae), { pathname: l } = ue(), c = de(), u = K(t, W(a, i.v7_relativeSplatPath), l, "path" === s), h = JSON.stringify(u); return React.useEffect(() => c(JSON.parse(h), { replace: n, state: r, relative: s }), [c, h, s, n, r]), null } function ke(e) { b(!1) } function Ce(e) { let { basename: t = "/", children: n = null, location: r, navigationType: s = g.Pop, navigator: i, static: o = !1, future: a } = e; ce() && b(!1); let l = t.replace(/^\/*/, "/"), c = React.useMemo(() => ({ basename: l, navigator: i, static: o, future: ne({ v7_relativeSplatPath: !1 }, a) }), [l, a, i, o]); "string" == typeof r && (r = I(r)); let { pathname: u = "/", search: h = "", hash: d = "", state: p = null, key: f = "default" } = r, m = React.useMemo(() => { let e = Y(u, l); return null == e ? null : { location: { pathname: e, search: h, hash: d, state: p, key: f }, navigationType: s } }, [l, u, h, d, p, f, s]); return null == m ? null : React.createElement(ie.Provider, { value: c }, React.createElement(oe.Provider, { children: n, value: m })) } function Ne(e) { let { children: t, location: n } = e; return function (e, t) { ce() || b(!1); let { navigator: n } = React.useContext(ie), { matches: r } = React.useContext(ae), s = r[r.length - 1], i = s ? s.params : {}; !s || s.pathname; let o = s ? s.pathnameBase : "/"; s && s.route; let a, l = ue(); if (t) { var c; let e = "string" == typeof t ? I(t) : t; "/" === o || (null == (c = e.pathname) ? void 0 : c.startsWith(o)) || b(!1), a = e } else a = l; let u = a.pathname || "/", h = u; if ("/" !== o) { let e = o.replace(/^\//, "").split("/"); h = "/" + u.replace(/^\//, "").split("/").slice(e.length).join("/") } let d = R(e, { pathname: h }), p = function (e, t, n, r) { var s; if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === r && (r = null), null == e) { var i; if (!n) return null; if (n.errors) e = n.matches; else { if (!(null != (i = r) && i.v7_partialHydration && 0 === t.length && !n.initialized && n.matches.length > 0)) return null; e = n.matches } } let o = e, a = null == (s = n) ? void 0 : s.errors; if (null != a) { let e = o.findIndex(e => e.route.id && void 0 !== (null == a ? void 0 : a[e.route.id])); e >= 0 || b(!1), o = o.slice(0, Math.min(o.length, e + 1)) } let l = !1, c = -1; if (n && r && r.v7_partialHydration) for (let u = 0; u < o.length; u++) { let e = o[u]; if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (c = u), e.route.id) { let { loaderData: t, errors: r } = n, s = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]); if (e.route.lazy || s) { l = !0, o = c >= 0 ? o.slice(0, c + 1) : [o[0]]; break } } } return o.reduceRight((e, r, s) => { let i, u = !1, h = null, d = null; n && (i = a && r.route.id ? a[r.route.id] : void 0, h = r.route.errorElement || ge, l && (c < 0 && 0 === s ? (be["route-fallback"] || (be["route-fallback"] = !0), u = !0, d = null) : c === s && (u = !0, d = r.route.hydrateFallbackElement || null))); let p = t.concat(o.slice(0, s + 1)), f = () => { let t; return t = i ? h : u ? d : r.route.Component ? React.createElement(r.route.Component, null) : r.route.element ? r.route.element : e, React.createElement(Te, { match: r, routeContext: { outlet: e, matches: p, isDataRoute: null != n }, children: t }) }; return n && (r.route.ErrorBoundary || r.route.errorElement || 0 === s) ? React.createElement(Ee, { location: n.location, revalidation: n.revalidation, component: h, error: i, children: f(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : f() }, null) }(d && d.map(e => Object.assign({}, e, { params: Object.assign({}, i, e.params), pathname: Q([o, n.encodeLocation ? n.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? o : Q([o, n.encodeLocation ? n.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) })), r, void 0, void 0); return t && p ? React.createElement(oe.Provider, { value: { location: ne({ pathname: "/", search: "", hash: "", state: null, key: "default" }, a), navigationType: g.Pop } }, p) : p }(Ie(t), n) } function Ie(e, t) { void 0 === t && (t = []); let n = []; return React.Children.forEach(e, (e, r) => { if (!React.isValidElement(e)) return; let s = [...t, r]; if (e.type === React.Fragment) return void n.push.apply(n, Ie(e.props.children, s)); e.type !== ke && b(!1), e.props.index && e.props.children && b(!1); let i = { id: e.props.id || s.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (i.children = Ie(e.props.children, s)), n.push(i) }), n }
/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Oe() { return Oe = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Oe.apply(this, arguments) } React.startTransition, new Promise(() => { }), React.Component; const xe = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]; try { window.__reactRouterVersion = "6" } catch (ag) { } const Re = React.startTransition; function ve(e) { let { basename: t, children: n, future: r, window: s } = e, i = React.useRef(); null == i.current && (i.current = y({ window: s, v5Compat: !0 })); let o = i.current, [a, l] = React.useState({ action: o.action, location: o.location }), { v7_startTransition: c } = r || {}, u = React.useCallback(e => { c && Re ? Re(() => l(e)) : l(e) }, [l, c]); return React.useLayoutEffect(() => o.listen(u), [o, u]), React.useEffect(() => { return null == (e = r) || e.v7_startTransition, void (null == e || e.v7_relativeSplatPath); var e }, [r]), React.createElement(Ce, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } ReactDOM.flushSync, React.useId; const De = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement, Le = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Pe = React.forwardRef(function (e, t) { let n, { onClick: r, relative: s, reloadDocument: i, replace: o, state: a, target: l, to: c, preventScrollReset: u, viewTransition: h } = e, d = function (e, t) { if (null == e) return {}; var n, r, s = {}, i = Object.keys(e); for (r = 0; r < i.length; r++)n = i[r], t.indexOf(n) >= 0 || (s[n] = e[n]); return s }(e, xe), { basename: p } = React.useContext(ie), f = !1; if ("string" == typeof c && Le.test(c) && (n = c, De)) try { let e = new URL(window.location.href), t = c.startsWith("//") ? new URL(e.protocol + c) : new URL(c), n = Y(t.pathname, p); t.origin === e.origin && null != n ? c = n + t.search + t.hash : f = !0 } catch (ag) { } let m = function (e, t) { let { relative: n } = void 0 === t ? {} : t; ce() || b(!1); let { basename: r, navigator: s } = React.useContext(ie), { hash: i, pathname: o, search: a } = fe(e, { relative: n }), l = o; return "/" !== r && (l = "/" === o ? r : Q([r, o])), s.createHref({ pathname: l, search: a, hash: i }) }(c, { relative: s }), g = function (e, t) { let { target: n, replace: r, state: s, preventScrollReset: i, relative: o, viewTransition: a } = void 0 === t ? {} : t, l = de(), c = ue(), u = fe(e, { relative: o }); return React.useCallback(t => { if (function (e, t) { return !(0 !== e.button || t && "_self" !== t || function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) }(e)) }(t, n)) { t.preventDefault(); let n = void 0 !== r ? r : N(c) === N(u); l(e, { replace: n, state: s, preventScrollReset: i, relative: o, viewTransition: a }) } }, [c, l, u, r, s, n, e, i, o, a]) }(c, { replace: o, state: a, target: l, preventScrollReset: u, relative: s, viewTransition: h }); return React.createElement("a", Oe({}, d, { href: n || m, onClick: f || i ? r : function (e) { r && r(e), e.defaultPrevented || g(e) }, ref: t, target: l })) }); var we, Me, Fe, Be; (Me = we || (we = {})).UseScrollRestoration = "useScrollRestoration", Me.UseSubmit = "useSubmit", Me.UseSubmitFetcher = "useSubmitFetcher", Me.UseFetcher = "useFetcher", Me.useViewTransitionState = "useViewTransitionState", (Be = Fe || (Fe = {})).UseFetcher = "useFetcher", Be.UseFetchers = "useFetchers", Be.UseScrollRestoration = "useScrollRestoration"; var Ue = "undefined" != typeof Element, He = "function" == typeof Map, je = "function" == typeof Set, Ge = "function" == typeof ArrayBuffer && !!ArrayBuffer.isView; function ze(e, t) { if (e === t) return !0; if (e && t && "object" == typeof e && "object" == typeof t) { if (e.constructor !== t.constructor) return !1; var n, r, s, i; if (Array.isArray(e)) { if ((n = e.length) != t.length) return !1; for (r = n; 0 !== r--;)if (!ze(e[r], t[r])) return !1; return !0 } if (He && e instanceof Map && t instanceof Map) { if (e.size !== t.size) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!t.has(r.value[0])) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!ze(r.value[1], t.get(r.value[0]))) return !1; return !0 } if (je && e instanceof Set && t instanceof Set) { if (e.size !== t.size) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!t.has(r.value[0])) return !1; return !0 } if (Ge && ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) { if ((n = e.length) != t.length) return !1; for (r = n; 0 !== r--;)if (e[r] !== t[r]) return !1; return !0 } if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags; if (e.valueOf !== Object.prototype.valueOf && "function" == typeof e.valueOf && "function" == typeof t.valueOf) return e.valueOf() === t.valueOf(); if (e.toString !== Object.prototype.toString && "function" == typeof e.toString && "function" == typeof t.toString) return e.toString() === t.toString(); if ((n = (s = Object.keys(e)).length) !== Object.keys(t).length) return !1; for (r = n; 0 !== r--;)if (!Object.prototype.hasOwnProperty.call(t, s[r])) return !1; if (Ue && e instanceof Element) return !1; for (r = n; 0 !== r--;)if (("_owner" !== s[r] && "__v" !== s[r] && "__o" !== s[r] || !e.$$typeof) && !ze(e[s[r]], t[s[r]])) return !1; return !0 } return e != e && t != t } const Ye = i(function (e, t) { try { return ze(e, t) } catch (n) { if ((n.message || "").match(/stack|recursion/i)) return !1; throw n } }), qe = i(function (e, t, n, r, s, i, o, a) { if (!e) { var l; if (void 0 === t) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, s, i, o, a], u = 0; (l = new Error(t.replace(/%s/g, function () { return c[u++] }))).name = "Invariant Violation" } throw l.framesToPop = 1, l } }), Ve = i(function (e, t, n, r) { var s = n ? n.call(r, e, t) : void 0; if (void 0 !== s) return !!s; if (e === t) return !0; if ("object" != typeof e || !e || "object" != typeof t || !t) return !1; var i = Object.keys(e), o = Object.keys(t); if (i.length !== o.length) return !1; for (var a = Object.prototype.hasOwnProperty.bind(t), l = 0; l < i.length; l++) { var c = i[l]; if (!a(c)) return !1; var u = e[c], h = t[c]; if (!1 === (s = n ? n.call(r, u, h, c) : void 0) || void 0 === s && u !== h) return !1 } return !0 }); var $e = (e => (e.BASE = "base", e.BODY = "body", e.HEAD = "head", e.HTML = "html", e.LINK = "link", e.META = "meta", e.NOSCRIPT = "noscript", e.SCRIPT = "script", e.STYLE = "style", e.TITLE = "title", e.FRAGMENT = "Symbol(react.fragment)", e))($e || {}), We = { rel: ["amphtml", "canonical", "alternate"] }, Ke = { type: ["application/ld+json"] }, Qe = { charset: "", name: ["generator", "robots", "description"], property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"] }, Xe = Object.values($e), Je = { accesskey: "accessKey", charset: "charSet", class: "className", contenteditable: "contentEditable", contextmenu: "contextMenu", "http-equiv": "httpEquiv", itemprop: "itemProp", tabindex: "tabIndex" }, Ze = Object.entries(Je).reduce((e, [t, n]) => (e[n] = t, e), {}), et = "data-rh", tt = (e, t) => { for (let n = e.length - 1; n >= 0; n -= 1) { const r = e[n]; if (Object.prototype.hasOwnProperty.call(r, t)) return r[t] } return null }, nt = e => { let t = tt(e, "title"); const n = tt(e, "titleTemplate"); if (Array.isArray(t) && (t = t.join("")), n && t) return n.replace(/%s/g, () => t); const r = tt(e, "defaultTitle"); return t || r || void 0 }, rt = e => tt(e, "onChangeClientState") || (() => { }), st = (e, t) => t.filter(t => void 0 !== t[e]).map(t => t[e]).reduce((e, t) => ({ ...e, ...t }), {}), it = (e, t) => t.filter(e => void 0 !== e.base).map(e => e.base).reverse().reduce((t, n) => { if (!t.length) { const r = Object.keys(n); for (let s = 0; s < r.length; s += 1) { const i = r[s].toLowerCase(); if (-1 !== e.indexOf(i) && n[i]) return t.concat(n) } } return t }, []), ot = (e, t, n) => { const r = {}; return n.filter(t => !!Array.isArray(t[e]) || (void 0 !== t[e] && (t[e], console && console.warn), !1)).map(t => t[e]).reverse().reduce((e, n) => { const s = {}; n.filter(e => { let n; const i = Object.keys(e); for (let r = 0; r < i.length; r += 1) { const s = i[r], o = s.toLowerCase(); -1 === t.indexOf(o) || "rel" === n && "canonical" === e[n].toLowerCase() || "rel" === o && "stylesheet" === e[o].toLowerCase() || (n = o), -1 === t.indexOf(s) || "innerHTML" !== s && "cssText" !== s && "itemprop" !== s || (n = s) } if (!n || !e[n]) return !1; const o = e[n].toLowerCase(); return r[n] || (r[n] = {}), s[n] || (s[n] = {}), !r[n][o] && (s[n][o] = !0, !0) }).reverse().forEach(t => e.push(t)); const i = Object.keys(s); for (let t = 0; t < i.length; t += 1) { const e = i[t], n = { ...r[e], ...s[e] }; r[e] = n } return e }, []).reverse() }, at = (e, t) => { if (Array.isArray(e) && e.length) for (let n = 0; n < e.length; n += 1)if (e[n][t]) return !0; return !1 }, lt = e => Array.isArray(e) ? e.join("") : e, ct = (e, t) => Array.isArray(e) ? e.reduce((e, n) => (((e, t) => { const n = Object.keys(e); for (let r = 0; r < n.length; r += 1)if (t[n[r]] && t[n[r]].includes(e[n[r]])) return !0; return !1 })(n, t) ? e.priority.push(n) : e.default.push(n), e), { priority: [], default: [] }) : { default: e, priority: [] }, ut = (e, t) => ({ ...e, [t]: void 0 }), ht = ["noscript", "script", "style"], dt = (e, t = !0) => !1 === t ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"), pt = e => Object.keys(e).reduce((t, n) => { const r = void 0 !== e[n] ? `${n}="${e[n]}"` : `${n}`; return t ? `${t} ${r}` : r }, ""), ft = (e, t = {}) => Object.keys(e).reduce((t, n) => (t[Je[n] || n] = e[n], t), t), mt = (e, t) => t.map((t, n) => { const r = { key: n, [et]: !0 }; return Object.keys(t).forEach(e => { const n = Je[e] || e; if ("innerHTML" === n || "cssText" === n) { const e = t.innerHTML || t.cssText; r.dangerouslySetInnerHTML = { __html: e } } else r[n] = t[e] }), React.createElement(e, r) }), gt = (e, t, n = !0) => { switch (e) { case "title": return { toComponent: () => ((e, t, n) => { const r = ft(n, { key: t, [et]: !0 }); return [React.createElement("title", r, t)] })(0, t.title, t.titleAttributes), toString: () => ((e, t, n, r) => { const s = pt(n), i = lt(t); return s ? `<${e} ${et}="true" ${s}>${dt(i, r)}</${e}>` : `<${e} ${et}="true">${dt(i, r)}</${e}>` })(e, t.title, t.titleAttributes, n) }; case "bodyAttributes": case "htmlAttributes": return { toComponent: () => ft(t), toString: () => pt(t) }; default: return { toComponent: () => mt(e, t), toString: () => ((e, t, n = !0) => t.reduce((t, r) => { const s = r, i = Object.keys(s).filter(e => !("innerHTML" === e || "cssText" === e)).reduce((e, t) => { const r = void 0 === s[t] ? t : `${t}="${dt(s[t], n)}"`; return e ? `${e} ${r}` : r }, ""), o = s.innerHTML || s.cssText || "", a = -1 === ht.indexOf(e); return `${t}<${e} ${et}="true" ${i}${a ? "/>" : `>${o}</${e}>`}` }, ""))(e, t, n) } } }, Et = e => { const { baseTag: t, bodyAttributes: n, encode: r = !0, htmlAttributes: s, noscriptTags: i, styleTags: o, title: a = "", titleAttributes: l, prioritizeSeoTags: c } = e; let { linkTags: u, metaTags: h, scriptTags: d } = e, p = { toComponent: () => { }, toString: () => "" }; return c && ({ priorityMethods: p, linkTags: u, metaTags: h, scriptTags: d } = (({ metaTags: e, linkTags: t, scriptTags: n, encode: r }) => { const s = ct(e, Qe), i = ct(t, We), o = ct(n, Ke); return { priorityMethods: { toComponent: () => [...mt("meta", s.priority), ...mt("link", i.priority), ...mt("script", o.priority)], toString: () => `${gt("meta", s.priority, r)} ${gt("link", i.priority, r)} ${gt("script", o.priority, r)}` }, metaTags: s.default, linkTags: i.default, scriptTags: o.default } })(e)), { priority: p, base: gt("base", t, r), bodyAttributes: gt("bodyAttributes", n, r), htmlAttributes: gt("htmlAttributes", s, r), link: gt("link", u, r), meta: gt("meta", h, r), noscript: gt("noscript", i, r), script: gt("script", d, r), style: gt("style", o, r), title: gt("title", { title: a, titleAttributes: l }, r) } }, Tt = [], At = !("undefined" == typeof window || !window.document || !window.document.createElement), _t = class { constructor(e, t) { r(this, "instances", []), r(this, "canUseDOM", At), r(this, "context"), r(this, "value", { setHelmet: e => { this.context.helmet = e }, helmetInstances: { get: () => this.canUseDOM ? Tt : this.instances, add: e => { (this.canUseDOM ? Tt : this.instances).push(e) }, remove: e => { const t = (this.canUseDOM ? Tt : this.instances).indexOf(e); (this.canUseDOM ? Tt : this.instances).splice(t, 1) } } }), this.context = e, this.canUseDOM = t || !1, t || (e.helmet = Et({ baseTag: [], bodyAttributes: {}, htmlAttributes: {}, linkTags: [], metaTags: [], noscriptTags: [], scriptTags: [], styleTags: [], title: "", titleAttributes: {} })) } }, yt = React.createContext({}), bt = (e = class extends React.Component { constructor(t) { super(t), r(this, "helmetData"), this.helmetData = new _t(this.props.context || {}, e.canUseDOM) } render() { return React.createElement(yt.Provider, { value: this.helmetData.value }, this.props.children) } }, r(e, "canUseDOM", At), e), St = (e, t) => { const n = document.head || document.querySelector("head"), r = n.querySelectorAll(`${e}[${et}]`), s = [].slice.call(r), i = []; let o; return t && t.length && t.forEach(t => { const n = document.createElement(e); for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) if ("innerHTML" === e) n.innerHTML = t.innerHTML; else if ("cssText" === e) n.styleSheet ? n.styleSheet.cssText = t.cssText : n.appendChild(document.createTextNode(t.cssText)); else { const r = e, s = void 0 === t[r] ? "" : t[r]; n.setAttribute(e, s) } n.setAttribute(et, "true"), s.some((e, t) => (o = t, n.isEqualNode(e))) ? s.splice(o, 1) : i.push(n) }), s.forEach(e => { var t; return null == (t = e.parentNode) ? void 0 : t.removeChild(e) }), i.forEach(e => n.appendChild(e)), { oldTags: s, newTags: i } }, kt = (e, t) => { const n = document.getElementsByTagName(e)[0]; if (!n) return; const r = n.getAttribute(et), s = r ? r.split(",") : [], i = [...s], o = Object.keys(t); for (const a of o) { const e = t[a] || ""; n.getAttribute(a) !== e && n.setAttribute(a, e), -1 === s.indexOf(a) && s.push(a); const r = i.indexOf(a); -1 !== r && i.splice(r, 1) } for (let a = i.length - 1; a >= 0; a -= 1)n.removeAttribute(i[a]); s.length === i.length ? n.removeAttribute(et) : n.getAttribute(et) !== o.join(",") && n.setAttribute(et, o.join(",")) }, Ct = (e, t) => { const { baseTag: n, bodyAttributes: r, htmlAttributes: s, linkTags: i, metaTags: o, noscriptTags: a, onChangeClientState: l, scriptTags: c, styleTags: u, title: h, titleAttributes: d } = e; kt("body", r), kt("html", s), ((e, t) => { void 0 !== e && document.title !== e && (document.title = lt(e)), kt("title", t) })(h, d); const p = { baseTag: St("base", n), linkTags: St("link", i), metaTags: St("meta", o), noscriptTags: St("noscript", a), scriptTags: St("script", c), styleTags: St("style", u) }, f = {}, m = {}; Object.keys(p).forEach(e => { const { newTags: t, oldTags: n } = p[e]; t.length && (f[e] = t), n.length && (m[e] = p[e].oldTags) }), t && t(), l(e, f, m) }, Nt = null, It = class extends React.Component { constructor() { super(...arguments), r(this, "rendered", !1) } shouldComponentUpdate(e) { return !Ve(e, this.props) } componentDidUpdate() { this.emitChange() } componentWillUnmount() { const { helmetInstances: e } = this.props.context; e.remove(this), this.emitChange() } emitChange() { const { helmetInstances: e, setHelmet: t } = this.props.context; let n = null; const r = (s = e.get().map(e => { const t = { ...e.props }; return delete t.context, t }), { baseTag: it(["href"], s), bodyAttributes: st("bodyAttributes", s), defer: tt(s, "defer"), encode: tt(s, "encodeSpecialCharacters"), htmlAttributes: st("htmlAttributes", s), linkTags: ot("link", ["rel", "href"], s), metaTags: ot("meta", ["name", "charset", "http-equiv", "property", "itemprop"], s), noscriptTags: ot("noscript", ["innerHTML"], s), onChangeClientState: rt(s), scriptTags: ot("script", ["src", "innerHTML"], s), styleTags: ot("style", ["cssText"], s), title: nt(s), titleAttributes: st("titleAttributes", s), prioritizeSeoTags: at(s, "prioritizeSeoTags") }); var s, i; bt.canUseDOM ? (i = r, Nt && cancelAnimationFrame(Nt), i.defer ? Nt = requestAnimationFrame(() => { Ct(i, () => { Nt = null }) }) : (Ct(i), Nt = null)) : Et && (n = Et(r)), t(n) } init() { if (this.rendered) return; this.rendered = !0; const { helmetInstances: e } = this.props.context; e.add(this), this.emitChange() } render() { return this.init(), null } }, Ot = (t = class extends React.Component { shouldComponentUpdate(e) { return !Ye(ut(this.props, "helmetData"), ut(e, "helmetData")) } mapNestedChildrenToProps(e, t) { if (!t) return null; switch (e.type) { case "script": case "noscript": return { innerHTML: t }; case "style": return { cssText: t }; default: throw new Error(`<${e.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`) } } flattenArrayTypeChildren(e, t, n, r) { return { ...t, [e.type]: [...t[e.type] || [], { ...n, ...this.mapNestedChildrenToProps(e, r) }] } } mapObjectTypeChildren(e, t, n, r) { switch (e.type) { case "title": return { ...t, [e.type]: r, titleAttributes: { ...n } }; case "body": return { ...t, bodyAttributes: { ...n } }; case "html": return { ...t, htmlAttributes: { ...n } }; default: return { ...t, [e.type]: { ...n } } } } mapArrayTypeChildrenToProps(e, t) { let n = { ...t }; return Object.keys(e).forEach(t => { n = { ...n, [t]: e[t] } }), n } warnOnInvalidChildren(e, t) { return qe(Xe.some(t => e.type === t), "function" == typeof e.type ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${Xe.join(", ")} are allowed. Helmet does not support rendering <${e.type}> elements. Refer to our API for more information.`), qe(!t || "string" == typeof t || Array.isArray(t) && !t.some(e => "string" != typeof e), `Helmet expects a string as a child of <${e.type}>. Did you forget to wrap your children in braces? ( <${e.type}>{\`\`}</${e.type}> ) Refer to our API for more information.`), !0 } mapChildrenToProps(e, t) { let n = {}; return React.Children.forEach(e, e => { if (!e || !e.props) return; const { children: r, ...s } = e.props, i = Object.keys(s).reduce((e, t) => (e[Ze[t] || t] = s[t], e), {}); let { type: o } = e; switch ("symbol" == typeof o ? o = o.toString() : this.warnOnInvalidChildren(e, r), o) { case "Symbol(react.fragment)": t = this.mapChildrenToProps(r, t); break; case "link": case "meta": case "noscript": case "script": case "style": n = this.flattenArrayTypeChildren(e, n, i, r); break; default: t = this.mapObjectTypeChildren(e, t, i, r) } }), this.mapArrayTypeChildrenToProps(n, t) } render() { const { children: e, ...t } = this.props; let n = { ...t }, { helmetData: r } = t; return e && (n = this.mapChildrenToProps(e, n)), !r || r instanceof _t || (r = new _t(r.context, !0), delete n.helmetData), r ? React.createElement(It, { ...n, context: r.value }) : React.createElement(yt.Consumer, null, e => React.createElement(It, { ...n, context: e })) } }, r(t, "defaultProps", { defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1 }), t); const xt = React.createContext(void 0); function Rt({ children: e }) { const [t, n] = React.useState(() => { try { const e = localStorage.getItem("cr-blog-theme") || localStorage.getItem("theme"); if ("dark" === e || "light" === e) return e } catch (ag) { } return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" }), [r, s] = React.useState(() => { try { const e = localStorage.getItem("cr-blog-text-size") || localStorage.getItem("textSize"); if ("small" === e || "medium" === e || "large" === e || "xlarge" === e || "xxlarge" === e || "xxxlarge" === e) return e } catch (ag) { } return "medium" }); return React.useEffect(() => { const e = document.documentElement; e.classList.remove("light", "dark"), e.classList.add(t); try { localStorage.setItem("cr-blog-theme", t), localStorage.removeItem("theme") } catch (ag) { } }, [t]), React.useEffect(() => { document.documentElement.setAttribute("data-text-size", r); try { localStorage.setItem("cr-blog-text-size", r), localStorage.removeItem("textSize") } catch (ag) { } }, [r]), React.useEffect(() => { const e = document.documentElement; e.style.setProperty("--prose-body-line-height", String(1.8)), e.style.setProperty("--prose-list-line-height", String(1.65)), e.style.setProperty("--prose-blockquote-line-height", String(1.65)) }, []), T.jsx(xt.Provider, { value: { theme: t, textSize: r, toggleTheme: () => { n(e => "light" === e ? "dark" : "light") }, setTextSize: e => { s(e) } }, children: e }) } const vt = e => "string" == typeof e, Dt = () => { let e, t; const n = new Promise((n, r) => { e = n, t = r }); return n.resolve = e, n.reject = t, n }, Lt = e => null == e ? "" : "" + e, Pt = /###/g, wt = e => e && e.indexOf("###") > -1 ? e.replace(Pt, ".") : e, Mt = e => !e || vt(e), Ft = (e, t, n) => { const r = vt(t) ? t.split(".") : t; let s = 0; for (; s < r.length - 1;) { if (Mt(e)) return {}; const t = wt(r[s]); !e[t] && n && (e[t] = new n), e = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : {}, ++s } return Mt(e) ? {} : { obj: e, k: wt(r[s]) } }, Bt = (e, t, n) => { const { obj: r, k: s } = Ft(e, t, Object); if (void 0 !== r || 1 === t.length) return void (r[s] = n); let i = t[t.length - 1], o = t.slice(0, t.length - 1), a = Ft(e, o, Object); for (; void 0 === a.obj && o.length;)i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), a = Ft(e, o, Object), (null == a ? void 0 : a.obj) && void 0 !== a.obj[`${a.k}.${i}`] && (a.obj = void 0); a.obj[`${a.k}.${i}`] = n }, Ut = (e, t) => { const { obj: n, k: r } = Ft(e, t); if (n && Object.prototype.hasOwnProperty.call(n, r)) return n[r] }, Ht = (e, t, n) => { for (const r in t) "__proto__" !== r && "constructor" !== r && (r in e ? vt(e[r]) || e[r] instanceof String || vt(t[r]) || t[r] instanceof String ? n && (e[r] = t[r]) : Ht(e[r], t[r], n) : e[r] = t[r]); return e }, jt = e => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"); var Gt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" }; const zt = e => vt(e) ? e.replace(/[&<>"'\/]/g, e => Gt[e]) : e, Yt = [" ", ",", "?", "!", ";"], qt = new class { constructor(e) { this.capacity = e, this.regExpMap = new Map, this.regExpQueue = [] } getRegExp(e) { const t = this.regExpMap.get(e); if (void 0 !== t) return t; const n = new RegExp(e); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n } }(20), Vt = (e, t, n = ".") => { if (!e) return; if (e[t]) { if (!Object.prototype.hasOwnProperty.call(e, t)) return; return e[t] } const r = t.split(n); let s = e; for (let i = 0; i < r.length;) { if (!s || "object" != typeof s) return; let e, t = ""; for (let o = i; o < r.length; ++o)if (o !== i && (t += n), t += r[o], e = s[t], void 0 !== e) { if (["string", "number", "boolean"].indexOf(typeof e) > -1 && o < r.length - 1) continue; i += o - i + 1; break } s = e } return s }, $t = e => null == e ? void 0 : e.replace("_", "-"), Wt = { type: "logger", log(e) { this.output("log", e) }, warn(e) { this.output("warn", e) }, error(e) { this.output("error", e) }, output(e, t) { var n, r; null == (r = null == (n = null == console ? void 0 : console[e]) ? void 0 : n.apply) || r.call(n, console, t) } }; class Kt { constructor(e, t = {}) { this.init(e, t) } init(e, t = {}) { this.prefix = t.prefix || "i18next:", this.logger = e || Wt, this.options = t, this.debug = t.debug } log(...e) { return this.forward(e, "log", "", !0) } warn(...e) { return this.forward(e, "warn", "", !0) } error(...e) { return this.forward(e, "error", "") } deprecate(...e) { return this.forward(e, "warn", "WARNING DEPRECATED: ", !0) } forward(e, t, n, r) { return r && !this.debug ? null : (vt(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e)) } create(e) { return new Kt(this.logger, { prefix: `${this.prefix}:${e}:`, ...this.options }) } clone(e) { return (e = e || this.options).prefix = e.prefix || this.prefix, new Kt(this.logger, e) } } var Qt = new Kt; class Xt { constructor() { this.observers = {} } on(e, t) { return e.split(" ").forEach(e => { this.observers[e] || (this.observers[e] = new Map); const n = this.observers[e].get(t) || 0; this.observers[e].set(t, n + 1) }), this } off(e, t) { this.observers[e] && (t ? this.observers[e].delete(t) : delete this.observers[e]) } emit(e, ...t) { this.observers[e] && Array.from(this.observers[e].entries()).forEach(([e, n]) => { for (let r = 0; r < n; r++)e(...t) }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([n, r]) => { for (let s = 0; s < r; s++)n.apply(n, [e, ...t]) }) } } class Jt extends Xt { constructor(e, t = { ns: ["translation"], defaultNS: "translation" }) { super(), this.data = e || {}, this.options = t, void 0 === this.options.keySeparator && (this.options.keySeparator = "."), void 0 === this.options.ignoreJSONStructure && (this.options.ignoreJSONStructure = !0) } addNamespaces(e) { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) } removeNamespaces(e) { const t = this.options.ns.indexOf(e); t > -1 && this.options.ns.splice(t, 1) } getResource(e, t, n, r = {}) { var s, i; const o = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, a = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure; let l; e.indexOf(".") > -1 ? l = e.split(".") : (l = [e, t], n && (Array.isArray(n) ? l.push(...n) : vt(n) && o ? l.push(...n.split(o)) : l.push(n))); const c = Ut(this.data, l); return !c && !t && !n && e.indexOf(".") > -1 && (e = l[0], t = l[1], n = l.slice(2).join(".")), !c && a && vt(n) ? Vt(null == (i = null == (s = this.data) ? void 0 : s[e]) ? void 0 : i[t], n, o) : c } addResource(e, t, n, r, s = { silent: !1 }) { const i = void 0 !== s.keySeparator ? s.keySeparator : this.options.keySeparator; let o = [e, t]; n && (o = o.concat(i ? n.split(i) : n)), e.indexOf(".") > -1 && (o = e.split("."), r = t, t = o[1]), this.addNamespaces(t), Bt(this.data, o, r), s.silent || this.emit("added", e, t, n, r) } addResources(e, t, n, r = { silent: !1 }) { for (const s in n) (vt(n[s]) || Array.isArray(n[s])) && this.addResource(e, t, s, n[s], { silent: !0 }); r.silent || this.emit("added", e, t, n) } addResourceBundle(e, t, n, r, s, i = { silent: !1, skipCopy: !1 }) { let o = [e, t]; e.indexOf(".") > -1 && (o = e.split("."), r = n, n = t, t = o[1]), this.addNamespaces(t); let a = Ut(this.data, o) || {}; i.skipCopy || (n = JSON.parse(JSON.stringify(n))), r ? Ht(a, n, s) : a = { ...a, ...n }, Bt(this.data, o, a), i.silent || this.emit("added", e, t, n) } removeResourceBundle(e, t) { this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t) } hasResourceBundle(e, t) { return void 0 !== this.getResource(e, t) } getResourceBundle(e, t) { return t || (t = this.options.defaultNS), this.getResource(e, t) } getDataByLanguage(e) { return this.data[e] } hasLanguageSomeTranslations(e) { const t = this.getDataByLanguage(e); return !!(t && Object.keys(t) || []).find(e => t[e] && Object.keys(t[e]).length > 0) } toJSON() { return this.data } } var Zt = { processors: {}, addPostProcessor(e) { this.processors[e.name] = e }, handle(e, t, n, r, s) { return e.forEach(e => { var i; t = (null == (i = this.processors[e]) ? void 0 : i.process(t, n, r, s)) ?? t }), t } }; const en = Symbol("i18next/PATH_KEY"); function tn(e, t) { const { [en]: n } = e(function () { const e = [], t = Object.create(null); let n; return t.get = (r, s) => { var i; return null == (i = null == n ? void 0 : n.revoke) || i.call(n), s === en ? e : (e.push(s), n = Proxy.revocable(r, t), n.proxy) }, Proxy.revocable(Object.create(null), t).proxy }()); return n.join((null == t ? void 0 : t.keySeparator) ?? ".") } const nn = {}, rn = e => !vt(e) && "boolean" != typeof e && "number" != typeof e; class sn extends Xt { constructor(e, t = {}) { var n, r; super(), n = e, r = this, ["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"].forEach(e => { n[e] && (r[e] = n[e]) }), this.options = t, void 0 === this.options.keySeparator && (this.options.keySeparator = "."), this.logger = Qt.create("translator") } changeLanguage(e) { e && (this.language = e) } exists(e, t = { interpolation: {} }) { const n = { ...t }; if (null == e) return !1; const r = this.resolve(e, n); if (void 0 === (null == r ? void 0 : r.res)) return !1; const s = rn(r.res); return !1 !== n.returnObjects || !s } extractFromKey(e, t) { let n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator; void 0 === n && (n = ":"); const r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator; let s = t.ns || this.options.defaultNS || []; const i = n && e.indexOf(n) > -1, o = !(this.options.userDefinedKeySeparator || t.keySeparator || this.options.userDefinedNsSeparator || t.nsSeparator || ((e, t, n) => { t = t || "", n = n || ""; const r = Yt.filter(e => t.indexOf(e) < 0 && n.indexOf(e) < 0); if (0 === r.length) return !0; const s = qt.getRegExp(`(${r.map(e => "?" === e ? "\\?" : e).join("|")})`); let i = !s.test(e); if (!i) { const t = e.indexOf(n); t > 0 && !s.test(e.substring(0, t)) && (i = !0) } return i })(e, n, r)); if (i && !o) { const t = e.match(this.interpolator.nestingRegexp); if (t && t.length > 0) return { key: e, namespaces: vt(s) ? [s] : s }; const i = e.split(n); (n !== r || n === r && this.options.ns.indexOf(i[0]) > -1) && (s = i.shift()), e = i.join(r) } return { key: e, namespaces: vt(s) ? [s] : s } } translate(e, t, n) { let r = "object" == typeof t ? { ...t } : t; if ("object" != typeof r && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), "object" == typeof r && (r = { ...r }), r || (r = {}), null == e) return ""; "function" == typeof e && (e = tn(e, { ...this.options, ...r })), Array.isArray(e) || (e = [String(e)]); const s = void 0 !== r.returnDetails ? r.returnDetails : this.options.returnDetails, i = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, { key: o, namespaces: a } = this.extractFromKey(e[e.length - 1], r), l = a[a.length - 1]; let c = void 0 !== r.nsSeparator ? r.nsSeparator : this.options.nsSeparator; void 0 === c && (c = ":"); const u = r.lng || this.language, h = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if ("cimode" === (null == u ? void 0 : u.toLowerCase())) return h ? s ? { res: `${l}${c}${o}`, usedKey: o, exactUsedKey: o, usedLng: u, usedNS: l, usedParams: this.getUsedParamsDetails(r) } : `${l}${c}${o}` : s ? { res: o, usedKey: o, exactUsedKey: o, usedLng: u, usedNS: l, usedParams: this.getUsedParamsDetails(r) } : o; const d = this.resolve(e, r); let p = null == d ? void 0 : d.res; const f = (null == d ? void 0 : d.usedKey) || o, m = (null == d ? void 0 : d.exactUsedKey) || o, g = void 0 !== r.joinArrays ? r.joinArrays : this.options.joinArrays, E = !this.i18nFormat || this.i18nFormat.handleAsObject, T = void 0 !== r.count && !vt(r.count), A = sn.hasDefaultValue(r), _ = T ? this.pluralResolver.getSuffix(u, r.count, r) : "", y = r.ordinal && T ? this.pluralResolver.getSuffix(u, r.count, { ordinal: !1 }) : "", b = T && !r.ordinal && 0 === r.count, S = b && r[`defaultValue${this.options.pluralSeparator}zero`] || r[`defaultValue${_}`] || r[`defaultValue${y}`] || r.defaultValue; let k = p; E && !p && A && (k = S); const C = rn(k), N = Object.prototype.toString.apply(k); if (!(E && k && C && ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(N) < 0) || vt(g) && Array.isArray(k)) if (E && vt(g) && Array.isArray(p)) p = p.join(g), p && (p = this.extendTranslation(p, e, r, n)); else { let t = !1, s = !1; !this.isValidLookup(p) && A && (t = !0, p = S), this.isValidLookup(p) || (s = !0, p = o); const a = (r.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && s ? void 0 : p, h = A && S !== p && this.options.updateMissing; if (s || t || h) { if (this.logger.log(h ? "updateKey" : "missingKey", u, l, o, h ? S : p), i) { const e = this.resolve(o, { ...r, keySeparator: !1 }); e && e.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.") } let e = []; const t = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language); if ("fallback" === this.options.saveMissingTo && t && t[0]) for (let r = 0; r < t.length; r++)e.push(t[r]); else "all" === this.options.saveMissingTo ? e = this.languageUtils.toResolveHierarchy(r.lng || this.language) : e.push(r.lng || this.language); const n = (e, t, n) => { var s; const i = A && n !== p ? n : a; this.options.missingKeyHandler ? this.options.missingKeyHandler(e, l, t, i, h, r) : (null == (s = this.backendConnector) ? void 0 : s.saveMissing) && this.backendConnector.saveMissing(e, l, t, i, h, r), this.emit("missingKey", e, l, t, p) }; this.options.saveMissing && (this.options.saveMissingPlurals && T ? e.forEach(e => { const t = this.pluralResolver.getSuffixes(e, r); b && r[`defaultValue${this.options.pluralSeparator}zero`] && t.indexOf(`${this.options.pluralSeparator}zero`) < 0 && t.push(`${this.options.pluralSeparator}zero`), t.forEach(t => { n([e], o + t, r[`defaultValue${t}`] || S) }) }) : n(e, o, S)) } p = this.extendTranslation(p, e, r, d, n), s && p === o && this.options.appendNamespaceToMissingKey && (p = `${l}${c}${o}`), (s || t) && this.options.parseMissingKeyHandler && (p = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}${c}${o}` : o, t ? p : void 0, r)) } else { if (!r.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"); const e = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(f, k, { ...r, ns: a }) : `key '${o} (${this.language})' returned an object instead of string.`; return s ? (d.res = e, d.usedParams = this.getUsedParamsDetails(r), d) : e } if (i) { const e = Array.isArray(k), t = e ? [] : {}, n = e ? m : f; for (const s in k) if (Object.prototype.hasOwnProperty.call(k, s)) { const e = `${n}${i}${s}`; t[s] = A && !p ? this.translate(e, { ...r, defaultValue: rn(S) ? S[s] : void 0, joinArrays: !1, ns: a }) : this.translate(e, { ...r, joinArrays: !1, ns: a }), t[s] === e && (t[s] = k[s]) } p = t } } return s ? (d.res = p, d.usedParams = this.getUsedParamsDetails(r), d) : p } extendTranslation(e, t, n, r, s) { var i, o; if (null == (i = this.i18nFormat) ? void 0 : i.parse) e = this.i18nFormat.parse(e, { ...this.options.interpolation.defaultVariables, ...n }, n.lng || this.language || r.usedLng, r.usedNS, r.usedKey, { resolved: r }); else if (!n.skipInterpolation) { n.interpolation && this.interpolator.init({ ...n, interpolation: { ...this.options.interpolation, ...n.interpolation } }); const i = vt(e) && (void 0 !== (null == (o = null == n ? void 0 : n.interpolation) ? void 0 : o.skipOnVariables) ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let a; if (i) { const t = e.match(this.interpolator.nestingRegexp); a = t && t.length } let l = n.replace && !vt(n.replace) ? n.replace : n; if (this.options.interpolation.defaultVariables && (l = { ...this.options.interpolation.defaultVariables, ...l }), e = this.interpolator.interpolate(e, l, n.lng || this.language || r.usedLng, n), i) { const t = e.match(this.interpolator.nestingRegexp); a < (t && t.length) && (n.nest = !1) } !n.lng && r && r.res && (n.lng = this.language || r.usedLng), !1 !== n.nest && (e = this.interpolator.nest(e, (...e) => (null == s ? void 0 : s[0]) !== e[0] || n.context ? this.translate(...e, t) : (this.logger.warn(`It seems you are nesting recursively key: ${e[0]} in key: ${t[0]}`), null), n)), n.interpolation && this.interpolator.reset() } const a = n.postProcess || this.options.postProcess, l = vt(a) ? [a] : a; return null != e && (null == l ? void 0 : l.length) && !1 !== n.applyPostProcessor && (e = Zt.handle(l, e, t, this.options && this.options.postProcessPassResolved ? { i18nResolved: { ...r, usedParams: this.getUsedParamsDetails(n) }, ...n } : n, this)), e } resolve(e, t = {}) { let n, r, s, i, o; return vt(e) && (e = [e]), e.forEach(e => { if (this.isValidLookup(n)) return; const a = this.extractFromKey(e, t), l = a.key; r = l; let c = a.namespaces; this.options.fallbackNS && (c = c.concat(this.options.fallbackNS)); const u = void 0 !== t.count && !vt(t.count), h = u && !t.ordinal && 0 === t.count, d = void 0 !== t.context && (vt(t.context) || "number" == typeof t.context) && "" !== t.context, p = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng); c.forEach(e => { var a, c; this.isValidLookup(n) || (o = e, nn[`${p[0]}-${e}`] || !(null == (a = this.utils) ? void 0 : a.hasLoadedNamespace) || (null == (c = this.utils) ? void 0 : c.hasLoadedNamespace(o)) || (nn[`${p[0]}-${e}`] = !0, this.logger.warn(`key "${r}" for languages "${p.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), p.forEach(r => { var o; if (this.isValidLookup(n)) return; i = r; const a = [l]; if (null == (o = this.i18nFormat) ? void 0 : o.addLookupKeys) this.i18nFormat.addLookupKeys(a, l, r, e, t); else { let e; u && (e = this.pluralResolver.getSuffix(r, t.count, t)); const n = `${this.options.pluralSeparator}zero`, s = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (u && (t.ordinal && 0 === e.indexOf(s) && a.push(l + e.replace(s, this.options.pluralSeparator)), a.push(l + e), h && a.push(l + n)), d) { const r = `${l}${this.options.contextSeparator || "_"}${t.context}`; a.push(r), u && (t.ordinal && 0 === e.indexOf(s) && a.push(r + e.replace(s, this.options.pluralSeparator)), a.push(r + e), h && a.push(r + n)) } } let c; for (; c = a.pop();)this.isValidLookup(n) || (s = c, n = this.getResource(r, e, c, t)) })) }) }), { res: n, usedKey: r, exactUsedKey: s, usedLng: i, usedNS: o } } isValidLookup(e) { return !(void 0 === e || !this.options.returnNull && null === e || !this.options.returnEmptyString && "" === e) } getResource(e, t, n, r = {}) { var s; return (null == (s = this.i18nFormat) ? void 0 : s.getResource) ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r) } getUsedParamsDetails(e = {}) { const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && !vt(e.replace); let r = n ? e.replace : e; if (n && void 0 !== e.count && (r.count = e.count), this.options.interpolation.defaultVariables && (r = { ...this.options.interpolation.defaultVariables, ...r }), !n) { r = { ...r }; for (const e of t) delete r[e] } return r } static hasDefaultValue(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t) && "defaultValue" === t.substring(0, 12) && void 0 !== e[t]) return !0; return !1 } } class on { constructor(e) { this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Qt.create("languageUtils") } getScriptPartFromCode(e) { if (!(e = $t(e)) || e.indexOf("-") < 0) return null; const t = e.split("-"); return 2 === t.length ? null : (t.pop(), "x" === t[t.length - 1].toLowerCase() ? null : this.formatLanguageCode(t.join("-"))) } getLanguagePartFromCode(e) { if (!(e = $t(e)) || e.indexOf("-") < 0) return e; const t = e.split("-"); return this.formatLanguageCode(t[0]) } formatLanguageCode(e) { if (vt(e) && e.indexOf("-") > -1) { let t; try { t = Intl.getCanonicalLocales(e)[0] } catch (ag) { } return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e) } return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e } isSupportedCode(e) { return ("languageOnly" === this.options.load || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1 } getBestMatchFromCodes(e) { if (!e) return null; let t; return e.forEach(e => { if (t) return; const n = this.formatLanguageCode(e); this.options.supportedLngs && !this.isSupportedCode(n) || (t = n) }), !t && this.options.supportedLngs && e.forEach(e => { if (t) return; const n = this.getScriptPartFromCode(e); if (this.isSupportedCode(n)) return t = n; const r = this.getLanguagePartFromCode(e); if (this.isSupportedCode(r)) return t = r; t = this.options.supportedLngs.find(e => e === r ? e : e.indexOf("-") < 0 && r.indexOf("-") < 0 ? void 0 : e.indexOf("-") > 0 && r.indexOf("-") < 0 && e.substring(0, e.indexOf("-")) === r || 0 === e.indexOf(r) && r.length > 1 ? e : void 0) }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t } getFallbackCodes(e, t) { if (!e) return []; if ("function" == typeof e && (e = e(t)), vt(e) && (e = [e]), Array.isArray(e)) return e; if (!t) return e.default || []; let n = e[t]; return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [] } toResolveHierarchy(e, t) { const n = this.getFallbackCodes((!1 === t ? [] : t) || this.options.fallbackLng || [], e), r = [], s = e => { e && (this.isSupportedCode(e) ? r.push(e) : this.logger.warn(`rejecting language code not found in supportedLngs: ${e}`)) }; return vt(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? ("languageOnly" !== this.options.load && s(this.formatLanguageCode(e)), "languageOnly" !== this.options.load && "currentOnly" !== this.options.load && s(this.getScriptPartFromCode(e)), "currentOnly" !== this.options.load && s(this.getLanguagePartFromCode(e))) : vt(e) && s(this.formatLanguageCode(e)), n.forEach(e => { r.indexOf(e) < 0 && s(this.formatLanguageCode(e)) }), r } } const an = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }, ln = { select: e => 1 === e ? "one" : "other", resolvedOptions: () => ({ pluralCategories: ["one", "other"] }) }; class cn { constructor(e, t = {}) { this.languageUtils = e, this.options = t, this.logger = Qt.create("pluralResolver"), this.pluralRulesCache = {} } addRule(e, t) { this.rules[e] = t } clearCache() { this.pluralRulesCache = {} } getRule(e, t = {}) { const n = $t("dev" === e ? "en" : e), r = t.ordinal ? "ordinal" : "cardinal", s = JSON.stringify({ cleanedCode: n, type: r }); if (s in this.pluralRulesCache) return this.pluralRulesCache[s]; let i; try { i = new Intl.PluralRules(n, { type: r }) } catch (o) { if (!Intl) return this.logger.error("No Intl support, please use an Intl polyfill!"), ln; if (!e.match(/-|_/)) return ln; const n = this.languageUtils.getLanguagePartFromCode(e); i = this.getRule(n, t) } return this.pluralRulesCache[s] = i, i } needsPlural(e, t = {}) { let n = this.getRule(e, t); return n || (n = this.getRule("dev", t)), (null == n ? void 0 : n.resolvedOptions().pluralCategories.length) > 1 } getPluralFormsOfKey(e, t, n = {}) { return this.getSuffixes(e, n).map(e => `${t}${e}`) } getSuffixes(e, t = {}) { let n = this.getRule(e, t); return n || (n = this.getRule("dev", t)), n ? n.resolvedOptions().pluralCategories.sort((e, t) => an[e] - an[t]).map(e => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${e}`) : [] } getSuffix(e, t, n = {}) { const r = this.getRule(e, n); return r ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${r.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix("dev", t, n)) } } const un = (e, t, n, r = ".", s = !0) => { let i = ((e, t, n) => { const r = Ut(e, n); return void 0 !== r ? r : Ut(t, n) })(e, t, n); return !i && s && vt(n) && (i = Vt(e, n, r), void 0 === i && (i = Vt(t, n, r))), i }, hn = e => e.replace(/\$/g, "$$$$"); class dn { constructor(e = {}) { var t; this.logger = Qt.create("interpolator"), this.options = e, this.format = (null == (t = null == e ? void 0 : e.interpolation) ? void 0 : t.format) || (e => e), this.init(e) } init(e = {}) { e.interpolation || (e.interpolation = { escapeValue: !0 }); const { escape: t, escapeValue: n, useRawValueToEscape: r, prefix: s, prefixEscaped: i, suffix: o, suffixEscaped: a, formatSeparator: l, unescapeSuffix: c, unescapePrefix: u, nestingPrefix: h, nestingPrefixEscaped: d, nestingSuffix: p, nestingSuffixEscaped: f, nestingOptionsSeparator: m, maxReplaces: g, alwaysFormat: E } = e.interpolation; this.escape = void 0 !== t ? t : zt, this.escapeValue = void 0 === n || n, this.useRawValueToEscape = void 0 !== r && r, this.prefix = s ? jt(s) : i || "{{", this.suffix = o ? jt(o) : a || "}}", this.formatSeparator = l || ",", this.unescapePrefix = c ? "" : u || "-", this.unescapeSuffix = this.unescapePrefix ? "" : c || "", this.nestingPrefix = h ? jt(h) : d || jt("$t("), this.nestingSuffix = p ? jt(p) : f || jt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = g || 1e3, this.alwaysFormat = void 0 !== E && E, this.resetRegExp() } reset() { this.options && this.init(this.options) } resetRegExp() { const e = (e, t) => (null == e ? void 0 : e.source) === t ? (e.lastIndex = 0, e) : new RegExp(t, "g"); this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`) } interpolate(e, t, n, r) { var s; let i, o, a; const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = e => { if (e.indexOf(this.formatSeparator) < 0) { const s = un(t, l, e, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(s, void 0, n, { ...r, ...t, interpolationkey: e }) : s } const s = e.split(this.formatSeparator), i = s.shift().trim(), o = s.join(this.formatSeparator).trim(); return this.format(un(t, l, i, this.options.keySeparator, this.options.ignoreJSONStructure), o, n, { ...r, ...t, interpolationkey: i }) }; this.resetRegExp(); const u = (null == r ? void 0 : r.missingInterpolationHandler) || this.options.missingInterpolationHandler, h = void 0 !== (null == (s = null == r ? void 0 : r.interpolation) ? void 0 : s.skipOnVariables) ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: e => hn(e) }, { regex: this.regexp, safeValue: e => this.escapeValue ? hn(this.escape(e)) : hn(e) }].forEach(t => { for (a = 0; i = t.regex.exec(e);) { const n = i[1].trim(); if (o = c(n), void 0 === o) if ("function" == typeof u) { const t = u(e, i, r); o = vt(t) ? t : "" } else if (r && Object.prototype.hasOwnProperty.call(r, n)) o = ""; else { if (h) { o = i[0]; continue } this.logger.warn(`missed to pass in variable ${n} for interpolating ${e}`), o = "" } else vt(o) || this.useRawValueToEscape || (o = Lt(o)); const s = t.safeValue(o); if (e = e.replace(i[0], s), h ? (t.regex.lastIndex += o.length, t.regex.lastIndex -= i[0].length) : t.regex.lastIndex = 0, a++, a >= this.maxReplaces) break } }), e } nest(e, t, n = {}) { let r, s, i; const o = (e, t) => { const n = this.nestingOptionsSeparator; if (e.indexOf(n) < 0) return e; const r = e.split(new RegExp(`${n}[ ]*{`)); let s = `{${r[1]}`; e = r[0], s = this.interpolate(s, i); const o = s.match(/'/g), a = s.match(/"/g); (((null == o ? void 0 : o.length) ?? 0) % 2 == 0 && !a || a.length % 2 != 0) && (s = s.replace(/'/g, '"')); try { i = JSON.parse(s), t && (i = { ...t, ...i }) } catch (ag) { return this.logger.warn(`failed parsing options string in nesting for key ${e}`, ag), `${e}${n}${s}` } return i.defaultValue && i.defaultValue.indexOf(this.prefix) > -1 && delete i.defaultValue, e }; for (; r = this.nestingRegexp.exec(e);) { let a = []; i = { ...n }, i = i.replace && !vt(i.replace) ? i.replace : i, i.applyPostProcessor = !1, delete i.defaultValue; const l = /{.*}/.test(r[1]) ? r[1].lastIndexOf("}") + 1 : r[1].indexOf(this.formatSeparator); if (-1 !== l && (a = r[1].slice(l).split(this.formatSeparator).map(e => e.trim()).filter(Boolean), r[1] = r[1].slice(0, l)), s = t(o.call(this, r[1].trim(), i), i), s && r[0] === e && !vt(s)) return s; vt(s) || (s = Lt(s)), s || (this.logger.warn(`missed to resolve ${r[1]} for nesting ${e}`), s = ""), a.length && (s = a.reduce((e, t) => this.format(e, t, n.lng, { ...n, interpolationkey: r[1].trim() }), s.trim())), e = e.replace(r[0], s), this.regexp.lastIndex = 0 } return e } } const pn = e => { const t = {}; return (n, r, s) => { let i = s; s && s.interpolationkey && s.formatParams && s.formatParams[s.interpolationkey] && s[s.interpolationkey] && (i = { ...i, [s.interpolationkey]: void 0 }); const o = r + JSON.stringify(i); let a = t[o]; return a || (a = e($t(r), s), t[o] = a), a(n) } }, fn = e => (t, n, r) => e($t(n), r)(t); class mn { constructor(e = {}) { this.logger = Qt.create("formatter"), this.options = e, this.init(e) } init(e, t = { interpolation: {} }) { this.formatSeparator = t.interpolation.formatSeparator || ","; const n = t.cacheInBuiltFormats ? pn : fn; this.formats = { number: n((e, t) => { const n = new Intl.NumberFormat(e, { ...t }); return e => n.format(e) }), currency: n((e, t) => { const n = new Intl.NumberFormat(e, { ...t, style: "currency" }); return e => n.format(e) }), datetime: n((e, t) => { const n = new Intl.DateTimeFormat(e, { ...t }); return e => n.format(e) }), relativetime: n((e, t) => { const n = new Intl.RelativeTimeFormat(e, { ...t }); return e => n.format(e, t.range || "day") }), list: n((e, t) => { const n = new Intl.ListFormat(e, { ...t }); return e => n.format(e) }) } } add(e, t) { this.formats[e.toLowerCase().trim()] = t } addCached(e, t) { this.formats[e.toLowerCase().trim()] = pn(t) } format(e, t, n, r = {}) { const s = t.split(this.formatSeparator); if (s.length > 1 && s[0].indexOf("(") > 1 && s[0].indexOf(")") < 0 && s.find(e => e.indexOf(")") > -1)) { const e = s.findIndex(e => e.indexOf(")") > -1); s[0] = [s[0], ...s.splice(1, e)].join(this.formatSeparator) } return s.reduce((e, t) => { var s; const { formatName: i, formatOptions: o } = (e => { let t = e.toLowerCase().trim(); const n = {}; if (e.indexOf("(") > -1) { const r = e.split("("); t = r[0].toLowerCase().trim(); const s = r[1].substring(0, r[1].length - 1); "currency" === t && s.indexOf(":") < 0 ? n.currency || (n.currency = s.trim()) : "relativetime" === t && s.indexOf(":") < 0 ? n.range || (n.range = s.trim()) : s.split(";").forEach(e => { if (e) { const [t, ...r] = e.split(":"), s = r.join(":").trim().replace(/^'+|'+$/g, ""), i = t.trim(); n[i] || (n[i] = s), "false" === s && (n[i] = !1), "true" === s && (n[i] = !0), isNaN(s) || (n[i] = parseInt(s, 10)) } }) } return { formatName: t, formatOptions: n } })(t); if (this.formats[i]) { let t = e; try { const a = (null == (s = null == r ? void 0 : r.formatParams) ? void 0 : s[r.interpolationkey]) || {}, l = a.locale || a.lng || r.locale || r.lng || n; t = this.formats[i](e, l, { ...o, ...r, ...a }) } catch (a) { this.logger.warn(a) } return t } return this.logger.warn(`there was no format function for ${i}`), e }, e) } } class gn extends Xt { constructor(e, t, n, r = {}) { var s, i; super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = r, this.logger = Qt.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = r.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5, this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350, this.state = {}, this.queue = [], null == (i = null == (s = this.backend) ? void 0 : s.init) || i.call(s, n, r.backend, r) } queueLoad(e, t, n, r) { const s = {}, i = {}, o = {}, a = {}; return e.forEach(e => { let r = !0; t.forEach(t => { const o = `${e}|${t}`; !n.reload && this.store.hasResourceBundle(e, t) ? this.state[o] = 2 : this.state[o] < 0 || (1 === this.state[o] ? void 0 === i[o] && (i[o] = !0) : (this.state[o] = 1, r = !1, void 0 === i[o] && (i[o] = !0), void 0 === s[o] && (s[o] = !0), void 0 === a[t] && (a[t] = !0))) }), r || (o[e] = !0) }), (Object.keys(s).length || Object.keys(i).length) && this.queue.push({ pending: i, pendingCount: Object.keys(i).length, loaded: {}, errors: [], callback: r }), { toLoad: Object.keys(s), pending: Object.keys(i), toLoadLanguages: Object.keys(o), toLoadNamespaces: Object.keys(a) } } loaded(e, t, n) { const r = e.split("|"), s = r[0], i = r[1]; t && this.emit("failedLoading", s, i, t), !t && n && this.store.addResourceBundle(s, i, n, void 0, void 0, { skipCopy: !0 }), this.state[e] = t ? -1 : 2, t && n && (this.state[e] = 0); const o = {}; this.queue.forEach(n => { ((e, t, n) => { const { obj: r, k: s } = Ft(e, t, Object); r[s] = r[s] || [], r[s].push(n) })(n.loaded, [s], i), ((e, t) => { void 0 !== e.pending[t] && (delete e.pending[t], e.pendingCount--) })(n, e), t && n.errors.push(t), 0 !== n.pendingCount || n.done || (Object.keys(n.loaded).forEach(e => { o[e] || (o[e] = {}); const t = n.loaded[e]; t.length && t.forEach(t => { void 0 === o[e][t] && (o[e][t] = !0) }) }), n.done = !0, n.errors.length ? n.callback(n.errors) : n.callback()) }), this.emit("loaded", o), this.queue = this.queue.filter(e => !e.done) } read(e, t, n, r = 0, s = this.retryTimeout, i) { if (!e.length) return i(null, {}); if (this.readingCalls >= this.maxParallelReads) return void this.waitingReads.push({ lng: e, ns: t, fcName: n, tried: r, wait: s, callback: i }); this.readingCalls++; const o = (o, a) => { if (this.readingCalls--, this.waitingReads.length > 0) { const e = this.waitingReads.shift(); this.read(e.lng, e.ns, e.fcName, e.tried, e.wait, e.callback) } o && a && r < this.maxRetries ? setTimeout(() => { this.read.call(this, e, t, n, r + 1, 2 * s, i) }, s) : i(o, a) }, a = this.backend[n].bind(this.backend); if (2 !== a.length) return a(e, t, o); try { const n = a(e, t); n && "function" == typeof n.then ? n.then(e => o(null, e)).catch(o) : o(null, n) } catch (l) { o(l) } } prepareLoading(e, t, n = {}, r) { if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), r && r(); vt(e) && (e = this.languageUtils.toResolveHierarchy(e)), vt(t) && (t = [t]); const s = this.queueLoad(e, t, n, r); if (!s.toLoad.length) return s.pending.length || r(), null; s.toLoad.forEach(e => { this.loadOne(e) }) } load(e, t, n) { this.prepareLoading(e, t, {}, n) } reload(e, t, n) { this.prepareLoading(e, t, { reload: !0 }, n) } loadOne(e, t = "") { const n = e.split("|"), r = n[0], s = n[1]; this.read(r, s, "read", void 0, void 0, (n, i) => { n && this.logger.warn(`${t}loading namespace ${s} for language ${r} failed`, n), !n && i && this.logger.log(`${t}loaded namespace ${s} for language ${r}`, i), this.loaded(e, n, i) }) } saveMissing(e, t, n, r, s, i = {}, o = () => { }) { var a, l, c, u, h; if (!(null == (l = null == (a = this.services) ? void 0 : a.utils) ? void 0 : l.hasLoadedNamespace) || (null == (u = null == (c = this.services) ? void 0 : c.utils) ? void 0 : u.hasLoadedNamespace(t))) { if (null != n && "" !== n) { if (null == (h = this.backend) ? void 0 : h.create) { const a = { ...i, isUpdate: s }, l = this.backend.create.bind(this.backend); if (l.length < 6) try { let s; s = 5 === l.length ? l(e, t, n, r, a) : l(e, t, n, r), s && "function" == typeof s.then ? s.then(e => o(null, e)).catch(o) : o(null, s) } catch (d) { o(d) } else l(e, t, n, r, o, a) } e && e[0] && this.store.addResource(e[0], t, n, r) } } else this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!") } } const En = () => ({ debug: !1, initAsync: !0, ns: ["translation"], defaultNS: ["translation"], fallbackLng: ["dev"], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: "all", preload: !1, simplifyPluralSuffix: !0, keySeparator: ".", nsSeparator: ":", pluralSeparator: "_", contextSeparator: "_", partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: "fallback", saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !1, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: e => { let t = {}; if ("object" == typeof e[1] && (t = e[1]), vt(e[1]) && (t.defaultValue = e[1]), vt(e[2]) && (t.tDescription = e[2]), "object" == typeof e[2] || "object" == typeof e[3]) { const n = e[3] || e[2]; Object.keys(n).forEach(e => { t[e] = n[e] }) } return t }, interpolation: { escapeValue: !0, format: e => e, prefix: "{{", suffix: "}}", formatSeparator: ",", unescapePrefix: "-", nestingPrefix: "$t(", nestingSuffix: ")", nestingOptionsSeparator: ",", maxReplaces: 1e3, skipOnVariables: !0 }, cacheInBuiltFormats: !0 }), Tn = e => { var t, n; return vt(e.ns) && (e.ns = [e.ns]), vt(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), vt(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), (null == (n = null == (t = e.supportedLngs) ? void 0 : t.indexOf) ? void 0 : n.call(t, "cimode")) < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), "boolean" == typeof e.initImmediate && (e.initAsync = e.initImmediate), e }, An = () => { }; class _n extends Xt { constructor(e = {}, t) { var n; if (super(), this.options = Tn(e), this.services = {}, this.logger = Qt, this.modules = { external: [] }, n = this, Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(e => { "function" == typeof n[e] && (n[e] = n[e].bind(n)) }), t && !this.isInitialized && !e.isClone) { if (!this.options.initAsync) return this.init(e, t), this; setTimeout(() => { this.init(e, t) }, 0) } } init(e = {}, t) { this.isInitializing = !0, "function" == typeof e && (t = e, e = {}), null == e.defaultNS && e.ns && (vt(e.ns) ? e.defaultNS = e.ns : e.ns.indexOf("translation") < 0 && (e.defaultNS = e.ns[0])); const n = En(); this.options = { ...n, ...this.options, ...Tn(e) }, this.options.interpolation = { ...n.interpolation, ...this.options.interpolation }, void 0 !== e.keySeparator && (this.options.userDefinedKeySeparator = e.keySeparator), void 0 !== e.nsSeparator && (this.options.userDefinedNsSeparator = e.nsSeparator), "function" != typeof this.options.overloadTranslationOptionHandler && (this.options.overloadTranslationOptionHandler = n.overloadTranslationOptionHandler); const r = e => e ? "function" == typeof e ? new e : e : null; if (!this.options.isClone) { let e; this.modules.logger ? Qt.init(r(this.modules.logger), this.options) : Qt.init(null, this.options), e = this.modules.formatter ? this.modules.formatter : mn; const t = new on(this.options); this.store = new Jt(this.options.resources, this.options); const s = this.services; s.logger = Qt, s.resourceStore = this.store, s.languageUtils = t, s.pluralResolver = new cn(t, { prepend: this.options.pluralSeparator, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), this.options.interpolation.format && this.options.interpolation.format !== n.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), !e || this.options.interpolation.format && this.options.interpolation.format !== n.interpolation.format || (s.formatter = r(e), s.formatter.init && s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new dn(this.options), s.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, s.backendConnector = new gn(r(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on("*", (e, ...t) => { this.emit(e, ...t) }), this.modules.languageDetector && (s.languageDetector = r(this.modules.languageDetector), s.languageDetector.init && s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = r(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new sn(this.services, this.options), this.translator.on("*", (e, ...t) => { this.emit(e, ...t) }), this.modules.external.forEach(e => { e.init && e.init(this) }) } if (this.format = this.options.interpolation.format, t || (t = An), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const e = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); e.length > 0 && "dev" !== e[0] && (this.options.lng = e[0]) } this.services.languageDetector || this.options.lng || this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(e => { this[e] = (...t) => this.store[e](...t) }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(e => { this[e] = (...t) => (this.store[e](...t), this) }); const s = Dt(), i = () => { const e = (e, n) => { this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), s.resolve(n), t(e, n) }; if (this.languages && !this.isInitialized) return e(null, this.t.bind(this)); this.changeLanguage(this.options.lng, e) }; return this.options.resources || !this.options.initAsync ? i() : setTimeout(i, 0), s } loadResources(e, t = An) { var n, r; let s = t; const i = vt(e) ? e : this.language; if ("function" == typeof e && (s = e), !this.options.resources || this.options.partialBundledLanguages) { if ("cimode" === (null == i ? void 0 : i.toLowerCase()) && (!this.options.preload || 0 === this.options.preload.length)) return s(); const e = [], t = t => { t && "cimode" !== t && this.services.languageUtils.toResolveHierarchy(t).forEach(t => { "cimode" !== t && e.indexOf(t) < 0 && e.push(t) }) }; i ? t(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(e => t(e)), null == (r = null == (n = this.options.preload) ? void 0 : n.forEach) || r.call(n, e => t(e)), this.services.backendConnector.load(e, this.options.ns, e => { e || this.resolvedLanguage || !this.language || this.setResolvedLanguage(this.language), s(e) }) } else s(null) } reloadResources(e, t, n) { const r = Dt(); return "function" == typeof e && (n = e, e = void 0), "function" == typeof t && (n = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), n || (n = An), this.services.backendConnector.reload(e, t, e => { r.resolve(), n(e) }), r } use(e) { if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()"); if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()"); return "backend" === e.type && (this.modules.backend = e), ("logger" === e.type || e.log && e.warn && e.error) && (this.modules.logger = e), "languageDetector" === e.type && (this.modules.languageDetector = e), "i18nFormat" === e.type && (this.modules.i18nFormat = e), "postProcessor" === e.type && Zt.addPostProcessor(e), "formatter" === e.type && (this.modules.formatter = e), "3rdParty" === e.type && this.modules.external.push(e), this } setResolvedLanguage(e) { if (e && this.languages && !(["cimode", "dev"].indexOf(e) > -1)) { for (let e = 0; e < this.languages.length; e++) { const t = this.languages[e]; if (!(["cimode", "dev"].indexOf(t) > -1) && this.store.hasLanguageSomeTranslations(t)) { this.resolvedLanguage = t; break } } !this.resolvedLanguage && this.languages.indexOf(e) < 0 && this.store.hasLanguageSomeTranslations(e) && (this.resolvedLanguage = e, this.languages.unshift(e)) } } changeLanguage(e, t) { this.isLanguageChangingTo = e; const n = Dt(); this.emit("languageChanging", e); const r = e => { this.language = e, this.languages = this.services.languageUtils.toResolveHierarchy(e), this.resolvedLanguage = void 0, this.setResolvedLanguage(e) }, s = (s, i) => { i ? this.isLanguageChangingTo === e && (r(i), this.translator.changeLanguage(i), this.isLanguageChangingTo = void 0, this.emit("languageChanged", i), this.logger.log("languageChanged", i)) : this.isLanguageChangingTo = void 0, n.resolve((...e) => this.t(...e)), t && t(s, (...e) => this.t(...e)) }, i = t => { var n, i; e || t || !this.services.languageDetector || (t = []); const o = vt(t) ? t : t && t[0], a = this.store.hasLanguageSomeTranslations(o) ? o : this.services.languageUtils.getBestMatchFromCodes(vt(t) ? [t] : t); a && (this.language || r(a), this.translator.language || this.translator.changeLanguage(a), null == (i = null == (n = this.services.languageDetector) ? void 0 : n.cacheUserLanguage) || i.call(n, a)), this.loadResources(a, e => { s(e, a) }) }; return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? 0 === this.services.languageDetector.detect.length ? this.services.languageDetector.detect().then(i) : this.services.languageDetector.detect(i) : i(e) : i(this.services.languageDetector.detect()), n } getFixedT(e, t, n) { const r = (e, t, ...s) => { let i; i = "object" != typeof t ? this.options.overloadTranslationOptionHandler([e, t].concat(s)) : { ...t }, i.lng = i.lng || r.lng, i.lngs = i.lngs || r.lngs, i.ns = i.ns || r.ns, "" !== i.keyPrefix && (i.keyPrefix = i.keyPrefix || n || r.keyPrefix); const o = this.options.keySeparator || "."; let a; return i.keyPrefix && Array.isArray(e) ? a = e.map(e => ("function" == typeof e && (e = tn(e, { ...this.options, ...t })), `${i.keyPrefix}${o}${e}`)) : ("function" == typeof e && (e = tn(e, { ...this.options, ...t })), a = i.keyPrefix ? `${i.keyPrefix}${o}${e}` : e), this.t(a, i) }; return vt(e) ? r.lng = e : r.lngs = e, r.ns = t, r.keyPrefix = n, r } t(...e) { var t; return null == (t = this.translator) ? void 0 : t.translate(...e) } exists(...e) { var t; return null == (t = this.translator) ? void 0 : t.exists(...e) } setDefaultNamespace(e) { this.options.defaultNS = e } hasLoadedNamespace(e, t = {}) { if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1; const n = t.lng || this.resolvedLanguage || this.languages[0], r = !!this.options && this.options.fallbackLng, s = this.languages[this.languages.length - 1]; if ("cimode" === n.toLowerCase()) return !0; const i = (e, t) => { const n = this.services.backendConnector.state[`${e}|${t}`]; return -1 === n || 0 === n || 2 === n }; if (t.precheck) { const e = t.precheck(this, i); if (void 0 !== e) return e } return !(!this.hasResourceBundle(n, e) && this.services.backendConnector.backend && (!this.options.resources || this.options.partialBundledLanguages) && (!i(n, e) || r && !i(s, e))) } loadNamespaces(e, t) { const n = Dt(); return this.options.ns ? (vt(e) && (e = [e]), e.forEach(e => { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) }), this.loadResources(e => { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } loadLanguages(e, t) { const n = Dt(); vt(e) && (e = [e]); const r = this.options.preload || [], s = e.filter(e => r.indexOf(e) < 0 && this.services.languageUtils.isSupportedCode(e)); return s.length ? (this.options.preload = r.concat(s), this.loadResources(e => { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } dir(e) { var t, n; if (e || (e = this.resolvedLanguage || ((null == (t = this.languages) ? void 0 : t.length) > 0 ? this.languages[0] : this.language)), !e) return "rtl"; try { const t = new Intl.Locale(e); if (t && t.getTextInfo) { const e = t.getTextInfo(); if (e && e.direction) return e.direction } } catch (ag) { } const r = (null == (n = this.services) ? void 0 : n.languageUtils) || new on(En()); return e.toLowerCase().indexOf("-latn") > 1 ? "ltr" : ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"].indexOf(r.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr" } static createInstance(e = {}, t) { const n = new _n(e, t); return n.createInstance = _n.createInstance, n } cloneInstance(e = {}, t = An) { const n = e.forkResourceStore; n && delete e.forkResourceStore; const r = { ...this.options, ...e, isClone: !0 }, s = new _n(r); if (void 0 === e.debug && void 0 === e.prefix || (s.logger = s.logger.clone(e)), ["store", "services", "language"].forEach(e => { s[e] = this[e] }), s.services = { ...this.services }, s.services.utils = { hasLoadedNamespace: s.hasLoadedNamespace.bind(s) }, n) { const e = Object.keys(this.store.data).reduce((e, t) => (e[t] = { ...this.store.data[t] }, e[t] = Object.keys(e[t]).reduce((n, r) => (n[r] = { ...e[t][r] }, n), e[t]), e), {}); s.store = new Jt(e, r), s.services.resourceStore = s.store } return e.interpolation && (s.services.interpolator = new dn(r)), s.translator = new sn(s.services, r), s.translator.on("*", (e, ...t) => { s.emit(e, ...t) }), s.init(r, t), s.translator.options = r, s.translator.backendConnector.services.utils = { hasLoadedNamespace: s.hasLoadedNamespace.bind(s) }, s } toJSON() { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } } const yn = _n.createInstance(); yn.createInstance, yn.dir, yn.init, yn.loadResources, yn.reloadResources, yn.use, yn.changeLanguage, yn.getFixedT, yn.t, yn.exists, yn.setDefaultNamespace, yn.hasLoadedNamespace, yn.loadNamespaces, yn.loadLanguages; const bn = {}, Sn = (e, t, n, r) => { In(n) && bn[n] || (In(n) && (bn[n] = new Date), ((e, t, n, r) => { var s, i, o, a; const l = [n, { code: t, ...r || {} }]; if (null == (i = null == (s = null == e ? void 0 : e.services) ? void 0 : s.logger) ? void 0 : i.forward) return e.services.logger.forward(l, "warn", "react-i18next::", !0); In(l[0]) && (l[0] = `react-i18next:: ${l[0]}`), (null == (a = null == (o = null == e ? void 0 : e.services) ? void 0 : o.logger) ? void 0 : a.warn) ? e.services.logger.warn(...l) : null == console || console.warn })(e, t, n, r)) }, kn = (e, t) => () => { if (e.isInitialized) t(); else { const n = () => { setTimeout(() => { e.off("initialized", n) }, 0), t() }; e.on("initialized", n) } }, Cn = (e, t, n) => { e.loadNamespaces(t, kn(e, n)) }, Nn = (e, t, n, r) => { if (In(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(t) > -1) return Cn(e, n, r); n.forEach(t => { e.options.ns.indexOf(t) < 0 && e.options.ns.push(t) }), e.loadLanguages(t, kn(e, r)) }, In = e => "string" == typeof e, On = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, xn = { "&amp;": "&", "&#38;": "&", "&lt;": "<", "&#60;": "<", "&gt;": ">", "&#62;": ">", "&apos;": "'", "&#39;": "'", "&quot;": '"', "&#34;": '"', "&nbsp;": " ", "&#160;": " ", "&copy;": "", "&#169;": "", "&reg;": "", "&#174;": "", "&hellip;": "", "&#8230;": "", "&#x2F;": "/", "&#47;": "/" }, Rn = e => xn[e]; let vn, Dn = { bindI18n: "languageChanged", bindI18nStore: "", transEmptyNodeValue: "", transSupportBasicHtmlNodes: !0, transWrapTextNodes: "", transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"], useSuspense: !0, unescape: e => e.replace(On, Rn), transDefaultProps: void 0 }; const Ln = { type: "3rdParty", init(e) { ((e = {}) => { Dn = { ...Dn, ...e } })(e.options.react), (e => { vn = e })(e) } }, Pn = React.createContext(); class wn { constructor() { this.usedNamespaces = {} } addUsedNamespaces(e) { e.forEach(e => { this.usedNamespaces[e] || (this.usedNamespaces[e] = !0) }) } getUsedNamespaces() { return Object.keys(this.usedNamespaces) } } var Mn = { exports: {} }, Fn = {}, Bn = l, Un = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, Hn = Bn.useState, jn = Bn.useEffect, Gn = Bn.useLayoutEffect, zn = Bn.useDebugValue; function Yn(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Un(e, n) } catch (r) { return !0 } } var qn = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), r = Hn({ inst: { value: n, getSnapshot: t } }), s = r[0].inst, i = r[1]; return Gn(function () { s.value = n, s.getSnapshot = t, Yn(s) && i({ inst: s }) }, [e, n, t]), jn(function () { return Yn(s) && i({ inst: s }), e(function () { Yn(s) && i({ inst: s }) }) }, [e]), zn(n), n }; Fn.useSyncExternalStore = void 0 !== Bn.useSyncExternalStore ? Bn.useSyncExternalStore : qn, Mn.exports = Fn; var Vn = Mn.exports; const $n = { t: (e, t) => { return In(t) ? t : "object" == typeof (n = t) && null !== n && In(t.defaultValue) ? t.defaultValue : Array.isArray(e) ? e[e.length - 1] : e; var n }, ready: !1 }, Wn = () => () => { }, Kn = (e, t = {}) => { var n, r, s; const { i18n: i } = t, { i18n: o, defaultNS: a } = React.useContext(Pn) || {}, l = i || o || vn; l && !l.reportNamespaces && (l.reportNamespaces = new wn), l || Sn(l, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next"); const c = React.useMemo(() => { var e; return { ...Dn, ...null == (e = null == l ? void 0 : l.options) ? void 0 : e.react, ...t } }, [l, t]), { useSuspense: u, keyPrefix: h } = c, d = a || (null == (n = null == l ? void 0 : l.options) ? void 0 : n.defaultNS), p = In(d) ? [d] : d || ["translation"], f = React.useMemo(() => p, p); null == (s = null == (r = null == l ? void 0 : l.reportNamespaces) ? void 0 : r.addUsedNamespaces) || s.call(r, f); const m = React.useRef(0), g = React.useCallback(e => { if (!l) return Wn; const { bindI18n: t, bindI18nStore: n } = c, r = () => { m.current += 1, e() }; return t && l.on(t, r), n && l.store.on(n, r), () => { t && t.split(" ").forEach(e => l.off(e, r)), n && n.split(" ").forEach(e => l.store.off(e, r)) } }, [l, c]), E = React.useRef(), T = React.useCallback(() => { if (!l) return $n; const e = !(!l.isInitialized && !l.initializedStoreOnce) && f.every(e => ((e, t, n = {}) => t.languages && t.languages.length ? t.hasLoadedNamespace(e, { lng: n.lng, precheck: (t, r) => { if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !r(t.isLanguageChangingTo, e)) return !1 } }) : (Sn(t, "NO_LANGUAGES", "i18n.languages were undefined or empty", { languages: t.languages }), !0))(e, l, c)), n = t.lng || l.language, r = m.current, s = E.current; if (s && s.ready === e && s.lng === n && s.keyPrefix === h && s.revision === r) return s; const i = { t: l.getFixedT(n, "fallback" === c.nsMode ? f : f[0], h), ready: e, lng: n, keyPrefix: h, revision: r }; return E.current = i, i }, [l, f, h, c, t.lng]), [A, _] = React.useState(0), { t: y, ready: b } = Vn.useSyncExternalStore(g, T, T); React.useEffect(() => { if (l && !b && !u) { const e = () => _(e => e + 1); t.lng ? Nn(l, t.lng, f, e) : Cn(l, f, e) } }, [l, t.lng, f, b, u, A]); const S = l || {}, k = React.useRef(null), C = React.useRef(), N = e => { const t = Object.getOwnPropertyDescriptors(e); t.__original && delete t.__original; const n = Object.create(Object.getPrototypeOf(e), t); if (!Object.prototype.hasOwnProperty.call(n, "__original")) try { Object.defineProperty(n, "__original", { value: e, writable: !1, enumerable: !1, configurable: !1 }) } catch (r) { } return n }, I = React.useMemo(() => { const e = S, t = null == e ? void 0 : e.language; let n = e; e && (k.current && k.current.__original === e ? C.current !== t ? (n = N(e), k.current = n, C.current = t) : n = k.current : (n = N(e), k.current = n, C.current = t)); const r = [y, n, b]; return r.t = y, r.i18n = n, r.ready = b, r }, [y, S, b, S.resolvedLanguage, S.language, S.languages]); if (l && u && !b) throw new Promise(e => { const n = () => e(); t.lng ? Nn(l, t.lng, f, n) : Cn(l, f, n) }); return I }, Qn = React.createContext({ user: null, isAuthenticated: !1, isLoading: !1, login: async () => !1, logout: () => { } }); function Xn() { return React.useContext(Qn) } function Jn(e, t) { return function () { return e.apply(t, arguments) } } const { toString: Zn } = Object.prototype, { getPrototypeOf: er } = Object, { iterator: tr, toStringTag: nr } = Symbol, rr = (e => t => { const n = Zn.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), sr = e => (e = e.toLowerCase(), t => rr(t) === e), ir = e => t => typeof t === e, { isArray: or } = Array, ar = ir("undefined"); function lr(e) { return null !== e && !ar(e) && null !== e.constructor && !ar(e.constructor) && hr(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const cr = sr("ArrayBuffer"), ur = ir("string"), hr = ir("function"), dr = ir("number"), pr = e => null !== e && "object" == typeof e, fr = e => { if ("object" !== rr(e)) return !1; const t = er(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || nr in e || tr in e) }, mr = sr("Date"), gr = sr("File"), Er = sr("Blob"), Tr = sr("FileList"), Ar = sr("URLSearchParams"), [_r, yr, br, Sr] = ["ReadableStream", "Request", "Response", "Headers"].map(sr); function kr(e, t, { allOwnKeys: n = !1 } = {}) { if (null == e) return; let r, s; if ("object" != typeof e && (e = [e]), or(e)) for (r = 0, s = e.length; r < s; r++)t.call(null, e[r], r, e); else { if (lr(e)) return; const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), i = s.length; let o; for (r = 0; r < i; r++)o = s[r], t.call(null, e[o], o, e) } } function Cr(e, t) { if (lr(e)) return null; t = t.toLowerCase(); const n = Object.keys(e); let r, s = n.length; for (; s-- > 0;)if (r = n[s], t === r.toLowerCase()) return r; return null } const Nr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, Ir = e => !ar(e) && e !== Nr, Or = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && er(Uint8Array)), xr = sr("HTMLFormElement"), Rr = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), vr = sr("RegExp"), Dr = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; kr(n, (n, s) => { let i; !1 !== (i = t(n, s, e)) && (r[s] = i || n) }), Object.defineProperties(e, r) }, Lr = sr("AsyncFunction"), Pr = (wr = "function" == typeof setImmediate, Mr = hr(Nr.postMessage), wr ? setImmediate : Mr ? (Fr = `axios@${Math.random()}`, Br = [], Nr.addEventListener("message", ({ source: e, data: t }) => { e === Nr && t === Fr && Br.length && Br.shift()() }, !1), e => { Br.push(e), Nr.postMessage(Fr, "*") }) : e => setTimeout(e)); var wr, Mr, Fr, Br; const Ur = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(Nr) : "undefined" != typeof process && process.nextTick || Pr, Hr = { isArray: or, isArrayBuffer: cr, isBuffer: lr, isFormData: e => { let t; return e && ("function" == typeof FormData && e instanceof FormData || hr(e.append) && ("formdata" === (t = rr(e)) || "object" === t && hr(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && cr(e.buffer), t }, isString: ur, isNumber: dr, isBoolean: e => !0 === e || !1 === e, isObject: pr, isPlainObject: fr, isEmptyObject: e => { if (!pr(e) || lr(e)) return !1; try { return 0 === Object.keys(e).length && Object.getPrototypeOf(e) === Object.prototype } catch (ag) { return !1 } }, isReadableStream: _r, isRequest: yr, isResponse: br, isHeaders: Sr, isUndefined: ar, isDate: mr, isFile: gr, isBlob: Er, isRegExp: vr, isFunction: hr, isStream: e => pr(e) && hr(e.pipe), isURLSearchParams: Ar, isTypedArray: Or, isFileList: Tr, forEach: kr, merge: function e() { const { caseless: t, skipUndefined: n } = Ir(this) && this || {}, r = {}, s = (s, i) => { const o = t && Cr(r, i) || i; fr(r[o]) && fr(s) ? r[o] = e(r[o], s) : fr(s) ? r[o] = e({}, s) : or(s) ? r[o] = s.slice() : n && ar(s) || (r[o] = s) }; for (let i = 0, o = arguments.length; i < o; i++)arguments[i] && kr(arguments[i], s); return r }, extend: (e, t, n, { allOwnKeys: r } = {}) => (kr(t, (t, r) => { n && hr(t) ? e[r] = Jn(t, n) : e[r] = t }, { allOwnKeys: r }), e), trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, toFlatObject: (e, t, n, r) => { let s, i, o; const a = {}; if (t = t || {}, null == e) return t; do { for (s = Object.getOwnPropertyNames(e), i = s.length; i-- > 0;)o = s[i], r && !r(o, e, t) || a[o] || (t[o] = e[o], a[o] = !0); e = !1 !== n && er(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: rr, kindOfTest: sr, endsWith: (e, t, n) => { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return -1 !== r && r === n }, toArray: e => { if (!e) return null; if (or(e)) return e; let t = e.length; if (!dr(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, forEachEntry: (e, t) => { const n = (e && e[tr]).call(e); let r; for (; (r = n.next()) && !r.done;) { const n = r.value; t.call(e, n[0], n[1]) } }, matchAll: (e, t) => { let n; const r = []; for (; null !== (n = e.exec(t));)r.push(n); return r }, isHTMLForm: xr, hasOwnProperty: Rr, hasOwnProp: Rr, reduceDescriptors: Dr, freezeMethods: e => { Dr(e, (t, n) => { if (hr(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1; const r = e[n]; hr(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") })) }) }, toObjectSet: (e, t) => { const n = {}, r = e => { e.forEach(e => { n[e] = !0 }) }; return or(e) ? r(e) : r(String(e).split(t)), n }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (e, t, n) { return t.toUpperCase() + n }), noop: () => { }, toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t, findKey: Cr, global: Nr, isContextDefined: Ir, isSpecCompliantForm: function (e) { return !!(e && hr(e.append) && "FormData" === e[nr] && e[tr]) }, toJSONObject: e => { const t = new Array(10), n = (e, r) => { if (pr(e)) { if (t.indexOf(e) >= 0) return; if (lr(e)) return e; if (!("toJSON" in e)) { t[r] = e; const s = or(e) ? [] : {}; return kr(e, (e, t) => { const i = n(e, r + 1); !ar(i) && (s[t] = i) }), t[r] = void 0, s } } return e }; return n(e, 0) }, isAsyncFn: Lr, isThenable: e => e && (pr(e) || hr(e)) && hr(e.then) && hr(e.catch), setImmediate: Pr, asap: Ur, isIterable: e => null != e && hr(e[tr]) }; function jr(e, t, n, r, s) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null) } Hr.inherits(jr, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Hr.toJSONObject(this.config), code: this.code, status: this.status } } }); const Gr = jr.prototype, zr = {}; function Yr(e) { return Hr.isPlainObject(e) || Hr.isArray(e) } function qr(e) { return Hr.endsWith(e, "[]") ? e.slice(0, -2) : e } function Vr(e, t, n) { return e ? e.concat(t).map(function (e, t) { return e = qr(e), !n && t ? "[" + e + "]" : e }).join(n ? "." : "") : t } ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { zr[e] = { value: e } }), Object.defineProperties(jr, zr), Object.defineProperty(Gr, "isAxiosError", { value: !0 }), jr.from = (e, t, n, r, s, i) => { const o = Object.create(Gr); Hr.toFlatObject(e, o, function (e) { return e !== Error.prototype }, e => "isAxiosError" !== e); const a = e && e.message ? e.message : "Error", l = null == t && e ? e.code : t; return jr.call(o, a, l, n, r, s), e && null == o.cause && Object.defineProperty(o, "cause", { value: e, configurable: !0 }), o.name = e && e.name || "Error", i && Object.assign(o, i), o }; const $r = Hr.toFlatObject(Hr, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function Wr(e, t, n) { if (!Hr.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const r = (n = Hr.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (e, t) { return !Hr.isUndefined(t[e]) })).metaTokens, s = n.visitor || c, i = n.dots, o = n.indexes, a = (n.Blob || "undefined" != typeof Blob && Blob) && Hr.isSpecCompliantForm(t); if (!Hr.isFunction(s)) throw new TypeError("visitor must be a function"); function l(e) { if (null === e) return ""; if (Hr.isDate(e)) return e.toISOString(); if (Hr.isBoolean(e)) return e.toString(); if (!a && Hr.isBlob(e)) throw new jr("Blob is not supported. Use a Buffer instead."); return Hr.isArrayBuffer(e) || Hr.isTypedArray(e) ? a && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, n, s) { let a = e; if (e && !s && "object" == typeof e) if (Hr.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e); else if (Hr.isArray(e) && function (e) { return Hr.isArray(e) && !e.some(Yr) }(e) || (Hr.isFileList(e) || Hr.endsWith(n, "[]")) && (a = Hr.toArray(e))) return n = qr(n), a.forEach(function (e, r) { !Hr.isUndefined(e) && null !== e && t.append(!0 === o ? Vr([n], r, i) : null === o ? n : n + "[]", l(e)) }), !1; return !!Yr(e) || (t.append(Vr(s, n, i), l(e)), !1) } const u = [], h = Object.assign($r, { defaultVisitor: c, convertValue: l, isVisitable: Yr }); if (!Hr.isObject(e)) throw new TypeError("data must be an object"); return function e(n, r) { if (!Hr.isUndefined(n)) { if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join(".")); u.push(n), Hr.forEach(n, function (n, i) { !0 === (!(Hr.isUndefined(n) || null === n) && s.call(t, n, Hr.isString(i) ? i.trim() : i, r, h)) && e(n, r ? r.concat(i) : [i]) }), u.pop() } }(e), t } function Kr(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) { return t[e] }) } function Qr(e, t) { this._pairs = [], e && Wr(e, this, t) } const Xr = Qr.prototype; function Jr(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function Zr(e, t, n) { if (!t) return e; const r = n && n.encode || Jr; Hr.isFunction(n) && (n = { serialize: n }); const s = n && n.serialize; let i; if (i = s ? s(t, n) : Hr.isURLSearchParams(t) ? t.toString() : new Qr(t, n).toString(r), i) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + i } return e } Xr.append = function (e, t) { this._pairs.push([e, t]) }, Xr.toString = function (e) { const t = e ? function (t) { return e.call(this, t, Kr) } : Kr; return this._pairs.map(function (e) { return t(e[0]) + "=" + t(e[1]) }, "").join("&") }; class es { constructor() { this.handlers = [] } use(e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { Hr.forEach(this.handlers, function (t) { null !== t && e(t) }) } } const ts = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, ns = { isBrowser: !0, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Qr, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, rs = "undefined" != typeof window && "undefined" != typeof document, ss = "object" == typeof navigator && navigator || void 0, is = rs && (!ss || ["ReactNative", "NativeScript", "NS"].indexOf(ss.product) < 0), os = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, as = rs && window.location.href || "http://localhost", ls = { ...Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: rs, hasStandardBrowserEnv: is, hasStandardBrowserWebWorkerEnv: os, navigator: ss, origin: as }, Symbol.toStringTag, { value: "Module" })), ...ns }; function cs(e) { function t(e, n, r, s) { let i = e[s++]; if ("__proto__" === i) return !0; const o = Number.isFinite(+i), a = s >= e.length; return i = !i && Hr.isArray(r) ? r.length : i, a ? (Hr.hasOwnProp(r, i) ? r[i] = [r[i], n] : r[i] = n, !o) : (r[i] && Hr.isObject(r[i]) || (r[i] = []), t(e, n, r[i], s) && Hr.isArray(r[i]) && (r[i] = function (e) { const t = {}, n = Object.keys(e); let r; const s = n.length; let i; for (r = 0; r < s; r++)i = n[r], t[i] = e[i]; return t }(r[i])), !o) } if (Hr.isFormData(e) && Hr.isFunction(e.entries)) { const n = {}; return Hr.forEachEntry(e, (e, r) => { t(function (e) { return Hr.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0]) }(e), r, n, 0) }), n } return null } const us = { transitional: ts, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, s = Hr.isObject(e); if (s && Hr.isHTMLForm(e) && (e = new FormData(e)), Hr.isFormData(e)) return r ? JSON.stringify(cs(e)) : e; if (Hr.isArrayBuffer(e) || Hr.isBuffer(e) || Hr.isStream(e) || Hr.isFile(e) || Hr.isBlob(e) || Hr.isReadableStream(e)) return e; if (Hr.isArrayBufferView(e)) return e.buffer; if (Hr.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let i; if (s) { if (n.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return Wr(e, new ls.classes.URLSearchParams, { visitor: function (e, t, n, r) { return ls.isNode && Hr.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) }, ...t }) }(e, this.formSerializer).toString(); if ((i = Hr.isFileList(e)) || n.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return Wr(i ? { "files[]": e } : e, t && new t, this.formSerializer) } } return s || r ? (t.setContentType("application/json", !1), function (e) { if (Hr.isString(e)) try { return (0, JSON.parse)(e), Hr.trim(e) } catch (ag) { if ("SyntaxError" !== ag.name) throw ag } return (0, JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || us.transitional, n = t && t.forcedJSONParsing, r = "json" === this.responseType; if (Hr.isResponse(e) || Hr.isReadableStream(e)) return e; if (e && Hr.isString(e) && (n && !this.responseType || r)) { const n = !(t && t.silentJSONParsing) && r; try { return JSON.parse(e, this.parseReviver) } catch (ag) { if (n) { if ("SyntaxError" === ag.name) throw jr.from(ag, jr.ERR_BAD_RESPONSE, this, null, this.response); throw ag } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: ls.classes.FormData, Blob: ls.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; Hr.forEach(["delete", "get", "head", "post", "put", "patch"], e => { us.headers[e] = {} }); const hs = Hr.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), ds = Symbol("internals"); function ps(e) { return e && String(e).trim().toLowerCase() } function fs(e) { return !1 === e || null == e ? e : Hr.isArray(e) ? e.map(fs) : String(e) } function ms(e, t, n, r, s) { return Hr.isFunction(r) ? r.call(this, t, n) : (s && (t = n), Hr.isString(t) ? Hr.isString(r) ? -1 !== t.indexOf(r) : Hr.isRegExp(r) ? r.test(t) : void 0 : void 0) } let gs = class { constructor(e) { e && this.set(e) } set(e, t, n) { const r = this; function s(e, t, n) { const s = ps(t); if (!s) throw new Error("header name must be a non-empty string"); const i = Hr.findKey(r, s); (!i || void 0 === r[i] || !0 === n || void 0 === n && !1 !== r[i]) && (r[i || t] = fs(e)) } const i = (e, t) => Hr.forEach(e, (e, n) => s(e, n, t)); if (Hr.isPlainObject(e) || e instanceof this.constructor) i(e, t); else if (Hr.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) i((e => { const t = {}; let n, r, s; return e && e.split("\n").forEach(function (e) { s = e.indexOf(":"), n = e.substring(0, s).trim().toLowerCase(), r = e.substring(s + 1).trim(), !n || t[n] && hs[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) }), t })(e), t); else if (Hr.isObject(e) && Hr.isIterable(e)) { let n, r, s = {}; for (const t of e) { if (!Hr.isArray(t)) throw TypeError("Object iterator must return a key-value pair"); s[r = t[0]] = (n = s[r]) ? Hr.isArray(n) ? [...n, t[1]] : [n, t[1]] : t[1] } i(s, t) } else null != e && s(t, e, n); return this } get(e, t) { if (e = ps(e)) { const n = Hr.findKey(this, e); if (n) { const e = this[n]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t }(e); if (Hr.isFunction(t)) return t.call(this, e, n); if (Hr.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = ps(e)) { const n = Hr.findKey(this, e); return !(!n || void 0 === this[n] || t && !ms(0, this[n], n, t)) } return !1 } delete(e, t) { const n = this; let r = !1; function s(e) { if (e = ps(e)) { const s = Hr.findKey(n, e); !s || t && !ms(0, n[s], s, t) || (delete n[s], r = !0) } } return Hr.isArray(e) ? e.forEach(s) : s(e), r } clear(e) { const t = Object.keys(this); let n = t.length, r = !1; for (; n--;) { const s = t[n]; e && !ms(0, this[s], s, e, !0) || (delete this[s], r = !0) } return r } normalize(e) { const t = this, n = {}; return Hr.forEach(this, (r, s) => { const i = Hr.findKey(n, s); if (i) return t[i] = fs(r), void delete t[s]; const o = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n) }(s) : String(s).trim(); o !== s && delete t[s], t[o] = fs(r), n[o] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return Hr.forEach(this, (n, r) => { null != n && !1 !== n && (t[r] = e && Hr.isArray(n) ? n.join(", ") : n) }), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n") } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const n = new this(e); return t.forEach(e => n.set(e)), n } static accessor(e) { const t = (this[ds] = this[ds] = { accessors: {} }).accessors, n = this.prototype; function r(e) { const r = ps(e); t[r] || (function (e, t) { const n = Hr.toCamelCase(" " + t);["get", "set", "has"].forEach(r => { Object.defineProperty(e, r + n, { value: function (e, n, s) { return this[r].call(this, t, e, n, s) }, configurable: !0 }) }) }(n, e), t[r] = !0) } return Hr.isArray(e) ? e.forEach(r) : r(e), this } }; function Es(e, t) { const n = this || us, r = t || n, s = gs.from(r.headers); let i = r.data; return Hr.forEach(e, function (e) { i = e.call(n, i, s.normalize(), t ? t.status : void 0) }), s.normalize(), i } function Ts(e) { return !(!e || !e.__CANCEL__) } function As(e, t, n) { jr.call(this, null == e ? "canceled" : e, jr.ERR_CANCELED, t, n), this.name = "CanceledError" } function _s(e, t, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? t(new jr("Request failed with status code " + n.status, [jr.ERR_BAD_REQUEST, jr.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) } gs.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Hr.reduceDescriptors(gs.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(e) { this[n] = e } } }), Hr.freezeMethods(gs), Hr.inherits(As, jr, { __CANCEL__: !0 }); const ys = (e, t, n = 3) => { let r = 0; const s = function (e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let s, i = 0, o = 0; return t = void 0 !== t ? t : 1e3, function (a) { const l = Date.now(), c = r[o]; s || (s = l), n[i] = a, r[i] = l; let u = o, h = 0; for (; u !== i;)h += n[u++], u %= e; if (i = (i + 1) % e, i === o && (o = (o + 1) % e), l - s < t) return; const d = c && l - c; return d ? Math.round(1e3 * h / d) : void 0 } }(50, 250); return function (n, i) { let o, a, l = 0, c = 1e3 / i; const u = (n, i = Date.now()) => { l = i, o = null, a && (clearTimeout(a), a = null), (n => { const i = n.loaded, o = n.lengthComputable ? n.total : void 0, a = i - r, l = s(a); r = i, e({ loaded: i, total: o, progress: o ? i / o : void 0, bytes: a, rate: l || void 0, estimated: l && o && i <= o ? (o - i) / l : void 0, event: n, lengthComputable: null != o, [t ? "download" : "upload"]: !0 }) })(...n) }; return [(...e) => { const t = Date.now(), n = t - l; n >= c ? u(e, t) : (o = e, a || (a = setTimeout(() => { a = null, u(o) }, c - n))) }, () => o && u(o)] }(0, n) }, bs = (e, t) => { const n = null != e; return [r => t[0]({ lengthComputable: n, total: e, loaded: r }), t[1]] }, Ss = e => (...t) => Hr.asap(() => e(...t)), ks = ls.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, ls.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(ls.origin), ls.navigator && /(msie|trident)/i.test(ls.navigator.userAgent)) : () => !0, Cs = ls.hasStandardBrowserEnv ? { write(e, t, n, r, s, i, o) { if ("undefined" == typeof document) return; const a = [`${e}=${encodeURIComponent(t)}`]; Hr.isNumber(n) && a.push(`expires=${new Date(n).toUTCString()}`), Hr.isString(r) && a.push(`path=${r}`), Hr.isString(s) && a.push(`domain=${s}`), !0 === i && a.push("secure"), Hr.isString(o) && a.push(`SameSite=${o}`), document.cookie = a.join("; ") }, read(e) { if ("undefined" == typeof document) return null; const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5, "/") } } : { write() { }, read: () => null, remove() { } }; function Ns(e, t, n) { let r = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t); return e && (r || 0 == n) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const Is = e => e instanceof gs ? { ...e } : e; function Os(e, t) { t = t || {}; const n = {}; function r(e, t, n, r) { return Hr.isPlainObject(e) && Hr.isPlainObject(t) ? Hr.merge.call({ caseless: r }, e, t) : Hr.isPlainObject(t) ? Hr.merge({}, t) : Hr.isArray(t) ? t.slice() : t } function s(e, t, n, s) { return Hr.isUndefined(t) ? Hr.isUndefined(e) ? void 0 : r(void 0, e, 0, s) : r(e, t, 0, s) } function i(e, t) { if (!Hr.isUndefined(t)) return r(void 0, t) } function o(e, t) { return Hr.isUndefined(t) ? Hr.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t) } function a(n, s, i) { return i in t ? r(n, s) : i in e ? r(void 0, n) : void 0 } const l = { url: i, method: i, data: i, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (e, t, n) => s(Is(e), Is(t), 0, !0) }; return Hr.forEach(Object.keys({ ...e, ...t }), function (r) { const i = l[r] || s, o = i(e[r], t[r], r); Hr.isUndefined(o) && i !== a || (n[r] = o) }), n } const xs = e => { const t = Os({}, e); let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: a } = t; if (t.headers = o = gs.from(o), t.url = Zr(Ns(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))), Hr.isFormData(n)) if (ls.hasStandardBrowserEnv || ls.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0); else if (Hr.isFunction(n.getHeaders)) { const e = n.getHeaders(), t = ["content-type", "content-length"]; Object.entries(e).forEach(([e, n]) => { t.includes(e.toLowerCase()) && o.set(e, n) }) } if (ls.hasStandardBrowserEnv && (r && Hr.isFunction(r) && (r = r(t)), r || !1 !== r && ks(t.url))) { const e = s && i && Cs.read(i); e && o.set(s, e) } return t }, Rs = "undefined" != typeof XMLHttpRequest && function (e) { return new Promise(function (t, n) { const r = xs(e); let s = r.data; const i = gs.from(r.headers).normalize(); let o, a, l, c, u, { responseType: h, onUploadProgress: d, onDownloadProgress: p } = r; function f() { c && c(), u && u(), r.cancelToken && r.cancelToken.unsubscribe(o), r.signal && r.signal.removeEventListener("abort", o) } let m = new XMLHttpRequest; function g() { if (!m) return; const r = gs.from("getAllResponseHeaders" in m && m.getAllResponseHeaders()); _s(function (e) { t(e), f() }, function (e) { n(e), f() }, { data: h && "text" !== h && "json" !== h ? m.response : m.responseText, status: m.status, statusText: m.statusText, headers: r, config: e, request: m }), m = null } m.open(r.method.toUpperCase(), r.url, !0), m.timeout = r.timeout, "onloadend" in m ? m.onloadend = g : m.onreadystatechange = function () { m && 4 === m.readyState && (0 !== m.status || m.responseURL && 0 === m.responseURL.indexOf("file:")) && setTimeout(g) }, m.onabort = function () { m && (n(new jr("Request aborted", jr.ECONNABORTED, e, m)), m = null) }, m.onerror = function (t) { const r = new jr(t && t.message ? t.message : "Network Error", jr.ERR_NETWORK, e, m); r.event = t || null, n(r), m = null }, m.ontimeout = function () { let t = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"; const s = r.transitional || ts; r.timeoutErrorMessage && (t = r.timeoutErrorMessage), n(new jr(t, s.clarifyTimeoutError ? jr.ETIMEDOUT : jr.ECONNABORTED, e, m)), m = null }, void 0 === s && i.setContentType(null), "setRequestHeader" in m && Hr.forEach(i.toJSON(), function (e, t) { m.setRequestHeader(t, e) }), Hr.isUndefined(r.withCredentials) || (m.withCredentials = !!r.withCredentials), h && "json" !== h && (m.responseType = r.responseType), p && ([l, u] = ys(p, !0), m.addEventListener("progress", l)), d && m.upload && ([a, c] = ys(d), m.upload.addEventListener("progress", a), m.upload.addEventListener("loadend", c)), (r.cancelToken || r.signal) && (o = t => { m && (n(!t || t.type ? new As(null, e, m) : t), m.abort(), m = null) }, r.cancelToken && r.cancelToken.subscribe(o), r.signal && (r.signal.aborted ? o() : r.signal.addEventListener("abort", o))); const E = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(r.url); E && -1 === ls.protocols.indexOf(E) ? n(new jr("Unsupported protocol " + E + ":", jr.ERR_BAD_REQUEST, e)) : m.send(s || null) }) }, vs = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let n, r = new AbortController; const s = function (e) { if (!n) { n = !0, o(); const t = e instanceof Error ? e : this.reason; r.abort(t instanceof jr ? t : new As(t instanceof Error ? t.message : t)) } }; let i = t && setTimeout(() => { i = null, s(new jr(`timeout ${t} of ms exceeded`, jr.ETIMEDOUT)) }, t); const o = () => { e && (i && clearTimeout(i), i = null, e.forEach(e => { e.unsubscribe ? e.unsubscribe(s) : e.removeEventListener("abort", s) }), e = null) }; e.forEach(e => e.addEventListener("abort", s)); const { signal: a } = r; return a.unsubscribe = () => Hr.asap(o), a } }, Ds = function* (e, t) { let n = e.byteLength; if (n < t) return void (yield e); let r, s = 0; for (; s < n;)r = s + t, yield e.slice(s, r), s = r }, Ls = (e, t, n, r) => { const s = async function* (e, t) { for await (const n of async function* (e) { if (e[Symbol.asyncIterator]) return void (yield* e); const t = e.getReader(); try { for (; ;) { const { done: e, value: n } = await t.read(); if (e) break; yield n } } finally { await t.cancel() } }(e)) yield* Ds(n, t) }(e, t); let i, o = 0, a = e => { i || (i = !0, r && r(e)) }; return new ReadableStream({ async pull(e) { try { const { done: t, value: r } = await s.next(); if (t) return a(), void e.close(); let i = r.byteLength; if (n) { let e = o += i; n(e) } e.enqueue(new Uint8Array(r)) } catch (t) { throw a(t), t } }, cancel: e => (a(e), s.return()) }, { highWaterMark: 2 }) }, { isFunction: Ps } = Hr, ws = (({ Request: e, Response: t }) => ({ Request: e, Response: t }))(Hr.global), { ReadableStream: Ms, TextEncoder: Fs } = Hr.global, Bs = (e, ...t) => { try { return !!e(...t) } catch (ag) { return !1 } }, Us = e => { e = Hr.merge.call({ skipUndefined: !0 }, ws, e); const { fetch: t, Request: n, Response: r } = e, s = t ? Ps(t) : "function" == typeof fetch, i = Ps(n), o = Ps(r); if (!s) return !1; const a = s && Ps(Ms), l = s && ("function" == typeof Fs ? (e => t => e.encode(t))(new Fs) : async e => new Uint8Array(await new n(e).arrayBuffer())), c = i && a && Bs(() => { let e = !1; const t = new n(ls.origin, { body: new Ms, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t }), u = o && a && Bs(() => Hr.isReadableStream(new r("").body)), h = { stream: u && (e => e.body) }; s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => { !h[e] && (h[e] = (t, n) => { let r = t && t[e]; if (r) return r.call(t); throw new jr(`Response type '${e}' is not supported`, jr.ERR_NOT_SUPPORT, n) }) }); return async e => { let { url: s, method: o, data: a, signal: d, cancelToken: p, timeout: f, onDownloadProgress: m, onUploadProgress: g, responseType: E, headers: T, withCredentials: A = "same-origin", fetchOptions: _ } = xs(e), y = t || fetch; E = E ? (E + "").toLowerCase() : "text"; let b = vs([d, p && p.toAbortSignal()], f), S = null; const k = b && b.unsubscribe && (() => { b.unsubscribe() }); let C; try { if (g && c && "get" !== o && "head" !== o && 0 !== (C = await (async (e, t) => { const r = Hr.toFiniteNumber(e.getContentLength()); return null == r ? (async e => { if (null == e) return 0; if (Hr.isBlob(e)) return e.size; if (Hr.isSpecCompliantForm(e)) { const t = new n(ls.origin, { method: "POST", body: e }); return (await t.arrayBuffer()).byteLength } return Hr.isArrayBufferView(e) || Hr.isArrayBuffer(e) ? e.byteLength : (Hr.isURLSearchParams(e) && (e += ""), Hr.isString(e) ? (await l(e)).byteLength : void 0) })(t) : r })(T, a))) { let e, t = new n(s, { method: "POST", body: a, duplex: "half" }); if (Hr.isFormData(a) && (e = t.headers.get("content-type")) && T.setContentType(e), t.body) { const [e, n] = bs(C, ys(Ss(g))); a = Ls(t.body, 65536, e, n) } } Hr.isString(A) || (A = A ? "include" : "omit"); const t = i && "credentials" in n.prototype, d = { ..._, signal: b, method: o.toUpperCase(), headers: T.normalize().toJSON(), body: a, duplex: "half", credentials: t ? A : void 0 }; S = i && new n(s, d); let p = await (i ? y(S, _) : y(s, d)); const f = u && ("stream" === E || "response" === E); if (u && (m || f && k)) { const e = {};["status", "statusText", "headers"].forEach(t => { e[t] = p[t] }); const t = Hr.toFiniteNumber(p.headers.get("content-length")), [n, s] = m && bs(t, ys(Ss(m), !0)) || []; p = new r(Ls(p.body, 65536, n, () => { s && s(), k && k() }), e) } E = E || "text"; let N = await h[Hr.findKey(h, E) || "text"](p, e); return !f && k && k(), await new Promise((t, n) => { _s(t, n, { data: N, headers: gs.from(p.headers), status: p.status, statusText: p.statusText, config: e, request: S }) }) } catch (N) { if (k && k(), N && "TypeError" === N.name && /Load failed|fetch/i.test(N.message)) throw Object.assign(new jr("Network Error", jr.ERR_NETWORK, e, S), { cause: N.cause || N }); throw jr.from(N, N && N.code, e, S) } } }, Hs = new Map, js = e => { let t = e && e.env || {}; const { fetch: n, Request: r, Response: s } = t, i = [r, s, n]; let o, a, l = i.length, c = Hs; for (; l--;)o = i[l], a = c.get(o), void 0 === a && c.set(o, a = l ? new Map : Us(t)), c = a; return a }; js(); const Gs = { http: null, xhr: Rs, fetch: { get: js } }; Hr.forEach(Gs, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (ag) { } Object.defineProperty(e, "adapterName", { value: t }) } }); const zs = e => `- ${e}`, Ys = e => Hr.isFunction(e) || null === e || !1 === e, qs = function (e, t) { e = Hr.isArray(e) ? e : [e]; const { length: n } = e; let r, s; const i = {}; for (let o = 0; o < n; o++) { let n; if (r = e[o], s = r, !Ys(r) && (s = Gs[(n = String(r)).toLowerCase()], void 0 === s)) throw new jr(`Unknown adapter '${n}'`); if (s && (Hr.isFunction(s) || (s = s.get(t)))) break; i[n || "#" + o] = s } if (!s) { const e = Object.entries(i).map(([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build")); throw new jr("There is no suitable adapter to dispatch the request " + (n ? e.length > 1 ? "since :\n" + e.map(zs).join("\n") : " " + zs(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT") } return s }; function Vs(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new As(null, e) } function $s(e) { return Vs(e), e.headers = gs.from(e.headers), e.data = Es.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), qs(e.adapter || us.adapter, e)(e).then(function (t) { return Vs(e), t.data = Es.call(e, e.transformResponse, t), t.headers = gs.from(t.headers), t }, function (t) { return Ts(t) || (Vs(e), t && t.response && (t.response.data = Es.call(e, e.transformResponse, t.response), t.response.headers = gs.from(t.response.headers))), Promise.reject(t) }) } const Ws = "1.13.2", Ks = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { Ks[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } }); const Qs = {}; Ks.transitional = function (e, t, n) { return (r, s, i) => { if (!1 === e) throw new jr(function (e, t) { return "[Axios v" + Ws + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "") }(s, " has been removed" + (t ? " in " + t : "")), jr.ERR_DEPRECATED); return t && !Qs[s] && (Qs[s] = !0), !e || e(r, s, i) } }, Ks.spelling = function (e) { return (e, t) => !0 }; const Xs = { assertOptions: function (e, t, n) { if ("object" != typeof e) throw new jr("options must be an object", jr.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let s = r.length; for (; s-- > 0;) { const i = r[s], o = t[i]; if (o) { const t = e[i], n = void 0 === t || o(t, i, e); if (!0 !== n) throw new jr("option " + i + " must be " + n, jr.ERR_BAD_OPTION_VALUE); continue } if (!0 !== n) throw new jr("Unknown option " + i, jr.ERR_BAD_OPTION) } }, validators: Ks }, Js = Xs.validators; let Zs = class { constructor(e) { this.defaults = e || {}, this.interceptors = { request: new es, response: new es } } async request(e, t) { try { return await this._request(e, t) } catch (n) { if (n instanceof Error) { let e = {}; Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error; const t = e.stack ? e.stack.replace(/^.+\n/, "") : ""; try { n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t } catch (ag) { } } throw n } } _request(e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, t = Os(this.defaults, t); const { transitional: n, paramsSerializer: r, headers: s } = t; void 0 !== n && Xs.assertOptions(n, { silentJSONParsing: Js.transitional(Js.boolean), forcedJSONParsing: Js.transitional(Js.boolean), clarifyTimeoutError: Js.transitional(Js.boolean) }, !1), null != r && (Hr.isFunction(r) ? t.paramsSerializer = { serialize: r } : Xs.assertOptions(r, { encode: Js.function, serialize: Js.function }, !0)), void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Xs.assertOptions(t, { baseUrl: Js.spelling("baseURL"), withXsrfToken: Js.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let i = s && Hr.merge(s.common, s[t.method]); s && Hr.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => { delete s[e] }), t.headers = gs.concat(i, s); const o = []; let a = !0; this.interceptors.request.forEach(function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, o.unshift(e.fulfilled, e.rejected)) }); const l = []; let c; this.interceptors.response.forEach(function (e) { l.push(e.fulfilled, e.rejected) }); let u, h = 0; if (!a) { const e = [$s.bind(this), void 0]; for (e.unshift(...o), e.push(...l), u = e.length, c = Promise.resolve(t); h < u;)c = c.then(e[h++], e[h++]); return c } u = o.length; let d = t; for (; h < u;) { const e = o[h++], t = o[h++]; try { d = e(d) } catch (p) { t.call(this, p); break } } try { c = $s.call(this, d) } catch (p) { return Promise.reject(p) } for (h = 0, u = l.length; h < u;)c = c.then(l[h++], l[h++]); return c } getUri(e) { return Zr(Ns((e = Os(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer) } }; Hr.forEach(["delete", "get", "head", "options"], function (e) { Zs.prototype[e] = function (t, n) { return this.request(Os(n || {}, { method: e, url: t, data: (n || {}).data })) } }), Hr.forEach(["post", "put", "patch"], function (e) { function t(t) { return function (n, r, s) { return this.request(Os(s || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r })) } } Zs.prototype[e] = t(), Zs.prototype[e + "Form"] = t(!0) }); const ei = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(ei).forEach(([e, t]) => { ei[t] = e }); const ti = function e(t) { const n = new Zs(t), r = Jn(Zs.prototype.request, n); return Hr.extend(r, Zs.prototype, n, { allOwnKeys: !0 }), Hr.extend(r, n, null, { allOwnKeys: !0 }), r.create = function (n) { return e(Os(t, n)) }, r }(us); ti.Axios = Zs, ti.CanceledError = As, ti.CancelToken = class e { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise(function (e) { t = e }); const n = this; this.promise.then(e => { if (!n._listeners) return; let t = n._listeners.length; for (; t-- > 0;)n._listeners[t](e); n._listeners = null }), this.promise.then = e => { let t; const r = new Promise(e => { n.subscribe(e), t = e }).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e(function (e, r, s) { n.reason || (n.reason = new As(e, r, s), t(n.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = t => { e.abort(t) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let t; return { token: new e(function (e) { t = e }), cancel: t } } }, ti.isCancel = Ts, ti.VERSION = Ws, ti.toFormData = Wr, ti.AxiosError = jr, ti.Cancel = ti.CanceledError, ti.all = function (e) { return Promise.all(e) }, ti.spread = function (e) { return function (t) { return e.apply(null, t) } }, ti.isAxiosError = function (e) { return Hr.isObject(e) && !0 === e.isAxiosError }, ti.mergeConfig = Os, ti.AxiosHeaders = gs, ti.formToJSON = e => cs(Hr.isHTMLForm(e) ? new FormData(e) : e), ti.getAdapter = qs, ti.HttpStatusCode = ei, ti.default = ti; const { Axios: ni, AxiosError: ri, CanceledError: si, isCancel: ii, CancelToken: oi, VERSION: ai, all: li, Cancel: ci, isAxiosError: ui, spread: hi, toFormData: di, AxiosHeaders: pi, HttpStatusCode: fi, formToJSON: mi, getAdapter: gi, mergeConfig: Ei } = ti, Ti = ti.create({ baseURL: "https://next-blog-server-226627032790.asia-east1.run.app/api", headers: { "Content-Type": "application/json" } }); Ti.interceptors.request.use(e => { try { const t = localStorage.getItem("auth_token"); t && (e.headers.Authorization = `Bearer ${t}`) } catch (ag) { } return e }); const Ai = () => Ti.get("/posts"), _i = () => Ti.get("/categories"); function yi() { const { t: e, i18n: t } = Kn(), { theme: n, toggleTheme: r, textSize: s, setTextSize: i } = function () { const e = React.useContext(xt); if (!e) throw new Error("useTheme must be used within ThemeProvider"); return e }(), { isAuthenticated: o, logout: a } = Xn(), [l, c] = React.useState([]), [u, h] = React.useState(!1), d = React.useRef(null); return React.useEffect(() => { function e(e) { d.current && !d.current.contains(e.target) && h(!1) } return document.addEventListener("mousedown", e), () => document.removeEventListener("mousedown", e) }, []), React.useEffect(() => { const e = () => { _i().then(e => { c(e.data.categories) }).catch(e => { }) }; return e(), window.addEventListener("categories-updated", e), () => window.removeEventListener("categories-updated", e) }, []), T.jsx("nav", { className: "border-b border-gray-200 dark:border-gray-700", children: T.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: T.jsxs("div", { className: "flex justify-between h-16 items-center", children: [T.jsxs(Pe, { to: "/", className: "flex items-center text-2xl font-display text-text-light dark:text-text-dark hover:opacity-70 transition-opacity", children: [T.jsx("img", { src: "data:image/svg+xml,%3csvg%20width='64'%20height='64'%20viewBox='0%200%2064%2064'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3c!--%20Glow%20Filter%20--%3e%3cdefs%3e%3cfilter%20id='glow'%20x='-50%25'%20y='-50%25'%20width='200%25'%20height='200%25'%3e%3cfeGaussianBlur%20stdDeviation='1.5'%20result='coloredBlur'/%3e%3cfeMerge%3e%3cfeMergeNode%20in='coloredBlur'/%3e%3cfeMergeNode%20in='SourceGraphic'/%3e%3c/feMerge%3e%3c/filter%3e%3c/defs%3e%3c!--%20Bear%20Head%20Base%20(Wider)%20--%3e%3cpath%20d='M10%2024C10%2016%2018%2010%2032%2010C46%2010%2054%2016%2054%2024V32C54%2044%2046%2054%2032%2054C18%2054%2010%2044%2010%2032V24Z'%20fill='%23161b22'%20stroke='%2330363d'%20stroke-width='2'/%3e%3c!--%20Ears%20--%3e%3ccircle%20cx='10'%20cy='18'%20r='7'%20fill='%23161b22'%20stroke='%2330363d'%20stroke-width='2'/%3e%3ccircle%20cx='54'%20cy='18'%20r='7'%20fill='%23161b22'%20stroke='%2330363d'%20stroke-width='2'/%3e%3c!--%20Forehead%20overlay%20--%3e%3cpath%20d='M10%2024C10%2017%2018%2011%2032%2011C46%2011%2054%2017%2054%2024V32C54%2043%2046%2053%2032%2053C18%2053%2010%2043%2010%2032V24Z'%20fill='%23161b22'/%3e%3c!--%20The%20V%20Shape%20(Moved%20Higher)%20--%3e%3cpath%20d='M18%2038%20L32%2046%20L46%2038%20L32%2050%20Z'%20fill='%23F0F6FC'%20opacity='0.9'/%3e%3c!--%20Glowing%20White%20Eyes%20--%3e%3ccircle%20cx='22'%20cy='28'%20r='3.5'%20fill='%23FFFFFF'%20filter='url(%23glow)'/%3e%3ccircle%20cx='42'%20cy='28'%20r='3.5'%20fill='%23FFFFFF'%20filter='url(%23glow)'/%3e%3c!--%20Snout%20--%3e%3cellipse%20cx='32'%20cy='36'%20rx='8'%20ry='5'%20fill='%2321262d'/%3e%3cellipse%20cx='32'%20cy='35'%20rx='3'%20ry='2'%20fill='%230d1117'/%3e%3c/svg%3e", alt: "Logo", className: "mr-3 dark:invert flex-shrink-0", style: { width: "32px", height: "32px" } }), e("brand")] }), T.jsxs("div", { className: "flex items-center space-x-6", children: [T.jsx(Pe, { to: "/", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: e("nav.home") }), T.jsxs("div", { className: "relative", ref: d, children: [T.jsxs("button", { onClick: () => h(!u), className: "flex items-center gap-1 text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: [e("nav.categories", "Categories"), T.jsx("svg", { className: "w-4 h-4 transition-transform " + (u ? "rotate-180" : ""), fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })] }), u && T.jsx("div", { className: "absolute left-0 mt-2 py-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-50", children: l.filter(e => o || !e.adminOnly).map(e => { var n, r; return T.jsxs(Pe, { to: `/category/${e.slug || e.id}`, className: "block px-4 py-2 text-muted-light dark:text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-text-light dark:hover:text-text-dark transition-colors " + (e.adminOnly ? "opacity-70" : ""), onClick: () => h(!1), children: [e.adminOnly ? " " : "", (null == (r = null == (n = e.translations) ? void 0 : n[t.language]) ? void 0 : r.title) || e.title] }, e.id) }) })] }), o && T.jsxs(Pe, { to: "/admin", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors font-medium", children: [" ", e("nav.admin")] })] }), T.jsxs("div", { className: "flex items-center space-x-4", children: [T.jsxs("div", { className: "hidden sm:flex items-center space-x-1 text-sm", children: [T.jsx("button", { onClick: () => { const e = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], t = e.indexOf(s); t > 0 && i(e[t - 1]) }, disabled: "small" === s, className: "w-6 h-6 flex items-center justify-center rounded " + ("small" === s ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"), title: "Decrease text size", children: "" }), T.jsx("span", { className: "w-6 h-6 flex items-center justify-center font-medium", children: "A" }), T.jsx("button", { onClick: () => { const e = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], t = e.indexOf(s); t < e.length - 1 && i(e[t + 1]) }, disabled: "xxxlarge" === s, className: "w-6 h-6 flex items-center justify-center rounded " + ("xxxlarge" === s ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"), title: "Increase text size", children: "+" })] }), T.jsxs("select", { value: t.language, onChange: e => t.changeLanguage(e.target.value), className: "bg-transparent text-sm text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark uppercase border-none focus:ring-0 cursor-pointer appearance-none p-0 pr-6 bg-[url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E')] bg-[length:0.7em] bg-[right_0_center] bg-no-repeat", "aria-label": "Select Language", children: [T.jsx("option", { value: "en", className: "bg-white dark:bg-gray-800", children: "EN" }), T.jsx("option", { value: "poj", className: "bg-white dark:bg-gray-800", children: "POJ" }), T.jsx("option", { value: "hanlo", className: "bg-white dark:bg-gray-800", children: "" })] }), T.jsx("button", { onClick: r, className: "p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800", "aria-label": "Toggle theme", children: "light" === n ? T.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) }) : T.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) }), !1] })] }) }) }) } function bi() { const { t: e } = Kn(), t = (new Date).getFullYear(); return T.jsx("footer", { className: "border-t border-gray-200 dark:border-gray-700 mt-20 py-10", children: T.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: T.jsx("div", { className: "text-muted-light dark:text-muted-dark text-sm", children: e("footer.copyright", { year: t }) }) }) }) } function Si({ post: e, featured: t = !1, showDraftBadge: n = !1 }) { var r; const s = e.published || e.draft, i = null == s ? void 0 : s.meta, o = "published" !== e.status; if (!s) return null; const a = (null == (r = null == i ? void 0 : i.date) ? void 0 : r.substring(0, 7)) || `${(new Date).getFullYear()}-01`, l = (null == i ? void 0 : i.url) || e.id, c = (null == i ? void 0 : i.thumbImage) || ((e, t = 800, n = 600) => `https://picsum.photos/seed/${e}/${t}/${n}`)(e.id); return T.jsxs("article", { className: "group relative flex flex-col " + (t ? "col-span-full md:grid md:grid-cols-2 md:gap-8" : "h-full"), children: [T.jsx(Pe, { to: `/posts/${a}/${l}`, className: "absolute inset-0 z-10", "aria-label": s.title }), T.jsxs("div", { className: `overflow-hidden rounded-lg bg-gray-100 dark:bg-gray-800 ${t ? "aspect-video md:aspect-auto md:h-full" : "aspect-[16/10]"} mb-4 md:mb-0 relative shadow-sm transition-all duration-300 group-hover:shadow-md group-hover:translate-y-[-2px]`, children: [T.jsx("img", { src: c, alt: s.title, className: "w-full h-full object-cover transition-transform duration-700 ease-out group-hover:scale-105", loading: "lazy" }), n && o && T.jsx("div", { className: "absolute top-4 right-4 z-20", children: T.jsx("span", { className: "inline-block px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-orange-500/80 backdrop-blur-sm rounded-sm", children: "Draft" }) }), (null == i ? void 0 : i.category) && T.jsx("div", { className: "absolute top-4 left-4 z-20", children: T.jsx("span", { className: "inline-block px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-black/50 backdrop-blur-sm rounded-sm", children: i.category }) })] }), T.jsxs("div", { className: "flex flex-col " + (t ? "justify-center md:py-4" : "flex-1"), children: [T.jsxs("div", { className: "flex items-center gap-3 mb-3 text-xs font-medium text-muted-light dark:text-muted-dark", children: [(null == i ? void 0 : i.date) && T.jsx("time", { dateTime: i.date, children: i.date }), (null == i ? void 0 : i.featured) && T.jsx("span", { className: "text-yellow-600 dark:text-yellow-500 font-bold", children: " Featured" }), n && o && T.jsx("span", { className: "text-orange-500 font-bold", children: " Draft" })] }), T.jsx("h2", { className: `font-display font-bold text-text-light dark:text-text-dark ${t ? "text-3xl md:text-4xl" : "text-xl"} leading-tight mb-3 group-hover:text-accent transition-colors duration-200`, children: s.title }), (null == i ? void 0 : i.thumbText) && T.jsx("p", { className: `text-muted-light dark:text-muted-dark ${t ? "text-lg line-clamp-3" : "text-sm line-clamp-2"} mb-4`, children: i.thumbText }), T.jsx("div", { className: "mt-auto flex items-center text-sm font-medium text-accent opacity-0 -translate-x-2 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0", children: "Read article " })] })] }) } function ki() { const { t: e, i18n: t } = Kn(), [n, r] = React.useState([]), [s, i] = React.useState(!0), [o, a] = React.useState(null); React.useEffect(() => { l() }, [t.language]); const l = async () => { try { i(!0); const e = await Ai(); r(e.data.posts) } catch (e) { a("Failed to load posts") } finally { i(!1) } }, c = n.filter(e => { var t, n, r; return "help" !== (null == (r = null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.category) ? void 0 : r.toLowerCase()) }), u = c.filter(e => { var t, n; return null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.featured }), h = c.filter(e => { var t, n; return !(null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.featured) }); return T.jsxs(T.Fragment, { children: [T.jsxs(Ot, { children: [T.jsxs("title", { children: [e("home.title"), " | Next Blog"] }), T.jsx("meta", { name: "description", content: "A modern blog built with React and Firestore" })] }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(yi, {}), T.jsx("main", { className: "flex-1", children: T.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [u.length > 0 && T.jsxs("section", { className: "mb-16", children: [T.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.featured") }), T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8", children: u.slice(0, 2).map(e => T.jsx(Si, { post: e, featured: !0 }, e.id)) })] }), T.jsxs("section", { children: [T.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.latest") }), s ? T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((e, t) => T.jsxs("div", { className: "animate-pulse", children: [T.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-2" }), T.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, t)) }) : o ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: o }) : 0 === h.length ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: "No posts yet." }) : T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: h.map(e => T.jsx(Si, { post: e }, e.id)) })] })] }) }), T.jsx(bi, {})] })] }) } const Ci = {}, Ni = function (e, t, n) { let r = Promise.resolve(); if (t && t.length > 0) { const e = document.getElementsByTagName("link"), s = document.querySelector("meta[property=csp-nonce]"), i = (null == s ? void 0 : s.nonce) || (null == s ? void 0 : s.getAttribute("nonce")); r = Promise.allSettled(t.map(t => { if (t = function (e, t) { return new URL(e, t).href }(t, n), t in Ci) return; Ci[t] = !0; const r = t.endsWith(".css"), s = r ? '[rel="stylesheet"]' : ""; if (n) for (let n = e.length - 1; n >= 0; n--) { const s = e[n]; if (s.href === t && (!r || "stylesheet" === s.rel)) return } else if (document.querySelector(`link[href="${t}"]${s}`)) return; const o = document.createElement("link"); return o.rel = r ? "stylesheet" : "modulepreload", r || (o.as = "script"), o.crossOrigin = "", o.href = t, i && o.setAttribute("nonce", i), document.head.appendChild(o), r ? new Promise((e, n) => { o.addEventListener("load", e), o.addEventListener("error", () => n(new Error(`Unable to preload CSS for ${t}`))) }) : void 0 })) } function s(e) { const t = new Event("vite:preloadError", { cancelable: !0 }); if (t.payload = e, window.dispatchEvent(t), !t.defaultPrevented) throw e } return r.then(t => { for (const e of t || []) "rejected" === e.status && s(e.reason); return e().catch(s) }) }, Ii = React.lazy(() => Ni(() => Promise.resolve().then(() => Vu), void 0, import.meta.url).then(e => ({ default: e.default }))), Oi = Ni(() => Promise.resolve().then(() => Hd), void 0, import.meta.url).then(e => e.default), xi = Ni(() => Promise.resolve().then(() => og), void 0, import.meta.url).then(e => e.default); let Ri = null, vi = null; Promise.all([Oi, xi]).then(([e, t]) => { Ri = e, vi = t }); const Di = () => T.jsx("div", { className: "animate-pulse space-y-4", children: [...Array(5)].map((e, t) => T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, t)) }); function Li({ children: e, className: t }) { return T.jsx(React.Suspense, { fallback: T.jsx(Di, {}), children: T.jsx(Ii, { remarkPlugins: Ri ? [Ri] : [], rehypePlugins: vi ? [vi] : [], className: t, children: e }) }) } const Pi = (e, t = 1200, n = 800) => `https://picsum.photos/seed/${e}/${t}/${n}`; function wi() { const { yearMonth: e, slug: t } = pe(), [n, r] = React.useState(null), [s, i] = React.useState(!0), [o, a] = React.useState(null); React.useEffect(() => { e && t && l(e, t) }, [e, t]); const l = async (e, t) => { try { i(!0); const n = await ((e, t) => Ti.get(`/posts/by-slug/${e}/${t}`))(e, t); r(n.data.post) } catch (n) { a("Post not found") } finally { i(!1) } }, c = (null == n ? void 0 : n.published) || (null == n ? void 0 : n.draft), u = null == c ? void 0 : c.meta; return s ? T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(yi, {}), T.jsx("main", { className: "flex-1 animate-pulse", children: T.jsxs("div", { className: "max-w-3xl mx-auto px-4 py-12", children: [T.jsx("div", { className: "h-8 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-4" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-8" }), T.jsx("div", { className: "space-y-4", children: [...Array(8)].map((e, t) => T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, t)) })] }) }), T.jsx(bi, {})] }) : !o && n && c ? T.jsxs(T.Fragment, { children: [T.jsxs(Ot, { children: [T.jsxs("title", { children: [c.title, " | Next Blog"] }), T.jsx("meta", { name: "description", content: (null == u ? void 0 : u.thumbText) || c.title }), (null == u ? void 0 : u.ogImage) && T.jsx("meta", { property: "og:image", content: u.ogImage })] }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(yi, {}), T.jsxs("main", { className: "flex-1 bg-background-light dark:bg-background-dark", children: [T.jsxs("div", { className: "relative w-full h-[50vh] md:h-[60vh] min-h-[400px] bg-gray-900 overflow-hidden", children: [T.jsx("img", { src: (null == u ? void 0 : u.thumbImage) || Pi(n.id), alt: c.title, className: "w-full h-full object-cover opacity-80" }), T.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-background-light dark:from-background-dark via-transparent to-transparent opacity-90" }), T.jsxs("div", { className: "absolute bottom-0 left-0 right-0 p-6 md:p-12 max-w-4xl mx-auto text-center", children: [T.jsxs("div", { className: "flex items-center justify-center gap-3 mb-6 animate-fade-in-up", children: [(null == u ? void 0 : u.featured) && T.jsx("span", { className: "px-2 py-1 text-xs uppercase tracking-[0.2em] font-bold text-white bg-yellow-600/90 rounded-sm shadow-sm backdrop-blur-sm", children: "Featured" }), (null == u ? void 0 : u.category) && T.jsx("span", { className: "px-2 py-1 text-xs uppercase tracking-[0.2em] font-medium text-white/90 bg-accent/80 rounded-sm shadow-sm backdrop-blur-sm", children: u.category })] }), T.jsx("h1", { className: "font-display text-4xl md:text-6xl lg:text-7xl text-white mb-6 leading-tight text-shadow-lg animate-fade-in-up delay-100", children: c.title }), T.jsxs("div", { className: "flex items-center justify-center space-x-6 text-white/80 text-sm md:text-base font-medium animate-fade-in-up delay-200", children: [(null == u ? void 0 : u.author) && T.jsxs("div", { className: "flex items-center gap-2", children: [T.jsx("div", { className: "w-8 h-8 rounded-full bg-accent/30 flex items-center justify-center text-xs font-bold ring-1 ring-white/20", children: u.author[0] }), T.jsx("span", { children: u.author })] }), (null == u ? void 0 : u.date) && T.jsxs(T.Fragment, { children: [T.jsx("span", { children: "" }), T.jsx("time", { className: "font-mono opacity-80", children: u.date })] })] })] })] }), T.jsxs("article", { className: "max-w-3xl mx-auto px-4 sm:px-6 py-16", children: [T.jsx("div", { className: "prose prose-lg md:prose-xl dark:prose-invert mx-auto drop-cap", children: T.jsx(Li, { children: c.text }) }), (null == u ? void 0 : u.tags) && u.tags.length > 0 && T.jsx("div", { className: "mt-16 pt-10 border-t border-gray-200 dark:border-gray-800", children: T.jsx("div", { className: "flex flex-wrap gap-3", children: u.tags.map(e => T.jsxs("a", { href: `/tag/${e}`, className: "px-4 py-1.5 text-sm font-medium text-text-light dark:text-text-dark bg-surface-light dark:bg-surface-dark border border-gray-200 dark:border-gray-700 rounded-full hover:border-accent hover:text-accent dark:hover:text-accent transition-colors duration-200", children: ["#", e] }, e)) }) })] })] }), T.jsx(bi, {})] })] }) : T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(yi, {}), T.jsx("main", { className: "flex-1 flex items-center justify-center", children: T.jsx("p", { className: "text-muted-light dark:text-muted-dark", children: o || "Post not found" }) }), T.jsx(bi, {})] }) } function Mi() { const { category: e, tag: t, author: n } = pe(), { isAuthenticated: r } = Xn(), [s, i] = React.useState([]), [o, a] = React.useState([]), [l, c] = React.useState(!0), [u, h] = React.useState(!1); React.useEffect(() => { _i().then(e => { a(e.data.categories) }).catch(console.error) }, []), React.useEffect(() => { if (e && o.length > 0) { const t = o.find(t => t.id === e || t.slug === e); h((null == t ? void 0 : t.adminOnly) || !1) } d() }, [e, t, n, o, r]); const d = async () => { try { let s; c(!0); const a = o.find(t => t.id === e || t.slug === e); if (r && (null == a ? void 0 : a.adminOnly)) { s = await ((e = 1, t = 15) => Ti.get(`/posts/admin/all?page=${e}&limit=${t}`))(1, 1e3); const t = s.data.posts.filter(t => { var n, r, s; return (null == (s = null == (r = null == (n = t.draft) ? void 0 : n.meta) ? void 0 : r.category) ? void 0 : s.toLowerCase()) === (null == e ? void 0 : e.toLowerCase()) }); i(t) } else e ? (s = await ((e, t = "en") => Ti.get(`/posts?category=${e}&language=${t}`))(e, "all"), i(s.data.posts)) : t ? (s = await ((e, t = "en") => Ti.get(`/posts?tag=${e}&language=${t}`))(t, "all"), i(s.data.posts)) : n ? (s = await ((e, t = "en") => Ti.get(`/posts?author=${e}&language=${t}`))(n, "all"), i(s.data.posts)) : (s = await Ai(), i(s.data.posts)) } catch (s) { } finally { c(!1) } }, p = e || t || n || "Posts"; return T.jsxs(T.Fragment, { children: [T.jsx(Ot, { children: T.jsxs("title", { children: [p, " | Next Blog"] }) }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(yi, {}), T.jsx("main", { className: "flex-1", children: T.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [T.jsxs("header", { className: "mb-12", children: [T.jsxs("h1", { className: "font-display text-4xl mb-2", children: [u && r ? " " : "", p] }), T.jsxs("p", { className: "text-muted-light dark:text-muted-dark", children: [s.length, " post", 1 !== s.length ? "s" : "", u && r && " (including drafts)"] })] }), l ? T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((e, t) => T.jsxs("div", { className: "animate-pulse", children: [T.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), T.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, t)) }) : 0 === s.length ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: "No posts found." }) : T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: s.map(e => T.jsx(Si, { post: e, showDraftBadge: u && r }, e.id)) })] }) }), T.jsx(bi, {})] })] }) } function Fi() { return T.jsx(bt, { children: T.jsx(Rt, { children: T.jsx(ve, { children: T.jsxs(Ne, { children: [T.jsx(ke, { path: "/", element: T.jsx(ki, {}) }), T.jsx(ke, { path: "/posts/:yearMonth/:slug", element: T.jsx(wi, {}) }), T.jsx(ke, { path: "/category/:category", element: T.jsx(Mi, {}) }), T.jsx(ke, { path: "/tag/:tag", element: T.jsx(Mi, {}) }), T.jsx(ke, { path: "/author/:author", element: T.jsx(Mi, {}) }), T.jsx(ke, { path: "*", element: T.jsx(Se, { to: "/", replace: !0 }) })] }) }) }) }) } let Bi = !1; try { document.cookie, Bi = !0 } catch (ag) { } yn.use(Ln).init({ resources: { en: { translation: { brand: "", footer: { copyright: " {{year}} Next Blog. MIT License." }, nav: { home: "Home", tutorials: "Tutorials", admin: "Admin" }, home: { title: "Blog", featured: "Featured", latest: "Latest Posts", readMore: "Read More", noPosts: "No posts yet.", loading: "Loading...", failedToLoad: "Failed to load posts" }, post: { by: "By", published: "Published", share: "Share" } } }, poj: { translation: { brand: "", footer: { copyright: " {{year}} Next P-lok-keh. MIT License." }, nav: { home: "Thu-iah", tutorials: "Ku-hak", admin: "Kon-l" }, home: { title: "Blog", featured: "Cheng-son", latest: "Sing-sin Bn-chiu", readMore: "Kho Sing-s", noPosts: "Iu-be  bn-chiu", loading: "Teh chi-jip...", failedToLoad: "Bn-chiu chi-jip sit-pi" }, post: { by: "Chok-chi:", published: "Hoat-p", share: "Hun-hing" } } }, hanlo: { translation: { brand: "", footer: { copyright: " {{year}} Next . MIT License." }, nav: { home: "", tutorials: "", admin: "" }, home: { title: "Blog", featured: "", latest: "", readMore: "", noPosts: "", loading: "Teh liah...", failedToLoad: "" }, post: { by: "", published: "", share: "" } } } }, lng: "en", fallbackLng: "en", interpolation: { escapeValue: !1 } }); class Ui extends React.Component { constructor(e) { super(e), this.state = { hasError: !1, error: null } } static getDerivedStateFromError(e) { return { hasError: !0, error: e } } componentDidCatch(e, t) { } render() { var e, t; return this.state.hasError ? T.jsxs("div", { style: { padding: "20px", color: "red" }, children: [T.jsx("h1", { children: "Something went wrong." }), T.jsx("pre", { children: null == (e = this.state.error) ? void 0 : e.toString() }), T.jsx("pre", { children: null == (t = this.state.error) ? void 0 : t.stack })] }) : this.props.children } } function Hi() { } function ji() { } function Gi(e) { const t = [], n = String(e || ""); let r = n.indexOf(","), s = 0, i = !1; for (; !i;) { -1 === r && (r = n.length, i = !0); const e = n.slice(s, r).trim(); !e && i || t.push(e), s = r + 1, r = n.indexOf(",", s) } return t } function zi(e, t) { const n = {}; return ("" === e[e.length - 1] ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " ")).trim() } ReactDOM.createRoot(document.getElementById("root")).render(T.jsx(React.StrictMode, { children: T.jsx(Ui, { children: T.jsx(Fi, {}) }) })); const Yi = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, qi = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Vi = {}; function $i(e, t) { return (Vi.jsx ? qi : Yi).test(e) } const Wi = /[ \t\n\f\r]/g; function Ki(e) { return "" === e.replace(Wi, "") } class Qi { constructor(e, t, n) { this.normal = t, this.property = e, n && (this.space = n) } } function Xi(e, t) { const n = {}, r = {}; for (const s of e) Object.assign(n, s.property), Object.assign(r, s.normal); return new Qi(n, r, t) } function Ji(e) { return e.toLowerCase() } Qi.prototype.normal = {}, Qi.prototype.property = {}, Qi.prototype.space = void 0; class Zi { constructor(e, t) { this.attribute = t, this.property = e } } Zi.prototype.attribute = "", Zi.prototype.booleanish = !1, Zi.prototype.boolean = !1, Zi.prototype.commaOrSpaceSeparated = !1, Zi.prototype.commaSeparated = !1, Zi.prototype.defined = !1, Zi.prototype.mustUseProperty = !1, Zi.prototype.number = !1, Zi.prototype.overloadedBoolean = !1, Zi.prototype.property = "", Zi.prototype.spaceSeparated = !1, Zi.prototype.space = void 0; let eo = 0; const to = lo(), no = lo(), ro = lo(), so = lo(), io = lo(), oo = lo(), ao = lo(); function lo() { return 2 ** ++eo } const co = Object.freeze(Object.defineProperty({ __proto__: null, boolean: to, booleanish: no, commaOrSpaceSeparated: ao, commaSeparated: oo, number: so, overloadedBoolean: ro, spaceSeparated: io }, Symbol.toStringTag, { value: "Module" })), uo = Object.keys(co); class ho extends Zi { constructor(e, t, n, r) { let s = -1; if (super(e, t), po(this, "space", r), "number" == typeof n) for (; ++s < uo.length;) { const e = uo[s]; po(this, uo[s], (n & co[e]) === co[e]) } } } function po(e, t, n) { n && (e[t] = n) } function fo(e) { const t = {}, n = {}; for (const [r, s] of Object.entries(e.properties)) { const i = new ho(r, e.transform(e.attributes || {}, r), s, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[Ji(r)] = r, n[Ji(i.attribute)] = r } return new Qi(t, n, e.space) } ho.prototype.defined = !0; const mo = fo({ properties: { ariaActiveDescendant: null, ariaAtomic: no, ariaAutoComplete: null, ariaBusy: no, ariaChecked: no, ariaColCount: so, ariaColIndex: so, ariaColSpan: so, ariaControls: io, ariaCurrent: null, ariaDescribedBy: io, ariaDetails: null, ariaDisabled: no, ariaDropEffect: io, ariaErrorMessage: null, ariaExpanded: no, ariaFlowTo: io, ariaGrabbed: no, ariaHasPopup: null, ariaHidden: no, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: io, ariaLevel: so, ariaLive: null, ariaModal: no, ariaMultiLine: no, ariaMultiSelectable: no, ariaOrientation: null, ariaOwns: io, ariaPlaceholder: null, ariaPosInSet: so, ariaPressed: no, ariaReadOnly: no, ariaRelevant: null, ariaRequired: no, ariaRoleDescription: io, ariaRowCount: so, ariaRowIndex: so, ariaRowSpan: so, ariaSelected: no, ariaSetSize: so, ariaSort: null, ariaValueMax: so, ariaValueMin: so, ariaValueNow: so, ariaValueText: null, role: null }, transform: (e, t) => "role" === t ? t : "aria-" + t.slice(4).toLowerCase() }); function go(e, t) { return t in e ? e[t] : t } function Eo(e, t) { return go(e, t.toLowerCase()) } const To = fo({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: oo, acceptCharset: io, accessKey: io, action: null, allow: null, allowFullScreen: to, allowPaymentRequest: to, allowUserMedia: to, alt: null, as: null, async: to, autoCapitalize: null, autoComplete: io, autoFocus: to, autoPlay: to, blocking: io, capture: null, charSet: null, checked: to, cite: null, className: io, cols: so, colSpan: null, content: null, contentEditable: no, controls: to, controlsList: io, coords: so | oo, crossOrigin: null, data: null, dateTime: null, decoding: null, default: to, defer: to, dir: null, dirName: null, disabled: to, download: ro, draggable: no, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: to, formTarget: null, headers: io, height: so, hidden: ro, high: so, href: null, hrefLang: null, htmlFor: io, httpEquiv: io, id: null, imageSizes: null, imageSrcSet: null, inert: to, inputMode: null, integrity: null, is: null, isMap: to, itemId: null, itemProp: io, itemRef: io, itemScope: to, itemType: io, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: to, low: so, manifest: null, max: null, maxLength: so, media: null, method: null, min: null, minLength: so, multiple: to, muted: to, name: null, nonce: null, noModule: to, noValidate: to, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: to, optimum: so, pattern: null, ping: io, placeholder: null, playsInline: to, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: to, referrerPolicy: null, rel: io, required: to, reversed: to, rows: so, rowSpan: so, sandbox: io, scope: null, scoped: to, seamless: to, selected: to, shadowRootClonable: to, shadowRootDelegatesFocus: to, shadowRootMode: null, shape: null, size: so, sizes: null, slot: null, span: so, spellCheck: no, src: null, srcDoc: null, srcLang: null, srcSet: null, start: so, step: null, style: null, tabIndex: so, target: null, title: null, translate: null, type: null, typeMustMatch: to, useMap: null, value: no, width: so, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: io, axis: null, background: null, bgColor: null, border: so, borderColor: null, bottomMargin: so, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: to, declare: to, event: null, face: null, frame: null, frameBorder: null, hSpace: so, leftMargin: so, link: null, longDesc: null, lowSrc: null, marginHeight: so, marginWidth: so, noResize: to, noHref: to, noShade: to, noWrap: to, object: null, profile: null, prompt: null, rev: null, rightMargin: so, rules: null, scheme: null, scrolling: no, standby: null, summary: null, text: null, topMargin: so, valueType: null, version: null, vAlign: null, vLink: null, vSpace: so, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: to, disableRemotePlayback: to, prefix: null, property: null, results: so, security: null, unselectable: null }, space: "html", transform: Eo }), Ao = fo({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: ao, accentHeight: so, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: so, amplitude: so, arabicForm: null, ascent: so, attributeName: null, attributeType: null, azimuth: so, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: so, by: null, calcMode: null, capHeight: so, className: io, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: so, diffuseConstant: so, direction: null, display: null, dur: null, divisor: so, dominantBaseline: null, download: to, dx: null, dy: null, edgeMode: null, editable: null, elevation: so, enableBackground: null, end: null, event: null, exponent: so, externalResourcesRequired: null, fill: null, fillOpacity: so, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: oo, g2: oo, glyphName: oo, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: so, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: so, horizOriginX: so, horizOriginY: so, id: null, ideographic: so, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: so, k: so, k1: so, k2: so, k3: so, k4: so, kernelMatrix: ao, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: so, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: so, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: so, overlineThickness: so, paintOrder: null, panose1: null, path: null, pathLength: so, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: io, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: so, pointsAtY: so, pointsAtZ: so, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: ao, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: ao, rev: ao, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: ao, requiredFeatures: ao, requiredFonts: ao, requiredFormats: ao, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: so, specularExponent: so, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: so, strikethroughThickness: so, string: null, stroke: null, strokeDashArray: ao, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: so, strokeOpacity: so, strokeWidth: null, style: null, surfaceScale: so, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: ao, tabIndex: so, tableValues: null, target: null, targetX: so, targetY: so, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: ao, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: so, underlineThickness: so, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: so, values: null, vAlphabetic: so, vMathematical: so, vectorEffect: null, vHanging: so, vIdeographic: so, version: null, vertAdvY: so, vertOriginX: so, vertOriginY: so, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: so, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: go }), _o = fo({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform: (e, t) => "xlink:" + t.slice(5).toLowerCase() }), yo = fo({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: Eo }), bo = fo({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform: (e, t) => "xml:" + t.slice(3).toLowerCase() }), So = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, ko = /[A-Z]/g, Co = /-[a-z]/g, No = /^data[-\w.:]+$/i; function Io(e, t) { const n = Ji(t); let r = t, s = Zi; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && "data" === n.slice(0, 4) && No.test(t)) { if ("-" === t.charAt(4)) { const e = t.slice(5).replace(Co, xo); r = "data" + e.charAt(0).toUpperCase() + e.slice(1) } else { const e = t.slice(4); if (!Co.test(e)) { let n = e.replace(ko, Oo); "-" !== n.charAt(0) && (n = "-" + n), t = "data" + n } } s = ho } return new s(r, t) } function Oo(e) { return "-" + e.toLowerCase() } function xo(e) { return e.charAt(1).toUpperCase() } const Ro = Xi([mo, To, _o, yo, bo], "html"), vo = Xi([mo, Ao, _o, yo, bo], "svg"); function Do(e) { const t = String(e || "").trim(); return t ? t.split(/[ \t\n\r\f]+/g) : [] } function Lo(e) { return e.join(" ").trim() } var Po = {}, wo = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Mo = /\n/g, Fo = /^\s*/, Bo = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Uo = /^:\s*/, Ho = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, jo = /^[;\s]*/, Go = /^\s+|\s+$/g, zo = ""; function Yo(e) { return e ? e.replace(Go, zo) : zo } var qo = s && s.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(Po, "__esModule", { value: !0 }), Po.default = function (e, t) { let n = null; if (!e || "string" != typeof e) return n; const r = (0, Vo.default)(e), s = "function" == typeof t; return r.forEach(e => { if ("declaration" !== e.type) return; const { property: r, value: i } = e; s ? t(r, i, e) : i && (n = n || {}, n[r] = i) }), n }; const Vo = qo(function (e, t) { if ("string" != typeof e) throw new TypeError("First argument must be a string"); if (!e) return []; t = t || {}; var n = 1, r = 1; function s(e) { var t = e.match(Mo); t && (n += t.length); var s = e.lastIndexOf("\n"); r = ~s ? e.length - s : r + e.length } function i() { var e = { line: n, column: r }; return function (t) { return t.position = new o(e), c(), t } } function o(e) { this.start = e, this.end = { line: n, column: r }, this.source = t.source } function a(s) { var i = new Error(t.source + ":" + n + ":" + r + ": " + s); if (i.reason = s, i.filename = t.source, i.line = n, i.column = r, i.source = e, !t.silent) throw i } function l(t) { var n = t.exec(e); if (n) { var r = n[0]; return s(r), e = e.slice(r.length), n } } function c() { l(Fo) } function u(e) { var t; for (e = e || []; t = h();)!1 !== t && e.push(t); return e } function h() { var t = i(); if ("/" == e.charAt(0) && "*" == e.charAt(1)) { for (var n = 2; zo != e.charAt(n) && ("*" != e.charAt(n) || "/" != e.charAt(n + 1));)++n; if (n += 2, zo === e.charAt(n - 1)) return a("End of comment missing"); var o = e.slice(2, n - 2); return r += 2, s(o), e = e.slice(n), r += 2, t({ type: "comment", comment: o }) } } function d() { var e = i(), t = l(Bo); if (t) { if (h(), !l(Uo)) return a("property missing ':'"); var n = l(Ho), r = e({ type: "declaration", property: Yo(t[0].replace(wo, zo)), value: n ? Yo(n[0].replace(wo, zo)) : zo }); return l(jo), r } } return o.prototype.content = e, c(), function () { var e, t = []; for (u(t); e = d();)!1 !== e && (t.push(e), u(t)); return t }() }); var $o = {}; Object.defineProperty($o, "__esModule", { value: !0 }), $o.camelCase = void 0; var Wo = /^--[a-zA-Z0-9_-]+$/, Ko = /-([a-z])/g, Qo = /^[^-]+$/, Xo = /^-(webkit|moz|ms|o|khtml)-/, Jo = /^-(ms)-/, Zo = function (e, t) { return t.toUpperCase() }, ea = function (e, t) { return "".concat(t, "-") }; $o.camelCase = function (e, t) { return void 0 === t && (t = {}), function (e) { return !e || Qo.test(e) || Wo.test(e) }(e) ? e : (e = e.toLowerCase(), (e = t.reactCompat ? e.replace(Jo, ea) : e.replace(Xo, ea)).replace(Ko, Zo)) }; var ta = (s && s.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } })(Po), na = $o; function ra(e, t) { var n = {}; return e && "string" == typeof e ? ((0, ta.default)(e, function (e, r) { e && r && (n[(0, na.camelCase)(e, t)] = r) }), n) : n } ra.default = ra; const sa = i(ra), ia = aa("end"), oa = aa("start"); function aa(e) { return function (t) { const n = t && t.position && t.position[e] || {}; if ("number" == typeof n.line && n.line > 0 && "number" == typeof n.column && n.column > 0) return { line: n.line, column: n.column, offset: "number" == typeof n.offset && n.offset > -1 ? n.offset : void 0 } } } function la(e) { return e && "object" == typeof e ? "position" in e || "type" in e ? ua(e.position) : "start" in e || "end" in e ? ua(e) : "line" in e || "column" in e ? ca(e) : "" : "" } function ca(e) { return ha(e && e.line) + ":" + ha(e && e.column) } function ua(e) { return ca(e && e.start) + "-" + ca(e && e.end) } function ha(e) { return e && "number" == typeof e ? e : 1 } class da extends Error { constructor(e, t, n) { super(), "string" == typeof t && (n = t, t = void 0); let r = "", s = {}, i = !1; if (t && (s = "line" in t && "column" in t || "start" in t && "end" in t ? { place: t } : "type" in t ? { ancestors: [t], place: t.position } : { ...t }), "string" == typeof e ? r = e : !s.cause && e && (i = !0, r = e.message, s.cause = e), !s.ruleId && !s.source && "string" == typeof n) { const e = n.indexOf(":"); -1 === e ? s.ruleId = n : (s.source = n.slice(0, e), s.ruleId = n.slice(e + 1)) } if (!s.place && s.ancestors && s.ancestors) { const e = s.ancestors[s.ancestors.length - 1]; e && (s.place = e.position) } const o = s.place && "start" in s.place ? s.place.start : s.place; this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file = "", this.message = r, this.line = o ? o.line : void 0, this.name = la(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = i && s.cause && "string" == typeof s.cause.stack ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0 } } da.prototype.file = "", da.prototype.name = "", da.prototype.reason = "", da.prototype.message = "", da.prototype.stack = "", da.prototype.column = void 0, da.prototype.line = void 0, da.prototype.ancestors = void 0, da.prototype.cause = void 0, da.prototype.fatal = void 0, da.prototype.place = void 0, da.prototype.ruleId = void 0, da.prototype.source = void 0; const pa = {}.hasOwnProperty, fa = new Map, ma = /[A-Z]/g, ga = new Set(["table", "tbody", "thead", "tfoot", "tr"]), Ea = new Set(["td", "th"]), Ta = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"; function Aa(e, t, n) { return "element" === t.type ? function (e, t, n) { const r = e.schema; let s = r; "svg" === t.tagName.toLowerCase() && "html" === r.space && (s = vo, e.schema = s), e.ancestors.push(t); const i = ka(e, t.tagName, !1), o = function (e, t) { const n = {}; let r, s; for (s in t.properties) if ("children" !== s && pa.call(t.properties, s)) { const i = Sa(e, s, t.properties[s]); if (i) { const [s, o] = i; e.tableCellAlignToStyle && "align" === s && "string" == typeof o && Ea.has(t.tagName) ? r = o : n[s] = o } } return r && ((n.style || (n.style = {}))["css" === e.stylePropertyNameCase ? "text-align" : "textAlign"] = r), n }(e, t); let a = ba(e, t); return ga.has(t.tagName) && (a = a.filter(function (e) { return "string" != typeof e || !("object" == typeof (t = e) ? "text" === t.type && Ki(t.value) : Ki(t)); var t })), _a(e, o, i, t), ya(o, a), e.ancestors.pop(), e.schema = r, e.create(t, i, o, n) }(e, t, n) : "mdxFlowExpression" === t.type || "mdxTextExpression" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) { const n = t.data.estree.body[0]; return n.type, e.evaluater.evaluateExpression(n.expression) } Ca(e, t.position) }(e, t) : "mdxJsxFlowElement" === t.type || "mdxJsxTextElement" === t.type ? function (e, t, n) { const r = e.schema; let s = r; "svg" === t.name && "html" === r.space && (s = vo, e.schema = s), e.ancestors.push(t); const i = null === t.name ? e.Fragment : ka(e, t.name, !0), o = function (e, t) { const n = {}; for (const r of t.attributes) if ("mdxJsxExpressionAttribute" === r.type) if (r.data && r.data.estree && e.evaluater) { const t = r.data.estree.body[0]; Hi(t.type); const s = t.expression; Hi(s.type); const i = s.properties[0]; Hi(i.type), Object.assign(n, e.evaluater.evaluateExpression(i.argument)) } else Ca(e, t.position); else { const s = r.name; let i; if (r.value && "object" == typeof r.value) if (r.value.data && r.value.data.estree && e.evaluater) { const t = r.value.data.estree.body[0]; Hi(t.type), i = e.evaluater.evaluateExpression(t.expression) } else Ca(e, t.position); else i = null === r.value || r.value; n[s] = i } return n }(e, t), a = ba(e, t); return _a(e, o, i, t), ya(o, a), e.ancestors.pop(), e.schema = r, e.create(t, i, o, n) }(e, t, n) : "mdxjsEsm" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree); Ca(e, t.position) }(e, t) : "root" === t.type ? function (e, t, n) { const r = {}; return ya(r, ba(e, t)), e.create(t, e.Fragment, r, n) }(e, t, n) : "text" === t.type ? function (e, t) { return t.value }(0, t) : void 0 } function _a(e, t, n, r) { "string" != typeof n && n !== e.Fragment && e.passNode && (t.node = r) } function ya(e, t) { if (t.length > 0) { const n = t.length > 1 ? t : t[0]; n && (e.children = n) } } function ba(e, t) { const n = []; let r = -1; const s = e.passKeys ? new Map : fa; for (; ++r < t.children.length;) { const i = t.children[r]; let o; if (e.passKeys) { const e = "element" === i.type ? i.tagName : "mdxJsxFlowElement" === i.type || "mdxJsxTextElement" === i.type ? i.name : void 0; if (e) { const t = s.get(e) || 0; o = e + "-" + t, s.set(e, t + 1) } } const a = Aa(e, i, o); void 0 !== a && n.push(a) } return n } function Sa(e, t, n) { const r = Io(e.schema, t); if (!(null == n || "number" == typeof n && Number.isNaN(n))) { if (Array.isArray(n) && (n = r.commaSeparated ? zi(n) : Lo(n)), "style" === r.property) { let t = "object" == typeof n ? n : function (e, t) { try { return sa(t, { reactCompat: !0 }) } catch (n) { if (e.ignoreInvalidStyle) return {}; const t = n, r = new da("Cannot parse `style` attribute", { ancestors: e.ancestors, cause: t, ruleId: "style", source: "hast-util-to-jsx-runtime" }); throw r.file = e.filePath || void 0, r.url = Ta + "#cannot-parse-style-attribute", r } }(e, String(n)); return "css" === e.stylePropertyNameCase && (t = function (e) { const t = {}; let n; for (n in e) pa.call(e, n) && (t[Na(n)] = e[n]); return t }(t)), ["style", t] } return ["react" === e.elementAttributeNameCase && r.space ? So[r.property] || r.property : r.attribute, n] } } function ka(e, t, n) { let r; if (n) if (t.includes(".")) { const e = t.split("."); let n, s = -1; for (; ++s < e.length;) { const t = $i(e[s]) ? { type: "Identifier", name: e[s] } : { type: "Literal", value: e[s] }; n = n ? { type: "MemberExpression", object: n, property: t, computed: Boolean(s && "Literal" === t.type), optional: !1 } : t } r = n } else r = $i(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }; else r = { type: "Literal", value: t }; if ("Literal" === r.type) { const t = r.value; return pa.call(e.components, t) ? e.components[t] : t } if (e.evaluater) return e.evaluater.evaluateExpression(r); Ca(e) } function Ca(e, t) { const n = new da("Cannot handle MDX estrees without `createEvaluater`", { ancestors: e.ancestors, place: t, ruleId: "mdx-estree", source: "hast-util-to-jsx-runtime" }); throw n.file = e.filePath || void 0, n.url = Ta + "#cannot-handle-mdx-estrees-without-createevaluater", n } function Na(e) { let t = e.replace(ma, Ia); return "ms-" === t.slice(0, 3) && (t = "-" + t), t } function Ia(e) { return "-" + e.toLowerCase() } const Oa = { action: ["form"], cite: ["blockquote", "del", "ins", "q"], data: ["object"], formAction: ["button", "input"], href: ["a", "area", "base", "link"], icon: ["menuitem"], itemId: null, manifest: ["html"], ping: ["a", "area"], poster: ["video"], src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"] }, xa = {}; function Ra(e, t) { return va(e, "boolean" != typeof xa.includeImageAlt || xa.includeImageAlt, "boolean" != typeof xa.includeHtml || xa.includeHtml) } function va(e, t, n) { if (function (e) { return Boolean(e && "object" == typeof e) }(e)) { if ("value" in e) return "html" !== e.type || n ? e.value : ""; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return Da(e.children, t, n) } return Array.isArray(e) ? Da(e, t, n) : "" } function Da(e, t, n) { const r = []; let s = -1; for (; ++s < e.length;)r[s] = va(e[s], t, n); return r.join("") } const La = document.createElement("i"); function Pa(e) { const t = "&" + e + ";"; La.innerHTML = t; const n = La.textContent; return (59 !== n.charCodeAt(n.length - 1) || "semi" === e) && n !== t && n } function wa(e, t, n, r) { const s = e.length; let i, o = 0; if (t = t < 0 ? -t > s ? 0 : s + t : t > s ? s : t, n = n > 0 ? n : 0, r.length < 1e4) i = Array.from(r), i.unshift(t, n), e.splice(...i); else for (n && e.splice(t, n); o < r.length;)i = r.slice(o, o + 1e4), i.unshift(t, 0), e.splice(...i), o += 1e4, t += 1e4 } function Ma(e, t) { return e.length > 0 ? (wa(e, e.length, 0, t), e) : t } const Fa = {}.hasOwnProperty; function Ba(e) { const t = {}; let n = -1; for (; ++n < e.length;)Ua(t, e[n]); return t } function Ua(e, t) { let n; for (n in t) { const r = (Fa.call(e, n) ? e[n] : void 0) || (e[n] = {}), s = t[n]; let i; if (s) for (i in s) { Fa.call(r, i) || (r[i] = []); const e = s[i]; Ha(r[i], Array.isArray(e) ? e : e ? [e] : []) } } } function Ha(e, t) { let n = -1; const r = []; for (; ++n < t.length;)("after" === t[n].add ? e : r).push(t[n]); wa(e, 0, 0, r) } function ja(e, t) { const n = Number.parseInt(e, t); return n < 9 || 11 === n || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || !(65535 & ~n) || 65534 == (65535 & n) || n > 1114111 ? "" : String.fromCodePoint(n) } function Ga(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const za = tl(/[A-Za-z]/), Ya = tl(/[\dA-Za-z]/), qa = tl(/[#-'*+\--9=?A-Z^-~]/); function Va(e) { return null !== e && (e < 32 || 127 === e) } const $a = tl(/\d/), Wa = tl(/[\dA-Fa-f]/), Ka = tl(/[!-/:-@[-`{-~]/); function Qa(e) { return null !== e && e < -2 } function Xa(e) { return null !== e && (e < 0 || 32 === e) } function Ja(e) { return -2 === e || -1 === e || 32 === e } const Za = tl(new RegExp("\\p{P}|\\p{S}", "u")), el = tl(/\s/); function tl(e) { return function (t) { return null !== t && t > -1 && e.test(String.fromCharCode(t)) } } function nl(e) { const t = []; let n = -1, r = 0, s = 0; for (; ++n < e.length;) { const i = e.charCodeAt(n); let o = ""; if (37 === i && Ya(e.charCodeAt(n + 1)) && Ya(e.charCodeAt(n + 2))) s = 2; else if (i < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (o = String.fromCharCode(i)); else if (i > 55295 && i < 57344) { const t = e.charCodeAt(n + 1); i < 56320 && t > 56319 && t < 57344 ? (o = String.fromCharCode(i, t), s = 1) : o = "" } else o = String.fromCharCode(i); o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + s + 1, o = ""), s && (n += s, s = 0) } return t.join("") + e.slice(r) } function rl(e, t, n, r) { const s = r ? r - 1 : Number.POSITIVE_INFINITY; let i = 0; return function (r) { return Ja(r) ? (e.enter(n), o(r)) : t(r) }; function o(r) { return Ja(r) && i++ < s ? (e.consume(r), o) : (e.exit(n), t(r)) } } const sl = { tokenize: function (e) { const t = e.attempt(this.parser.constructs.contentInitial, function (n) { if (null !== n) return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), rl(e, t, "linePrefix"); e.consume(n) }, function (t) { return e.enter("paragraph"), r(t) }); let n; return t; function r(t) { const r = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = r), n = r, s(t) } function s(t) { return null === t ? (e.exit("chunkText"), e.exit("paragraph"), void e.consume(t)) : Qa(t) ? (e.consume(t), e.exit("chunkText"), r) : (e.consume(t), s) } } }, il = { tokenize: function (e) { const t = this, n = []; let r, s, i, o = 0; return a; function a(r) { if (o < n.length) { const s = n[o]; return t.containerState = s[1], e.attempt(s[0].continuation, l, c)(r) } return c(r) } function l(e) { if (o++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, r && T(); const n = t.events.length; let s, i = n; for (; i--;)if ("exit" === t.events[i][0] && "chunkFlow" === t.events[i][1].type) { s = t.events[i][1].end; break } E(o); let a = n; for (; a < t.events.length;)t.events[a][1].end = { ...s }, a++; return wa(t.events, i + 1, 0, t.events.slice(n)), t.events.length = a, c(e) } return a(e) } function c(s) { if (o === n.length) { if (!r) return d(s); if (r.currentConstruct && r.currentConstruct.concrete) return f(s); t.interrupt = Boolean(r.currentConstruct && !r._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(ol, u, h)(s) } function u(e) { return r && T(), E(o), d(e) } function h(e) { return t.parser.lazy[t.now().line] = o !== n.length, i = t.now().offset, f(e) } function d(n) { return t.containerState = {}, e.attempt(ol, p, f)(n) } function p(e) { return o++, n.push([t.currentConstruct, t.containerState]), d(e) } function f(n) { return null === n ? (r && T(), E(0), void e.consume(n)) : (r = r || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: r, contentType: "flow", previous: s }), m(n)) } function m(n) { return null === n ? (g(e.exit("chunkFlow"), !0), E(0), void e.consume(n)) : Qa(n) ? (e.consume(n), g(e.exit("chunkFlow")), o = 0, t.interrupt = void 0, a) : (e.consume(n), m) } function g(e, n) { const a = t.sliceStream(e); if (n && a.push(null), e.previous = s, s && (s.next = e), s = e, r.defineSkip(e.start), r.write(a), t.parser.lazy[e.start.line]) { let e = r.events.length; for (; e--;)if (r.events[e][1].start.offset < i && (!r.events[e][1].end || r.events[e][1].end.offset > i)) return; const n = t.events.length; let s, a, l = n; for (; l--;)if ("exit" === t.events[l][0] && "chunkFlow" === t.events[l][1].type) { if (s) { a = t.events[l][1].end; break } s = !0 } for (E(o), e = n; e < t.events.length;)t.events[e][1].end = { ...a }, e++; wa(t.events, l + 1, 0, t.events.slice(n)), t.events.length = e } } function E(r) { let s = n.length; for (; s-- > r;) { const r = n[s]; t.containerState = r[1], r[0].exit.call(t, e) } n.length = r } function T() { r.write([null]), s = void 0, r = void 0, t.containerState._closeFlow = void 0 } } }, ol = { tokenize: function (e, t, n) { return rl(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } }; function al(e) { return null === e || Xa(e) || el(e) ? 1 : Za(e) ? 2 : void 0 } function ll(e, t, n) { const r = []; let s = -1; for (; ++s < e.length;) { const i = e[s].resolveAll; i && !r.includes(i) && (t = i(t, n), r.push(i)) } return t } const cl = { name: "attention", resolveAll: function (e, t) { let n, r, s, i, o, a, l, c, u = -1; for (; ++u < e.length;)if ("enter" === e[u][0] && "attentionSequence" === e[u][1].type && e[u][1]._close) for (n = u; n--;)if ("exit" === e[n][0] && "attentionSequence" === e[n][1].type && e[n][1]._open && t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[u][1]).charCodeAt(0)) { if ((e[n][1]._close || e[u][1]._open) && (e[u][1].end.offset - e[u][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[u][1].end.offset - e[u][1].start.offset) % 3)) continue; a = e[n][1].end.offset - e[n][1].start.offset > 1 && e[u][1].end.offset - e[u][1].start.offset > 1 ? 2 : 1; const h = { ...e[n][1].end }, d = { ...e[u][1].start }; ul(h, -a), ul(d, a), i = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: h, end: { ...e[n][1].end } }, o = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: { ...e[u][1].start }, end: d }, s = { type: a > 1 ? "strongText" : "emphasisText", start: { ...e[n][1].end }, end: { ...e[u][1].start } }, r = { type: a > 1 ? "strong" : "emphasis", start: { ...i.start }, end: { ...o.end } }, e[n][1].end = { ...i.start }, e[u][1].start = { ...o.end }, l = [], e[n][1].end.offset - e[n][1].start.offset && (l = Ma(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])), l = Ma(l, [["enter", r, t], ["enter", i, t], ["exit", i, t], ["enter", s, t]]), l = Ma(l, ll(t.parser.constructs.insideSpan.null, e.slice(n + 1, u), t)), l = Ma(l, [["exit", s, t], ["enter", o, t], ["exit", o, t], ["exit", r, t]]), e[u][1].end.offset - e[u][1].start.offset ? (c = 2, l = Ma(l, [["enter", e[u][1], t], ["exit", e[u][1], t]])) : c = 0, wa(e, n - 1, u - n + 3, l), u = n + l.length - c - 2; break } for (u = -1; ++u < e.length;)"attentionSequence" === e[u][1].type && (e[u][1].type = "data"); return e }, tokenize: function (e, t) { const n = this.parser.constructs.attentionMarkers.null, r = this.previous, s = al(r); let i; return function (t) { return i = t, e.enter("attentionSequence"), o(t) }; function o(a) { if (a === i) return e.consume(a), o; const l = e.exit("attentionSequence"), c = al(a), u = !c || 2 === c && s || n.includes(a), h = !s || 2 === s && c || n.includes(r); return l._open = Boolean(42 === i ? u : u && (s || !h)), l._close = Boolean(42 === i ? h : h && (c || !u)), t(a) } } }; function ul(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const hl = { name: "autolink", tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(t), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s }; function s(t) { return za(t) ? (e.consume(t), i) : 64 === t ? n(t) : l(t) } function i(e) { return 43 === e || 45 === e || 46 === e || Ya(e) ? (r = 1, o(e)) : l(e) } function o(t) { return 58 === t ? (e.consume(t), r = 0, a) : (43 === t || 45 === t || 46 === t || Ya(t)) && r++ < 32 ? (e.consume(t), o) : (r = 0, l(t)) } function a(r) { return 62 === r ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(r), e.exit("autolinkMarker"), e.exit("autolink"), t) : null === r || 32 === r || 60 === r || Va(r) ? n(r) : (e.consume(r), a) } function l(t) { return 64 === t ? (e.consume(t), c) : qa(t) ? (e.consume(t), l) : n(t) } function c(e) { return Ya(e) ? u(e) : n(e) } function u(n) { return 46 === n ? (e.consume(n), r = 0, c) : 62 === n ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(n), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(n) } function h(t) { if ((45 === t || Ya(t)) && r++ < 63) { const n = 45 === t ? h : u; return e.consume(t), n } return n(t) } } }, dl = { partial: !0, tokenize: function (e, t, n) { return function (t) { return Ja(t) ? rl(e, r, "linePrefix")(t) : r(t) }; function r(e) { return null === e || Qa(e) ? t(e) : n(e) } } }, pl = { continuation: { tokenize: function (e, t, n) { const r = this; return function (t) { return Ja(t) ? rl(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : s(t) }; function s(r) { return e.attempt(pl, t, n)(r) } } }, exit: function (e) { e.exit("blockQuote") }, name: "blockQuote", tokenize: function (e, t, n) { const r = this; return function (t) { if (62 === t) { const n = r.containerState; return n.open || (e.enter("blockQuote", { _container: !0 }), n.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(t), e.exit("blockQuoteMarker"), s } return n(t) }; function s(n) { return Ja(n) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(n), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(n)) } } }, fl = { name: "characterEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(t), e.exit("escapeMarker"), r }; function r(r) { return Ka(r) ? (e.enter("characterEscapeValue"), e.consume(r), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(r) } } }, ml = { name: "characterReference", tokenize: function (e, t, n) { const r = this; let s, i, o = 0; return function (t) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(t), e.exit("characterReferenceMarker"), a }; function a(t) { return 35 === t ? (e.enter("characterReferenceMarkerNumeric"), e.consume(t), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), s = 31, i = Ya, c(t)) } function l(t) { return 88 === t || 120 === t ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(t), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, i = Wa, c) : (e.enter("characterReferenceValue"), s = 7, i = $a, c(t)) } function c(a) { if (59 === a && o) { const s = e.exit("characterReferenceValue"); return i !== Ya || Pa(r.sliceSerialize(s)) ? (e.enter("characterReferenceMarker"), e.consume(a), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) : n(a) } return i(a) && o++ < s ? (e.consume(a), c) : n(a) } } }, gl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return null === t ? n(t) : (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) }; function s(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, El = { concrete: !0, name: "codeFenced", tokenize: function (e, t, n) { const r = this, s = { partial: !0, tokenize: function (e, t, n) { let s = 0; return function (t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), o }; function o(t) { return e.enter("codeFencedFence"), Ja(t) ? rl(e, l, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : l(t) } function l(t) { return t === i ? (e.enter("codeFencedFenceSequence"), c(t)) : n(t) } function c(t) { return t === i ? (s++, e.consume(t), c) : s >= a ? (e.exit("codeFencedFenceSequence"), Ja(t) ? rl(e, u, "whitespace")(t) : u(t)) : n(t) } function u(r) { return null === r || Qa(r) ? (e.exit("codeFencedFence"), t(r)) : n(r) } } }; let i, o = 0, a = 0; return function (t) { return function (t) { const n = r.events[r.events.length - 1]; return o = n && "linePrefix" === n[1].type ? n[2].sliceSerialize(n[1], !0).length : 0, i = t, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), l(t) }(t) }; function l(t) { return t === i ? (a++, e.consume(t), l) : a < 3 ? n(t) : (e.exit("codeFencedFenceSequence"), Ja(t) ? rl(e, c, "whitespace")(t) : c(t)) } function c(n) { return null === n || Qa(n) ? (e.exit("codeFencedFence"), r.interrupt ? t(n) : e.check(gl, p, T)(n)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), u(n)) } function u(t) { return null === t || Qa(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), c(t)) : Ja(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), rl(e, h, "whitespace")(t)) : 96 === t && t === i ? n(t) : (e.consume(t), u) } function h(t) { return null === t || Qa(t) ? c(t) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), d(t)) } function d(t) { return null === t || Qa(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), c(t)) : 96 === t && t === i ? n(t) : (e.consume(t), d) } function p(t) { return e.attempt(s, T, f)(t) } function f(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), m } function m(t) { return o > 0 && Ja(t) ? rl(e, g, "linePrefix", o + 1)(t) : g(t) } function g(t) { return null === t || Qa(t) ? e.check(gl, p, T)(t) : (e.enter("codeFlowValue"), E(t)) } function E(t) { return null === t || Qa(t) ? (e.exit("codeFlowValue"), g(t)) : (e.consume(t), E) } function T(n) { return e.exit("codeFenced"), t(n) } } }, Tl = { name: "codeIndented", tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("codeIndented"), rl(e, s, "linePrefix", 5)(t) }; function s(e) { const t = r.events[r.events.length - 1]; return t && "linePrefix" === t[1].type && t[2].sliceSerialize(t[1], !0).length >= 4 ? i(e) : n(e) } function i(t) { return null === t ? a(t) : Qa(t) ? e.attempt(Al, i, a)(t) : (e.enter("codeFlowValue"), o(t)) } function o(t) { return null === t || Qa(t) ? (e.exit("codeFlowValue"), i(t)) : (e.consume(t), o) } function a(n) { return e.exit("codeIndented"), t(n) } } }, Al = { partial: !0, tokenize: function (e, t, n) { const r = this; return s; function s(t) { return r.parser.lazy[r.now().line] ? n(t) : Qa(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : rl(e, i, "linePrefix", 5)(t) } function i(e) { const i = r.events[r.events.length - 1]; return i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(e) : Qa(e) ? s(e) : n(e) } } }, _l = { name: "codeText", previous: function (e) { return 96 !== e || "characterEscape" === this.events[this.events.length - 1][1].type }, resolve: function (e) { let t, n, r = e.length - 4, s = 3; if (!("lineEnding" !== e[s][1].type && "space" !== e[s][1].type || "lineEnding" !== e[r][1].type && "space" !== e[r][1].type)) for (t = s; ++t < r;)if ("codeTextData" === e[t][1].type) { e[s][1].type = "codeTextPadding", e[r][1].type = "codeTextPadding", s += 2, r -= 2; break } for (t = s - 1, r++; ++t <= r;)void 0 === n ? t !== r && "lineEnding" !== e[t][1].type && (n = t) : t !== r && "lineEnding" !== e[t][1].type || (e[n][1].type = "codeTextData", t !== n + 2 && (e[n][1].end = e[t - 1][1].end, e.splice(n + 2, t - n - 2), r -= t - n - 2, t = n + 2), n = void 0); return e }, tokenize: function (e, t, n) { let r, s, i = 0; return function (t) { return e.enter("codeText"), e.enter("codeTextSequence"), o(t) }; function o(t) { return 96 === t ? (e.consume(t), i++, o) : (e.exit("codeTextSequence"), a(t)) } function a(t) { return null === t ? n(t) : 32 === t ? (e.enter("space"), e.consume(t), e.exit("space"), a) : 96 === t ? (s = e.enter("codeTextSequence"), r = 0, c(t)) : Qa(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), a) : (e.enter("codeTextData"), l(t)) } function l(t) { return null === t || 32 === t || 96 === t || Qa(t) ? (e.exit("codeTextData"), a(t)) : (e.consume(t), l) } function c(n) { return 96 === n ? (e.consume(n), r++, c) : r === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(n)) : (s.type = "codeTextData", l(n)) } } }; class yl { constructor(e) { this.left = e ? [...e] : [], this.right = [] } get(e) { if (e < 0 || e >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(e, t) { const n = null == t ? Number.POSITIVE_INFINITY : t; return n < this.left.length ? this.left.slice(e, n) : e > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse()) } splice(e, t, n) { const r = t || 0; this.setCursor(Math.trunc(e)); const s = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY); return n && bl(this.left, n), s.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(e) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e) } pushMany(e) { this.setCursor(Number.POSITIVE_INFINITY), bl(this.left, e) } unshift(e) { this.setCursor(0), this.right.push(e) } unshiftMany(e) { this.setCursor(0), bl(this.right, e.reverse()) } setCursor(e) { if (!(e === this.left.length || e > this.left.length && 0 === this.right.length || e < 0 && 0 === this.left.length)) if (e < this.left.length) { const t = this.left.splice(e, Number.POSITIVE_INFINITY); bl(this.right, t.reverse()) } else { const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY); bl(this.left, t.reverse()) } } } function bl(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function Sl(e) { const t = {}; let n, r, s, i, o, a, l, c = -1; const u = new yl(e); for (; ++c < u.length;) { for (; c in t;)c = t[c]; if (n = u.get(c), c && "chunkFlow" === n[1].type && "listItemPrefix" === u.get(c - 1)[1].type && (a = n[1]._tokenizer.events, s = 0, s < a.length && "lineEndingBlank" === a[s][1].type && (s += 2), s < a.length && "content" === a[s][1].type)) for (; ++s < a.length && "content" !== a[s][1].type;)"chunkText" === a[s][1].type && (a[s][1]._isInFirstContentOfListItem = !0, s++); if ("enter" === n[0]) n[1].contentType && (Object.assign(t, kl(u, c)), c = t[c], l = !0); else if (n[1]._container) { for (s = c, r = void 0; s--;)if (i = u.get(s), "lineEnding" === i[1].type || "lineEndingBlank" === i[1].type) "enter" === i[0] && (r && (u.get(r)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", r = s); else if ("linePrefix" !== i[1].type && "listItemIndent" !== i[1].type) break; r && (n[1].end = { ...u.get(r)[1].start }, o = u.slice(r, c), o.unshift(n), u.splice(r, c - r + 1, o)) } } return wa(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !l } function kl(e, t) { const n = e.get(t)[1], r = e.get(t)[2]; let s = t - 1; const i = []; let o = n._tokenizer; o || (o = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0)); const a = o.events, l = [], c = {}; let u, h, d = -1, p = n, f = 0, m = 0; const g = [m]; for (; p;) { for (; e.get(++s)[1] !== p;); i.push(s), p._tokenizer || (u = r.sliceStream(p), p.next || u.push(null), h && o.defineSkip(p.start), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = p, p = p.next } for (p = n; ++d < a.length;)"exit" === a[d][0] && "enter" === a[d - 1][0] && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (m = d + 1, g.push(m), p._tokenizer = void 0, p.previous = void 0, p = p.next); for (o.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : g.pop(), d = g.length; d--;) { const t = a.slice(g[d], g[d + 1]), n = i.pop(); l.push([n, n + t.length - 1]), e.splice(n, 2, t) } for (l.reverse(), d = -1; ++d < l.length;)c[f + l[d][0]] = f + l[d][1], f += l[d][1] - l[d][0] - 1; return c } const Cl = { resolve: function (e) { return Sl(e), e }, tokenize: function (e, t) { let n; return function (t) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), r(t) }; function r(t) { return null === t ? s(t) : Qa(t) ? e.check(Nl, i, s)(t) : (e.consume(t), r) } function s(n) { return e.exit("chunkContent"), e.exit("content"), t(n) } function i(t) { return e.consume(t), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, r } } }, Nl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), rl(e, s, "linePrefix") }; function s(s) { if (null === s || Qa(s)) return n(s); const i = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s) } } }; function Il(e, t, n, r, s, i, o, a, l) { const c = l || Number.POSITIVE_INFINITY; let u = 0; return function (t) { return 60 === t ? (e.enter(r), e.enter(s), e.enter(i), e.consume(t), e.exit(i), h) : null === t || 32 === t || 41 === t || Va(t) ? n(t) : (e.enter(r), e.enter(o), e.enter(a), e.enter("chunkString", { contentType: "string" }), f(t)) }; function h(n) { return 62 === n ? (e.enter(i), e.consume(n), e.exit(i), e.exit(s), e.exit(r), t) : (e.enter(a), e.enter("chunkString", { contentType: "string" }), d(n)) } function d(t) { return 62 === t ? (e.exit("chunkString"), e.exit(a), h(t)) : null === t || 60 === t || Qa(t) ? n(t) : (e.consume(t), 92 === t ? p : d) } function p(t) { return 60 === t || 62 === t || 92 === t ? (e.consume(t), d) : d(t) } function f(s) { return u || null !== s && 41 !== s && !Xa(s) ? u < c && 40 === s ? (e.consume(s), u++, f) : 41 === s ? (e.consume(s), u--, f) : null === s || 32 === s || 40 === s || Va(s) ? n(s) : (e.consume(s), 92 === s ? m : f) : (e.exit("chunkString"), e.exit(a), e.exit(o), e.exit(r), t(s)) } function m(t) { return 40 === t || 41 === t || 92 === t ? (e.consume(t), f) : f(t) } } function Ol(e, t, n, r, s, i) { const o = this; let a, l = 0; return function (t) { return e.enter(r), e.enter(s), e.consume(t), e.exit(s), e.enter(i), c }; function c(h) { return l > 999 || null === h || 91 === h || 93 === h && !a || 94 === h && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? n(h) : 93 === h ? (e.exit(i), e.enter(s), e.consume(h), e.exit(s), e.exit(r), t) : Qa(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("chunkString", { contentType: "string" }), u(h)) } function u(t) { return null === t || 91 === t || 93 === t || Qa(t) || l++ > 999 ? (e.exit("chunkString"), c(t)) : (e.consume(t), a || (a = !Ja(t)), 92 === t ? h : u) } function h(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), l++, u) : u(t) } } function xl(e, t, n, r, s, i) { let o; return function (t) { return 34 === t || 39 === t || 40 === t ? (e.enter(r), e.enter(s), e.consume(t), e.exit(s), o = 40 === t ? 41 : t, a) : n(t) }; function a(n) { return n === o ? (e.enter(s), e.consume(n), e.exit(s), e.exit(r), t) : (e.enter(i), l(n)) } function l(t) { return t === o ? (e.exit(i), a(o)) : null === t ? n(t) : Qa(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), rl(e, l, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), c(t)) } function c(t) { return t === o || null === t || Qa(t) ? (e.exit("chunkString"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return t === o || 92 === t ? (e.consume(t), c) : c(t) } } function Rl(e, t) { let n; return function r(s) { return Qa(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), n = !0, r) : Ja(s) ? rl(e, r, n ? "linePrefix" : "lineSuffix")(s) : t(s) } } const vl = { name: "definition", tokenize: function (e, t, n) { const r = this; let s; return function (t) { return e.enter("definition"), function (t) { return Ol.call(r, e, i, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t) }(t) }; function i(t) { return s = Ga(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), o) : n(t) } function o(t) { return Xa(t) ? Rl(e, a)(t) : a(t) } function a(t) { return Il(e, l, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(t) } function l(t) { return e.attempt(Dl, c, c)(t) } function c(t) { return Ja(t) ? rl(e, u, "whitespace")(t) : u(t) } function u(i) { return null === i || Qa(i) ? (e.exit("definition"), r.parser.defined.push(s), t(i)) : n(i) } } }, Dl = { partial: !0, tokenize: function (e, t, n) { return function (t) { return Xa(t) ? Rl(e, r)(t) : n(t) }; function r(t) { return xl(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t) } function s(t) { return Ja(t) ? rl(e, i, "whitespace")(t) : i(t) } function i(e) { return null === e || Qa(e) ? t(e) : n(e) } } }, Ll = { name: "hardBreakEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("hardBreakEscape"), e.consume(t), r }; function r(r) { return Qa(r) ? (e.exit("hardBreakEscape"), t(r)) : n(r) } } }, Pl = { name: "headingAtx", resolve: function (e, t) { let n, r, s = e.length - 2, i = 3; return "whitespace" === e[i][1].type && (i += 2), s - 2 > i && "whitespace" === e[s][1].type && (s -= 2), "atxHeadingSequence" === e[s][1].type && (i === s - 1 || s - 4 > i && "whitespace" === e[s - 2][1].type) && (s -= i + 1 === s ? 2 : 4), s > i && (n = { type: "atxHeadingText", start: e[i][1].start, end: e[s][1].end }, r = { type: "chunkText", start: e[i][1].start, end: e[s][1].end, contentType: "text" }, wa(e, i, s - i + 1, [["enter", n, t], ["enter", r, t], ["exit", r, t], ["exit", n, t]])), e }, tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("atxHeading"), function (t) { return e.enter("atxHeadingSequence"), s(t) }(t) }; function s(t) { return 35 === t && r++ < 6 ? (e.consume(t), s) : null === t || Xa(t) ? (e.exit("atxHeadingSequence"), i(t)) : n(t) } function i(n) { return 35 === n ? (e.enter("atxHeadingSequence"), o(n)) : null === n || Qa(n) ? (e.exit("atxHeading"), t(n)) : Ja(n) ? rl(e, i, "whitespace")(n) : (e.enter("atxHeadingText"), a(n)) } function o(t) { return 35 === t ? (e.consume(t), o) : (e.exit("atxHeadingSequence"), i(t)) } function a(t) { return null === t || 35 === t || Xa(t) ? (e.exit("atxHeadingText"), i(t)) : (e.consume(t), a) } } }, wl = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Ml = ["pre", "script", "style", "textarea"], Fl = { concrete: !0, name: "htmlFlow", resolveTo: function (e) { let t = e.length; for (; t-- && ("enter" !== e[t][0] || "htmlFlow" !== e[t][1].type);); return t > 1 && "linePrefix" === e[t - 2][1].type && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e }, tokenize: function (e, t, n) { const r = this; let s, i, o, a, l; return function (t) { return function (t) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(t), c }(t) }; function c(a) { return 33 === a ? (e.consume(a), u) : 47 === a ? (e.consume(a), i = !0, p) : 63 === a ? (e.consume(a), s = 3, r.interrupt ? t : P) : za(a) ? (e.consume(a), o = String.fromCharCode(a), f) : n(a) } function u(i) { return 45 === i ? (e.consume(i), s = 2, h) : 91 === i ? (e.consume(i), s = 5, a = 0, d) : za(i) ? (e.consume(i), s = 4, r.interrupt ? t : P) : n(i) } function h(s) { return 45 === s ? (e.consume(s), r.interrupt ? t : P) : n(s) } function d(s) { return s === "CDATA[".charCodeAt(a++) ? (e.consume(s), 6 === a ? r.interrupt ? t : N : d) : n(s) } function p(t) { return za(t) ? (e.consume(t), o = String.fromCharCode(t), f) : n(t) } function f(a) { if (null === a || 47 === a || 62 === a || Xa(a)) { const l = 47 === a, c = o.toLowerCase(); return l || i || !Ml.includes(c) ? wl.includes(o.toLowerCase()) ? (s = 6, l ? (e.consume(a), m) : r.interrupt ? t(a) : N(a)) : (s = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(a) : i ? g(a) : E(a)) : (s = 1, r.interrupt ? t(a) : N(a)) } return 45 === a || Ya(a) ? (e.consume(a), o += String.fromCharCode(a), f) : n(a) } function m(s) { return 62 === s ? (e.consume(s), r.interrupt ? t : N) : n(s) } function g(t) { return Ja(t) ? (e.consume(t), g) : k(t) } function E(t) { return 47 === t ? (e.consume(t), k) : 58 === t || 95 === t || za(t) ? (e.consume(t), T) : Ja(t) ? (e.consume(t), E) : k(t) } function T(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Ya(t) ? (e.consume(t), T) : A(t) } function A(t) { return 61 === t ? (e.consume(t), _) : Ja(t) ? (e.consume(t), A) : E(t) } function _(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), l = t, y) : Ja(t) ? (e.consume(t), _) : b(t) } function y(t) { return t === l ? (e.consume(t), l = null, S) : null === t || Qa(t) ? n(t) : (e.consume(t), y) } function b(t) { return null === t || 34 === t || 39 === t || 47 === t || 60 === t || 61 === t || 62 === t || 96 === t || Xa(t) ? A(t) : (e.consume(t), b) } function S(e) { return 47 === e || 62 === e || Ja(e) ? E(e) : n(e) } function k(t) { return 62 === t ? (e.consume(t), C) : n(t) } function C(t) { return null === t || Qa(t) ? N(t) : Ja(t) ? (e.consume(t), C) : n(t) } function N(t) { return 45 === t && 2 === s ? (e.consume(t), R) : 60 === t && 1 === s ? (e.consume(t), v) : 62 === t && 4 === s ? (e.consume(t), w) : 63 === t && 3 === s ? (e.consume(t), P) : 93 === t && 5 === s ? (e.consume(t), L) : !Qa(t) || 6 !== s && 7 !== s ? null === t || Qa(t) ? (e.exit("htmlFlowData"), I(t)) : (e.consume(t), N) : (e.exit("htmlFlowData"), e.check(Bl, M, I)(t)) } function I(t) { return e.check(Ul, O, M)(t) } function O(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), x } function x(t) { return null === t || Qa(t) ? I(t) : (e.enter("htmlFlowData"), N(t)) } function R(t) { return 45 === t ? (e.consume(t), P) : N(t) } function v(t) { return 47 === t ? (e.consume(t), o = "", D) : N(t) } function D(t) { if (62 === t) { const n = o.toLowerCase(); return Ml.includes(n) ? (e.consume(t), w) : N(t) } return za(t) && o.length < 8 ? (e.consume(t), o += String.fromCharCode(t), D) : N(t) } function L(t) { return 93 === t ? (e.consume(t), P) : N(t) } function P(t) { return 62 === t ? (e.consume(t), w) : 45 === t && 2 === s ? (e.consume(t), P) : N(t) } function w(t) { return null === t || Qa(t) ? (e.exit("htmlFlowData"), M(t)) : (e.consume(t), w) } function M(n) { return e.exit("htmlFlow"), t(n) } } }, Bl = { partial: !0, tokenize: function (e, t, n) { return function (r) { return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), e.attempt(dl, t, n) } } }, Ul = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return Qa(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : n(t) }; function s(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, Hl = { name: "htmlText", tokenize: function (e, t, n) { const r = this; let s, i, o; return function (t) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(t), a }; function a(t) { return 33 === t ? (e.consume(t), l) : 47 === t ? (e.consume(t), _) : 63 === t ? (e.consume(t), T) : za(t) ? (e.consume(t), S) : n(t) } function l(t) { return 45 === t ? (e.consume(t), c) : 91 === t ? (e.consume(t), i = 0, p) : za(t) ? (e.consume(t), E) : n(t) } function c(t) { return 45 === t ? (e.consume(t), d) : n(t) } function u(t) { return null === t ? n(t) : 45 === t ? (e.consume(t), h) : Qa(t) ? (o = u, D(t)) : (e.consume(t), u) } function h(t) { return 45 === t ? (e.consume(t), d) : u(t) } function d(e) { return 62 === e ? v(e) : 45 === e ? h(e) : u(e) } function p(t) { return t === "CDATA[".charCodeAt(i++) ? (e.consume(t), 6 === i ? f : p) : n(t) } function f(t) { return null === t ? n(t) : 93 === t ? (e.consume(t), m) : Qa(t) ? (o = f, D(t)) : (e.consume(t), f) } function m(t) { return 93 === t ? (e.consume(t), g) : f(t) } function g(t) { return 62 === t ? v(t) : 93 === t ? (e.consume(t), g) : f(t) } function E(t) { return null === t || 62 === t ? v(t) : Qa(t) ? (o = E, D(t)) : (e.consume(t), E) } function T(t) { return null === t ? n(t) : 63 === t ? (e.consume(t), A) : Qa(t) ? (o = T, D(t)) : (e.consume(t), T) } function A(e) { return 62 === e ? v(e) : T(e) } function _(t) { return za(t) ? (e.consume(t), y) : n(t) } function y(t) { return 45 === t || Ya(t) ? (e.consume(t), y) : b(t) } function b(t) { return Qa(t) ? (o = b, D(t)) : Ja(t) ? (e.consume(t), b) : v(t) } function S(t) { return 45 === t || Ya(t) ? (e.consume(t), S) : 47 === t || 62 === t || Xa(t) ? k(t) : n(t) } function k(t) { return 47 === t ? (e.consume(t), v) : 58 === t || 95 === t || za(t) ? (e.consume(t), C) : Qa(t) ? (o = k, D(t)) : Ja(t) ? (e.consume(t), k) : v(t) } function C(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Ya(t) ? (e.consume(t), C) : N(t) } function N(t) { return 61 === t ? (e.consume(t), I) : Qa(t) ? (o = N, D(t)) : Ja(t) ? (e.consume(t), N) : k(t) } function I(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), s = t, O) : Qa(t) ? (o = I, D(t)) : Ja(t) ? (e.consume(t), I) : (e.consume(t), x) } function O(t) { return t === s ? (e.consume(t), s = void 0, R) : null === t ? n(t) : Qa(t) ? (o = O, D(t)) : (e.consume(t), O) } function x(t) { return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 96 === t ? n(t) : 47 === t || 62 === t || Xa(t) ? k(t) : (e.consume(t), x) } function R(e) { return 47 === e || 62 === e || Xa(e) ? k(e) : n(e) } function v(r) { return 62 === r ? (e.consume(r), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(r) } function D(t) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), L } function L(t) { return Ja(t) ? rl(e, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : P(t) } function P(t) { return e.enter("htmlTextData"), o(t) } } }, jl = { name: "labelEnd", resolveAll: function (e) { let t = -1; const n = []; for (; ++t < e.length;) { const r = e[t][1]; if (n.push(e[t]), "labelImage" === r.type || "labelLink" === r.type || "labelEnd" === r.type) { const e = "labelImage" === r.type ? 4 : 2; r.type = "data", t += e } } return e.length !== n.length && wa(e, 0, e.length, n), e }, resolveTo: function (e, t) { let n, r, s, i, o = e.length, a = 0; for (; o--;)if (n = e[o][1], r) { if ("link" === n.type || "labelLink" === n.type && n._inactive) break; "enter" === e[o][0] && "labelLink" === n.type && (n._inactive = !0) } else if (s) { if ("enter" === e[o][0] && ("labelImage" === n.type || "labelLink" === n.type) && !n._balanced && (r = o, "labelLink" !== n.type)) { a = 2; break } } else "labelEnd" === n.type && (s = o); const l = { type: "labelLink" === e[r][1].type ? "link" : "image", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }, c = { type: "label", start: { ...e[r][1].start }, end: { ...e[s][1].end } }, u = { type: "labelText", start: { ...e[r + a + 2][1].end }, end: { ...e[s - 2][1].start } }; return i = [["enter", l, t], ["enter", c, t]], i = Ma(i, e.slice(r + 1, r + a + 3)), i = Ma(i, [["enter", u, t]]), i = Ma(i, ll(t.parser.constructs.insideSpan.null, e.slice(r + a + 4, s - 3), t)), i = Ma(i, [["exit", u, t], e[s - 2], e[s - 1], ["exit", c, t]]), i = Ma(i, e.slice(s + 1)), i = Ma(i, [["exit", l, t]]), wa(e, r, e.length, i), e }, tokenize: function (e, t, n) { const r = this; let s, i, o = r.events.length; for (; o--;)if (("labelImage" === r.events[o][1].type || "labelLink" === r.events[o][1].type) && !r.events[o][1]._balanced) { s = r.events[o][1]; break } return function (t) { return s ? s._inactive ? u(t) : (i = r.parser.defined.includes(Ga(r.sliceSerialize({ start: s.end, end: r.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelEnd"), a) : n(t) }; function a(t) { return 40 === t ? e.attempt(Gl, c, i ? c : u)(t) : 91 === t ? e.attempt(zl, c, i ? l : u)(t) : i ? c(t) : u(t) } function l(t) { return e.attempt(Yl, c, u)(t) } function c(e) { return t(e) } function u(e) { return s._balanced = !0, n(e) } } }, Gl = { tokenize: function (e, t, n) { return function (t) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(t), e.exit("resourceMarker"), r }; function r(t) { return Xa(t) ? Rl(e, s)(t) : s(t) } function s(t) { return 41 === t ? c(t) : Il(e, i, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(t) } function i(t) { return Xa(t) ? Rl(e, a)(t) : c(t) } function o(e) { return n(e) } function a(t) { return 34 === t || 39 === t || 40 === t ? xl(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t) : c(t) } function l(t) { return Xa(t) ? Rl(e, c)(t) : c(t) } function c(r) { return 41 === r ? (e.enter("resourceMarker"), e.consume(r), e.exit("resourceMarker"), e.exit("resource"), t) : n(r) } } }, zl = { tokenize: function (e, t, n) { const r = this; return function (t) { return Ol.call(r, e, s, i, "reference", "referenceMarker", "referenceString")(t) }; function s(e) { return r.parser.defined.includes(Ga(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(e) : n(e) } function i(e) { return n(e) } } }, Yl = { tokenize: function (e, t, n) { return function (t) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(t), e.exit("referenceMarker"), r }; function r(r) { return 93 === r ? (e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), e.exit("reference"), t) : n(r) } } }, ql = { name: "labelStartImage", resolveAll: jl.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(t), e.exit("labelImageMarker"), s }; function s(t) { return 91 === t ? (e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelImage"), i) : n(t) } function i(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }, Vl = { name: "labelStartLink", resolveAll: jl.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelLink"), s }; function s(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }, $l = { name: "lineEnding", tokenize: function (e, t) { return function (n) { return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), rl(e, t, "linePrefix") } } }, Wl = { name: "thematicBreak", tokenize: function (e, t, n) { let r, s = 0; return function (t) { return e.enter("thematicBreak"), function (e) { return r = e, i(e) }(t) }; function i(i) { return i === r ? (e.enter("thematicBreakSequence"), o(i)) : s >= 3 && (null === i || Qa(i)) ? (e.exit("thematicBreak"), t(i)) : n(i) } function o(t) { return t === r ? (e.consume(t), s++, o) : (e.exit("thematicBreakSequence"), Ja(t) ? rl(e, i, "whitespace")(t) : i(t)) } } }, Kl = { continuation: { tokenize: function (e, t, n) { const r = this; return r.containerState._closeFlow = void 0, e.check(dl, function (n) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, rl(e, t, "listItemIndent", r.containerState.size + 1)(n) }, function (n) { return r.containerState.furtherBlankLines || !Ja(n) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(n)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(Xl, t, s)(n)) }); function s(s) { return r.containerState._closeFlow = !0, r.interrupt = void 0, rl(e, e.attempt(Kl, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) } } }, exit: function (e) { e.exit(this.containerState.type) }, name: "list", tokenize: function (e, t, n) { const r = this, s = r.events[r.events.length - 1]; let i = s && "linePrefix" === s[1].type ? s[2].sliceSerialize(s[1], !0).length : 0, o = 0; return function (t) { const s = r.containerState.type || (42 === t || 43 === t || 45 === t ? "listUnordered" : "listOrdered"); if ("listUnordered" === s ? !r.containerState.marker || t === r.containerState.marker : $a(t)) { if (r.containerState.type || (r.containerState.type = s, e.enter(s, { _container: !0 })), "listUnordered" === s) return e.enter("listItemPrefix"), 42 === t || 45 === t ? e.check(Wl, n, l)(t) : l(t); if (!r.interrupt || 49 === t) return e.enter("listItemPrefix"), e.enter("listItemValue"), a(t) } return n(t) }; function a(t) { return $a(t) && ++o < 10 ? (e.consume(t), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? t === r.containerState.marker : 41 === t || 46 === t) ? (e.exit("listItemValue"), l(t)) : n(t) } function l(t) { return e.enter("listItemMarker"), e.consume(t), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || t, e.check(dl, r.interrupt ? n : c, e.attempt(Ql, h, u)) } function c(e) { return r.containerState.initialBlankLine = !0, i++, h(e) } function u(t) { return Ja(t) ? (e.enter("listItemPrefixWhitespace"), e.consume(t), e.exit("listItemPrefixWhitespace"), h) : n(t) } function h(n) { return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(n) } } }, Ql = { partial: !0, tokenize: function (e, t, n) { const r = this; return rl(e, function (e) { const s = r.events[r.events.length - 1]; return !Ja(e) && s && "listItemPrefixWhitespace" === s[1].type ? t(e) : n(e) }, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5) } }, Xl = { partial: !0, tokenize: function (e, t, n) { const r = this; return rl(e, function (e) { const s = r.events[r.events.length - 1]; return s && "listItemIndent" === s[1].type && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(e) : n(e) }, "listItemIndent", r.containerState.size + 1) } }, Jl = { name: "setextUnderline", resolveTo: function (e, t) { let n, r, s, i = e.length; for (; i--;)if ("enter" === e[i][0]) { if ("content" === e[i][1].type) { n = i; break } "paragraph" === e[i][1].type && (r = i) } else "content" === e[i][1].type && e.splice(i, 1), s || "definition" !== e[i][1].type || (s = i); const o = { type: "setextHeading", start: { ...e[n][1].start }, end: { ...e[e.length - 1][1].end } }; return e[r][1].type = "setextHeadingText", s ? (e.splice(r, 0, ["enter", o, t]), e.splice(s + 1, 0, ["exit", e[n][1], t]), e[n][1].end = { ...e[s][1].end }) : e[n][1] = o, e.push(["exit", o, t]), e }, tokenize: function (e, t, n) { const r = this; let s; return function (t) { let o, a = r.events.length; for (; a--;)if ("lineEnding" !== r.events[a][1].type && "linePrefix" !== r.events[a][1].type && "content" !== r.events[a][1].type) { o = "paragraph" === r.events[a][1].type; break } return r.parser.lazy[r.now().line] || !r.interrupt && !o ? n(t) : (e.enter("setextHeadingLine"), s = t, function (t) { return e.enter("setextHeadingLineSequence"), i(t) }(t)) }; function i(t) { return t === s ? (e.consume(t), i) : (e.exit("setextHeadingLineSequence"), Ja(t) ? rl(e, o, "lineSuffix")(t) : o(t)) } function o(r) { return null === r || Qa(r) ? (e.exit("setextHeadingLine"), t(r)) : n(r) } } }, Zl = { tokenize: function (e) { const t = this, n = e.attempt(dl, function (r) { if (null !== r) return e.enter("lineEndingBlank"), e.consume(r), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n; e.consume(r) }, e.attempt(this.parser.constructs.flowInitial, r, rl(e, e.attempt(this.parser.constructs.flow, r, e.attempt(Cl, r)), "linePrefix"))); return n; function r(r) { if (null !== r) return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), t.currentConstruct = void 0, n; e.consume(r) } } }, ec = { resolveAll: sc() }, tc = rc("string"), nc = rc("text"); function rc(e) { return { resolveAll: sc("text" === e ? ic : void 0), tokenize: function (t) { const n = this, r = this.parser.constructs[e], s = t.attempt(r, i, o); return i; function i(e) { return l(e) ? s(e) : o(e) } function o(e) { if (null !== e) return t.enter("data"), t.consume(e), a; t.consume(e) } function a(e) { return l(e) ? (t.exit("data"), s(e)) : (t.consume(e), a) } function l(e) { if (null === e) return !0; const t = r[e]; let s = -1; if (t) for (; ++s < t.length;) { const e = t[s]; if (!e.previous || e.previous.call(n, n.previous)) return !0 } return !1 } } } } function sc(e) { return function (t, n) { let r, s = -1; for (; ++s <= t.length;)void 0 === r ? t[s] && "data" === t[s][1].type && (r = s, s++) : t[s] && "data" === t[s][1].type || (s !== r + 2 && (t[r][1].end = t[s - 1][1].end, t.splice(r + 2, s - r - 2), s = r + 2), r = void 0); return e ? e(t, n) : t } } function ic(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || "lineEnding" === e[n][1].type) && "data" === e[n - 1][1].type) { const r = e[n - 1][1], s = t.sliceStream(r); let i, o = s.length, a = -1, l = 0; for (; o--;) { const e = s[o]; if ("string" == typeof e) { for (a = e.length; 32 === e.charCodeAt(a - 1);)l++, a--; if (a) break; a = -1 } else if (-2 === e) i = !0, l++; else if (-1 !== e) { o++; break } } if (t._contentTypeTextTrailing && n === e.length && (l = 0), l) { const s = { type: n === e.length || i || l < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: o ? a : r.start._bufferIndex + a, _index: r.start._index + o, line: r.end.line, column: r.end.column - l, offset: r.end.offset - l }, end: { ...r.end } }; r.end = { ...s.start }, r.start.offset === r.end.offset ? Object.assign(r, s) : (e.splice(n, 0, ["enter", s, t], ["exit", s, t]), n += 2) } n++ } return e } const oc = { 42: Kl, 43: Kl, 45: Kl, 48: Kl, 49: Kl, 50: Kl, 51: Kl, 52: Kl, 53: Kl, 54: Kl, 55: Kl, 56: Kl, 57: Kl, 62: pl }, ac = { 91: vl }, lc = { [-2]: Tl, [-1]: Tl, 32: Tl }, cc = { 35: Pl, 42: Wl, 45: [Jl, Wl], 60: Fl, 61: Jl, 95: Wl, 96: El, 126: El }, uc = { 38: ml, 92: fl }, hc = { [-5]: $l, [-4]: $l, [-3]: $l, 33: ql, 38: ml, 42: cl, 60: [hl, Hl], 91: Vl, 92: [Ll, fl], 93: jl, 95: cl, 96: _l }, dc = { null: [cl, ec] }, pc = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: { null: [42, 95] }, contentInitial: ac, disable: { null: [] }, document: oc, flow: cc, flowInitial: lc, insideSpan: dc, string: uc, text: hc }, Symbol.toStringTag, { value: "Module" })); function fc(e, t, n) { let r = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const s = {}, i = []; let o = [], a = []; const l = { attempt: m(function (e, t) { g(e, t.from) }), check: m(f), consume: function (e) { Qa(e) ? (r.line++, r.column = 1, r.offset += -3 === e ? 2 : 1, E()) : -1 !== e && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = e }, enter: function (e, t) { const n = t || {}; return n.type = e, n.start = d(), c.events.push(["enter", n, c]), a.push(n), n }, exit: function (e) { const t = a.pop(); return t.end = d(), c.events.push(["exit", t, c]), t }, interrupt: m(f, { interrupt: !0 }) }, c = { code: null, containerState: {}, defineSkip: function (e) { s[e.line] = e.column, E() }, events: [], now: d, parser: e, previous: null, sliceSerialize: function (e, t) { return function (e, t) { let n = -1; const r = []; let s; for (; ++n < e.length;) { const i = e[n]; let o; if ("string" == typeof i) o = i; else switch (i) { case -5: o = "\r"; break; case -4: o = "\n"; break; case -3: o = "\r\n"; break; case -2: o = t ? " " : "\t"; break; case -1: if (!t && s) continue; o = " "; break; default: o = String.fromCharCode(i) }s = -2 === i, r.push(o) } return r.join("") }(h(e), t) }, sliceStream: h, write: function (e) { return o = Ma(o, e), function () { let e; for (; r._index < o.length;) { const t = o[r._index]; if ("string" == typeof t) for (e = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === e && r._bufferIndex < t.length;)p(t.charCodeAt(r._bufferIndex)); else p(t) } }(), null !== o[o.length - 1] ? [] : (g(t, 0), c.events = ll(i, c.events, c), c.events) } }; let u = t.tokenize.call(c, l); return t.resolveAll && i.push(t), c; function h(e) { return function (e, t) { const n = t.start._index, r = t.start._bufferIndex, s = t.end._index, i = t.end._bufferIndex; let o; if (n === s) o = [e[n].slice(r, i)]; else { if (o = e.slice(n, s), r > -1) { const e = o[0]; "string" == typeof e ? o[0] = e.slice(r) : o.shift() } i > 0 && o.push(e[s].slice(0, i)) } return o }(o, e) } function d() { const { _bufferIndex: e, _index: t, line: n, column: s, offset: i } = r; return { _bufferIndex: e, _index: t, line: n, column: s, offset: i } } function p(e) { u = u(e) } function f(e, t) { t.restore() } function m(e, t) { return function (n, s, i) { let o, u, h, p; return Array.isArray(n) ? m(n) : "tokenize" in n ? m([n]) : (f = n, function (e) { const t = null !== e && f[e], n = null !== e && f.null; return m([...Array.isArray(t) ? t : t ? [t] : [], ...Array.isArray(n) ? n : n ? [n] : []])(e) }); var f; function m(e) { return o = e, u = 0, 0 === e.length ? i : g(e[u]) } function g(e) { return function (n) { return p = function () { const e = d(), t = c.previous, n = c.currentConstruct, s = c.events.length, i = Array.from(a); return { from: s, restore: function () { r = e, c.previous = t, c.currentConstruct = n, c.events.length = s, a = i, E() } } }(), h = e, e.partial || (c.currentConstruct = e), e.name && c.parser.constructs.disable.null.includes(e.name) ? A() : e.tokenize.call(t ? Object.assign(Object.create(c), t) : c, l, T, A)(n) } } function T(t) { return e(h, p), s } function A(e) { return p.restore(), ++u < o.length ? g(o[u]) : i } } } function g(e, t) { e.resolveAll && !i.includes(e) && i.push(e), e.resolve && wa(c.events, t, c.events.length - t, e.resolve(c.events.slice(t), c)), e.resolveTo && (c.events = e.resolveTo(c.events, c)) } function E() { r.line in s && r.column < 2 && (r.column = s[r.line], r.offset += s[r.line] - 1) } } const mc = /[\0\t\n\r]/g, gc = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function Ec(e, t, n) { if (t) return t; if (35 === n.charCodeAt(0)) { const e = n.charCodeAt(1), t = 120 === e || 88 === e; return ja(n.slice(t ? 2 : 1), t ? 16 : 10) } return Pa(n) || e } const Tc = {}.hasOwnProperty; function Ac(e, t, n) { return "string" != typeof t && (n = t, t = void 0), function (e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: s(T), autolinkProtocol: u, autolinkEmail: u, atxHeading: s(m), blockQuote: s(function () { return { type: "blockquote", children: [] } }), characterEscape: u, characterReference: u, codeFenced: s(f), codeFencedFenceInfo: i, codeFencedFenceMeta: i, codeIndented: s(f, i), codeText: s(function () { return { type: "inlineCode", value: "" } }, i), codeTextData: u, data: u, codeFlowValue: u, definition: s(function () { return { type: "definition", identifier: "", label: null, title: null, url: "" } }), definitionDestinationString: i, definitionLabelString: i, definitionTitleString: i, emphasis: s(function () { return { type: "emphasis", children: [] } }), hardBreakEscape: s(g), hardBreakTrailing: s(g), htmlFlow: s(E, i), htmlFlowData: u, htmlText: s(E, i), htmlTextData: u, image: s(function () { return { type: "image", title: null, url: "", alt: null } }), label: i, link: s(T), listItem: s(function (e) { return { type: "listItem", spread: e._spread, checked: null, children: [] } }), listItemValue: function (e) { this.data.expectingFirstListItemValue && (this.stack[this.stack.length - 2].start = Number.parseInt(this.sliceSerialize(e), 10), this.data.expectingFirstListItemValue = void 0) }, listOrdered: s(A, function () { this.data.expectingFirstListItemValue = !0 }), listUnordered: s(A), paragraph: s(function () { return { type: "paragraph", children: [] } }), reference: function () { this.data.referenceType = "collapsed" }, referenceString: i, resourceDestinationString: i, resourceTitleString: i, setextHeading: s(m), strong: s(function () { return { type: "strong", children: [] } }), thematicBreak: s(function () { return { type: "thematicBreak" } }) }, exit: { atxHeading: a(), atxHeadingSequence: function (e) { const t = this.stack[this.stack.length - 1]; if (!t.depth) { const n = this.sliceSerialize(e).length; t.depth = n } }, autolink: a(), autolinkEmail: function (e) { h.call(this, e), this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(e) }, autolinkProtocol: function (e) { h.call(this, e), this.stack[this.stack.length - 1].url = this.sliceSerialize(e) }, blockQuote: a(), characterEscapeValue: h, characterReferenceMarkerHexadecimal: p, characterReferenceMarkerNumeric: p, characterReferenceValue: function (e) { const t = this.sliceSerialize(e), n = this.data.characterReferenceType; let r; n ? (r = ja(t, "characterReferenceMarkerNumeric" === n ? 10 : 16), this.data.characterReferenceType = void 0) : r = Pa(t); this.stack[this.stack.length - 1].value += r }, characterReference: function (e) { this.stack.pop().position.end = _c(e.end) }, codeFenced: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 }), codeFencedFence: function () { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) }, codeFencedFenceInfo: function () { const e = this.resume(); this.stack[this.stack.length - 1].lang = e }, codeFencedFenceMeta: function () { const e = this.resume(); this.stack[this.stack.length - 1].meta = e }, codeFlowValue: h, codeIndented: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/(\r?\n|\r)$/g, "") }), codeText: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), codeTextData: h, data: h, definition: a(), definitionDestinationString: function () { const e = this.resume(); this.stack[this.stack.length - 1].url = e }, definitionLabelString: function (e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = Ga(this.sliceSerialize(e)).toLowerCase() }, definitionTitleString: function () { const e = this.resume(); this.stack[this.stack.length - 1].title = e }, emphasis: a(), hardBreakEscape: a(d), hardBreakTrailing: a(d), htmlFlow: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), htmlFlowData: h, htmlText: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), htmlTextData: h, image: a(function () { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 }), label: function () { const e = this.stack[this.stack.length - 1], t = this.resume(), n = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, "link" === n.type) { const t = e.children; n.children = t } else n.alt = t }, labelText: function (e) { const t = this.sliceSerialize(e), n = this.stack[this.stack.length - 2]; n.label = function (e) { return e.replace(gc, Ec) }(t), n.identifier = Ga(t).toLowerCase() }, lineEnding: function (e) { const n = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) return n.children[n.children.length - 1].position.end = _c(e.end), void (this.data.atHardBreak = void 0); !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(n.type) && (u.call(this, e), h.call(this, e)) }, link: a(function () { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 }), listItem: a(), listOrdered: a(), listUnordered: a(), paragraph: a(), referenceString: function (e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = Ga(this.sliceSerialize(e)).toLowerCase(), this.data.referenceType = "full" }, resourceDestinationString: function () { const e = this.resume(); this.stack[this.stack.length - 1].url = e }, resourceTitleString: function () { const e = this.resume(); this.stack[this.stack.length - 1].title = e }, resource: function () { this.data.inReference = void 0 }, setextHeading: a(function () { this.data.setextHeadingSlurpLineEnding = void 0 }), setextHeadingLineSequence: function (e) { this.stack[this.stack.length - 1].depth = 61 === this.sliceSerialize(e).codePointAt(0) ? 1 : 2 }, setextHeadingText: function () { this.data.setextHeadingSlurpLineEnding = !0 }, strong: a(), thematicBreak: a() } }; yc(t, (e || {}).mdastExtensions || []); const n = {}; return function (e) { let s = { type: "root", children: [] }; const a = { stack: [s], tokenStack: [], config: t, enter: o, exit: l, buffer: i, resume: c, data: n }, u = []; let h = -1; for (; ++h < e.length;)"listOrdered" !== e[h][1].type && "listUnordered" !== e[h][1].type || ("enter" === e[h][0] ? u.push(h) : h = r(e, u.pop(), h)); for (h = -1; ++h < e.length;) { const n = t[e[h][0]]; Tc.call(n, e[h][1].type) && n[e[h][1].type].call(Object.assign({ sliceSerialize: e[h][2].sliceSerialize }, a), e[h][1]) } if (a.tokenStack.length > 0) { const e = a.tokenStack[a.tokenStack.length - 1]; (e[1] || Sc).call(a, void 0, e[0]) } for (s.position = { start: _c(e.length > 0 ? e[0][1].start : { line: 1, column: 1, offset: 0 }), end: _c(e.length > 0 ? e[e.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, h = -1; ++h < t.transforms.length;)s = t.transforms[h](s) || s; return s }; function r(e, t, n) { let r, s, i, o, a = t - 1, l = -1, c = !1; for (; ++a <= n;) { const t = e[a]; switch (t[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": "enter" === t[0] ? l++ : l--, o = void 0; break; case "lineEndingBlank": "enter" === t[0] && (!r || o || l || i || (i = a), o = void 0); break; case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: o = void 0 }if (!l && "enter" === t[0] && "listItemPrefix" === t[1].type || -1 === l && "exit" === t[0] && ("listUnordered" === t[1].type || "listOrdered" === t[1].type)) { if (r) { let o = a; for (s = void 0; o--;) { const t = e[o]; if ("lineEnding" === t[1].type || "lineEndingBlank" === t[1].type) { if ("exit" === t[0]) continue; s && (e[s][1].type = "lineEndingBlank", c = !0), t[1].type = "lineEnding", s = o } else if ("linePrefix" !== t[1].type && "blockQuotePrefix" !== t[1].type && "blockQuotePrefixWhitespace" !== t[1].type && "blockQuoteMarker" !== t[1].type && "listItemIndent" !== t[1].type) break } i && (!s || i < s) && (r._spread = !0), r.end = Object.assign({}, s ? e[s][1].start : t[1].end), e.splice(s || a, 0, ["exit", r, t[2]]), a++, n++ } if ("listItemPrefix" === t[1].type) { const s = { type: "listItem", _spread: !1, start: Object.assign({}, t[1].start), end: void 0 }; r = s, e.splice(a, 0, ["enter", s, t[2]]), a++, n++, i = void 0, o = !0 } } } return e[t][1]._spread = c, n } function s(e, t) { return function (n) { o.call(this, e(n), n), t && t.call(this, n) } } function i() { this.stack.push({ type: "fragment", children: [] }) } function o(e, t, n) { this.stack[this.stack.length - 1].children.push(e), this.stack.push(e), this.tokenStack.push([t, n || void 0]), e.position = { start: _c(t.start), end: void 0 } } function a(e) { return function (t) { e && e.call(this, t), l.call(this, t) } } function l(e, t) { const n = this.stack.pop(), r = this.tokenStack.pop(); if (!r) throw new Error("Cannot close `" + e.type + "` (" + la({ start: e.start, end: e.end }) + "): its not open"); r[0].type !== e.type && (t ? t.call(this, e, r[0]) : (r[1] || Sc).call(this, e, r[0])), n.position.end = _c(e.end) } function c() { return Ra(this.stack.pop()) } function u(e) { const t = this.stack[this.stack.length - 1].children; let n = t[t.length - 1]; n && "text" === n.type || (n = { type: "text", value: "" }, n.position = { start: _c(e.start), end: void 0 }, t.push(n)), this.stack.push(n) } function h(e) { const t = this.stack.pop(); t.value += this.sliceSerialize(e), t.position.end = _c(e.end) } function d() { this.data.atHardBreak = !0 } function p(e) { this.data.characterReferenceType = e.type } function f() { return { type: "code", lang: null, meta: null, value: "" } } function m() { return { type: "heading", depth: 0, children: [] } } function g() { return { type: "break" } } function E() { return { type: "html", value: "" } } function T() { return { type: "link", title: null, url: "", children: [] } } function A(e) { return { type: "list", ordered: "listOrdered" === e.type, start: null, spread: e._spread, children: [] } } }(n)(function (e) { for (; !Sl(e);); return e }(function (e) { const t = { constructs: Ba([pc, ...(e || {}).extensions || []]), content: n(sl), defined: [], document: n(il), flow: n(Zl), lazy: {}, string: n(tc), text: n(nc) }; return t; function n(e) { return function (n) { return fc(t, e, n) } } }(n).document().write(function () { let e, t = 1, n = "", r = !0; return function (s, i, o) { const a = []; let l, c, u, h, d; for (s = n + ("string" == typeof s ? s.toString() : new TextDecoder(i || void 0).decode(s)), u = 0, n = "", r && (65279 === s.charCodeAt(0) && u++, r = void 0); u < s.length;) { if (mc.lastIndex = u, l = mc.exec(s), h = l && void 0 !== l.index ? l.index : s.length, d = s.charCodeAt(h), !l) { n = s.slice(u); break } if (10 === d && u === h && e) a.push(-3), e = void 0; else switch (e && (a.push(-5), e = void 0), u < h && (a.push(s.slice(u, h)), t += h - u), d) { case 0: a.push(65533), t++; break; case 9: for (c = 4 * Math.ceil(t / 4), a.push(-2); t++ < c;)a.push(-1); break; case 10: a.push(-4), t = 1; break; default: e = !0, t = 1 }u = h + 1 } return o && (e && a.push(-5), n && a.push(n), a.push(null)), a } }()(e, t, !0)))) } function _c(e) { return { line: e.line, column: e.column, offset: e.offset } } function yc(e, t) { let n = -1; for (; ++n < t.length;) { const r = t[n]; Array.isArray(r) ? yc(e, r) : bc(e, r) } } function bc(e, t) { let n; for (n in t) if (Tc.call(t, n)) switch (n) { case "canContainEols": { const r = t[n]; r && e[n].push(...r); break } case "transforms": { const r = t[n]; r && e[n].push(...r); break } case "enter": case "exit": { const r = t[n]; r && Object.assign(e[n], r); break } } } function Sc(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + la({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + la({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + la({ start: t.start, end: t.end }) + ") is still open") } function kc(e) { const t = this; t.parser = function (n) { return Ac(n, { ...t.data("settings"), ...e, extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] }) } } function Cc(e, t) { const n = t.referenceType; let r = "]"; if ("collapsed" === n ? r += "[]" : "full" === n && (r += "[" + (t.label || t.identifier) + "]"), "imageReference" === t.type) return [{ type: "text", value: "![" + t.alt + r }]; const s = e.all(t), i = s[0]; i && "text" === i.type ? i.value = "[" + i.value : s.unshift({ type: "text", value: "[" }); const o = s[s.length - 1]; return o && "text" === o.type ? o.value += r : s.push({ type: "text", value: r }), s } function Nc(e) { const t = e.spread; return null == t ? e.children.length > 1 : t } function Ic(e) { const t = String(e), n = /\r?\n|\r/g; let r = n.exec(t), s = 0; const i = []; for (; r;)i.push(Oc(t.slice(s, r.index), s > 0, !0), r[0]), s = r.index + r[0].length, r = n.exec(t); return i.push(Oc(t.slice(s), s > 0, !1)), i.join("") } function Oc(e, t, n) { let r = 0, s = e.length; if (t) { let t = e.codePointAt(r); for (; 9 === t || 32 === t;)r++, t = e.codePointAt(r) } if (n) { let t = e.codePointAt(s - 1); for (; 9 === t || 32 === t;)s--, t = e.codePointAt(s - 1) } return s > r ? e.slice(r, s) : "" } const xc = { blockquote: function (e, t) { const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }; return e.patch(t, n), e.applyData(t, n) }, break: function (e, t) { const n = { type: "element", tagName: "br", properties: {}, children: [] }; return e.patch(t, n), [e.applyData(t, n), { type: "text", value: "\n" }] }, code: function (e, t) { const n = t.value ? t.value + "\n" : "", r = {}, s = t.lang ? t.lang.split(/\s+/) : []; s.length > 0 && (r.className = ["language-" + s[0]]); let i = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }; return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i }, delete: function (e, t) { const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, emphasis: function (e, t) { const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, footnoteReference: function (e, t) { const n = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), s = nl(r.toLowerCase()), i = e.footnoteOrder.indexOf(r); let o, a = e.footnoteCounts.get(r); void 0 === a ? (a = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = i + 1, a += 1, e.footnoteCounts.set(r, a); const l = { type: "element", tagName: "a", properties: { href: "#" + n + "fn-" + s, id: n + "fnref-" + s + (a > 1 ? "-" + a : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(o) }] }; e.patch(t, l); const c = { type: "element", tagName: "sup", properties: {}, children: [l] }; return e.patch(t, c), e.applyData(t, c) }, heading: function (e, t) { const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, html: function (e, t) { if (e.options.allowDangerousHtml) { const n = { type: "raw", value: t.value }; return e.patch(t, n), e.applyData(t, n) } }, imageReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Cc(e, t); const s = { src: nl(r.url || ""), alt: t.alt }; null !== r.title && void 0 !== r.title && (s.title = r.title); const i = { type: "element", tagName: "img", properties: s, children: [] }; return e.patch(t, i), e.applyData(t, i) }, image: function (e, t) { const n = { src: nl(t.url) }; null !== t.alt && void 0 !== t.alt && (n.alt = t.alt), null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "img", properties: n, children: [] }; return e.patch(t, r), e.applyData(t, r) }, inlineCode: function (e, t) { const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }; e.patch(t, n); const r = { type: "element", tagName: "code", properties: {}, children: [n] }; return e.patch(t, r), e.applyData(t, r) }, linkReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Cc(e, t); const s = { href: nl(r.url || "") }; null !== r.title && void 0 !== r.title && (s.title = r.title); const i = { type: "element", tagName: "a", properties: s, children: e.all(t) }; return e.patch(t, i), e.applyData(t, i) }, link: function (e, t) { const n = { href: nl(t.url) }; null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) }, listItem: function (e, t, n) { const r = e.all(t), s = n ? function (e) { let t = !1; if ("list" === e.type) { t = e.spread || !1; const n = e.children; let r = -1; for (; !t && ++r < n.length;)t = Nc(n[r]) } return t }(n) : Nc(t), i = {}, o = []; if ("boolean" == typeof t.checked) { const e = r[0]; let n; e && "element" === e.type && "p" === e.tagName ? n = e : (n = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(n)), n.children.length > 0 && n.children.unshift({ type: "text", value: " " }), n.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: t.checked, disabled: !0 }, children: [] }), i.className = ["task-list-item"] } let a = -1; for (; ++a < r.length;) { const e = r[a]; (s || 0 !== a || "element" !== e.type || "p" !== e.tagName) && o.push({ type: "text", value: "\n" }), "element" !== e.type || "p" !== e.tagName || s ? o.push(e) : o.push(...e.children) } const l = r[r.length - 1]; l && (s || "element" !== l.type || "p" !== l.tagName) && o.push({ type: "text", value: "\n" }); const c = { type: "element", tagName: "li", properties: i, children: o }; return e.patch(t, c), e.applyData(t, c) }, list: function (e, t) { const n = {}, r = e.all(t); let s = -1; for ("number" == typeof t.start && 1 !== t.start && (n.start = t.start); ++s < r.length;) { const e = r[s]; if ("element" === e.type && "li" === e.tagName && e.properties && Array.isArray(e.properties.className) && e.properties.className.includes("task-list-item")) { n.className = ["contains-task-list"]; break } } const i = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }; return e.patch(t, i), e.applyData(t, i) }, paragraph: function (e, t) { const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, root: function (e, t) { const n = { type: "root", children: e.wrap(e.all(t)) }; return e.patch(t, n), e.applyData(t, n) }, strong: function (e, t) { const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, table: function (e, t) { const n = e.all(t), r = n.shift(), s = []; if (r) { const n = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }; e.patch(t.children[0], n), s.push(n) } if (n.length > 0) { const r = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) }, i = oa(t.children[1]), o = ia(t.children[t.children.length - 1]); i && o && (r.position = { start: i, end: o }), s.push(r) } const i = { type: "element", tagName: "table", properties: {}, children: e.wrap(s, !0) }; return e.patch(t, i), e.applyData(t, i) }, tableCell: function (e, t) { const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, tableRow: function (e, t, n) { const r = n ? n.children : void 0, s = 0 === (r ? r.indexOf(t) : 1) ? "th" : "td", i = n && "table" === n.type ? n.align : void 0, o = i ? i.length : t.children.length; let a = -1; const l = []; for (; ++a < o;) { const n = t.children[a], r = {}, o = i ? i[a] : void 0; o && (r.align = o); let c = { type: "element", tagName: s, properties: r, children: [] }; n && (c.children = e.all(n), e.patch(n, c), c = e.applyData(n, c)), l.push(c) } const c = { type: "element", tagName: "tr", properties: {}, children: e.wrap(l, !0) }; return e.patch(t, c), e.applyData(t, c) }, text: function (e, t) { const n = { type: "text", value: Ic(String(t.value)) }; return e.patch(t, n), e.applyData(t, n) }, thematicBreak: function (e, t) { const n = { type: "element", tagName: "hr", properties: {}, children: [] }; return e.patch(t, n), e.applyData(t, n) }, toml: Rc, yaml: Rc, definition: Rc, footnoteDefinition: Rc }; function Rc() { } const vc = "object" == typeof self ? self : globalThis, Dc = e => ((e, t) => { const n = (t, n) => (e.set(n, t), t), r = s => { if (e.has(s)) return e.get(s); const [i, o] = t[s]; switch (i) { case 0: case -1: return n(o, s); case 1: { const e = n([], s); for (const t of o) e.push(r(t)); return e } case 2: { const e = n({}, s); for (const [t, n] of o) e[r(t)] = r(n); return e } case 3: return n(new Date(o), s); case 4: { const { source: e, flags: t } = o; return n(new RegExp(e, t), s) } case 5: { const e = n(new Map, s); for (const [t, n] of o) e.set(r(t), r(n)); return e } case 6: { const e = n(new Set, s); for (const t of o) e.add(r(t)); return e } case 7: { const { name: e, message: t } = o; return n(new vc[e](t), s) } case 8: return n(BigInt(o), s); case "BigInt": return n(Object(BigInt(o)), s); case "ArrayBuffer": return n(new Uint8Array(o).buffer, o); case "DataView": { const { buffer: e } = new Uint8Array(o); return n(new DataView(e), o) } }return n(new vc[i](o), s) }; return r })(new Map, e)(0), Lc = "", { toString: Pc } = {}, { keys: wc } = Object, Mc = e => { const t = typeof e; if ("object" !== t || !e) return [0, t]; const n = Pc.call(e).slice(8, -1); switch (n) { case "Array": return [1, Lc]; case "Object": return [2, Lc]; case "Date": return [3, Lc]; case "RegExp": return [4, Lc]; case "Map": return [5, Lc]; case "Set": return [6, Lc]; case "DataView": return [1, n] }return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n] }, Fc = ([e, t]) => 0 === e && ("function" === t || "symbol" === t), Bc = (e, { json: t, lossy: n } = {}) => { const r = []; return ((e, t, n, r) => { const s = (e, t) => { const s = r.push(e) - 1; return n.set(t, s), s }, i = r => { if (n.has(r)) return n.get(r); let [o, a] = Mc(r); switch (o) { case 0: { let t = r; switch (a) { case "bigint": o = 8, t = r.toString(); break; case "function": case "symbol": if (e) throw new TypeError("unable to serialize " + a); t = null; break; case "undefined": return s([-1], r) }return s([o, t], r) } case 1: { if (a) { let e = r; return "DataView" === a ? e = new Uint8Array(r.buffer) : "ArrayBuffer" === a && (e = new Uint8Array(r)), s([a, [...e]], r) } const e = [], t = s([o, e], r); for (const n of r) e.push(i(n)); return t } case 2: { if (a) switch (a) { case "BigInt": return s([a, r.toString()], r); case "Boolean": case "Number": case "String": return s([a, r.valueOf()], r) }if (t && "toJSON" in r) return i(r.toJSON()); const n = [], l = s([o, n], r); for (const t of wc(r)) !e && Fc(Mc(r[t])) || n.push([i(t), i(r[t])]); return l } case 3: return s([o, r.toISOString()], r); case 4: { const { source: e, flags: t } = r; return s([o, { source: e, flags: t }], r) } case 5: { const t = [], n = s([o, t], r); for (const [s, o] of r) (e || !Fc(Mc(s)) && !Fc(Mc(o))) && t.push([i(s), i(o)]); return n } case 6: { const t = [], n = s([o, t], r); for (const s of r) !e && Fc(Mc(s)) || t.push(i(s)); return n } }const { message: l } = r; return s([o, { name: a, message: l }], r) }; return i })(!(t || n), !!t, new Map, r)(e), r }, Uc = "function" == typeof structuredClone ? (e, t) => t && ("json" in t || "lossy" in t) ? Dc(Bc(e, t)) : structuredClone(e) : (e, t) => Dc(Bc(e, t)); function Hc(e, t) { const n = [{ type: "text", value: "" }]; return t > 1 && n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }), n } function jc(e, t) { return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "") } const Gc = function (e) { if (null == e) return Yc; if ("function" == typeof e) return zc(e); if ("object" == typeof e) return Array.isArray(e) ? function (e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = Gc(e[n]); return zc(function (...e) { let n = -1; for (; ++n < t.length;)if (t[n].apply(this, e)) return !0; return !1 }) }(e) : function (e) { const t = e; return zc(function (n) { const r = n; let s; for (s in e) if (r[s] !== t[s]) return !1; return !0 }) }(e); if ("string" == typeof e) return t = e, zc(function (e) { return e && e.type === t }); var t; throw new Error("Expected function, string, or object as test") }; function zc(e) { return function (t, n, r) { return Boolean(function (e) { return null !== e && "object" == typeof e && "type" in e }(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0)) } } function Yc() { return !0 } const qc = [], Vc = !1; function $c(e, t, n, r) { let s; "function" == typeof t && "function" != typeof n ? (r = n, n = t) : s = t; const i = Gc(s), o = r ? -1 : 1; !function e(s, a, l) { const c = s && "object" == typeof s ? s : {}; if ("string" == typeof c.type) { const e = "string" == typeof c.tagName ? c.tagName : "string" == typeof c.name ? c.name : void 0; Object.defineProperty(u, "name", { value: "node (" + s.type + (e ? "<" + e + ">" : "") + ")" }) } return u; function u() { let c, u, h, d = qc; if ((!t || i(s, a, l[l.length - 1] || void 0)) && (d = function (e) { return Array.isArray(e) ? e : "number" == typeof e ? [true, e] : null == e ? qc : [e] }(n(s, l)), d[0] === Vc)) return d; if ("children" in s && s.children) { const t = s; if (t.children && "skip" !== d[0]) for (u = (r ? t.children.length : -1) + o, h = l.concat(t); u > -1 && u < t.children.length;) { const n = t.children[u]; if (c = e(n, u, h)(), c[0] === Vc) return c; u = "number" == typeof c[1] ? c[1] : u + o } } return d } }(e, void 0, [])() } function Wc(e, t, n, r) { let s, i, o; "function" == typeof t && "function" != typeof n ? (i = void 0, o = t, s = n) : (i = t, o = n, s = r), $c(e, i, function (e, t) { const n = t[t.length - 1], r = n ? n.children.indexOf(e) : void 0; return o(e, r, n) }, s) } const Kc = {}.hasOwnProperty, Qc = {}; function Xc(e, t) { e.position && (t.position = function (e) { const t = oa(e), n = ia(e); if (t && n) return { start: t, end: n } }(e)) } function Jc(e, t) { let n = t; if (e && e.data) { const t = e.data.hName, r = e.data.hChildren, s = e.data.hProperties; "string" == typeof t && ("element" === n.type ? n.tagName = t : n = { type: "element", tagName: t, properties: {}, children: "children" in n ? n.children : [n] }), "element" === n.type && s && Object.assign(n.properties, Uc(s)), "children" in n && n.children && null != r && (n.children = r) } return n } function Zc(e, t) { const n = t.data || {}, r = !("value" in t) || Kc.call(n, "hProperties") || Kc.call(n, "hChildren") ? { type: "element", tagName: "div", properties: {}, children: e.all(t) } : { type: "text", value: t.value }; return e.patch(t, r), e.applyData(t, r) } function eu(e, t) { const n = []; let r = -1; for (t && n.push({ type: "text", value: "\n" }); ++r < e.length;)r && n.push({ type: "text", value: "\n" }), n.push(e[r]); return t && e.length > 0 && n.push({ type: "text", value: "\n" }), n } function tu(e) { let t = 0, n = e.charCodeAt(t); for (; 9 === n || 32 === n;)t++, n = e.charCodeAt(t); return e.slice(t) } function nu(e, t) { const n = function (e, t) { const n = t || Qc, r = new Map, s = new Map, i = new Map, o = { ...xc, ...n.handlers }, a = { all: function (e) { const t = []; if ("children" in e) { const n = e.children; let r = -1; for (; ++r < n.length;) { const s = a.one(n[r], e); if (s) { if (r && "break" === n[r - 1].type && (Array.isArray(s) || "text" !== s.type || (s.value = tu(s.value)), !Array.isArray(s) && "element" === s.type)) { const e = s.children[0]; e && "text" === e.type && (e.value = tu(e.value)) } Array.isArray(s) ? t.push(...s) : t.push(s) } } } return t }, applyData: Jc, definitionById: r, footnoteById: s, footnoteCounts: i, footnoteOrder: [], handlers: o, one: function (e, t) { const n = e.type, r = a.handlers[n]; if (Kc.call(a.handlers, n) && r) return r(a, e, t); if (a.options.passThrough && a.options.passThrough.includes(n)) { if ("children" in e) { const { children: t, ...n } = e, r = Uc(n); return r.children = a.all(e), r } return Uc(e) } return (a.options.unknownHandler || Zc)(a, e, t) }, options: n, patch: Xc, wrap: eu }; return Wc(e, function (e) { if ("definition" === e.type || "footnoteDefinition" === e.type) { const t = "definition" === e.type ? r : s, n = String(e.identifier).toUpperCase(); t.has(n) || t.set(n, e) } }), a }(e, t), r = n.one(e, void 0), s = function (e) { const t = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || Hc, r = e.options.footnoteBackLabel || jc, s = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || { className: ["sr-only"] }, a = []; let l = -1; for (; ++l < e.footnoteOrder.length;) { const s = e.footnoteById.get(e.footnoteOrder[l]); if (!s) continue; const i = e.all(s), o = String(s.identifier).toUpperCase(), c = nl(o.toLowerCase()); let u = 0; const h = [], d = e.footnoteCounts.get(o); for (; void 0 !== d && ++u <= d;) { h.length > 0 && h.push({ type: "text", value: " " }); let e = "string" == typeof n ? n : n(l, u); "string" == typeof e && (e = { type: "text", value: e }), h.push({ type: "element", tagName: "a", properties: { href: "#" + t + "fnref-" + c + (u > 1 ? "-" + u : ""), dataFootnoteBackref: "", ariaLabel: "string" == typeof r ? r : r(l, u), className: ["data-footnote-backref"] }, children: Array.isArray(e) ? e : [e] }) } const p = i[i.length - 1]; if (p && "element" === p.type && "p" === p.tagName) { const e = p.children[p.children.length - 1]; e && "text" === e.type ? e.value += " " : p.children.push({ type: "text", value: " " }), p.children.push(...h) } else i.push(...h); const f = { type: "element", tagName: "li", properties: { id: t + "fn-" + c }, children: e.wrap(i, !0) }; e.patch(s, f), a.push(f) } if (0 !== a.length) return { type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: i, properties: { ...Uc(o), id: "footnote-label" }, children: [{ type: "text", value: s }] }, { type: "text", value: "\n" }, { type: "element", tagName: "ol", properties: {}, children: e.wrap(a, !0) }, { type: "text", value: "\n" }] } }(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }; return s && i.children.push({ type: "text", value: "\n" }, s), i } function ru(e, t) { return e && "run" in e ? async function (n, r) { const s = nu(n, { file: r, ...t }); await e.run(s, r) } : function (n, r) { return nu(n, { file: r, ...e || t }) } } function su(e) { if (e) throw e } var iu = Object.prototype.hasOwnProperty, ou = Object.prototype.toString, au = Object.defineProperty, lu = Object.getOwnPropertyDescriptor, cu = function (e) { return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === ou.call(e) }, uu = function (e) { if (!e || "[object Object]" !== ou.call(e)) return !1; var t, n = iu.call(e, "constructor"), r = e.constructor && e.constructor.prototype && iu.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !n && !r) return !1; for (t in e); return void 0 === t || iu.call(e, t) }, hu = function (e, t) { au && "__proto__" === t.name ? au(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 }) : e[t.name] = t.newValue }, du = function (e, t) { if ("__proto__" === t) { if (!iu.call(e, t)) return; if (lu) return lu(e, t).value } return e[t] }; const pu = i(function e() { var t, n, r, s, i, o, a = arguments[0], l = 1, c = arguments.length, u = !1; for ("boolean" == typeof a && (u = a, a = arguments[1] || {}, l = 2), (null == a || "object" != typeof a && "function" != typeof a) && (a = {}); l < c; ++l)if (null != (t = arguments[l])) for (n in t) r = du(a, n), a !== (s = du(t, n)) && (u && s && (uu(s) || (i = cu(s))) ? (i ? (i = !1, o = r && cu(r) ? r : []) : o = r && uu(r) ? r : {}, hu(a, { name: n, newValue: e(u, o, s) })) : void 0 !== s && hu(a, { name: n, newValue: s })); return a }); function fu(e) { if ("object" != typeof e || null === e) return !1; const t = Object.getPrototypeOf(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) } const mu = function (e, t) { if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string'); _u(e); let n, r = 0, s = -1, i = e.length; if (void 0 === t || 0 === t.length || t.length > e.length) { for (; i--;)if (47 === e.codePointAt(i)) { if (n) { r = i + 1; break } } else s < 0 && (n = !0, s = i + 1); return s < 0 ? "" : e.slice(r, s) } if (t === e) return ""; let o = -1, a = t.length - 1; for (; i--;)if (47 === e.codePointAt(i)) { if (n) { r = i + 1; break } } else o < 0 && (n = !0, o = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (s = i) : (a = -1, s = o)); return r === s ? s = o : s < 0 && (s = e.length), e.slice(r, s) }, gu = function (e) { if (_u(e), 0 === e.length) return "."; let t, n = -1, r = e.length; for (; --r;)if (47 === e.codePointAt(r)) { if (t) { n = r; break } } else t || (t = !0); return n < 0 ? 47 === e.codePointAt(0) ? "/" : "." : 1 === n && 47 === e.codePointAt(0) ? "//" : e.slice(0, n) }, Eu = function (e) { _u(e); let t, n = e.length, r = -1, s = 0, i = -1, o = 0; for (; n--;) { const a = e.codePointAt(n); if (47 !== a) r < 0 && (t = !0, r = n + 1), 46 === a ? i < 0 ? i = n : 1 !== o && (o = 1) : i > -1 && (o = -1); else if (t) { s = n + 1; break } } return i < 0 || r < 0 || 0 === o || 1 === o && i === r - 1 && i === s + 1 ? "" : e.slice(i, r) }, Tu = function (...e) { let t, n = -1; for (; ++n < e.length;)_u(e[n]), e[n] && (t = void 0 === t ? e[n] : t + "/" + e[n]); return void 0 === t ? "." : function (e) { _u(e); const t = 47 === e.codePointAt(0); let n = function (e, t) { let n, r, s = "", i = 0, o = -1, a = 0, l = -1; for (; ++l <= e.length;) { if (l < e.length) n = e.codePointAt(l); else { if (47 === n) break; n = 47 } if (47 === n) { if (o === l - 1 || 1 === a); else if (o !== l - 1 && 2 === a) { if (s.length < 2 || 2 !== i || 46 !== s.codePointAt(s.length - 1) || 46 !== s.codePointAt(s.length - 2)) if (s.length > 2) { if (r = s.lastIndexOf("/"), r !== s.length - 1) { r < 0 ? (s = "", i = 0) : (s = s.slice(0, r), i = s.length - 1 - s.lastIndexOf("/")), o = l, a = 0; continue } } else if (s.length > 0) { s = "", i = 0, o = l, a = 0; continue } t && (s = s.length > 0 ? s + "/.." : "..", i = 2) } else s.length > 0 ? s += "/" + e.slice(o + 1, l) : s = e.slice(o + 1, l), i = l - o - 1; o = l, a = 0 } else 46 === n && a > -1 ? a++ : a = -1 } return s }(e, !t); return 0 !== n.length || t || (n = "."), n.length > 0 && 47 === e.codePointAt(e.length - 1) && (n += "/"), t ? "/" + n : n }(t) }, Au = "/"; function _u(e) { if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const yu = function () { return "/" }; function bu(e) { return Boolean(null !== e && "object" == typeof e && "href" in e && e.href && "protocol" in e && e.protocol && void 0 === e.auth) } const Su = ["history", "path", "basename", "stem", "extname", "dirname"]; class ku { constructor(e) { let t; t = e ? bu(e) ? { path: e } : "string" == typeof e || function (e) { return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e) }(e) ? { value: e } : e : {}, this.cwd = "cwd" in t ? "" : yu(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let n, r = -1; for (; ++r < Su.length;) { const e = Su[r]; e in t && void 0 !== t[e] && null !== t[e] && (this[e] = "history" === e ? [...t[e]] : t[e]) } for (n in t) Su.includes(n) || (this[n] = t[n]) } get basename() { return "string" == typeof this.path ? mu(this.path) : void 0 } set basename(e) { Nu(e, "basename"), Cu(e, "basename"), this.path = Tu(this.dirname || "", e) } get dirname() { return "string" == typeof this.path ? gu(this.path) : void 0 } set dirname(e) { Iu(this.basename, "dirname"), this.path = Tu(e || "", this.basename) } get extname() { return "string" == typeof this.path ? Eu(this.path) : void 0 } set extname(e) { if (Cu(e, "extname"), Iu(this.dirname, "extname"), e) { if (46 !== e.codePointAt(0)) throw new Error("`extname` must start with `.`"); if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = Tu(this.dirname, this.stem + (e || "")) } get path() { return this.history[this.history.length - 1] } set path(e) { bu(e) && (e = function (e) { if ("string" == typeof e) e = new URL(e); else if (!bu(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if ("file:" !== e.protocol) { const e = new TypeError("The URL must be of scheme file"); throw e.code = "ERR_INVALID_URL_SCHEME", e } return function (e) { if ("" !== e.hostname) { const e = new TypeError('File URL host must be "localhost" or empty on darwin'); throw e.code = "ERR_INVALID_FILE_URL_HOST", e } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (37 === t.codePointAt(n) && 50 === t.codePointAt(n + 1)) { const e = t.codePointAt(n + 2); if (70 === e || 102 === e) { const e = new TypeError("File URL path must not include encoded / characters"); throw e.code = "ERR_INVALID_FILE_URL_PATH", e } } return decodeURIComponent(t) }(e) }(e)), Nu(e, "path"), this.path !== e && this.history.push(e) } get stem() { return "string" == typeof this.path ? mu(this.path, this.extname) : void 0 } set stem(e) { Nu(e, "stem"), Cu(e, "stem"), this.path = Tu(this.dirname || "", e + (this.extname || "")) } fail(e, t, n) { const r = this.message(e, t, n); throw r.fatal = !0, r } info(e, t, n) { const r = this.message(e, t, n); return r.fatal = void 0, r } message(e, t, n) { const r = new da(e, t, n); return this.path && (r.name = this.path + ":" + r.name, r.file = this.path), r.fatal = !1, this.messages.push(r), r } toString(e) { return void 0 === this.value ? "" : "string" == typeof this.value ? this.value : new TextDecoder(e || void 0).decode(this.value) } } function Cu(e, t) { if (e && e.includes(Au)) throw new Error("`" + t + "` cannot be a path: did not expect `" + Au + "`") } function Nu(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function Iu(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } const Ou = function (e) { const t = this.constructor.prototype, n = t[e], r = function () { return n.apply(r, arguments) }; return Object.setPrototypeOf(r, t), r }, xu = {}.hasOwnProperty; class Ru extends Ou { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = function () { const e = [], t = { run: function (...t) { let n = -1; const r = t.pop(); if ("function" != typeof r) throw new TypeError("Expected function as last argument, not " + r); !function s(i, ...o) { const a = e[++n]; let l = -1; if (i) r(i); else { for (; ++l < t.length;)null !== o[l] && void 0 !== o[l] || (o[l] = t[l]); t = o, a ? function (e, t) { let n; return function (...t) { const o = e.length > t.length; let a; o && t.push(r); try { a = e.apply(this, t) } catch (i) { if (o && n) throw i; return r(i) } o || (a && a.then && "function" == typeof a.then ? a.then(s, r) : a instanceof Error ? r(a) : s(a)) }; function r(e, ...r) { n || (n = !0, t(e, ...r)) } function s(e) { r(null, e) } }(a, s)(...o) : r(null, ...o) } }(null, ...t) }, use: function (n) { if ("function" != typeof n) throw new TypeError("Expected `middelware` to be a function, not " + n); return e.push(n), t } }; return t }() } copy() { const e = new Ru; let t = -1; for (; ++t < this.attachers.length;) { const n = this.attachers[t]; e.use(...n) } return e.data(pu(!0, {}, this.namespace)), e } data(e, t) { return "string" == typeof e ? 2 === arguments.length ? (Pu("data", this.frozen), this.namespace[e] = t, this) : xu.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Pu("data", this.frozen), this.namespace = e, this) : this.namespace } freeze() { if (this.frozen) return this; const e = this; for (; ++this.freezeIndex < this.attachers.length;) { const [t, ...n] = this.attachers[this.freezeIndex]; if (!1 === n[0]) continue; !0 === n[0] && (n[0] = void 0); const r = t.call(e, ...n); "function" == typeof r && this.transformers.use(r) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(e) { this.freeze(); const t = Fu(e), n = this.parser || this.Parser; return Du("parse", n), n(String(t), t) } process(e, t) { const n = this; return this.freeze(), Du("process", this.parser || this.Parser), Lu("process", this.compiler || this.Compiler), t ? r(void 0, t) : new Promise(r); function r(r, s) { const i = Fu(e), o = n.parse(i); function a(e, n) { e || !n ? s(e) : r ? r(n) : t(void 0, n) } n.run(o, i, function (e, t, r) { if (e || !t || !r) return a(e); const s = t, i = n.stringify(s, r); var o; "string" == typeof (o = i) || function (e) { return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e) }(o) ? r.value = i : r.result = i, a(e, r) }) } } processSync(e) { let t, n = !1; return this.freeze(), Du("processSync", this.parser || this.Parser), Lu("processSync", this.compiler || this.Compiler), this.process(e, function (e, r) { n = !0, su(e), t = r }), Mu("processSync", "process", n), t } run(e, t, n) { wu(e), this.freeze(); const r = this.transformers; return n || "function" != typeof t || (n = t, t = void 0), n ? s(void 0, n) : new Promise(s); function s(s, i) { const o = Fu(t); r.run(e, o, function (t, r, o) { const a = r || e; t ? i(t) : s ? s(a) : n(void 0, a, o) }) } } runSync(e, t) { let n, r = !1; return this.run(e, t, function (e, t) { su(e), n = t, r = !0 }), Mu("runSync", "run", r), n } stringify(e, t) { this.freeze(); const n = Fu(t), r = this.compiler || this.Compiler; return Lu("stringify", r), wu(e), r(e, n) } use(e, ...t) { const n = this.attachers, r = this.namespace; if (Pu("use", this.frozen), null == e); else if ("function" == typeof e) a(e, t); else { if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); Array.isArray(e) ? o(e) : i(e) } return this; function s(e) { if ("function" == typeof e) a(e, []); else { if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); if (Array.isArray(e)) { const [t, ...n] = e; a(t, n) } else i(e) } } function i(e) { if (!("plugins" in e) && !("settings" in e)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); o(e.plugins), e.settings && (r.settings = pu(!0, r.settings, e.settings)) } function o(e) { let t = -1; if (null == e); else { if (!Array.isArray(e)) throw new TypeError("Expected a list of plugins, not `" + e + "`"); for (; ++t < e.length;)s(e[t]) } } function a(e, t) { let r = -1, s = -1; for (; ++r < n.length;)if (n[r][0] === e) { s = r; break } if (-1 === s) n.push([e, ...t]); else if (t.length > 0) { let [r, ...i] = t; const o = n[s][1]; fu(o) && fu(r) && (r = pu(!0, o, r)), n[s] = [e, r, ...i] } } } } const vu = (new Ru).freeze(); function Du(e, t) { if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `parser`") } function Lu(e, t) { if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `compiler`") } function Pu(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function wu(e) { if (!fu(e) || "string" != typeof e.type) throw new TypeError("Expected node, got `" + e + "`") } function Mu(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function Fu(e) { return function (e) { return Boolean(e && "object" == typeof e && "message" in e && "messages" in e) }(e) ? e : new ku(e) } const Bu = [], Uu = { allowDangerousHtml: !0 }, Hu = /^(https?|ircs?|mailto|xmpp)$/i, ju = [{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" }, { from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" }, { from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" }, { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "includeElementIndex", id: "#remove-includeelementindex" }, { from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" }, { from: "linkTarget", id: "remove-linktarget" }, { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" }, { from: "rawSourcePos", id: "#remove-rawsourcepos" }, { from: "renderers", id: "change-renderers-to-components", to: "components" }, { from: "source", id: "change-source-to-children", to: "children" }, { from: "sourcePos", id: "#remove-sourcepos" }, { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" }, { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }]; function Gu(e) { const t = e.rehypePlugins || Bu, n = e.remarkPlugins || Bu, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...Uu } : Uu; return vu().use(kc).use(n).use(ru, r).use(t) } function zu(e) { const t = e.children || "", n = new ku; return "string" == typeof t && (n.value = t), n } function Yu(e, t) { const n = t.allowedElements, r = t.allowElement, s = t.components, i = t.disallowedElements, o = t.skipHtml, a = t.unwrapDisallowed, l = t.urlTransform || qu; for (const c of ju) Object.hasOwn(t, c.from) && ji((c.from, c.to && c.to, c.id)); return t.className && (e = { type: "element", tagName: "div", properties: { className: t.className }, children: "root" === e.type ? e.children : [e] }), Wc(e, function (e, t, s) { if ("raw" === e.type && s && "number" == typeof t) return o ? s.children.splice(t, 1) : s.children[t] = { type: "text", value: e.value }, t; if ("element" === e.type) { let t; for (t in Oa) if (Object.hasOwn(Oa, t) && Object.hasOwn(e.properties, t)) { const n = e.properties[t], r = Oa[t]; (null === r || r.includes(e.tagName)) && (e.properties[t] = l(String(n || ""), t, e)) } } if ("element" === e.type) { let o = n ? !n.includes(e.tagName) : !!i && i.includes(e.tagName); if (!o && r && "number" == typeof t && (o = !r(e, t, s)), o && s && "number" == typeof t) return a && e.children ? s.children.splice(t, 1, ...e.children) : s.children.splice(t, 1), t } }), function (e, t) { if (!t || void 0 === t.Fragment) throw new TypeError("Expected `Fragment` in options"); const n = t.filePath || void 0; let r; if (t.development) { if ("function" != typeof t.jsxDEV) throw new TypeError("Expected `jsxDEV` in options when `development: true`"); r = function (e, t) { return function (n, r, s, i) { const o = Array.isArray(s.children), a = oa(n); return t(r, s, i, o, { columnNumber: a ? a.column - 1 : void 0, fileName: e, lineNumber: a ? a.line : void 0 }, void 0) } }(n, t.jsxDEV) } else { if ("function" != typeof t.jsx) throw new TypeError("Expected `jsx` in production options"); if ("function" != typeof t.jsxs) throw new TypeError("Expected `jsxs` in production options"); s = t.jsx, i = t.jsxs, r = function (e, t, n, r) { const o = Array.isArray(n.children) ? i : s; return r ? o(t, n, r) : o(t, n) } } var s, i; const o = { Fragment: t.Fragment, ancestors: [], components: t.components || {}, create: r, elementAttributeNameCase: t.elementAttributeNameCase || "react", evaluater: t.createEvaluater ? t.createEvaluater() : void 0, filePath: n, ignoreInvalidStyle: t.ignoreInvalidStyle || !1, passKeys: !1 !== t.passKeys, passNode: t.passNode || !1, schema: "svg" === t.space ? vo : Ro, stylePropertyNameCase: t.stylePropertyNameCase || "dom", tableCellAlignToStyle: !1 !== t.tableCellAlignToStyle }, a = Aa(o, e, void 0); return a && "string" != typeof a ? a : o.create(e, o.Fragment, { children: a || void 0 }, void 0) }(e, { Fragment: T.Fragment, components: s, ignoreInvalidStyle: !0, jsx: T.jsx, jsxs: T.jsxs, passKeys: !0, passNode: !0 }) } function qu(e) { const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), s = e.indexOf("/"); return -1 === t || -1 !== s && t > s || -1 !== n && t > n || -1 !== r && t > r || Hu.test(e.slice(0, t)) ? e : "" } const Vu = Object.freeze(Object.defineProperty({ __proto__: null, MarkdownAsync: async function (e) { const t = Gu(e), n = zu(e); return Yu(await t.run(t.parse(n), n), e) }, MarkdownHooks: function (e) { const t = Gu(e), [n, r] = React.useState(void 0), [s, i] = React.useState(void 0); if (React.useEffect(function () { const n = zu(e); t.run(t.parse(n), n, function (e, t) { r(e), i(t) }) }, [e.children, e.rehypePlugins, e.remarkPlugins, e.remarkRehypeOptions]), n) throw n; return s ? Yu(s, e) : React.createElement(T.Fragment) }, default: function (e) { const t = Gu(e), n = zu(e); return Yu(t.runSync(t.parse(n), n), e) }, defaultUrlTransform: qu }, Symbol.toStringTag, { value: "Module" })); function $u(e, t) { const n = String(e); if ("string" != typeof t) throw new TypeError("Expected character"); let r = 0, s = n.indexOf(t); for (; -1 !== s;)r++, s = n.indexOf(t, s + t.length); return r } function Wu(e) { return "string" == typeof e ? new RegExp(function (e) { if ("string" != typeof e) throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") }(e), "g") : e } function Ku(e) { return "function" == typeof e ? e : function () { return e } } const Qu = "phrasing", Xu = ["autolink", "link", "image", "label"]; function Ju(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function Zu(e) { this.config.enter.autolinkProtocol.call(this, e) } function eh(e) { this.config.exit.autolinkProtocol.call(this, e) } function th(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function nh(e) { this.config.exit.autolinkEmail.call(this, e) } function rh(e) { this.exit(e) } function sh(e) { !function (e, t, n) { const r = Gc((n || {}).ignore || []), s = function (e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let r = -1; for (; ++r < n.length;) { const e = n[r]; t.push([Wu(e[0]), Ku(e[1])]) } return t }(t); let i = -1; for (; ++i < s.length;)$c(e, "text", o); function o(e, t) { let n, o = -1; for (; ++o < t.length;) { const e = t[o], s = n ? n.children : void 0; if (r(e, s ? s.indexOf(e) : void 0, n)) return; n = e } if (n) return function (e, t) { const n = t[t.length - 1], r = s[i][0], o = s[i][1]; let a = 0; const l = n.children.indexOf(e); let c = !1, u = []; r.lastIndex = 0; let h = r.exec(e.value); for (; h;) { const n = h.index, s = { index: h.index, input: h.input, stack: [...t, e] }; let i = o(...h, s); if ("string" == typeof i && (i = i.length > 0 ? { type: "text", value: i } : void 0), !1 === i ? r.lastIndex = n + 1 : (a !== n && u.push({ type: "text", value: e.value.slice(a, n) }), Array.isArray(i) ? u.push(...i) : i && u.push(i), a = n + h[0].length, c = !0), !r.global) break; h = r.exec(e.value) } return c ? (a < e.value.length && u.push({ type: "text", value: e.value.slice(a) }), n.children.splice(l, 1, ...u)) : u = [e], l + u.length }(e, t) } }(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, ih], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), oh]], { ignore: ["link", "linkReference"] }) } function ih(e, t, n, r, s) { let i = ""; if (!ah(s)) return !1; if (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !function (e) { const t = e.split("."); return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) }(n)) return !1; const o = function (e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], r = n.indexOf(")"); const s = $u(e, "("); let i = $u(e, ")"); for (; -1 !== r && s > i;)e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++; return [e, n] }(n + r); if (!o[0]) return !1; const a = { type: "link", title: null, url: i + t + o[0], children: [{ type: "text", value: t + o[0] }] }; return o[1] ? [a, { type: "text", value: o[1] }] : a } function oh(e, t, n, r) { return !(!ah(r, !0) || /[-\d_]$/.test(n)) && { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function ah(e, t) { const n = e.input.charCodeAt(e.index - 1); return (0 === e.index || el(n) || Za(n)) && (!t || 47 !== n) } function lh() { this.buffer() } function ch(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function uh() { this.buffer() } function hh(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function dh(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = Ga(this.sliceSerialize(e)).toLowerCase(), n.label = t } function ph(e) { this.exit(e) } function fh(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = Ga(this.sliceSerialize(e)).toLowerCase(), n.label = t } function mh(e) { this.exit(e) } function gh(e, t, n, r) { const s = n.createTracker(r); let i = s.move("[^"); const o = n.enter("footnoteReference"), a = n.enter("reference"); return i += s.move(n.safe(n.associationId(e), { after: "]", before: i })), a(), o(), i += s.move("]"), i } function Eh(e) { let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: function (e, n, r, s) { const i = r.createTracker(s); let o = i.move("[^"); const a = r.enter("footnoteDefinition"), l = r.enter("label"); return o += i.move(r.safe(r.associationId(e), { before: o, after: "]" })), l(), o += i.move("]:"), e.children && e.children.length > 0 && (i.shift(4), o += i.move((t ? "\n" : " ") + r.indentLines(r.containerFlow(e, i.current()), t ? Ah : Th))), a(), o }, footnoteReference: gh }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] } } function Th(e, t, n) { return 0 === t ? e : Ah(e, 0, n) } function Ah(e, t, n) { return (n ? "" : "    ") + e } gh.peek = function () { return "[" }; const _h = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; function yh(e) { this.enter({ type: "delete", children: [] }, e) } function bh(e) { this.exit(e) } function Sh(e, t, n, r) { const s = n.createTracker(r), i = n.enter("strikethrough"); let o = s.move("~~"); return o += n.containerPhrasing(e, { ...s.current(), before: o, after: "~" }), o += s.move("~~"), i(), o } function kh(e) { return e.length } function Ch(e) { return null == e ? "" : String(e) } function Nh(e) { const t = "string" == typeof e ? e.codePointAt(0) : 0; return 67 === t || 99 === t ? 99 : 76 === t || 108 === t ? 108 : 82 === t || 114 === t ? 114 : 0 } Sh.peek = function () { return "~" }; const Ih = {}.hasOwnProperty; function Oh(e, t) { const n = t || {}; function r(t, ...n) { let s = r.invalid; const i = r.handlers; if (t && Ih.call(t, e)) { const n = String(t[e]); s = Ih.call(i, n) ? i[n] : r.unknown } if (s) return s.call(this, t, ...n) } return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r } function xh(e, t, n) { return ">" + (n ? "" : " ") + e } function Rh(e, t) { return vh(e, t.inConstruct, !0) && !vh(e, t.notInConstruct, !1) } function vh(e, t, n) { if ("string" == typeof t && (t = [t]), !t || 0 === t.length) return n; let r = -1; for (; ++r < t.length;)if (e.includes(t[r])) return !0; return !1 } function Dh(e, t, n, r) { let s = -1; for (; ++s < n.unsafe.length;)if ("\n" === n.unsafe[s].character && Rh(n.stack, n.unsafe[s])) return /[ \t]/.test(r.before) ? "" : " "; return "\\\n" } function Lh(e, t, n) { return (n ? "" : "    ") + e } function Ph(e) { const t = e.options.quote || '"'; if ('"' !== t && "'" !== t) throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function wh(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function Mh(e, t, n) { const r = al(e), s = al(t); return void 0 === r ? void 0 === s ? "_" === n ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : 1 === r ? void 0 === s ? { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : void 0 === s ? { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } function Fh(e, t, n, r) { const s = function (e) { const t = e.options.emphasis || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t }(n), i = n.enter("emphasis"), o = n.createTracker(r), a = o.move(s); let l = o.move(n.containerPhrasing(e, { after: s, before: a, ...o.current() })); const c = l.charCodeAt(0), u = Mh(r.before.charCodeAt(r.before.length - 1), c, s); u.inside && (l = wh(c) + l.slice(1)); const h = l.charCodeAt(l.length - 1), d = Mh(r.after.charCodeAt(0), h, s); d.inside && (l = l.slice(0, -1) + wh(h)); const p = o.move(s); return i(), n.attentionEncodeSurroundingInfo = { after: d.outside, before: u.outside }, a + l + p } function Bh(e) { return e.value || "" } function Uh(e, t, n, r) { const s = Ph(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.enter("image"); let a = n.enter("label"); const l = n.createTracker(r); let c = l.move("!["); return c += l.move(n.safe(e.alt, { before: c, after: "]", ...l.current() })), c += l.move("]("), a(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...l.current() }))), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(n.safe(e.title, { before: c, after: s, ...l.current() })), c += l.move(s), a()), c += l.move(")"), o(), c } function Hh(e, t, n, r) { const s = e.referenceType, i = n.enter("imageReference"); let o = n.enter("label"); const a = n.createTracker(r); let l = a.move("!["); const c = n.safe(e.alt, { before: l, after: "]", ...a.current() }); l += a.move(c + "]["), o(); const u = n.stack; n.stack = [], o = n.enter("reference"); const h = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() }); return o(), n.stack = u, i(), "full" !== s && c && c === h ? "shortcut" === s ? l = l.slice(0, -1) : l += a.move("]") : l += a.move(h + "]"), l } function jh(e, t, n) { let r = e.value || "", s = "`", i = -1; for (; new RegExp("(^|[^`])" + s + "([^`]|$)").test(r);)s += "`"; for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length;) { const e = n.unsafe[i], t = n.compilePattern(e); let s; if (e.atBreak) for (; s = t.exec(r);) { let e = s.index; 10 === r.charCodeAt(e) && 13 === r.charCodeAt(e - 1) && e--, r = r.slice(0, e) + " " + r.slice(s.index + 1) } } return s + r + s } function Gh(e, t) { const n = Ra(e); return Boolean(!t.options.resourceLink && e.url && !e.title && e.children && 1 === e.children.length && "text" === e.children[0].type && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } function zh(e, t, n, r) { const s = Ph(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.createTracker(r); let a, l; if (Gh(e, n)) { const t = n.stack; n.stack = [], a = n.enter("autolink"); let r = o.move("<"); return r += o.move(n.containerPhrasing(e, { before: r, after: ">", ...o.current() })), r += o.move(">"), a(), n.stack = t, r } a = n.enter("link"), l = n.enter("label"); let c = o.move("["); return c += o.move(n.containerPhrasing(e, { before: c, after: "](", ...o.current() })), c += o.move("]("), l(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(n.safe(e.url, { before: c, after: ">", ...o.current() })), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...o.current() }))), l(), e.title && (l = n.enter(`title${i}`), c += o.move(" " + s), c += o.move(n.safe(e.title, { before: c, after: s, ...o.current() })), c += o.move(s), l()), c += o.move(")"), a(), c } function Yh(e, t, n, r) { const s = e.referenceType, i = n.enter("linkReference"); let o = n.enter("label"); const a = n.createTracker(r); let l = a.move("["); const c = n.containerPhrasing(e, { before: l, after: "]", ...a.current() }); l += a.move(c + "]["), o(); const u = n.stack; n.stack = [], o = n.enter("reference"); const h = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() }); return o(), n.stack = u, i(), "full" !== s && c && c === h ? "shortcut" === s ? l = l.slice(0, -1) : l += a.move("]") : l += a.move(h + "]"), l } function qh(e) { const t = e.options.bullet || "*"; if ("*" !== t && "+" !== t && "-" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function Vh(e) { const t = e.options.rule || "*"; if ("*" !== t && "-" !== t && "_" !== t) throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } Fh.peek = function (e, t, n) { return n.options.emphasis || "*" }, Bh.peek = function () { return "<" }, Uh.peek = function () { return "!" }, Hh.peek = function () { return "!" }, jh.peek = function () { return "`" }, zh.peek = function (e, t, n) { return Gh(e, n) ? "<" : "[" }, Yh.peek = function () { return "[" }; const $h = Gc(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function Wh(e, t, n, r) { const s = function (e) { const t = e.options.strong || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t }(n), i = n.enter("strong"), o = n.createTracker(r), a = o.move(s + s); let l = o.move(n.containerPhrasing(e, { after: s, before: a, ...o.current() })); const c = l.charCodeAt(0), u = Mh(r.before.charCodeAt(r.before.length - 1), c, s); u.inside && (l = wh(c) + l.slice(1)); const h = l.charCodeAt(l.length - 1), d = Mh(r.after.charCodeAt(0), h, s); d.inside && (l = l.slice(0, -1) + wh(h)); const p = o.move(s + s); return i(), n.attentionEncodeSurroundingInfo = { after: d.outside, before: u.outside }, a + l + p } Wh.peek = function (e, t, n) { return n.options.strong || "*" }; const Kh = { blockquote: function (e, t, n, r) { const s = n.enter("blockquote"), i = n.createTracker(r); i.move("> "), i.shift(2); const o = n.indentLines(n.containerFlow(e, i.current()), xh); return s(), o }, break: Dh, code: function (e, t, n, r) { const s = function (e) { const t = e.options.fence || "`"; if ("`" !== t && "~" !== t) throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t }(n), i = e.value || "", o = "`" === s ? "GraveAccent" : "Tilde"; if (function (e, t) { return Boolean(!1 === t.options.fences && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) }(e, n)) { const e = n.enter("codeIndented"), t = n.indentLines(i, Lh); return e(), t } const a = n.createTracker(r), l = s.repeat(Math.max(function (e, t) { const n = String(e); let r = n.indexOf(t), s = r, i = 0, o = 0; if ("string" != typeof t) throw new TypeError("Expected substring"); for (; -1 !== r;)r === s ? ++i > o && (o = i) : i = 1, s = r + t.length, r = n.indexOf(t, s); return o }(i, s) + 1, 3)), c = n.enter("codeFenced"); let u = a.move(l); if (e.lang) { const t = n.enter(`codeFencedLang${o}`); u += a.move(n.safe(e.lang, { before: u, after: " ", encode: ["`"], ...a.current() })), t() } if (e.lang && e.meta) { const t = n.enter(`codeFencedMeta${o}`); u += a.move(" "), u += a.move(n.safe(e.meta, { before: u, after: "\n", encode: ["`"], ...a.current() })), t() } return u += a.move("\n"), i && (u += a.move(i + "\n")), u += a.move(l), c(), u }, definition: function (e, t, n, r) { const s = Ph(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.enter("definition"); let a = n.enter("label"); const l = n.createTracker(r); let c = l.move("["); return c += l.move(n.safe(n.associationId(e), { before: c, after: "]", ...l.current() })), c += l.move("]: "), a(), !e.url || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : "\n", ...l.current() }))), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(n.safe(e.title, { before: c, after: s, ...l.current() })), c += l.move(s), a()), o(), c }, emphasis: Fh, hardBreak: Dh, heading: function (e, t, n, r) { const s = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r); if (function (e, t) { let n = !1; return Wc(e, function (e) { if ("value" in e && /\r?\n|\r/.test(e.value) || "break" === e.type) return n = !0, Vc }), Boolean((!e.depth || e.depth < 3) && Ra(e) && (t.options.setext || n)) }(e, n)) { const t = n.enter("headingSetext"), r = n.enter("phrasing"), o = n.containerPhrasing(e, { ...i.current(), before: "\n", after: "\n" }); return r(), t(), o + "\n" + (1 === s ? "=" : "-").repeat(o.length - (Math.max(o.lastIndexOf("\r"), o.lastIndexOf("\n")) + 1)) } const o = "#".repeat(s), a = n.enter("headingAtx"), l = n.enter("phrasing"); i.move(o + " "); let c = n.containerPhrasing(e, { before: "# ", after: "\n", ...i.current() }); return /^[\t ]/.test(c) && (c = wh(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), a(), c }, html: Bh, image: Uh, imageReference: Hh, inlineCode: jh, link: zh, linkReference: Yh, list: function (e, t, n, r) { const s = n.enter("list"), i = n.bulletCurrent; let o = e.ordered ? function (e) { const t = e.options.bulletOrdered || "."; if ("." !== t && ")" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t }(n) : qh(n); const a = e.ordered ? "." === o ? ")" : "." : function (e) { const t = qh(e), n = e.options.bulletOther; if (!n) return "*" === t ? "-" : "*"; if ("*" !== n && "+" !== n && "-" !== n) throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n }(n); let l = !(!t || !n.bulletLastUsed) && o === n.bulletLastUsed; if (!e.ordered) { const t = e.children ? e.children[0] : void 0; if ("*" !== o && "-" !== o || !t || t.children && t.children[0] || "list" !== n.stack[n.stack.length - 1] || "listItem" !== n.stack[n.stack.length - 2] || "list" !== n.stack[n.stack.length - 3] || "listItem" !== n.stack[n.stack.length - 4] || 0 !== n.indexStack[n.indexStack.length - 1] || 0 !== n.indexStack[n.indexStack.length - 2] || 0 !== n.indexStack[n.indexStack.length - 3] || (l = !0), Vh(n) === o && t) { let t = -1; for (; ++t < e.children.length;) { const n = e.children[t]; if (n && "listItem" === n.type && n.children && n.children[0] && "thematicBreak" === n.children[0].type) { l = !0; break } } } } l && (o = a), n.bulletCurrent = o; const c = n.containerFlow(e, r); return n.bulletLastUsed = o, n.bulletCurrent = i, s(), c }, listItem: function (e, t, n, r) { const s = function (e) { const t = e.options.listItemIndent || "one"; if ("tab" !== t && "one" !== t && "mixed" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t }(n); let i = n.bulletCurrent || qh(n); t && "list" === t.type && t.ordered && (i = ("number" == typeof t.start && t.start > -1 ? t.start : 1) + (!1 === n.options.incrementListMarker ? 0 : t.children.indexOf(e)) + i); let o = i.length + 1; ("tab" === s || "mixed" === s && (t && "list" === t.type && t.spread || e.spread)) && (o = 4 * Math.ceil(o / 4)); const a = n.createTracker(r); a.move(i + " ".repeat(o - i.length)), a.shift(o); const l = n.enter("listItem"), c = n.indentLines(n.containerFlow(e, a.current()), function (e, t, n) { return t ? (n ? "" : " ".repeat(o)) + e : (n ? i : i + " ".repeat(o - i.length)) + e }); return l(), c }, paragraph: function (e, t, n, r) { const s = n.enter("paragraph"), i = n.enter("phrasing"), o = n.containerPhrasing(e, r); return i(), s(), o }, root: function (e, t, n, r) { return (e.children.some(function (e) { return $h(e) }) ? n.containerPhrasing : n.containerFlow).call(n, e, r) }, strong: Wh, text: function (e, t, n, r) { return n.safe(e.value, r) }, thematicBreak: function (e, t, n) { const r = (Vh(n) + (n.options.ruleSpaces ? " " : "")).repeat(function (e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t }(n)); return n.options.ruleSpaces ? r.slice(0, -1) : r } }; function Qh(e) { const t = e._align; this.enter({ type: "table", align: t.map(function (e) { return "none" === e ? null : e }), children: [] }, e), this.data.inTable = !0 } function Xh(e) { this.exit(e), this.data.inTable = void 0 } function Jh(e) { this.enter({ type: "tableRow", children: [] }, e) } function Zh(e) { this.exit(e) } function ed(e) { this.enter({ type: "tableCell", children: [] }, e) } function td(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, nd)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function nd(e, t) { return "|" === t ? t : e } function rd(e) { const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, s = t.stringLength, i = n ? " " : "|"; return { unsafe: [{ character: "\r", inConstruct: "tableCell" }, { character: "\n", inConstruct: "tableCell" }, { atBreak: !0, character: "|", after: "[\t :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: function (e, t, n) { let r = Kh.inlineCode(e, t, n); return n.stack.includes("tableCell") && (r = r.replace(/\|/g, "\\$&")), r }, table: function (e, t, n, r) { return a(function (e, t, n) { const r = e.children; let s = -1; const i = [], o = t.enter("table"); for (; ++s < r.length;)i[s] = l(r[s], t, n); return o(), i }(e, n, r), e.align) }, tableCell: o, tableRow: function (e, t, n, r) { const s = a([l(e, n, r)]); return s.slice(0, s.indexOf("\n")) } } }; function o(e, t, n, r) { const s = n.enter("tableCell"), o = n.enter("phrasing"), a = n.containerPhrasing(e, { ...r, before: i, after: i }); return o(), s(), a } function a(e, t) { return function (e, t) { const n = t || {}, r = (n.align || []).concat(), s = n.stringLength || kh, i = [], o = [], a = [], l = []; let c = 0, u = -1; for (; ++u < e.length;) { const t = [], r = []; let i = -1; for (e[u].length > c && (c = e[u].length); ++i < e[u].length;) { const o = Ch(e[u][i]); if (!1 !== n.alignDelimiters) { const e = s(o); r[i] = e, (void 0 === l[i] || e > l[i]) && (l[i] = e) } t.push(o) } o[u] = t, a[u] = r } let h = -1; if ("object" == typeof r && "length" in r) for (; ++h < c;)i[h] = Nh(r[h]); else { const e = Nh(r); for (; ++h < c;)i[h] = e } h = -1; const d = [], p = []; for (; ++h < c;) { const e = i[h]; let t = "", r = ""; 99 === e ? (t = ":", r = ":") : 108 === e ? t = ":" : 114 === e && (r = ":"); let s = !1 === n.alignDelimiters ? 1 : Math.max(1, l[h] - t.length - r.length); const o = t + "-".repeat(s) + r; !1 !== n.alignDelimiters && (s = t.length + s + r.length, s > l[h] && (l[h] = s), p[h] = s), d[h] = o } o.splice(1, 0, d), a.splice(1, 0, p), u = -1; const f = []; for (; ++u < o.length;) { const e = o[u], t = a[u]; h = -1; const r = []; for (; ++h < c;) { const s = e[h] || ""; let o = "", a = ""; if (!1 !== n.alignDelimiters) { const e = l[h] - (t[h] || 0), n = i[h]; 114 === n ? o = " ".repeat(e) : 99 === n ? e % 2 ? (o = " ".repeat(e / 2 + .5), a = " ".repeat(e / 2 - .5)) : (o = " ".repeat(e / 2), a = o) : a = " ".repeat(e) } !1 === n.delimiterStart || h || r.push("|"), !1 === n.padding || !1 === n.alignDelimiters && "" === s || !1 === n.delimiterStart && !h || r.push(" "), !1 !== n.alignDelimiters && r.push(o), r.push(s), !1 !== n.alignDelimiters && r.push(a), !1 !== n.padding && r.push(" "), !1 === n.delimiterEnd && h === c - 1 || r.push("|") } f.push(!1 === n.delimiterEnd ? r.join("").replace(/ +$/, "") : r.join("")) } return f.join("\n") }(e, { align: t, alignDelimiters: r, padding: n, stringLength: s }) } function l(e, t, n) { const r = e.children; let s = -1; const i = [], a = t.enter("tableRow"); for (; ++s < r.length;)i[s] = o(r[s], 0, t, n); return a(), i } } function sd(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = "taskListCheckValueChecked" === e.type } function id(e) { const t = this.stack[this.stack.length - 2]; if (t && "listItem" === t.type && "boolean" == typeof t.checked) { const e = this.stack[this.stack.length - 1]; e.type; const n = e.children[0]; if (n && "text" === n.type) { const r = t.children; let s, i = -1; for (; ++i < r.length;) { const e = r[i]; if ("paragraph" === e.type) { s = e; break } } s === e && (n.value = n.value.slice(1), 0 === n.value.length ? e.children.shift() : e.position && n.position && "number" == typeof n.position.start.offset && (n.position.start.column++, n.position.start.offset++, e.position.start = Object.assign({}, n.position.start))) } } this.exit(e) } function od(e, t, n, r) { const s = e.children[0], i = "boolean" == typeof e.checked && s && "paragraph" === s.type, o = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r); i && a.move(o); let l = Kh.listItem(e, t, n, { ...r, ...a.current() }); return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, function (e) { return e + o })), l } const ad = { tokenize: function (e, t, n) { let r = 0; return function t(i) { return (87 === i || 119 === i) && r < 3 ? (r++, e.consume(i), t) : 46 === i && 3 === r ? (e.consume(i), s) : n(i) }; function s(e) { return null === e ? n(e) : t(e) } }, partial: !0 }, ld = { tokenize: function (e, t, n) { let r, s, i; return o; function o(t) { return 46 === t || 95 === t ? e.check(ud, l, a)(t) : null === t || Xa(t) || el(t) || 45 !== t && Za(t) ? l(t) : (i = !0, e.consume(t), o) } function a(t) { return 95 === t ? r = !0 : (s = r, r = void 0), e.consume(t), o } function l(e) { return s || r || !i ? n(e) : t(e) } }, partial: !0 }, cd = { tokenize: function (e, t) { let n = 0, r = 0; return s; function s(o) { return 40 === o ? (n++, e.consume(o), s) : 41 === o && r < n ? i(o) : 33 === o || 34 === o || 38 === o || 39 === o || 41 === o || 42 === o || 44 === o || 46 === o || 58 === o || 59 === o || 60 === o || 63 === o || 93 === o || 95 === o || 126 === o ? e.check(ud, t, i)(o) : null === o || Xa(o) || el(o) ? t(o) : (e.consume(o), s) } function i(t) { return 41 === t && r++, e.consume(t), s } }, partial: !0 }, ud = { tokenize: function (e, t, n) { return r; function r(o) { return 33 === o || 34 === o || 39 === o || 41 === o || 42 === o || 44 === o || 46 === o || 58 === o || 59 === o || 63 === o || 95 === o || 126 === o ? (e.consume(o), r) : 38 === o ? (e.consume(o), i) : 93 === o ? (e.consume(o), s) : 60 === o || null === o || Xa(o) || el(o) ? t(o) : n(o) } function s(e) { return null === e || 40 === e || 91 === e || Xa(e) || el(e) ? t(e) : r(e) } function i(e) { return za(e) ? o(e) : n(e) } function o(t) { return 59 === t ? (e.consume(t), r) : za(t) ? (e.consume(t), o) : n(t) } }, partial: !0 }, hd = { tokenize: function (e, t, n) { return function (t) { return e.consume(t), r }; function r(e) { return Ya(e) ? n(e) : t(e) } }, partial: !0 }, dd = { name: "wwwAutolink", tokenize: function (e, t, n) { const r = this; return function (t) { return 87 !== t && 119 !== t || !Ed.call(r, r.previous) || yd(r.events) ? n(t) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(ad, e.attempt(ld, e.attempt(cd, s), n), n)(t)) }; function s(n) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(n) } }, previous: Ed }, pd = { name: "protocolAutolink", tokenize: function (e, t, n) { const r = this; let s = "", i = !1; return function (t) { return 72 !== t && 104 !== t || !Td.call(r, r.previous) || yd(r.events) ? n(t) : (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), s += String.fromCodePoint(t), e.consume(t), o) }; function o(t) { if (za(t) && s.length < 5) return s += String.fromCodePoint(t), e.consume(t), o; if (58 === t) { const n = s.toLowerCase(); if ("http" === n || "https" === n) return e.consume(t), a } return n(t) } function a(t) { return 47 === t ? (e.consume(t), i ? l : (i = !0, a)) : n(t) } function l(t) { return null === t || Va(t) || Xa(t) || el(t) || Za(t) ? n(t) : e.attempt(ld, e.attempt(cd, c), n)(t) } function c(n) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(n) } }, previous: Td }, fd = { name: "emailAutolink", tokenize: function (e, t, n) { const r = this; let s, i; return function (t) { return _d(t) && Ad.call(r, r.previous) && !yd(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(t)) : n(t) }; function o(t) { return _d(t) ? (e.consume(t), o) : 64 === t ? (e.consume(t), a) : n(t) } function a(t) { return 46 === t ? e.check(hd, c, l)(t) : 45 === t || 95 === t || Ya(t) ? (i = !0, e.consume(t), a) : c(t) } function l(t) { return e.consume(t), s = !0, a } function c(o) { return i && s && za(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(o)) : n(o) } }, previous: Ad }, md = {}; let gd = 48; for (; gd < 123;)md[gd] = fd, gd++, 58 === gd ? gd = 65 : 91 === gd && (gd = 97); function Ed(e) { return null === e || 40 === e || 42 === e || 95 === e || 91 === e || 93 === e || 126 === e || Xa(e) } function Td(e) { return !za(e) } function Ad(e) { return !(47 === e || _d(e)) } function _d(e) { return 43 === e || 45 === e || 46 === e || 95 === e || Ya(e) } function yd(e) { let t = e.length, n = !1; for (; t--;) { const r = e[t][1]; if (("labelLink" === r.type || "labelImage" === r.type) && !r._balanced) { n = !0; break } if (r._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } md[43] = fd, md[45] = fd, md[46] = fd, md[95] = fd, md[72] = [fd, pd], md[104] = [fd, pd], md[87] = [fd, dd], md[119] = [fd, dd]; const bd = { tokenize: function (e, t, n) { const r = this; return rl(e, function (e) { const s = r.events[r.events.length - 1]; return s && "gfmFootnoteDefinitionIndent" === s[1].type && 4 === s[2].sliceSerialize(s[1], !0).length ? t(e) : n(e) }, "gfmFootnoteDefinitionIndent", 5) }, partial: !0 }; function Sd(e, t, n) { const r = this; let s = r.events.length; const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let o; for (; s--;) { const e = r.events[s][1]; if ("labelImage" === e.type) { o = e; break } if ("gfmFootnoteCall" === e.type || "labelLink" === e.type || "label" === e.type || "image" === e.type || "link" === e.type) break } return function (s) { if (!o || !o._balanced) return n(s); const a = Ga(r.sliceSerialize({ start: o.end, end: r.now() })); return 94 === a.codePointAt(0) && i.includes(a.slice(1)) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(s), e.exit("gfmFootnoteCallLabelMarker"), t(s)) : n(s) } } function kd(e, t) { let n = e.length; for (; n--;)if ("labelImage" === e[n][1].type && "enter" === e[n][0]) { e[n][1]; break } e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker"; const r = { type: "gfmFootnoteCall", start: Object.assign({}, e[n + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, s = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[n + 3][1].end), end: Object.assign({}, e[n + 3][1].end) }; s.end.column++, s.end.offset++, s.end._bufferIndex++; const i = { type: "gfmFootnoteCallString", start: Object.assign({}, s.end), end: Object.assign({}, e[e.length - 1][1].start) }, o = { type: "chunkString", contentType: "string", start: Object.assign({}, i.start), end: Object.assign({}, i.end) }, a = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", s, t], ["exit", s, t], ["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]]; return e.splice(n, e.length - n + 1, ...a), e } function Cd(e, t, n) { const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let i, o = 0; return function (t) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(t), e.exit("gfmFootnoteCallLabelMarker"), a }; function a(t) { return 94 !== t ? n(t) : (e.enter("gfmFootnoteCallMarker"), e.consume(t), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l) } function l(a) { if (o > 999 || 93 === a && !i || null === a || 91 === a || Xa(a)) return n(a); if (93 === a) { e.exit("chunkString"); const i = e.exit("gfmFootnoteCallString"); return s.includes(Ga(r.sliceSerialize(i))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(a), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(a) } return Xa(a) || (i = !0), o++, e.consume(a), 92 === a ? c : l } function c(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), o++, l) : l(t) } } function Nd(e, t, n) { const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let i, o, a = 0; return function (t) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), l }; function l(t) { return 94 === t ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(t) } function c(t) { if (a > 999 || 93 === t && !o || null === t || 91 === t || Xa(t)) return n(t); if (93 === t) { e.exit("chunkString"); const n = e.exit("gfmFootnoteDefinitionLabelString"); return i = Ga(r.sliceSerialize(n)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h } return Xa(t) || (o = !0), a++, e.consume(t), 92 === t ? u : c } function u(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), a++, c) : c(t) } function h(t) { return 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), s.includes(i) || s.push(i), rl(e, d, "gfmFootnoteDefinitionWhitespace")) : n(t) } function d(e) { return t(e) } } function Id(e, t, n) { return e.check(dl, t, e.attempt(bd, t, n)) } function Od(e) { e.exit("gfmFootnoteDefinition") } function xd(e) { let t = (e || {}).singleTilde; const n = { name: "strikethrough", tokenize: function (e, n, r) { const s = this.previous, i = this.events; let o = 0; return function (t) { return 126 === s && "characterEscape" !== i[i.length - 1][1].type ? r(t) : (e.enter("strikethroughSequenceTemporary"), a(t)) }; function a(i) { const l = al(s); if (126 === i) return o > 1 ? r(i) : (e.consume(i), o++, a); if (o < 2 && !t) return r(i); const c = e.exit("strikethroughSequenceTemporary"), u = al(i); return c._open = !u || 2 === u && Boolean(l), c._close = !l || 2 === l && Boolean(u), n(i) } }, resolveAll: function (e, t) { let n = -1; for (; ++n < e.length;)if ("enter" === e[n][0] && "strikethroughSequenceTemporary" === e[n][1].type && e[n][1]._close) { let r = n; for (; r--;)if ("exit" === e[r][0] && "strikethroughSequenceTemporary" === e[r][1].type && e[r][1]._open && e[n][1].end.offset - e[n][1].start.offset === e[r][1].end.offset - e[r][1].start.offset) { e[n][1].type = "strikethroughSequence", e[r][1].type = "strikethroughSequence"; const s = { type: "strikethrough", start: Object.assign({}, e[r][1].start), end: Object.assign({}, e[n][1].end) }, i = { type: "strikethroughText", start: Object.assign({}, e[r][1].end), end: Object.assign({}, e[n][1].start) }, o = [["enter", s, t], ["enter", e[r][1], t], ["exit", e[r][1], t], ["enter", i, t]], a = t.parser.constructs.insideSpan.null; a && wa(o, o.length, 0, ll(a, e.slice(r + 1, n), t)), wa(o, o.length, 0, [["exit", i, t], ["enter", e[n][1], t], ["exit", e[n][1], t], ["exit", s, t]]), wa(e, r - 1, n - r + 3, o), n = r + o.length - 2; break } } for (n = -1; ++n < e.length;)"strikethroughSequenceTemporary" === e[n][1].type && (e[n][1].type = "data"); return e } }; return null == t && (t = !0), { text: { 126: n }, insideSpan: { null: [n] }, attentionMarkers: { null: [126] } } } class Rd { constructor() { this.map = [] } add(e, t, n) { !function (e, t, n, r) { let s = 0; if (0 !== n || 0 !== r.length) { for (; s < e.map.length;) { if (e.map[s][0] === t) return e.map[s][1] += n, void e.map[s][2].push(...r); s += 1 } e.map.push([t, n, r]) } }(this, e, t, n) } consume(e) { if (this.map.sort(function (e, t) { return e[0] - t[0] }), 0 === this.map.length) return; let t = this.map.length; const n = []; for (; t > 0;)t -= 1, n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0]; n.push(e.slice()), e.length = 0; let r = n.pop(); for (; r;) { for (const t of r) e.push(t); r = n.pop() } this.map.length = 0 } } function vd(e, t) { let n = !1; const r = []; for (; t < e.length;) { const s = e[t]; if (n) { if ("enter" === s[0]) "tableContent" === s[1].type && r.push("tableDelimiterMarker" === e[t + 1][1].type ? "left" : "none"); else if ("tableContent" === s[1].type) { if ("tableDelimiterMarker" === e[t - 1][1].type) { const e = r.length - 1; r[e] = "left" === r[e] ? "center" : "right" } } else if ("tableDelimiterRow" === s[1].type) break } else "enter" === s[0] && "tableDelimiterRow" === s[1].type && (n = !0); t += 1 } return r } function Dd(e, t, n) { const r = this; let s, i = 0, o = 0; return function (e) { let t = r.events.length - 1; for (; t > -1;) { const e = r.events[t][1].type; if ("lineEnding" !== e && "linePrefix" !== e) break; t-- } const s = t > -1 ? r.events[t][1].type : null, i = "tableHead" === s || "tableRow" === s ? _ : a; return i === _ && r.parser.lazy[r.now().line] ? n(e) : i(e) }; function a(t) { return e.enter("tableHead"), e.enter("tableRow"), function (e) { return 124 === e || (s = !0, o += 1), l(e) }(t) } function l(t) { return null === t ? n(t) : Qa(t) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), h) : n(t) : Ja(t) ? rl(e, l, "whitespace")(t) : (o += 1, s && (s = !1, i += 1), 124 === t ? (e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), s = !0, l) : (e.enter("data"), c(t))) } function c(t) { return null === t || 124 === t || Xa(t) ? (e.exit("data"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return 92 === t || 124 === t ? (e.consume(t), c) : c(t) } function h(t) { return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(t) : (e.enter("tableDelimiterRow"), s = !1, Ja(t) ? rl(e, d, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : d(t)) } function d(t) { return 45 === t || 58 === t ? f(t) : 124 === t ? (s = !0, e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), p) : A(t) } function p(t) { return Ja(t) ? rl(e, f, "whitespace")(t) : f(t) } function f(t) { return 58 === t ? (o += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), m) : 45 === t ? (o += 1, m(t)) : null === t || Qa(t) ? T(t) : A(t) } function m(t) { return 45 === t ? (e.enter("tableDelimiterFiller"), g(t)) : A(t) } function g(t) { return 45 === t ? (e.consume(t), g) : 58 === t ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), E) : (e.exit("tableDelimiterFiller"), E(t)) } function E(t) { return Ja(t) ? rl(e, T, "whitespace")(t) : T(t) } function T(n) { return 124 === n ? d(n) : (null === n || Qa(n)) && s && i === o ? (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(n)) : A(n) } function A(e) { return n(e) } function _(t) { return e.enter("tableRow"), y(t) } function y(n) { return 124 === n ? (e.enter("tableCellDivider"), e.consume(n), e.exit("tableCellDivider"), y) : null === n || Qa(n) ? (e.exit("tableRow"), t(n)) : Ja(n) ? rl(e, y, "whitespace")(n) : (e.enter("data"), b(n)) } function b(t) { return null === t || 124 === t || Xa(t) ? (e.exit("data"), y(t)) : (e.consume(t), 92 === t ? S : b) } function S(t) { return 92 === t || 124 === t ? (e.consume(t), b) : b(t) } } function Ld(e, t) { let n, r, s, i = -1, o = !0, a = 0, l = [0, 0, 0, 0], c = [0, 0, 0, 0], u = !1, h = 0; const d = new Rd; for (; ++i < e.length;) { const p = e[i], f = p[1]; "enter" === p[0] ? "tableHead" === f.type ? (u = !1, 0 !== h && (wd(d, t, h, n, r), r = void 0, h = 0), n = { type: "table", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }, d.add(i, 0, [["enter", n, t]])) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (o = !0, s = void 0, l = [0, 0, 0, 0], c = [0, i + 1, 0, 0], u && (u = !1, r = { type: "tableBody", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }, d.add(i, 0, [["enter", r, t]])), a = "tableDelimiterRow" === f.type ? 2 : r ? 3 : 1) : !a || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type ? "tableCellDivider" === f.type && (o ? o = !1 : (0 !== l[1] && (c[0] = c[1], s = Pd(d, t, l, a, void 0, s)), l = c, c = [l[1], i, 0, 0])) : (o = !1, 0 === c[2] && (0 !== l[1] && (c[0] = c[1], s = Pd(d, t, l, a, void 0, s), l = [0, 0, 0, 0]), c[2] = i)) : "tableHead" === f.type ? (u = !0, h = i) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (h = i, 0 !== l[1] ? (c[0] = c[1], s = Pd(d, t, l, a, i, s)) : 0 !== c[1] && (s = Pd(d, t, c, a, i, s)), a = 0) : !a || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type || (c[3] = i) } for (0 !== h && wd(d, t, h, n, r), d.consume(t.events), i = -1; ++i < t.events.length;) { const e = t.events[i]; "enter" === e[0] && "table" === e[1].type && (e[1]._align = vd(t.events, i)) } return e } function Pd(e, t, n, r, s, i) { const o = 1 === r ? "tableHeader" : 2 === r ? "tableDelimiter" : "tableData"; 0 !== n[0] && (i.end = Object.assign({}, Md(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]])); const a = Md(t.events, n[1]); if (i = { type: o, start: Object.assign({}, a), end: Object.assign({}, a) }, e.add(n[1], 0, [["enter", i, t]]), 0 !== n[2]) { const s = Md(t.events, n[2]), i = Md(t.events, n[3]), o = { type: "tableContent", start: Object.assign({}, s), end: Object.assign({}, i) }; if (e.add(n[2], 0, [["enter", o, t]]), 2 !== r) { const r = t.events[n[2]], s = t.events[n[3]]; if (r[1].end = Object.assign({}, s[1].end), r[1].type = "chunkText", r[1].contentType = "text", n[3] > n[2] + 1) { const t = n[2] + 1, r = n[3] - n[2] - 1; e.add(t, r, []) } } e.add(n[3] + 1, 0, [["exit", o, t]]) } return void 0 !== s && (i.end = Object.assign({}, Md(t.events, s)), e.add(s, 0, [["exit", i, t]]), i = void 0), i } function wd(e, t, n, r, s) { const i = [], o = Md(t.events, n); s && (s.end = Object.assign({}, o), i.push(["exit", s, t])), r.end = Object.assign({}, o), i.push(["exit", r, t]), e.add(n + 1, 0, i) } function Md(e, t) { const n = e[t], r = "enter" === n[0] ? "start" : "end"; return n[1][r] } const Fd = { name: "tasklistCheck", tokenize: function (e, t, n) { const r = this; return function (t) { return null === r.previous && r._gfmTasklistFirstContentOfListItem ? (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), s) : n(t) }; function s(t) { return Xa(t) ? (e.enter("taskListCheckValueUnchecked"), e.consume(t), e.exit("taskListCheckValueUnchecked"), i) : 88 === t || 120 === t ? (e.enter("taskListCheckValueChecked"), e.consume(t), e.exit("taskListCheckValueChecked"), i) : n(t) } function i(t) { return 93 === t ? (e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(t) } function o(r) { return Qa(r) ? t(r) : Ja(r) ? e.check({ tokenize: Bd }, t, n)(r) : n(r) } } }; function Bd(e, t, n) { return rl(e, function (e) { return null === e ? n(e) : t(e) }, "whitespace") } const Ud = {}, Hd = Object.freeze(Object.defineProperty({ __proto__: null, default: function (e) { const t = e || Ud, n = this.data(), r = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), i = n.toMarkdownExtensions || (n.toMarkdownExtensions = []); r.push(function (e) { return Ba([{ text: md }, { document: { 91: { name: "gfmFootnoteDefinition", tokenize: Nd, continuation: { tokenize: Id }, exit: Od } }, text: { 91: { name: "gfmFootnoteCall", tokenize: Cd }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: Sd, resolveTo: kd } } }, xd(e), { flow: { null: { name: "table", tokenize: Dd, resolveAll: Ld } } }, { text: { 91: Fd } }]) }(t)), s.push([{ transforms: [sh], enter: { literalAutolink: Ju, literalAutolinkEmail: Zu, literalAutolinkHttp: Zu, literalAutolinkWww: Zu }, exit: { literalAutolink: rh, literalAutolinkEmail: nh, literalAutolinkHttp: eh, literalAutolinkWww: th } }, { enter: { gfmFootnoteCallString: lh, gfmFootnoteCall: ch, gfmFootnoteDefinitionLabelString: uh, gfmFootnoteDefinition: hh }, exit: { gfmFootnoteCallString: dh, gfmFootnoteCall: ph, gfmFootnoteDefinitionLabelString: fh, gfmFootnoteDefinition: mh } }, { canContainEols: ["delete"], enter: { strikethrough: yh }, exit: { strikethrough: bh } }, { enter: { table: Qh, tableData: ed, tableHeader: ed, tableRow: Jh }, exit: { codeText: td, table: Xh, tableData: Zh, tableHeader: Zh, tableRow: Zh } }, { exit: { taskListCheckValueChecked: sd, taskListCheckValueUnchecked: sd, paragraph: id } }]), i.push(function (e) { return { extensions: [{ unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: Qu, notInConstruct: Xu }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: Qu, notInConstruct: Xu }, { character: ":", before: "[ps]", after: "\\/", inConstruct: Qu, notInConstruct: Xu }] }, Eh(e), { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: _h }], handlers: { delete: Sh } }, rd(e), { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: od } }] } }(t)) } }, Symbol.toStringTag, { value: "Module" })), jd = /[#.]/g; function Gd(e, t, n) { const r = n ? function (e) { const t = new Map; for (const n of e) t.set(n.toLowerCase(), n); return t }(n) : void 0; return function (n, s, ...i) { let o; if (null == n) { o = { type: "root", children: [] }; const e = s; i.unshift(e) } else { o = function (e, t) { const n = e || "", r = {}; let s, i, o = 0; for (; o < n.length;) { jd.lastIndex = o; const e = jd.exec(n), t = n.slice(o, e ? e.index : n.length); t && (s ? "#" === s ? r.id = t : Array.isArray(r.className) ? r.className.push(t) : r.className = [t] : i = t, o += t.length), e && (s = e[0], o++) } return { type: "element", tagName: i || t || "div", properties: r, children: [] } }(n, t); const a = o.tagName.toLowerCase(), l = r ? r.get(a) : void 0; if (o.tagName = l || a, function (e) { if (null === e || "object" != typeof e || Array.isArray(e)) return !0; if ("string" != typeof e.type) return !1; const t = e, n = Object.keys(e); for (const r of n) { const e = t[r]; if (e && "object" == typeof e) { if (!Array.isArray(e)) return !0; const t = e; for (const e of t) if ("number" != typeof e && "string" != typeof e) return !0 } } return !(!("children" in e) || !Array.isArray(e.children)) }(s)) i.unshift(s); else for (const [t, n] of Object.entries(s)) zd(e, o.properties, t, n) } for (const e of i) Yd(o.children, e); return "element" === o.type && "template" === o.tagName && (o.content = { type: "root", children: o.children }, o.children = []), o } } function zd(e, t, n, r) { const s = Io(e, n); let i; if (null != r) { if ("number" == typeof r) { if (Number.isNaN(r)) return; i = r } else i = "boolean" == typeof r ? r : "string" == typeof r ? s.spaceSeparated ? Do(r) : s.commaSeparated ? Gi(r) : s.commaOrSpaceSeparated ? Do(Gi(r).join(" ")) : qd(s, s.property, r) : Array.isArray(r) ? [...r] : "style" === s.property ? function (e) { const t = []; for (const [n, r] of Object.entries(e)) t.push([n, r].join(": ")); return t.join("; ") }(r) : String(r); if (Array.isArray(i)) { const e = []; for (const t of i) e.push(qd(s, s.property, t)); i = e } "className" === s.property && Array.isArray(t.className) && (i = t.className.concat(i)), t[s.property] = i } } function Yd(e, t) { if (null == t); else if ("number" == typeof t || "string" == typeof t) e.push({ type: "text", value: String(t) }); else if (Array.isArray(t)) for (const n of t) Yd(e, n); else { if ("object" != typeof t || !("type" in t)) throw new Error("Expected node, nodes, or string, got `" + t + "`"); "root" === t.type ? Yd(e, t.children) : e.push(t) } } function qd(e, t, n) { if ("string" == typeof n) { if (e.number && n && !Number.isNaN(Number(n))) return Number(n); if ((e.boolean || e.overloadedBoolean) && ("" === n || Ji(n) === Ji(t))) return !0 } return n } const Vd = Gd(Ro, "div"), $d = Gd(vo, "g", ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"]); function Wd(e, t) { const n = e.indexOf("\r", t), r = e.indexOf("\n", t); return -1 === r ? n : -1 === n || n + 1 === r ? r : n < r ? n : r } const Kd = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, Qd = {}.hasOwnProperty, Xd = Object.prototype; function Jd(e, t) { let n; switch (t.nodeName) { case "#comment": { const r = t; return n = { type: "comment", value: r.data }, ep(e, r, n), n } case "#document": case "#document-fragment": { const r = t, s = "mode" in r && ("quirks" === r.mode || "limited-quirks" === r.mode); if (n = { type: "root", children: Zd(e, t.childNodes), data: { quirksMode: s } }, e.file && e.location) { const t = String(e.file), r = function (e) { const t = String(e), n = []; return { toOffset: function (e) { if (e && "number" == typeof e.line && "number" == typeof e.column && !Number.isNaN(e.line) && !Number.isNaN(e.column)) { for (; n.length < e.line;) { const e = n[n.length - 1], r = Wd(t, e), s = -1 === r ? t.length + 1 : r + 1; if (e === s) break; n.push(s) } const r = (e.line > 1 ? n[e.line - 2] : 0) + e.column - 1; if (r < n[e.line - 1]) return r } }, toPoint: function (e) { if ("number" == typeof e && e > -1 && e <= t.length) { let r = 0; for (; ;) { let s = n[r]; if (void 0 === s) { const e = Wd(t, n[r - 1]); s = -1 === e ? t.length + 1 : e + 1, n[r] = s } if (s > e) return { line: r + 1, column: e - (r > 0 ? n[r - 1] : 0) + 1, offset: e }; r++ } } } } }(t), s = r.toPoint(0), i = r.toPoint(t.length); n.position = { start: s, end: i } } return n } case "#documentType": return n = { type: "doctype" }, ep(e, t, n), n; case "#text": { const r = t; return n = { type: "text", value: r.value }, ep(e, r, n), n } default: return n = function (e, t) { const n = e.schema; e.schema = t.namespaceURI === Kd.svg ? vo : Ro; let r = -1; const s = {}; for (; ++r < t.attrs.length;) { const e = t.attrs[r], n = (e.prefix ? e.prefix + ":" : "") + e.name; Qd.call(Xd, n) || (s[n] = e.value) } const i = ("svg" === e.schema.space ? $d : Vd)(t.tagName, s, Zd(e, t.childNodes)); if (ep(e, t, i), "template" === i.tagName) { const n = t, r = n.sourceCodeLocation, s = r && r.startTag && tp(r.startTag), o = r && r.endTag && tp(r.endTag), a = Jd(e, n.content); s && o && e.file && (a.position = { start: s.end, end: o.start }), i.content = a } return e.schema = n, i }(e, t), n } } function Zd(e, t) { let n = -1; const r = []; for (; ++n < t.length;) { const s = Jd(e, t[n]); r.push(s) } return r } function ep(e, t, n) { if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) { const r = function (e, t, n) { const r = tp(n); if ("element" === t.type) { const s = t.children[t.children.length - 1]; if (r && !n.endTag && s && s.position && s.position.end && (r.end = Object.assign({}, s.position.end)), e.verbose) { const r = {}; let s; if (n.attrs) for (s in n.attrs) Qd.call(n.attrs, s) && (r[Io(e.schema, s).property] = tp(n.attrs[s])); n.startTag; const i = tp(n.startTag), o = n.endTag ? tp(n.endTag) : void 0, a = { opening: i }; o && (a.closing = o), a.properties = r, t.data = { position: a } } } return r }(e, n, t.sourceCodeLocation); r && (e.location = !0, n.position = r) } } function tp(e) { const t = np({ line: e.startLine, column: e.startCol, offset: e.startOffset }), n = np({ line: e.endLine, column: e.endCol, offset: e.endOffset }); return t || n ? { start: t, end: n } : void 0 } function np(e) { return e.line && e.column ? e : void 0 } const rp = {}, sp = {}.hasOwnProperty, ip = Oh("type", { handlers: { root: function (e, t) { const n = { nodeName: "#document", mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks", childNodes: [] }; return n.childNodes = ap(e.children, n, t), lp(e, n), n }, element: function (e, t) { const n = t; let r = n; "element" === e.type && "svg" === e.tagName.toLowerCase() && "html" === n.space && (r = vo); const s = []; let i; if (e.properties) for (i in e.properties) if ("children" !== i && sp.call(e.properties, i)) { const t = op(r, i, e.properties[i]); t && s.push(t) } const o = r.space, a = { nodeName: e.tagName, tagName: e.tagName, attrs: s, namespaceURI: Kd[o], childNodes: [], parentNode: null }; return a.childNodes = ap(e.children, a, r), lp(e, a), "template" === e.tagName && e.content && (a.content = function (e, t) { const n = { nodeName: "#document-fragment", childNodes: [] }; return n.childNodes = ap(e.children, n, t), lp(e, n), n }(e.content, r)), a }, text: function (e) { const t = { nodeName: "#text", value: e.value, parentNode: null }; return lp(e, t), t }, comment: function (e) { const t = { nodeName: "#comment", data: e.value, parentNode: null }; return lp(e, t), t }, doctype: function (e) { const t = { nodeName: "#documentType", name: "html", publicId: "", systemId: "", parentNode: null }; return lp(e, t), t } } }); function op(e, t, n) { const r = Io(e, t); if (!1 === n || null == n || "number" == typeof n && Number.isNaN(n) || !n && r.boolean) return; Array.isArray(n) && (n = r.commaSeparated ? zi(n) : Lo(n)); const s = { name: r.attribute, value: !0 === n ? "" : String(n) }; if (r.space && "html" !== r.space && "svg" !== r.space) { const e = s.name.indexOf(":"); e < 0 ? s.prefix = "" : (s.name = s.name.slice(e + 1), s.prefix = r.attribute.slice(0, e)), s.namespace = Kd[r.space] } return s } function ap(e, t, n) { let r = -1; const s = []; if (e) for (; ++r < e.length;) { const i = ip(e[r], n); i.parentNode = t, s.push(i) } return s } function lp(e, t) { const n = e.position; n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = { startLine: n.start.line, startCol: n.start.column, startOffset: n.start.offset, endLine: n.end.line, endCol: n.end.column, endOffset: n.end.offset }) } const cp = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], up = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]), hp = ""; var dp, pp; (pp = dp || (dp = {}))[pp.EOF = -1] = "EOF", pp[pp.NULL = 0] = "NULL", pp[pp.TABULATION = 9] = "TABULATION", pp[pp.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", pp[pp.LINE_FEED = 10] = "LINE_FEED", pp[pp.FORM_FEED = 12] = "FORM_FEED", pp[pp.SPACE = 32] = "SPACE", pp[pp.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", pp[pp.QUOTATION_MARK = 34] = "QUOTATION_MARK", pp[pp.AMPERSAND = 38] = "AMPERSAND", pp[pp.APOSTROPHE = 39] = "APOSTROPHE", pp[pp.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", pp[pp.SOLIDUS = 47] = "SOLIDUS", pp[pp.DIGIT_0 = 48] = "DIGIT_0", pp[pp.DIGIT_9 = 57] = "DIGIT_9", pp[pp.SEMICOLON = 59] = "SEMICOLON", pp[pp.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", pp[pp.EQUALS_SIGN = 61] = "EQUALS_SIGN", pp[pp.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", pp[pp.QUESTION_MARK = 63] = "QUESTION_MARK", pp[pp.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", pp[pp.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", pp[pp.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", pp[pp.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", pp[pp.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", pp[pp.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z"; const fp = "[CDATA[", mp = "doctype", gp = "script"; function Ep(e) { return e >= 55296 && e <= 57343 } function Tp(e) { return 32 !== e && 10 !== e && 13 !== e && 9 !== e && 12 !== e && e >= 1 && e <= 31 || e >= 127 && e <= 159 } function Ap(e) { return e >= 64976 && e <= 65007 || up.has(e) } var _p, yp, bp, Sp; (yp = _p || (_p = {})).controlCharacterInInputStream = "control-character-in-input-stream", yp.noncharacterInInputStream = "noncharacter-in-input-stream", yp.surrogateInInputStream = "surrogate-in-input-stream", yp.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", yp.endTagWithAttributes = "end-tag-with-attributes", yp.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", yp.unexpectedSolidusInTag = "unexpected-solidus-in-tag", yp.unexpectedNullCharacter = "unexpected-null-character", yp.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", yp.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", yp.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", yp.missingEndTagName = "missing-end-tag-name", yp.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", yp.unknownNamedCharacterReference = "unknown-named-character-reference", yp.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", yp.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", yp.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", yp.eofBeforeTagName = "eof-before-tag-name", yp.eofInTag = "eof-in-tag", yp.missingAttributeValue = "missing-attribute-value", yp.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", yp.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", yp.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", yp.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", yp.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", yp.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", yp.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", yp.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", yp.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", yp.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", yp.cdataInHtmlContent = "cdata-in-html-content", yp.incorrectlyOpenedComment = "incorrectly-opened-comment", yp.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", yp.eofInDoctype = "eof-in-doctype", yp.nestedComment = "nested-comment", yp.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", yp.eofInComment = "eof-in-comment", yp.incorrectlyClosedComment = "incorrectly-closed-comment", yp.eofInCdata = "eof-in-cdata", yp.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", yp.nullCharacterReference = "null-character-reference", yp.surrogateCharacterReference = "surrogate-character-reference", yp.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", yp.controlCharacterReference = "control-character-reference", yp.noncharacterCharacterReference = "noncharacter-character-reference", yp.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", yp.missingDoctypeName = "missing-doctype-name", yp.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", yp.duplicateAttribute = "duplicate-attribute", yp.nonConformingDoctype = "non-conforming-doctype", yp.missingDoctype = "missing-doctype", yp.misplacedDoctype = "misplaced-doctype", yp.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", yp.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", yp.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", yp.openElementsLeftAfterEof = "open-elements-left-after-eof", yp.abandonedHeadElementChild = "abandoned-head-element-child", yp.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", yp.nestedNoscriptInHead = "nested-noscript-in-head", yp.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text"; class kp { constructor(e) { this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = 65536, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1 } get col() { return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos) } get offset() { return this.droppedBufferSize + this.pos } getError(e, t) { const { line: n, col: r, offset: s } = this, i = r + t, o = s + t; return { code: e, startLine: n, endLine: n, startCol: i, endCol: i, startOffset: o, endOffset: o } } _err(e) { this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0))) } _addGap() { this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos } _processSurrogate(e) { if (this.pos !== this.html.length - 1) { const t = this.html.charCodeAt(this.pos + 1); if (function (e) { return e >= 56320 && e <= 57343 }(t)) return this.pos++, this._addGap(), 1024 * (e - 55296) + 9216 + t } else if (!this.lastChunkWritten) return this.endOfChunkHit = !0, dp.EOF; return this._err(_p.surrogateInInputStream), e } willDropParsedChunk() { return this.pos > this.bufferWaterline } dropParsedChunk() { this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0) } write(e, t) { this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = t } insertHtmlAtCurrentPos(e) { this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1 } startsWith(e, t) { if (this.pos + e.length > this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, !1; if (t) return this.html.startsWith(e, this.pos); for (let n = 0; n < e.length; n++)if ((32 | this.html.charCodeAt(this.pos + n)) !== e.charCodeAt(n)) return !1; return !0 } peek(e) { const t = this.pos + e; if (t >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, dp.EOF; const n = this.html.charCodeAt(t); return n === dp.CARRIAGE_RETURN ? dp.LINE_FEED : n } advance() { if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, dp.EOF; let e = this.html.charCodeAt(this.pos); return e === dp.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, dp.LINE_FEED) : e === dp.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Ep(e) && (e = this._processSurrogate(e)), null === this.handler.onParseError || e > 31 && e < 127 || e === dp.LINE_FEED || e === dp.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e) } _checkForProblematicCharacters(e) { Tp(e) ? this._err(_p.controlCharacterInInputStream) : Ap(e) && this._err(_p.noncharacterInInputStream) } retreat(e) { for (this.pos -= e; this.pos < this.lastGapPos;)this.lastGapPos = this.gapStack.pop(), this.pos--; this.isEol = !1 } } function Cp(e, t) { for (let n = e.attrs.length - 1; n >= 0; n--)if (e.attrs[n].name === t) return e.attrs[n].value; return null } (Sp = bp || (bp = {}))[Sp.CHARACTER = 0] = "CHARACTER", Sp[Sp.NULL_CHARACTER = 1] = "NULL_CHARACTER", Sp[Sp.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", Sp[Sp.START_TAG = 3] = "START_TAG", Sp[Sp.END_TAG = 4] = "END_TAG", Sp[Sp.COMMENT = 5] = "COMMENT", Sp[Sp.DOCTYPE = 6] = "DOCTYPE", Sp[Sp.EOF = 7] = "EOF", Sp[Sp.HIBERNATION = 8] = "HIBERNATION"; const Np = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(e => e.charCodeAt(0))), Ip = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]); var Op, xp, Rp, vp, Dp, Lp, Pp, wp, Mp, Fp, Bp, Up, Hp, jp, Gp, zp, Yp, qp; function Vp(e) { return e >= Op.ZERO && e <= Op.NINE } function $p(e) { return e >= Op.UPPER_A && e <= Op.UPPER_F || e >= Op.LOWER_A && e <= Op.LOWER_F } function Wp(e) { return e === Op.EQUALS || function (e) { return e >= Op.UPPER_A && e <= Op.UPPER_Z || e >= Op.LOWER_A && e <= Op.LOWER_Z || Vp(e) }(e) } (xp = Op || (Op = {}))[xp.NUM = 35] = "NUM", xp[xp.SEMI = 59] = "SEMI", xp[xp.EQUALS = 61] = "EQUALS", xp[xp.ZERO = 48] = "ZERO", xp[xp.NINE = 57] = "NINE", xp[xp.LOWER_A = 97] = "LOWER_A", xp[xp.LOWER_F = 102] = "LOWER_F", xp[xp.LOWER_X = 120] = "LOWER_X", xp[xp.LOWER_Z = 122] = "LOWER_Z", xp[xp.UPPER_A = 65] = "UPPER_A", xp[xp.UPPER_F = 70] = "UPPER_F", xp[xp.UPPER_Z = 90] = "UPPER_Z", (vp = Rp || (Rp = {}))[vp.VALUE_LENGTH = 49152] = "VALUE_LENGTH", vp[vp.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", vp[vp.JUMP_TABLE = 127] = "JUMP_TABLE", (Lp = Dp || (Dp = {}))[Lp.EntityStart = 0] = "EntityStart", Lp[Lp.NumericStart = 1] = "NumericStart", Lp[Lp.NumericDecimal = 2] = "NumericDecimal", Lp[Lp.NumericHex = 3] = "NumericHex", Lp[Lp.NamedEntity = 4] = "NamedEntity", (wp = Pp || (Pp = {}))[wp.Legacy = 0] = "Legacy", wp[wp.Strict = 1] = "Strict", wp[wp.Attribute = 2] = "Attribute"; class Kp { constructor(e, t, n) { this.decodeTree = e, this.emitCodePoint = t, this.errors = n, this.state = Dp.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Pp.Strict } startEntity(e) { this.decodeMode = e, this.state = Dp.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1 } write(e, t) { switch (this.state) { case Dp.EntityStart: return e.charCodeAt(t) === Op.NUM ? (this.state = Dp.NumericStart, this.consumed += 1, this.stateNumericStart(e, t + 1)) : (this.state = Dp.NamedEntity, this.stateNamedEntity(e, t)); case Dp.NumericStart: return this.stateNumericStart(e, t); case Dp.NumericDecimal: return this.stateNumericDecimal(e, t); case Dp.NumericHex: return this.stateNumericHex(e, t); case Dp.NamedEntity: return this.stateNamedEntity(e, t) } } stateNumericStart(e, t) { return t >= e.length ? -1 : (32 | e.charCodeAt(t)) === Op.LOWER_X ? (this.state = Dp.NumericHex, this.consumed += 1, this.stateNumericHex(e, t + 1)) : (this.state = Dp.NumericDecimal, this.stateNumericDecimal(e, t)) } addToNumericResult(e, t, n, r) { if (t !== n) { const s = n - t; this.result = this.result * Math.pow(r, s) + Number.parseInt(e.substr(t, s), r), this.consumed += s } } stateNumericHex(e, t) { const n = t; for (; t < e.length;) { const r = e.charCodeAt(t); if (!Vp(r) && !$p(r)) return this.addToNumericResult(e, n, t, 16), this.emitNumericEntity(r, 3); t += 1 } return this.addToNumericResult(e, n, t, 16), -1 } stateNumericDecimal(e, t) { const n = t; for (; t < e.length;) { const r = e.charCodeAt(t); if (!Vp(r)) return this.addToNumericResult(e, n, t, 10), this.emitNumericEntity(r, 2); t += 1 } return this.addToNumericResult(e, n, t, 10), -1 } emitNumericEntity(e, t) { var n; if (this.consumed <= t) return null === (n = this.errors) || void 0 === n || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; if (e === Op.SEMI) this.consumed += 1; else if (this.decodeMode === Pp.Strict) return 0; return this.emitCodePoint(function (e) { var t; return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : null !== (t = Ip.get(e)) && void 0 !== t ? t : e }(this.result), this.consumed), this.errors && (e !== Op.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed } stateNamedEntity(e, t) { const { decodeTree: n } = this; let r = n[this.treeIndex], s = (r & Rp.VALUE_LENGTH) >> 14; for (; t < e.length; t++, this.excess++) { const i = e.charCodeAt(t); if (this.treeIndex = Qp(n, r, this.treeIndex + Math.max(1, s), i), this.treeIndex < 0) return 0 === this.result || this.decodeMode === Pp.Attribute && (0 === s || Wp(i)) ? 0 : this.emitNotTerminatedNamedEntity(); if (r = n[this.treeIndex], s = (r & Rp.VALUE_LENGTH) >> 14, 0 !== s) { if (i === Op.SEMI) return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess); this.decodeMode !== Pp.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0) } } return -1 } emitNotTerminatedNamedEntity() { var e; const { result: t, decodeTree: n } = this, r = (n[t] & Rp.VALUE_LENGTH) >> 14; return this.emitNamedEntityData(t, r, this.consumed), null === (e = this.errors) || void 0 === e || e.missingSemicolonAfterCharacterReference(), this.consumed } emitNamedEntityData(e, t, n) { const { decodeTree: r } = this; return this.emitCodePoint(1 === t ? r[e] & ~Rp.VALUE_LENGTH : r[e + 1], n), 3 === t && this.emitCodePoint(r[e + 2], n), n } end() { var e; switch (this.state) { case Dp.NamedEntity: return 0 === this.result || this.decodeMode === Pp.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity(); case Dp.NumericDecimal: return this.emitNumericEntity(0, 2); case Dp.NumericHex: return this.emitNumericEntity(0, 3); case Dp.NumericStart: return null === (e = this.errors) || void 0 === e || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; case Dp.EntityStart: return 0 } } } function Qp(e, t, n, r) { const s = (t & Rp.BRANCH_LENGTH) >> 7, i = t & Rp.JUMP_TABLE; if (0 === s) return 0 !== i && r === i ? n : -1; if (i) { const t = r - i; return t < 0 || t >= s ? -1 : e[n + t] - 1 } let o = n, a = o + s - 1; for (; o <= a;) { const t = o + a >>> 1, n = e[t]; if (n < r) o = t + 1; else { if (!(n > r)) return e[t + s]; a = t - 1 } } return -1 } (Fp = Mp || (Mp = {})).HTML = "http://www.w3.org/1999/xhtml", Fp.MATHML = "http://www.w3.org/1998/Math/MathML", Fp.SVG = "http://www.w3.org/2000/svg", Fp.XLINK = "http://www.w3.org/1999/xlink", Fp.XML = "http://www.w3.org/XML/1998/namespace", Fp.XMLNS = "http://www.w3.org/2000/xmlns/", (Up = Bp || (Bp = {})).TYPE = "type", Up.ACTION = "action", Up.ENCODING = "encoding", Up.PROMPT = "prompt", Up.NAME = "name", Up.COLOR = "color", Up.FACE = "face", Up.SIZE = "size", (jp = Hp || (Hp = {})).NO_QUIRKS = "no-quirks", jp.QUIRKS = "quirks", jp.LIMITED_QUIRKS = "limited-quirks", (zp = Gp || (Gp = {})).A = "a", zp.ADDRESS = "address", zp.ANNOTATION_XML = "annotation-xml", zp.APPLET = "applet", zp.AREA = "area", zp.ARTICLE = "article", zp.ASIDE = "aside", zp.B = "b", zp.BASE = "base", zp.BASEFONT = "basefont", zp.BGSOUND = "bgsound", zp.BIG = "big", zp.BLOCKQUOTE = "blockquote", zp.BODY = "body", zp.BR = "br", zp.BUTTON = "button", zp.CAPTION = "caption", zp.CENTER = "center", zp.CODE = "code", zp.COL = "col", zp.COLGROUP = "colgroup", zp.DD = "dd", zp.DESC = "desc", zp.DETAILS = "details", zp.DIALOG = "dialog", zp.DIR = "dir", zp.DIV = "div", zp.DL = "dl", zp.DT = "dt", zp.EM = "em", zp.EMBED = "embed", zp.FIELDSET = "fieldset", zp.FIGCAPTION = "figcaption", zp.FIGURE = "figure", zp.FONT = "font", zp.FOOTER = "footer", zp.FOREIGN_OBJECT = "foreignObject", zp.FORM = "form", zp.FRAME = "frame", zp.FRAMESET = "frameset", zp.H1 = "h1", zp.H2 = "h2", zp.H3 = "h3", zp.H4 = "h4", zp.H5 = "h5", zp.H6 = "h6", zp.HEAD = "head", zp.HEADER = "header", zp.HGROUP = "hgroup", zp.HR = "hr", zp.HTML = "html", zp.I = "i", zp.IMG = "img", zp.IMAGE = "image", zp.INPUT = "input", zp.IFRAME = "iframe", zp.KEYGEN = "keygen", zp.LABEL = "label", zp.LI = "li", zp.LINK = "link", zp.LISTING = "listing", zp.MAIN = "main", zp.MALIGNMARK = "malignmark", zp.MARQUEE = "marquee", zp.MATH = "math", zp.MENU = "menu", zp.META = "meta", zp.MGLYPH = "mglyph", zp.MI = "mi", zp.MO = "mo", zp.MN = "mn", zp.MS = "ms", zp.MTEXT = "mtext", zp.NAV = "nav", zp.NOBR = "nobr", zp.NOFRAMES = "noframes", zp.NOEMBED = "noembed", zp.NOSCRIPT = "noscript", zp.OBJECT = "object", zp.OL = "ol", zp.OPTGROUP = "optgroup", zp.OPTION = "option", zp.P = "p", zp.PARAM = "param", zp.PLAINTEXT = "plaintext", zp.PRE = "pre", zp.RB = "rb", zp.RP = "rp", zp.RT = "rt", zp.RTC = "rtc", zp.RUBY = "ruby", zp.S = "s", zp.SCRIPT = "script", zp.SEARCH = "search", zp.SECTION = "section", zp.SELECT = "select", zp.SOURCE = "source", zp.SMALL = "small", zp.SPAN = "span", zp.STRIKE = "strike", zp.STRONG = "strong", zp.STYLE = "style", zp.SUB = "sub", zp.SUMMARY = "summary", zp.SUP = "sup", zp.TABLE = "table", zp.TBODY = "tbody", zp.TEMPLATE = "template", zp.TEXTAREA = "textarea", zp.TFOOT = "tfoot", zp.TD = "td", zp.TH = "th", zp.THEAD = "thead", zp.TITLE = "title", zp.TR = "tr", zp.TRACK = "track", zp.TT = "tt", zp.U = "u", zp.UL = "ul", zp.SVG = "svg", zp.VAR = "var", zp.WBR = "wbr", zp.XMP = "xmp", (qp = Yp || (Yp = {}))[qp.UNKNOWN = 0] = "UNKNOWN", qp[qp.A = 1] = "A", qp[qp.ADDRESS = 2] = "ADDRESS", qp[qp.ANNOTATION_XML = 3] = "ANNOTATION_XML", qp[qp.APPLET = 4] = "APPLET", qp[qp.AREA = 5] = "AREA", qp[qp.ARTICLE = 6] = "ARTICLE", qp[qp.ASIDE = 7] = "ASIDE", qp[qp.B = 8] = "B", qp[qp.BASE = 9] = "BASE", qp[qp.BASEFONT = 10] = "BASEFONT", qp[qp.BGSOUND = 11] = "BGSOUND", qp[qp.BIG = 12] = "BIG", qp[qp.BLOCKQUOTE = 13] = "BLOCKQUOTE", qp[qp.BODY = 14] = "BODY", qp[qp.BR = 15] = "BR", qp[qp.BUTTON = 16] = "BUTTON", qp[qp.CAPTION = 17] = "CAPTION", qp[qp.CENTER = 18] = "CENTER", qp[qp.CODE = 19] = "CODE", qp[qp.COL = 20] = "COL", qp[qp.COLGROUP = 21] = "COLGROUP", qp[qp.DD = 22] = "DD", qp[qp.DESC = 23] = "DESC", qp[qp.DETAILS = 24] = "DETAILS", qp[qp.DIALOG = 25] = "DIALOG", qp[qp.DIR = 26] = "DIR", qp[qp.DIV = 27] = "DIV", qp[qp.DL = 28] = "DL", qp[qp.DT = 29] = "DT", qp[qp.EM = 30] = "EM", qp[qp.EMBED = 31] = "EMBED", qp[qp.FIELDSET = 32] = "FIELDSET", qp[qp.FIGCAPTION = 33] = "FIGCAPTION", qp[qp.FIGURE = 34] = "FIGURE", qp[qp.FONT = 35] = "FONT", qp[qp.FOOTER = 36] = "FOOTER", qp[qp.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", qp[qp.FORM = 38] = "FORM", qp[qp.FRAME = 39] = "FRAME", qp[qp.FRAMESET = 40] = "FRAMESET", qp[qp.H1 = 41] = "H1", qp[qp.H2 = 42] = "H2", qp[qp.H3 = 43] = "H3", qp[qp.H4 = 44] = "H4", qp[qp.H5 = 45] = "H5", qp[qp.H6 = 46] = "H6", qp[qp.HEAD = 47] = "HEAD", qp[qp.HEADER = 48] = "HEADER", qp[qp.HGROUP = 49] = "HGROUP", qp[qp.HR = 50] = "HR", qp[qp.HTML = 51] = "HTML", qp[qp.I = 52] = "I", qp[qp.IMG = 53] = "IMG", qp[qp.IMAGE = 54] = "IMAGE", qp[qp.INPUT = 55] = "INPUT", qp[qp.IFRAME = 56] = "IFRAME", qp[qp.KEYGEN = 57] = "KEYGEN", qp[qp.LABEL = 58] = "LABEL", qp[qp.LI = 59] = "LI", qp[qp.LINK = 60] = "LINK", qp[qp.LISTING = 61] = "LISTING", qp[qp.MAIN = 62] = "MAIN", qp[qp.MALIGNMARK = 63] = "MALIGNMARK", qp[qp.MARQUEE = 64] = "MARQUEE", qp[qp.MATH = 65] = "MATH", qp[qp.MENU = 66] = "MENU", qp[qp.META = 67] = "META", qp[qp.MGLYPH = 68] = "MGLYPH", qp[qp.MI = 69] = "MI", qp[qp.MO = 70] = "MO", qp[qp.MN = 71] = "MN", qp[qp.MS = 72] = "MS", qp[qp.MTEXT = 73] = "MTEXT", qp[qp.NAV = 74] = "NAV", qp[qp.NOBR = 75] = "NOBR", qp[qp.NOFRAMES = 76] = "NOFRAMES", qp[qp.NOEMBED = 77] = "NOEMBED", qp[qp.NOSCRIPT = 78] = "NOSCRIPT", qp[qp.OBJECT = 79] = "OBJECT", qp[qp.OL = 80] = "OL", qp[qp.OPTGROUP = 81] = "OPTGROUP", qp[qp.OPTION = 82] = "OPTION", qp[qp.P = 83] = "P", qp[qp.PARAM = 84] = "PARAM", qp[qp.PLAINTEXT = 85] = "PLAINTEXT", qp[qp.PRE = 86] = "PRE", qp[qp.RB = 87] = "RB", qp[qp.RP = 88] = "RP", qp[qp.RT = 89] = "RT", qp[qp.RTC = 90] = "RTC", qp[qp.RUBY = 91] = "RUBY", qp[qp.S = 92] = "S", qp[qp.SCRIPT = 93] = "SCRIPT", qp[qp.SEARCH = 94] = "SEARCH", qp[qp.SECTION = 95] = "SECTION", qp[qp.SELECT = 96] = "SELECT", qp[qp.SOURCE = 97] = "SOURCE", qp[qp.SMALL = 98] = "SMALL", qp[qp.SPAN = 99] = "SPAN", qp[qp.STRIKE = 100] = "STRIKE", qp[qp.STRONG = 101] = "STRONG", qp[qp.STYLE = 102] = "STYLE", qp[qp.SUB = 103] = "SUB", qp[qp.SUMMARY = 104] = "SUMMARY", qp[qp.SUP = 105] = "SUP", qp[qp.TABLE = 106] = "TABLE", qp[qp.TBODY = 107] = "TBODY", qp[qp.TEMPLATE = 108] = "TEMPLATE", qp[qp.TEXTAREA = 109] = "TEXTAREA", qp[qp.TFOOT = 110] = "TFOOT", qp[qp.TD = 111] = "TD", qp[qp.TH = 112] = "TH", qp[qp.THEAD = 113] = "THEAD", qp[qp.TITLE = 114] = "TITLE", qp[qp.TR = 115] = "TR", qp[qp.TRACK = 116] = "TRACK", qp[qp.TT = 117] = "TT", qp[qp.U = 118] = "U", qp[qp.UL = 119] = "UL", qp[qp.SVG = 120] = "SVG", qp[qp.VAR = 121] = "VAR", qp[qp.WBR = 122] = "WBR", qp[qp.XMP = 123] = "XMP"; const Xp = new Map([[Gp.A, Yp.A], [Gp.ADDRESS, Yp.ADDRESS], [Gp.ANNOTATION_XML, Yp.ANNOTATION_XML], [Gp.APPLET, Yp.APPLET], [Gp.AREA, Yp.AREA], [Gp.ARTICLE, Yp.ARTICLE], [Gp.ASIDE, Yp.ASIDE], [Gp.B, Yp.B], [Gp.BASE, Yp.BASE], [Gp.BASEFONT, Yp.BASEFONT], [Gp.BGSOUND, Yp.BGSOUND], [Gp.BIG, Yp.BIG], [Gp.BLOCKQUOTE, Yp.BLOCKQUOTE], [Gp.BODY, Yp.BODY], [Gp.BR, Yp.BR], [Gp.BUTTON, Yp.BUTTON], [Gp.CAPTION, Yp.CAPTION], [Gp.CENTER, Yp.CENTER], [Gp.CODE, Yp.CODE], [Gp.COL, Yp.COL], [Gp.COLGROUP, Yp.COLGROUP], [Gp.DD, Yp.DD], [Gp.DESC, Yp.DESC], [Gp.DETAILS, Yp.DETAILS], [Gp.DIALOG, Yp.DIALOG], [Gp.DIR, Yp.DIR], [Gp.DIV, Yp.DIV], [Gp.DL, Yp.DL], [Gp.DT, Yp.DT], [Gp.EM, Yp.EM], [Gp.EMBED, Yp.EMBED], [Gp.FIELDSET, Yp.FIELDSET], [Gp.FIGCAPTION, Yp.FIGCAPTION], [Gp.FIGURE, Yp.FIGURE], [Gp.FONT, Yp.FONT], [Gp.FOOTER, Yp.FOOTER], [Gp.FOREIGN_OBJECT, Yp.FOREIGN_OBJECT], [Gp.FORM, Yp.FORM], [Gp.FRAME, Yp.FRAME], [Gp.FRAMESET, Yp.FRAMESET], [Gp.H1, Yp.H1], [Gp.H2, Yp.H2], [Gp.H3, Yp.H3], [Gp.H4, Yp.H4], [Gp.H5, Yp.H5], [Gp.H6, Yp.H6], [Gp.HEAD, Yp.HEAD], [Gp.HEADER, Yp.HEADER], [Gp.HGROUP, Yp.HGROUP], [Gp.HR, Yp.HR], [Gp.HTML, Yp.HTML], [Gp.I, Yp.I], [Gp.IMG, Yp.IMG], [Gp.IMAGE, Yp.IMAGE], [Gp.INPUT, Yp.INPUT], [Gp.IFRAME, Yp.IFRAME], [Gp.KEYGEN, Yp.KEYGEN], [Gp.LABEL, Yp.LABEL], [Gp.LI, Yp.LI], [Gp.LINK, Yp.LINK], [Gp.LISTING, Yp.LISTING], [Gp.MAIN, Yp.MAIN], [Gp.MALIGNMARK, Yp.MALIGNMARK], [Gp.MARQUEE, Yp.MARQUEE], [Gp.MATH, Yp.MATH], [Gp.MENU, Yp.MENU], [Gp.META, Yp.META], [Gp.MGLYPH, Yp.MGLYPH], [Gp.MI, Yp.MI], [Gp.MO, Yp.MO], [Gp.MN, Yp.MN], [Gp.MS, Yp.MS], [Gp.MTEXT, Yp.MTEXT], [Gp.NAV, Yp.NAV], [Gp.NOBR, Yp.NOBR], [Gp.NOFRAMES, Yp.NOFRAMES], [Gp.NOEMBED, Yp.NOEMBED], [Gp.NOSCRIPT, Yp.NOSCRIPT], [Gp.OBJECT, Yp.OBJECT], [Gp.OL, Yp.OL], [Gp.OPTGROUP, Yp.OPTGROUP], [Gp.OPTION, Yp.OPTION], [Gp.P, Yp.P], [Gp.PARAM, Yp.PARAM], [Gp.PLAINTEXT, Yp.PLAINTEXT], [Gp.PRE, Yp.PRE], [Gp.RB, Yp.RB], [Gp.RP, Yp.RP], [Gp.RT, Yp.RT], [Gp.RTC, Yp.RTC], [Gp.RUBY, Yp.RUBY], [Gp.S, Yp.S], [Gp.SCRIPT, Yp.SCRIPT], [Gp.SEARCH, Yp.SEARCH], [Gp.SECTION, Yp.SECTION], [Gp.SELECT, Yp.SELECT], [Gp.SOURCE, Yp.SOURCE], [Gp.SMALL, Yp.SMALL], [Gp.SPAN, Yp.SPAN], [Gp.STRIKE, Yp.STRIKE], [Gp.STRONG, Yp.STRONG], [Gp.STYLE, Yp.STYLE], [Gp.SUB, Yp.SUB], [Gp.SUMMARY, Yp.SUMMARY], [Gp.SUP, Yp.SUP], [Gp.TABLE, Yp.TABLE], [Gp.TBODY, Yp.TBODY], [Gp.TEMPLATE, Yp.TEMPLATE], [Gp.TEXTAREA, Yp.TEXTAREA], [Gp.TFOOT, Yp.TFOOT], [Gp.TD, Yp.TD], [Gp.TH, Yp.TH], [Gp.THEAD, Yp.THEAD], [Gp.TITLE, Yp.TITLE], [Gp.TR, Yp.TR], [Gp.TRACK, Yp.TRACK], [Gp.TT, Yp.TT], [Gp.U, Yp.U], [Gp.UL, Yp.UL], [Gp.SVG, Yp.SVG], [Gp.VAR, Yp.VAR], [Gp.WBR, Yp.WBR], [Gp.XMP, Yp.XMP]]); function Jp(e) { var t; return null !== (t = Xp.get(e)) && void 0 !== t ? t : Yp.UNKNOWN } const Zp = Yp, ef = { [Mp.HTML]: new Set([Zp.ADDRESS, Zp.APPLET, Zp.AREA, Zp.ARTICLE, Zp.ASIDE, Zp.BASE, Zp.BASEFONT, Zp.BGSOUND, Zp.BLOCKQUOTE, Zp.BODY, Zp.BR, Zp.BUTTON, Zp.CAPTION, Zp.CENTER, Zp.COL, Zp.COLGROUP, Zp.DD, Zp.DETAILS, Zp.DIR, Zp.DIV, Zp.DL, Zp.DT, Zp.EMBED, Zp.FIELDSET, Zp.FIGCAPTION, Zp.FIGURE, Zp.FOOTER, Zp.FORM, Zp.FRAME, Zp.FRAMESET, Zp.H1, Zp.H2, Zp.H3, Zp.H4, Zp.H5, Zp.H6, Zp.HEAD, Zp.HEADER, Zp.HGROUP, Zp.HR, Zp.HTML, Zp.IFRAME, Zp.IMG, Zp.INPUT, Zp.LI, Zp.LINK, Zp.LISTING, Zp.MAIN, Zp.MARQUEE, Zp.MENU, Zp.META, Zp.NAV, Zp.NOEMBED, Zp.NOFRAMES, Zp.NOSCRIPT, Zp.OBJECT, Zp.OL, Zp.P, Zp.PARAM, Zp.PLAINTEXT, Zp.PRE, Zp.SCRIPT, Zp.SECTION, Zp.SELECT, Zp.SOURCE, Zp.STYLE, Zp.SUMMARY, Zp.TABLE, Zp.TBODY, Zp.TD, Zp.TEMPLATE, Zp.TEXTAREA, Zp.TFOOT, Zp.TH, Zp.THEAD, Zp.TITLE, Zp.TR, Zp.TRACK, Zp.UL, Zp.WBR, Zp.XMP]), [Mp.MATHML]: new Set([Zp.MI, Zp.MO, Zp.MN, Zp.MS, Zp.MTEXT, Zp.ANNOTATION_XML]), [Mp.SVG]: new Set([Zp.TITLE, Zp.FOREIGN_OBJECT, Zp.DESC]), [Mp.XLINK]: new Set, [Mp.XML]: new Set, [Mp.XMLNS]: new Set }, tf = new Set([Zp.H1, Zp.H2, Zp.H3, Zp.H4, Zp.H5, Zp.H6]); var nf, rf; Gp.STYLE, Gp.SCRIPT, Gp.XMP, Gp.IFRAME, Gp.NOEMBED, Gp.NOFRAMES, Gp.PLAINTEXT, (rf = nf || (nf = {}))[rf.DATA = 0] = "DATA", rf[rf.RCDATA = 1] = "RCDATA", rf[rf.RAWTEXT = 2] = "RAWTEXT", rf[rf.SCRIPT_DATA = 3] = "SCRIPT_DATA", rf[rf.PLAINTEXT = 4] = "PLAINTEXT", rf[rf.TAG_OPEN = 5] = "TAG_OPEN", rf[rf.END_TAG_OPEN = 6] = "END_TAG_OPEN", rf[rf.TAG_NAME = 7] = "TAG_NAME", rf[rf.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", rf[rf.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", rf[rf.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", rf[rf.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", rf[rf.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", rf[rf.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", rf[rf.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", rf[rf.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", rf[rf.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", rf[rf.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", rf[rf.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", rf[rf.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", rf[rf.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", rf[rf.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", rf[rf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", rf[rf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", rf[rf.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", rf[rf.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", rf[rf.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", rf[rf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", rf[rf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", rf[rf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", rf[rf.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", rf[rf.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", rf[rf.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", rf[rf.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", rf[rf.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", rf[rf.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", rf[rf.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", rf[rf.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", rf[rf.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", rf[rf.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", rf[rf.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", rf[rf.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", rf[rf.COMMENT_START = 42] = "COMMENT_START", rf[rf.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", rf[rf.COMMENT = 44] = "COMMENT", rf[rf.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", rf[rf.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", rf[rf.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", rf[rf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", rf[rf.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", rf[rf.COMMENT_END = 50] = "COMMENT_END", rf[rf.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", rf[rf.DOCTYPE = 52] = "DOCTYPE", rf[rf.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", rf[rf.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", rf[rf.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", rf[rf.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", rf[rf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", rf[rf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", rf[rf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", rf[rf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", rf[rf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", rf[rf.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", rf[rf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", rf[rf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", rf[rf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", rf[rf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", rf[rf.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", rf[rf.CDATA_SECTION = 68] = "CDATA_SECTION", rf[rf.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", rf[rf.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", rf[rf.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", rf[rf.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND"; const sf = { DATA: nf.DATA, RCDATA: nf.RCDATA, RAWTEXT: nf.RAWTEXT, SCRIPT_DATA: nf.SCRIPT_DATA, PLAINTEXT: nf.PLAINTEXT, CDATA_SECTION: nf.CDATA_SECTION }; function of(e) { return e >= dp.LATIN_CAPITAL_A && e <= dp.LATIN_CAPITAL_Z } function af(e) { return function (e) { return e >= dp.LATIN_SMALL_A && e <= dp.LATIN_SMALL_Z }(e) || of(e) } function lf(e) { return af(e) || function (e) { return e >= dp.DIGIT_0 && e <= dp.DIGIT_9 }(e) } function cf(e) { return e + 32 } function uf(e) { return e === dp.SPACE || e === dp.LINE_FEED || e === dp.TABULATION || e === dp.FORM_FEED } function hf(e) { return uf(e) || e === dp.SOLIDUS || e === dp.GREATER_THAN_SIGN } class df { constructor(e, t) { this.options = e, this.handler = t, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = nf.DATA, this.returnState = nf.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new kp(t), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new Kp(Np, (e, t) => { this.preprocessor.pos = this.entityStartPos + t - 1, this._flushCodePointConsumedAsCharacterReference(e) }, t.onParseError ? { missingSemicolonAfterCharacterReference: () => { this._err(_p.missingSemicolonAfterCharacterReference, 1) }, absenceOfDigitsInNumericCharacterReference: e => { this._err(_p.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + e) }, validateNumericCharacterReference: e => { const t = function (e) { return e === dp.NULL ? _p.nullCharacterReference : e > 1114111 ? _p.characterReferenceOutsideUnicodeRange : Ep(e) ? _p.surrogateCharacterReference : Ap(e) ? _p.noncharacterCharacterReference : Tp(e) || e === dp.CARRIAGE_RETURN ? _p.controlCharacterReference : null }(e); t && this._err(t, 1) } } : void 0) } _err(e, t = 0) { var n, r; null === (r = (n = this.handler).onParseError) || void 0 === r || r.call(n, this.preprocessor.getError(e, t)) } getCurrentLocation(e) { return this.options.sourceCodeLocationInfo ? { startLine: this.preprocessor.line, startCol: this.preprocessor.col - e, startOffset: this.preprocessor.offset - e, endLine: -1, endCol: -1, endOffset: -1 } : null } _runParsingLoop() { if (!this.inLoop) { for (this.inLoop = !0; this.active && !this.paused;) { this.consumedAfterSnapshot = 0; const e = this._consume(); this._ensureHibernation() || this._callState(e) } this.inLoop = !1 } } pause() { this.paused = !0 } resume(e) { if (!this.paused) throw new Error("Parser was already resumed"); this.paused = !1, this.inLoop || (this._runParsingLoop(), this.paused || null == e || e()) } write(e, t, n) { this.active = !0, this.preprocessor.write(e, t), this._runParsingLoop(), this.paused || null == n || n() } insertHtmlAtCurrentPos(e) { this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop() } _ensureHibernation() { return !!this.preprocessor.endOfChunkHit && (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) } _consume() { return this.consumedAfterSnapshot++, this.preprocessor.advance() } _advanceBy(e) { this.consumedAfterSnapshot += e; for (let t = 0; t < e; t++)this.preprocessor.advance() } _consumeSequenceIfMatch(e, t) { return !!this.preprocessor.startsWith(e, t) && (this._advanceBy(e.length - 1), !0) } _createStartTagToken() { this.currentToken = { type: bp.START_TAG, tagName: "", tagID: Yp.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(1) } } _createEndTagToken() { this.currentToken = { type: bp.END_TAG, tagName: "", tagID: Yp.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(2) } } _createCommentToken(e) { this.currentToken = { type: bp.COMMENT, data: "", location: this.getCurrentLocation(e) } } _createDoctypeToken(e) { this.currentToken = { type: bp.DOCTYPE, name: e, forceQuirks: !1, publicId: null, systemId: null, location: this.currentLocation } } _createCharacterToken(e, t) { this.currentCharacterToken = { type: e, chars: t, location: this.currentLocation } } _createAttr(e) { this.currentAttr = { name: e, value: "" }, this.currentLocation = this.getCurrentLocation(0) } _leaveAttrName() { var e, t; const n = this.currentToken; null === Cp(n, this.currentAttr.name) ? (n.attrs.push(this.currentAttr), n.location && this.currentLocation && ((null !== (e = (t = n.location).attrs) && void 0 !== e ? e : t.attrs = Object.create(null))[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue())) : this._err(_p.duplicateAttribute) } _leaveAttrValue() { this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset) } prepareToken(e) { this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1) } emitCurrentTagToken() { const e = this.currentToken; this.prepareToken(e), e.tagID = Jp(e.tagName), e.type === bp.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(_p.endTagWithAttributes), e.selfClosing && this._err(_p.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk() } emitCurrentComment(e) { this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk() } emitCurrentDoctype(e) { this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk() } _emitCurrentCharacterToken(e) { if (this.currentCharacterToken) { switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) { case bp.CHARACTER: this.handler.onCharacter(this.currentCharacterToken); break; case bp.NULL_CHARACTER: this.handler.onNullCharacter(this.currentCharacterToken); break; case bp.WHITESPACE_CHARACTER: this.handler.onWhitespaceCharacter(this.currentCharacterToken) }this.currentCharacterToken = null } } _emitEOFToken() { const e = this.getCurrentLocation(0); e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: bp.EOF, location: e }), this.active = !1 } _appendCharToCurrentCharacterToken(e, t) { if (this.currentCharacterToken) { if (this.currentCharacterToken.type === e) return void (this.currentCharacterToken.chars += t); this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk() } this._createCharacterToken(e, t) } _emitCodePoint(e) { const t = uf(e) ? bp.WHITESPACE_CHARACTER : e === dp.NULL ? bp.NULL_CHARACTER : bp.CHARACTER; this._appendCharToCurrentCharacterToken(t, String.fromCodePoint(e)) } _emitChars(e) { this._appendCharToCurrentCharacterToken(bp.CHARACTER, e) } _startCharacterReference() { this.returnState = this.state, this.state = nf.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? Pp.Attribute : Pp.Legacy) } _isCharacterReferenceInAttribute() { return this.returnState === nf.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === nf.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === nf.ATTRIBUTE_VALUE_UNQUOTED } _flushCodePointConsumedAsCharacterReference(e) { this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e) } _callState(e) { switch (this.state) { case nf.DATA: this._stateData(e); break; case nf.RCDATA: this._stateRcdata(e); break; case nf.RAWTEXT: this._stateRawtext(e); break; case nf.SCRIPT_DATA: this._stateScriptData(e); break; case nf.PLAINTEXT: this._statePlaintext(e); break; case nf.TAG_OPEN: this._stateTagOpen(e); break; case nf.END_TAG_OPEN: this._stateEndTagOpen(e); break; case nf.TAG_NAME: this._stateTagName(e); break; case nf.RCDATA_LESS_THAN_SIGN: this._stateRcdataLessThanSign(e); break; case nf.RCDATA_END_TAG_OPEN: this._stateRcdataEndTagOpen(e); break; case nf.RCDATA_END_TAG_NAME: this._stateRcdataEndTagName(e); break; case nf.RAWTEXT_LESS_THAN_SIGN: this._stateRawtextLessThanSign(e); break; case nf.RAWTEXT_END_TAG_OPEN: this._stateRawtextEndTagOpen(e); break; case nf.RAWTEXT_END_TAG_NAME: this._stateRawtextEndTagName(e); break; case nf.SCRIPT_DATA_LESS_THAN_SIGN: this._stateScriptDataLessThanSign(e); break; case nf.SCRIPT_DATA_END_TAG_OPEN: this._stateScriptDataEndTagOpen(e); break; case nf.SCRIPT_DATA_END_TAG_NAME: this._stateScriptDataEndTagName(e); break; case nf.SCRIPT_DATA_ESCAPE_START: this._stateScriptDataEscapeStart(e); break; case nf.SCRIPT_DATA_ESCAPE_START_DASH: this._stateScriptDataEscapeStartDash(e); break; case nf.SCRIPT_DATA_ESCAPED: this._stateScriptDataEscaped(e); break; case nf.SCRIPT_DATA_ESCAPED_DASH: this._stateScriptDataEscapedDash(e); break; case nf.SCRIPT_DATA_ESCAPED_DASH_DASH: this._stateScriptDataEscapedDashDash(e); break; case nf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: this._stateScriptDataEscapedLessThanSign(e); break; case nf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: this._stateScriptDataEscapedEndTagOpen(e); break; case nf.SCRIPT_DATA_ESCAPED_END_TAG_NAME: this._stateScriptDataEscapedEndTagName(e); break; case nf.SCRIPT_DATA_DOUBLE_ESCAPE_START: this._stateScriptDataDoubleEscapeStart(e); break; case nf.SCRIPT_DATA_DOUBLE_ESCAPED: this._stateScriptDataDoubleEscaped(e); break; case nf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: this._stateScriptDataDoubleEscapedDash(e); break; case nf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: this._stateScriptDataDoubleEscapedDashDash(e); break; case nf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: this._stateScriptDataDoubleEscapedLessThanSign(e); break; case nf.SCRIPT_DATA_DOUBLE_ESCAPE_END: this._stateScriptDataDoubleEscapeEnd(e); break; case nf.BEFORE_ATTRIBUTE_NAME: this._stateBeforeAttributeName(e); break; case nf.ATTRIBUTE_NAME: this._stateAttributeName(e); break; case nf.AFTER_ATTRIBUTE_NAME: this._stateAfterAttributeName(e); break; case nf.BEFORE_ATTRIBUTE_VALUE: this._stateBeforeAttributeValue(e); break; case nf.ATTRIBUTE_VALUE_DOUBLE_QUOTED: this._stateAttributeValueDoubleQuoted(e); break; case nf.ATTRIBUTE_VALUE_SINGLE_QUOTED: this._stateAttributeValueSingleQuoted(e); break; case nf.ATTRIBUTE_VALUE_UNQUOTED: this._stateAttributeValueUnquoted(e); break; case nf.AFTER_ATTRIBUTE_VALUE_QUOTED: this._stateAfterAttributeValueQuoted(e); break; case nf.SELF_CLOSING_START_TAG: this._stateSelfClosingStartTag(e); break; case nf.BOGUS_COMMENT: this._stateBogusComment(e); break; case nf.MARKUP_DECLARATION_OPEN: this._stateMarkupDeclarationOpen(e); break; case nf.COMMENT_START: this._stateCommentStart(e); break; case nf.COMMENT_START_DASH: this._stateCommentStartDash(e); break; case nf.COMMENT: this._stateComment(e); break; case nf.COMMENT_LESS_THAN_SIGN: this._stateCommentLessThanSign(e); break; case nf.COMMENT_LESS_THAN_SIGN_BANG: this._stateCommentLessThanSignBang(e); break; case nf.COMMENT_LESS_THAN_SIGN_BANG_DASH: this._stateCommentLessThanSignBangDash(e); break; case nf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: this._stateCommentLessThanSignBangDashDash(e); break; case nf.COMMENT_END_DASH: this._stateCommentEndDash(e); break; case nf.COMMENT_END: this._stateCommentEnd(e); break; case nf.COMMENT_END_BANG: this._stateCommentEndBang(e); break; case nf.DOCTYPE: this._stateDoctype(e); break; case nf.BEFORE_DOCTYPE_NAME: this._stateBeforeDoctypeName(e); break; case nf.DOCTYPE_NAME: this._stateDoctypeName(e); break; case nf.AFTER_DOCTYPE_NAME: this._stateAfterDoctypeName(e); break; case nf.AFTER_DOCTYPE_PUBLIC_KEYWORD: this._stateAfterDoctypePublicKeyword(e); break; case nf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: this._stateBeforeDoctypePublicIdentifier(e); break; case nf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: this._stateDoctypePublicIdentifierDoubleQuoted(e); break; case nf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: this._stateDoctypePublicIdentifierSingleQuoted(e); break; case nf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: this._stateAfterDoctypePublicIdentifier(e); break; case nf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: this._stateBetweenDoctypePublicAndSystemIdentifiers(e); break; case nf.AFTER_DOCTYPE_SYSTEM_KEYWORD: this._stateAfterDoctypeSystemKeyword(e); break; case nf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: this._stateBeforeDoctypeSystemIdentifier(e); break; case nf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: this._stateDoctypeSystemIdentifierDoubleQuoted(e); break; case nf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: this._stateDoctypeSystemIdentifierSingleQuoted(e); break; case nf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: this._stateAfterDoctypeSystemIdentifier(e); break; case nf.BOGUS_DOCTYPE: this._stateBogusDoctype(e); break; case nf.CDATA_SECTION: this._stateCdataSection(e); break; case nf.CDATA_SECTION_BRACKET: this._stateCdataSectionBracket(e); break; case nf.CDATA_SECTION_END: this._stateCdataSectionEnd(e); break; case nf.CHARACTER_REFERENCE: this._stateCharacterReference(); break; case nf.AMBIGUOUS_AMPERSAND: this._stateAmbiguousAmpersand(e); break; default: throw new Error("Unknown state") } } _stateData(e) { switch (e) { case dp.LESS_THAN_SIGN: this.state = nf.TAG_OPEN; break; case dp.AMPERSAND: this._startCharacterReference(); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitCodePoint(e); break; case dp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateRcdata(e) { switch (e) { case dp.AMPERSAND: this._startCharacterReference(); break; case dp.LESS_THAN_SIGN: this.state = nf.RCDATA_LESS_THAN_SIGN; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitChars(hp); break; case dp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateRawtext(e) { switch (e) { case dp.LESS_THAN_SIGN: this.state = nf.RAWTEXT_LESS_THAN_SIGN; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitChars(hp); break; case dp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptData(e) { switch (e) { case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_LESS_THAN_SIGN; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitChars(hp); break; case dp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _statePlaintext(e) { switch (e) { case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitChars(hp); break; case dp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateTagOpen(e) { if (af(e)) this._createStartTagToken(), this.state = nf.TAG_NAME, this._stateTagName(e); else switch (e) { case dp.EXCLAMATION_MARK: this.state = nf.MARKUP_DECLARATION_OPEN; break; case dp.SOLIDUS: this.state = nf.END_TAG_OPEN; break; case dp.QUESTION_MARK: this._err(_p.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = nf.BOGUS_COMMENT, this._stateBogusComment(e); break; case dp.EOF: this._err(_p.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken(); break; default: this._err(_p.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = nf.DATA, this._stateData(e) } } _stateEndTagOpen(e) { if (af(e)) this._createEndTagToken(), this.state = nf.TAG_NAME, this._stateTagName(e); else switch (e) { case dp.GREATER_THAN_SIGN: this._err(_p.missingEndTagName), this.state = nf.DATA; break; case dp.EOF: this._err(_p.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken(); break; default: this._err(_p.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = nf.BOGUS_COMMENT, this._stateBogusComment(e) } } _stateTagName(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this.state = nf.BEFORE_ATTRIBUTE_NAME; break; case dp.SOLIDUS: this.state = nf.SELF_CLOSING_START_TAG; break; case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentTagToken(); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.tagName += hp; break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: t.tagName += String.fromCodePoint(of(e) ? cf(e) : e) } } _stateRcdataLessThanSign(e) { e === dp.SOLIDUS ? this.state = nf.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = nf.RCDATA, this._stateRcdata(e)) } _stateRcdataEndTagOpen(e) { af(e) ? (this.state = nf.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = nf.RCDATA, this._stateRcdata(e)) } handleSpecialEndTag(e) { if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation(); switch (this._createEndTagToken(), this.currentToken.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: return this._advanceBy(this.lastStartTagName.length), this.state = nf.BEFORE_ATTRIBUTE_NAME, !1; case dp.SOLIDUS: return this._advanceBy(this.lastStartTagName.length), this.state = nf.SELF_CLOSING_START_TAG, !1; case dp.GREATER_THAN_SIGN: return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = nf.DATA, !1; default: return !this._ensureHibernation() } } _stateRcdataEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = nf.RCDATA, this._stateRcdata(e)) } _stateRawtextLessThanSign(e) { e === dp.SOLIDUS ? this.state = nf.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = nf.RAWTEXT, this._stateRawtext(e)) } _stateRawtextEndTagOpen(e) { af(e) ? (this.state = nf.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = nf.RAWTEXT, this._stateRawtext(e)) } _stateRawtextEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = nf.RAWTEXT, this._stateRawtext(e)) } _stateScriptDataLessThanSign(e) { switch (e) { case dp.SOLIDUS: this.state = nf.SCRIPT_DATA_END_TAG_OPEN; break; case dp.EXCLAMATION_MARK: this.state = nf.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!"); break; default: this._emitChars("<"), this.state = nf.SCRIPT_DATA, this._stateScriptData(e) } } _stateScriptDataEndTagOpen(e) { af(e) ? (this.state = nf.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = nf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = nf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscapeStart(e) { e === dp.HYPHEN_MINUS ? (this.state = nf.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = nf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscapeStartDash(e) { e === dp.HYPHEN_MINUS ? (this.state = nf.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = nf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscaped(e) { switch (e) { case dp.HYPHEN_MINUS: this.state = nf.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-"); break; case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitChars(hp); break; case dp.EOF: this._err(_p.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptDataEscapedDash(e) { switch (e) { case dp.HYPHEN_MINUS: this.state = nf.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-"); break; case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.state = nf.SCRIPT_DATA_ESCAPED, this._emitChars(hp); break; case dp.EOF: this._err(_p.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = nf.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataEscapedDashDash(e) { switch (e) { case dp.HYPHEN_MINUS: this._emitChars("-"); break; case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case dp.GREATER_THAN_SIGN: this.state = nf.SCRIPT_DATA, this._emitChars(">"); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.state = nf.SCRIPT_DATA_ESCAPED, this._emitChars(hp); break; case dp.EOF: this._err(_p.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = nf.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataEscapedLessThanSign(e) { e === dp.SOLIDUS ? this.state = nf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : af(e) ? (this._emitChars("<"), this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = nf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataEscapedEndTagOpen(e) { af(e) ? (this.state = nf.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = nf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataEscapedEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = nf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataDoubleEscapeStart(e) { if (this.preprocessor.startsWith(gp, !1) && hf(this.preprocessor.peek(6))) { this._emitCodePoint(e); for (let e = 0; e < 6; e++)this._emitCodePoint(this._consume()); this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED } else this._ensureHibernation() || (this.state = nf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataDoubleEscaped(e) { switch (e) { case dp.HYPHEN_MINUS: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-"); break; case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._emitChars(hp); break; case dp.EOF: this._err(_p.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedDash(e) { switch (e) { case dp.HYPHEN_MINUS: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-"); break; case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(hp); break; case dp.EOF: this._err(_p.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedDashDash(e) { switch (e) { case dp.HYPHEN_MINUS: this._emitChars("-"); break; case dp.LESS_THAN_SIGN: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case dp.GREATER_THAN_SIGN: this.state = nf.SCRIPT_DATA, this._emitChars(">"); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(hp); break; case dp.EOF: this._err(_p.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedLessThanSign(e) { e === dp.SOLIDUS ? (this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e)) } _stateScriptDataDoubleEscapeEnd(e) { if (this.preprocessor.startsWith(gp, !1) && hf(this.preprocessor.peek(6))) { this._emitCodePoint(e); for (let e = 0; e < 6; e++)this._emitCodePoint(this._consume()); this.state = nf.SCRIPT_DATA_ESCAPED } else this._ensureHibernation() || (this.state = nf.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e)) } _stateBeforeAttributeName(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.SOLIDUS: case dp.GREATER_THAN_SIGN: case dp.EOF: this.state = nf.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e); break; case dp.EQUALS_SIGN: this._err(_p.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = nf.ATTRIBUTE_NAME; break; default: this._createAttr(""), this.state = nf.ATTRIBUTE_NAME, this._stateAttributeName(e) } } _stateAttributeName(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: case dp.SOLIDUS: case dp.GREATER_THAN_SIGN: case dp.EOF: this._leaveAttrName(), this.state = nf.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e); break; case dp.EQUALS_SIGN: this._leaveAttrName(), this.state = nf.BEFORE_ATTRIBUTE_VALUE; break; case dp.QUOTATION_MARK: case dp.APOSTROPHE: case dp.LESS_THAN_SIGN: this._err(_p.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.currentAttr.name += hp; break; default: this.currentAttr.name += String.fromCodePoint(of(e) ? cf(e) : e) } } _stateAfterAttributeName(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.SOLIDUS: this.state = nf.SELF_CLOSING_START_TAG; break; case dp.EQUALS_SIGN: this.state = nf.BEFORE_ATTRIBUTE_VALUE; break; case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentTagToken(); break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: this._createAttr(""), this.state = nf.ATTRIBUTE_NAME, this._stateAttributeName(e) } } _stateBeforeAttributeValue(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.QUOTATION_MARK: this.state = nf.ATTRIBUTE_VALUE_DOUBLE_QUOTED; break; case dp.APOSTROPHE: this.state = nf.ATTRIBUTE_VALUE_SINGLE_QUOTED; break; case dp.GREATER_THAN_SIGN: this._err(_p.missingAttributeValue), this.state = nf.DATA, this.emitCurrentTagToken(); break; default: this.state = nf.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e) } } _stateAttributeValueDoubleQuoted(e) { switch (e) { case dp.QUOTATION_MARK: this.state = nf.AFTER_ATTRIBUTE_VALUE_QUOTED; break; case dp.AMPERSAND: this._startCharacterReference(); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.currentAttr.value += hp; break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAttributeValueSingleQuoted(e) { switch (e) { case dp.APOSTROPHE: this.state = nf.AFTER_ATTRIBUTE_VALUE_QUOTED; break; case dp.AMPERSAND: this._startCharacterReference(); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.currentAttr.value += hp; break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAttributeValueUnquoted(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this._leaveAttrValue(), this.state = nf.BEFORE_ATTRIBUTE_NAME; break; case dp.AMPERSAND: this._startCharacterReference(); break; case dp.GREATER_THAN_SIGN: this._leaveAttrValue(), this.state = nf.DATA, this.emitCurrentTagToken(); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this.currentAttr.value += hp; break; case dp.QUOTATION_MARK: case dp.APOSTROPHE: case dp.LESS_THAN_SIGN: case dp.EQUALS_SIGN: case dp.GRAVE_ACCENT: this._err(_p.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e); break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAfterAttributeValueQuoted(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this._leaveAttrValue(), this.state = nf.BEFORE_ATTRIBUTE_NAME; break; case dp.SOLIDUS: this._leaveAttrValue(), this.state = nf.SELF_CLOSING_START_TAG; break; case dp.GREATER_THAN_SIGN: this._leaveAttrValue(), this.state = nf.DATA, this.emitCurrentTagToken(); break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: this._err(_p.missingWhitespaceBetweenAttributes), this.state = nf.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e) } } _stateSelfClosingStartTag(e) { switch (e) { case dp.GREATER_THAN_SIGN: this.currentToken.selfClosing = !0, this.state = nf.DATA, this.emitCurrentTagToken(); break; case dp.EOF: this._err(_p.eofInTag), this._emitEOFToken(); break; default: this._err(_p.unexpectedSolidusInTag), this.state = nf.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e) } } _stateBogusComment(e) { const t = this.currentToken; switch (e) { case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentComment(t); break; case dp.EOF: this.emitCurrentComment(t), this._emitEOFToken(); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.data += hp; break; default: t.data += String.fromCodePoint(e) } } _stateMarkupDeclarationOpen(e) { this._consumeSequenceIfMatch("--", !0) ? (this._createCommentToken(3), this.state = nf.COMMENT_START) : this._consumeSequenceIfMatch(mp, !1) ? (this.currentLocation = this.getCurrentLocation(8), this.state = nf.DOCTYPE) : this._consumeSequenceIfMatch(fp, !0) ? this.inForeignNode ? this.state = nf.CDATA_SECTION : (this._err(_p.cdataInHtmlContent), this._createCommentToken(8), this.currentToken.data = "[CDATA[", this.state = nf.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(_p.incorrectlyOpenedComment), this._createCommentToken(2), this.state = nf.BOGUS_COMMENT, this._stateBogusComment(e)) } _stateCommentStart(e) { switch (e) { case dp.HYPHEN_MINUS: this.state = nf.COMMENT_START_DASH; break; case dp.GREATER_THAN_SIGN: { this._err(_p.abruptClosingOfEmptyComment), this.state = nf.DATA; const e = this.currentToken; this.emitCurrentComment(e); break } default: this.state = nf.COMMENT, this._stateComment(e) } } _stateCommentStartDash(e) { const t = this.currentToken; switch (e) { case dp.HYPHEN_MINUS: this.state = nf.COMMENT_END; break; case dp.GREATER_THAN_SIGN: this._err(_p.abruptClosingOfEmptyComment), this.state = nf.DATA, this.emitCurrentComment(t); break; case dp.EOF: this._err(_p.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "-", this.state = nf.COMMENT, this._stateComment(e) } } _stateComment(e) { const t = this.currentToken; switch (e) { case dp.HYPHEN_MINUS: this.state = nf.COMMENT_END_DASH; break; case dp.LESS_THAN_SIGN: t.data += "<", this.state = nf.COMMENT_LESS_THAN_SIGN; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.data += hp; break; case dp.EOF: this._err(_p.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += String.fromCodePoint(e) } } _stateCommentLessThanSign(e) { const t = this.currentToken; switch (e) { case dp.EXCLAMATION_MARK: t.data += "!", this.state = nf.COMMENT_LESS_THAN_SIGN_BANG; break; case dp.LESS_THAN_SIGN: t.data += "<"; break; default: this.state = nf.COMMENT, this._stateComment(e) } } _stateCommentLessThanSignBang(e) { e === dp.HYPHEN_MINUS ? this.state = nf.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = nf.COMMENT, this._stateComment(e)) } _stateCommentLessThanSignBangDash(e) { e === dp.HYPHEN_MINUS ? this.state = nf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = nf.COMMENT_END_DASH, this._stateCommentEndDash(e)) } _stateCommentLessThanSignBangDashDash(e) { e !== dp.GREATER_THAN_SIGN && e !== dp.EOF && this._err(_p.nestedComment), this.state = nf.COMMENT_END, this._stateCommentEnd(e) } _stateCommentEndDash(e) { const t = this.currentToken; switch (e) { case dp.HYPHEN_MINUS: this.state = nf.COMMENT_END; break; case dp.EOF: this._err(_p.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "-", this.state = nf.COMMENT, this._stateComment(e) } } _stateCommentEnd(e) { const t = this.currentToken; switch (e) { case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentComment(t); break; case dp.EXCLAMATION_MARK: this.state = nf.COMMENT_END_BANG; break; case dp.HYPHEN_MINUS: t.data += "-"; break; case dp.EOF: this._err(_p.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "--", this.state = nf.COMMENT, this._stateComment(e) } } _stateCommentEndBang(e) { const t = this.currentToken; switch (e) { case dp.HYPHEN_MINUS: t.data += "--!", this.state = nf.COMMENT_END_DASH; break; case dp.GREATER_THAN_SIGN: this._err(_p.incorrectlyClosedComment), this.state = nf.DATA, this.emitCurrentComment(t); break; case dp.EOF: this._err(_p.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "--!", this.state = nf.COMMENT, this._stateComment(e) } } _stateDoctype(e) { switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this.state = nf.BEFORE_DOCTYPE_NAME; break; case dp.GREATER_THAN_SIGN: this.state = nf.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e); break; case dp.EOF: { this._err(_p.eofInDoctype), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this._emitEOFToken(); break } default: this._err(_p.missingWhitespaceBeforeDoctypeName), this.state = nf.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e) } } _stateBeforeDoctypeName(e) { if (of(e)) this._createDoctypeToken(String.fromCharCode(cf(e))), this.state = nf.DOCTYPE_NAME; else switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.NULL: this._err(_p.unexpectedNullCharacter), this._createDoctypeToken(hp), this.state = nf.DOCTYPE_NAME; break; case dp.GREATER_THAN_SIGN: { this._err(_p.missingDoctypeName), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this.state = nf.DATA; break } case dp.EOF: { this._err(_p.eofInDoctype), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this._emitEOFToken(); break } default: this._createDoctypeToken(String.fromCodePoint(e)), this.state = nf.DOCTYPE_NAME } } _stateDoctypeName(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this.state = nf.AFTER_DOCTYPE_NAME; break; case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.name += hp; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.name += String.fromCodePoint(of(e) ? cf(e) : e) } } _stateAfterDoctypeName(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._consumeSequenceIfMatch("public", !1) ? this.state = nf.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch("system", !1) ? this.state = nf.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(_p.invalidCharacterSequenceAfterDoctypeName), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e)) } } _stateAfterDoctypePublicKeyword(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this.state = nf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER; break; case dp.QUOTATION_MARK: this._err(_p.missingWhitespaceAfterDoctypePublicKeyword), t.publicId = "", this.state = nf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break; case dp.APOSTROPHE: this._err(_p.missingWhitespaceAfterDoctypePublicKeyword), t.publicId = "", this.state = nf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break; case dp.GREATER_THAN_SIGN: this._err(_p.missingDoctypePublicIdentifier), t.forceQuirks = !0, this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.missingQuoteBeforeDoctypePublicIdentifier), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBeforeDoctypePublicIdentifier(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.QUOTATION_MARK: t.publicId = "", this.state = nf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break; case dp.APOSTROPHE: t.publicId = "", this.state = nf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break; case dp.GREATER_THAN_SIGN: this._err(_p.missingDoctypePublicIdentifier), t.forceQuirks = !0, this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.missingQuoteBeforeDoctypePublicIdentifier), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateDoctypePublicIdentifierDoubleQuoted(e) { const t = this.currentToken; switch (e) { case dp.QUOTATION_MARK: this.state = nf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.publicId += hp; break; case dp.GREATER_THAN_SIGN: this._err(_p.abruptDoctypePublicIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.publicId += String.fromCodePoint(e) } } _stateDoctypePublicIdentifierSingleQuoted(e) { const t = this.currentToken; switch (e) { case dp.APOSTROPHE: this.state = nf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.publicId += hp; break; case dp.GREATER_THAN_SIGN: this._err(_p.abruptDoctypePublicIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.publicId += String.fromCodePoint(e) } } _stateAfterDoctypePublicIdentifier(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this.state = nf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS; break; case dp.GREATER_THAN_SIGN: this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.QUOTATION_MARK: this._err(_p.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case dp.APOSTROPHE: this._err(_p.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBetweenDoctypePublicAndSystemIdentifiers(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.QUOTATION_MARK: t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case dp.APOSTROPHE: t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateAfterDoctypeSystemKeyword(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: this.state = nf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER; break; case dp.QUOTATION_MARK: this._err(_p.missingWhitespaceAfterDoctypeSystemKeyword), t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case dp.APOSTROPHE: this._err(_p.missingWhitespaceAfterDoctypeSystemKeyword), t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case dp.GREATER_THAN_SIGN: this._err(_p.missingDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBeforeDoctypeSystemIdentifier(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.QUOTATION_MARK: t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case dp.APOSTROPHE: t.systemId = "", this.state = nf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case dp.GREATER_THAN_SIGN: this._err(_p.missingDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = nf.DATA, this.emitCurrentDoctype(t); break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateDoctypeSystemIdentifierDoubleQuoted(e) { const t = this.currentToken; switch (e) { case dp.QUOTATION_MARK: this.state = nf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.systemId += hp; break; case dp.GREATER_THAN_SIGN: this._err(_p.abruptDoctypeSystemIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.systemId += String.fromCodePoint(e) } } _stateDoctypeSystemIdentifierSingleQuoted(e) { const t = this.currentToken; switch (e) { case dp.APOSTROPHE: this.state = nf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break; case dp.NULL: this._err(_p.unexpectedNullCharacter), t.systemId += hp; break; case dp.GREATER_THAN_SIGN: this._err(_p.abruptDoctypeSystemIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.systemId += String.fromCodePoint(e) } } _stateAfterDoctypeSystemIdentifier(e) { const t = this.currentToken; switch (e) { case dp.SPACE: case dp.LINE_FEED: case dp.TABULATION: case dp.FORM_FEED: break; case dp.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.EOF: this._err(_p.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(_p.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = nf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBogusDoctype(e) { const t = this.currentToken; switch (e) { case dp.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = nf.DATA; break; case dp.NULL: this._err(_p.unexpectedNullCharacter); break; case dp.EOF: this.emitCurrentDoctype(t), this._emitEOFToken() } } _stateCdataSection(e) { switch (e) { case dp.RIGHT_SQUARE_BRACKET: this.state = nf.CDATA_SECTION_BRACKET; break; case dp.EOF: this._err(_p.eofInCdata), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateCdataSectionBracket(e) { e === dp.RIGHT_SQUARE_BRACKET ? this.state = nf.CDATA_SECTION_END : (this._emitChars("]"), this.state = nf.CDATA_SECTION, this._stateCdataSection(e)) } _stateCdataSectionEnd(e) { switch (e) { case dp.GREATER_THAN_SIGN: this.state = nf.DATA; break; case dp.RIGHT_SQUARE_BRACKET: this._emitChars("]"); break; default: this._emitChars("]]"), this.state = nf.CDATA_SECTION, this._stateCdataSection(e) } } _stateCharacterReference() { let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos); if (e < 0) { if (!this.preprocessor.lastChunkWritten) return this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, void (this.preprocessor.endOfChunkHit = !0); e = this.entityDecoder.end() } 0 === e ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(dp.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && lf(this.preprocessor.peek(1)) ? nf.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState } _stateAmbiguousAmpersand(e) { lf(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === dp.SEMICOLON && this._err(_p.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e)) } } const pf = new Set([Yp.DD, Yp.DT, Yp.LI, Yp.OPTGROUP, Yp.OPTION, Yp.P, Yp.RB, Yp.RP, Yp.RT, Yp.RTC]), ff = new Set([...pf, Yp.CAPTION, Yp.COLGROUP, Yp.TBODY, Yp.TD, Yp.TFOOT, Yp.TH, Yp.THEAD, Yp.TR]), mf = new Set([Yp.APPLET, Yp.CAPTION, Yp.HTML, Yp.MARQUEE, Yp.OBJECT, Yp.TABLE, Yp.TD, Yp.TEMPLATE, Yp.TH]), gf = new Set([...mf, Yp.OL, Yp.UL]), Ef = new Set([...mf, Yp.BUTTON]), Tf = new Set([Yp.ANNOTATION_XML, Yp.MI, Yp.MN, Yp.MO, Yp.MS, Yp.MTEXT]), Af = new Set([Yp.DESC, Yp.FOREIGN_OBJECT, Yp.TITLE]), _f = new Set([Yp.TR, Yp.TEMPLATE, Yp.HTML]), yf = new Set([Yp.TBODY, Yp.TFOOT, Yp.THEAD, Yp.TEMPLATE, Yp.HTML]), bf = new Set([Yp.TABLE, Yp.TEMPLATE, Yp.HTML]), Sf = new Set([Yp.TD, Yp.TH]); class kf { get currentTmplContentOrNode() { return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current } constructor(e, t, n) { this.treeAdapter = t, this.handler = n, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = Yp.UNKNOWN, this.current = e } _indexOf(e) { return this.items.lastIndexOf(e, this.stackTop) } _isInTemplate() { return this.currentTagId === Yp.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Mp.HTML } _updateCurrentElement() { this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop] } push(e, t) { this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = t, this.currentTagId = t, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, t, !0) } pop() { const e = this.current; this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0) } replace(e, t) { const n = this._indexOf(e); this.items[n] = t, n === this.stackTop && (this.current = t) } insertAfter(e, t, n) { const r = this._indexOf(e) + 1; this.items.splice(r, 0, t), this.tagIDs.splice(r, 0, n), this.stackTop++, r === this.stackTop && this._updateCurrentElement(), this.current && void 0 !== this.currentTagId && this.handler.onItemPush(this.current, this.currentTagId, r === this.stackTop) } popUntilTagNamePopped(e) { let t = this.stackTop + 1; do { t = this.tagIDs.lastIndexOf(e, t - 1) } while (t > 0 && this.treeAdapter.getNamespaceURI(this.items[t]) !== Mp.HTML); this.shortenToLength(Math.max(t, 0)) } shortenToLength(e) { for (; this.stackTop >= e;) { const t = this.current; this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, this.stackTop < e) } } popUntilElementPopped(e) { const t = this._indexOf(e); this.shortenToLength(Math.max(t, 0)) } popUntilPopped(e, t) { const n = this._indexOfTagNames(e, t); this.shortenToLength(Math.max(n, 0)) } popUntilNumberedHeaderPopped() { this.popUntilPopped(tf, Mp.HTML) } popUntilTableCellPopped() { this.popUntilPopped(Sf, Mp.HTML) } popAllUpToHtmlElement() { this.tmplCount = 0, this.shortenToLength(1) } _indexOfTagNames(e, t) { for (let n = this.stackTop; n >= 0; n--)if (e.has(this.tagIDs[n]) && this.treeAdapter.getNamespaceURI(this.items[n]) === t) return n; return -1 } clearBackTo(e, t) { const n = this._indexOfTagNames(e, t); this.shortenToLength(n + 1) } clearBackToTableContext() { this.clearBackTo(bf, Mp.HTML) } clearBackToTableBodyContext() { this.clearBackTo(yf, Mp.HTML) } clearBackToTableRowContext() { this.clearBackTo(_f, Mp.HTML) } remove(e) { const t = this._indexOf(e); t >= 0 && (t === this.stackTop ? this.pop() : (this.items.splice(t, 1), this.tagIDs.splice(t, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1))) } tryPeekProperlyNestedBodyElement() { return this.stackTop >= 1 && this.tagIDs[1] === Yp.BODY ? this.items[1] : null } contains(e) { return this._indexOf(e) > -1 } getCommonAncestor(e) { const t = this._indexOf(e) - 1; return t >= 0 ? this.items[t] : null } isRootHtmlElementCurrent() { return 0 === this.stackTop && this.tagIDs[0] === Yp.HTML } hasInDynamicScope(e, t) { for (let n = this.stackTop; n >= 0; n--) { const r = this.tagIDs[n]; switch (this.treeAdapter.getNamespaceURI(this.items[n])) { case Mp.HTML: if (r === e) return !0; if (t.has(r)) return !1; break; case Mp.SVG: if (Af.has(r)) return !1; break; case Mp.MATHML: if (Tf.has(r)) return !1 } } return !0 } hasInScope(e) { return this.hasInDynamicScope(e, mf) } hasInListItemScope(e) { return this.hasInDynamicScope(e, gf) } hasInButtonScope(e) { return this.hasInDynamicScope(e, Ef) } hasNumberedHeaderInScope() { for (let e = this.stackTop; e >= 0; e--) { const t = this.tagIDs[e]; switch (this.treeAdapter.getNamespaceURI(this.items[e])) { case Mp.HTML: if (tf.has(t)) return !0; if (mf.has(t)) return !1; break; case Mp.SVG: if (Af.has(t)) return !1; break; case Mp.MATHML: if (Tf.has(t)) return !1 } } return !0 } hasInTableScope(e) { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === Mp.HTML) switch (this.tagIDs[t]) { case e: return !0; case Yp.TABLE: case Yp.HTML: return !1 }return !0 } hasTableBodyContextInTableScope() { for (let e = this.stackTop; e >= 0; e--)if (this.treeAdapter.getNamespaceURI(this.items[e]) === Mp.HTML) switch (this.tagIDs[e]) { case Yp.TBODY: case Yp.THEAD: case Yp.TFOOT: return !0; case Yp.TABLE: case Yp.HTML: return !1 }return !0 } hasInSelectScope(e) { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === Mp.HTML) switch (this.tagIDs[t]) { case e: return !0; case Yp.OPTION: case Yp.OPTGROUP: break; default: return !1 }return !0 } generateImpliedEndTags() { for (; void 0 !== this.currentTagId && pf.has(this.currentTagId);)this.pop() } generateImpliedEndTagsThoroughly() { for (; void 0 !== this.currentTagId && ff.has(this.currentTagId);)this.pop() } generateImpliedEndTagsWithExclusion(e) { for (; void 0 !== this.currentTagId && this.currentTagId !== e && ff.has(this.currentTagId);)this.pop() } } var Cf, Nf; (Nf = Cf || (Cf = {}))[Nf.Marker = 0] = "Marker", Nf[Nf.Element = 1] = "Element"; const If = { type: Cf.Marker }; class Of { constructor(e) { this.treeAdapter = e, this.entries = [], this.bookmark = null } _getNoahArkConditionCandidates(e, t) { const n = [], r = t.length, s = this.treeAdapter.getTagName(e), i = this.treeAdapter.getNamespaceURI(e); for (let o = 0; o < this.entries.length; o++) { const e = this.entries[o]; if (e.type === Cf.Marker) break; const { element: t } = e; if (this.treeAdapter.getTagName(t) === s && this.treeAdapter.getNamespaceURI(t) === i) { const e = this.treeAdapter.getAttrList(t); e.length === r && n.push({ idx: o, attrs: e }) } } return n } _ensureNoahArkCondition(e) { if (this.entries.length < 3) return; const t = this.treeAdapter.getAttrList(e), n = this._getNoahArkConditionCandidates(e, t); if (n.length < 3) return; const r = new Map(t.map(e => [e.name, e.value])); let s = 0; for (let i = 0; i < n.length; i++) { const e = n[i]; e.attrs.every(e => r.get(e.name) === e.value) && (s += 1, s >= 3 && this.entries.splice(e.idx, 1)) } } insertMarker() { this.entries.unshift(If) } pushElement(e, t) { this._ensureNoahArkCondition(e), this.entries.unshift({ type: Cf.Element, element: e, token: t }) } insertElementAfterBookmark(e, t) { const n = this.entries.indexOf(this.bookmark); this.entries.splice(n, 0, { type: Cf.Element, element: e, token: t }) } removeEntry(e) { const t = this.entries.indexOf(e); -1 !== t && this.entries.splice(t, 1) } clearToLastMarker() { const e = this.entries.indexOf(If); -1 === e ? this.entries.length = 0 : this.entries.splice(0, e + 1) } getElementEntryInScopeWithTagName(e) { const t = this.entries.find(t => t.type === Cf.Marker || this.treeAdapter.getTagName(t.element) === e); return t && t.type === Cf.Element ? t : null } getElementEntry(e) { return this.entries.find(t => t.type === Cf.Element && t.element === e) } } const xf = { createDocument: () => ({ nodeName: "#document", mode: Hp.NO_QUIRKS, childNodes: [] }), createDocumentFragment: () => ({ nodeName: "#document-fragment", childNodes: [] }), createElement: (e, t, n) => ({ nodeName: e, tagName: e, attrs: n, namespaceURI: t, childNodes: [], parentNode: null }), createCommentNode: e => ({ nodeName: "#comment", data: e, parentNode: null }), createTextNode: e => ({ nodeName: "#text", value: e, parentNode: null }), appendChild(e, t) { e.childNodes.push(t), t.parentNode = e }, insertBefore(e, t, n) { const r = e.childNodes.indexOf(n); e.childNodes.splice(r, 0, t), t.parentNode = e }, setTemplateContent(e, t) { e.content = t }, getTemplateContent: e => e.content, setDocumentType(e, t, n, r) { const s = e.childNodes.find(e => "#documentType" === e.nodeName); if (s) s.name = t, s.publicId = n, s.systemId = r; else { const s = { nodeName: "#documentType", name: t, publicId: n, systemId: r, parentNode: null }; xf.appendChild(e, s) } }, setDocumentMode(e, t) { e.mode = t }, getDocumentMode: e => e.mode, detachNode(e) { if (e.parentNode) { const t = e.parentNode.childNodes.indexOf(e); e.parentNode.childNodes.splice(t, 1), e.parentNode = null } }, insertText(e, t) { if (e.childNodes.length > 0) { const n = e.childNodes[e.childNodes.length - 1]; if (xf.isTextNode(n)) return void (n.value += t) } xf.appendChild(e, xf.createTextNode(t)) }, insertTextBefore(e, t, n) { const r = e.childNodes[e.childNodes.indexOf(n) - 1]; r && xf.isTextNode(r) ? r.value += t : xf.insertBefore(e, xf.createTextNode(t), n) }, adoptAttributes(e, t) { const n = new Set(e.attrs.map(e => e.name)); for (let r = 0; r < t.length; r++)n.has(t[r].name) || e.attrs.push(t[r]) }, getFirstChild: e => e.childNodes[0], getChildNodes: e => e.childNodes, getParentNode: e => e.parentNode, getAttrList: e => e.attrs, getTagName: e => e.tagName, getNamespaceURI: e => e.namespaceURI, getTextNodeContent: e => e.value, getCommentNodeContent: e => e.data, getDocumentTypeNodeName: e => e.name, getDocumentTypeNodePublicId: e => e.publicId, getDocumentTypeNodeSystemId: e => e.systemId, isTextNode: e => "#text" === e.nodeName, isCommentNode: e => "#comment" === e.nodeName, isDocumentTypeNode: e => "#documentType" === e.nodeName, isElementNode: e => Object.prototype.hasOwnProperty.call(e, "tagName"), setNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = t }, getNodeSourceCodeLocation: e => e.sourceCodeLocation, updateNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t } } }, Rf = "html", vf = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"], Df = [...vf, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"], Lf = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]), Pf = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], wf = [...Pf, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]; function Mf(e, t) { return t.some(t => e.startsWith(t)) } const Ff = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(e => [e.toLowerCase(), e])), Bf = new Map([["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Mp.XLINK }], ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Mp.XLINK }], ["xlink:href", { prefix: "xlink", name: "href", namespace: Mp.XLINK }], ["xlink:role", { prefix: "xlink", name: "role", namespace: Mp.XLINK }], ["xlink:show", { prefix: "xlink", name: "show", namespace: Mp.XLINK }], ["xlink:title", { prefix: "xlink", name: "title", namespace: Mp.XLINK }], ["xlink:type", { prefix: "xlink", name: "type", namespace: Mp.XLINK }], ["xml:lang", { prefix: "xml", name: "lang", namespace: Mp.XML }], ["xml:space", { prefix: "xml", name: "space", namespace: Mp.XML }], ["xmlns", { prefix: "", name: "xmlns", namespace: Mp.XMLNS }], ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Mp.XMLNS }]]), Uf = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(e => [e.toLowerCase(), e])), Hf = new Set([Yp.B, Yp.BIG, Yp.BLOCKQUOTE, Yp.BODY, Yp.BR, Yp.CENTER, Yp.CODE, Yp.DD, Yp.DIV, Yp.DL, Yp.DT, Yp.EM, Yp.EMBED, Yp.H1, Yp.H2, Yp.H3, Yp.H4, Yp.H5, Yp.H6, Yp.HEAD, Yp.HR, Yp.I, Yp.IMG, Yp.LI, Yp.LISTING, Yp.MENU, Yp.META, Yp.NOBR, Yp.OL, Yp.P, Yp.PRE, Yp.RUBY, Yp.S, Yp.SMALL, Yp.SPAN, Yp.STRONG, Yp.STRIKE, Yp.SUB, Yp.SUP, Yp.TABLE, Yp.TT, Yp.U, Yp.UL, Yp.VAR]); function jf(e) { for (let t = 0; t < e.attrs.length; t++)if ("definitionurl" === e.attrs[t].name) { e.attrs[t].name = "definitionURL"; break } } function Gf(e) { for (let t = 0; t < e.attrs.length; t++) { const n = Ff.get(e.attrs[t].name); null != n && (e.attrs[t].name = n) } } function zf(e) { for (let t = 0; t < e.attrs.length; t++) { const n = Bf.get(e.attrs[t].name); n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace) } } var Yf, qf; (qf = Yf || (Yf = {}))[qf.INITIAL = 0] = "INITIAL", qf[qf.BEFORE_HTML = 1] = "BEFORE_HTML", qf[qf.BEFORE_HEAD = 2] = "BEFORE_HEAD", qf[qf.IN_HEAD = 3] = "IN_HEAD", qf[qf.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", qf[qf.AFTER_HEAD = 5] = "AFTER_HEAD", qf[qf.IN_BODY = 6] = "IN_BODY", qf[qf.TEXT = 7] = "TEXT", qf[qf.IN_TABLE = 8] = "IN_TABLE", qf[qf.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", qf[qf.IN_CAPTION = 10] = "IN_CAPTION", qf[qf.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", qf[qf.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", qf[qf.IN_ROW = 13] = "IN_ROW", qf[qf.IN_CELL = 14] = "IN_CELL", qf[qf.IN_SELECT = 15] = "IN_SELECT", qf[qf.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", qf[qf.IN_TEMPLATE = 17] = "IN_TEMPLATE", qf[qf.AFTER_BODY = 18] = "AFTER_BODY", qf[qf.IN_FRAMESET = 19] = "IN_FRAMESET", qf[qf.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", qf[qf.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", qf[qf.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET"; const Vf = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 }, $f = new Set([Yp.TABLE, Yp.TBODY, Yp.TFOOT, Yp.THEAD, Yp.TR]), Wf = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: xf, onParseError: null }; class Kf { constructor(e, t, n = null, r = null) { this.fragmentContext = n, this.scriptHandler = r, this.currentToken = null, this.stopped = !1, this.insertionMode = Yf.INITIAL, this.originalInsertionMode = Yf.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = { ...Wf, ...e }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = null != t ? t : this.treeAdapter.createDocument(), this.tokenizer = new df(this.options, this), this.activeFormattingElements = new Of(this.treeAdapter), this.fragmentContextID = n ? Jp(this.treeAdapter.getTagName(n)) : Yp.UNKNOWN, this._setContextModes(null != n ? n : this.document, this.fragmentContextID), this.openElements = new kf(this.document, this.treeAdapter, this) } static parse(e, t) { const n = new this(t); return n.tokenizer.write(e, !0), n.document } static getFragmentParser(e, t) { const n = { ...Wf, ...t }; null != e || (e = n.treeAdapter.createElement(Gp.TEMPLATE, Mp.HTML, [])); const r = n.treeAdapter.createElement("documentmock", Mp.HTML, []), s = new this(n, r, e); return s.fragmentContextID === Yp.TEMPLATE && s.tmplInsertionModeStack.unshift(Yf.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s } getFragment() { const e = this.treeAdapter.getFirstChild(this.document), t = this.treeAdapter.createDocumentFragment(); return this._adoptNodes(e, t), t } _err(e, t, n) { var r; if (!this.onParseError) return; const s = null !== (r = e.location) && void 0 !== r ? r : Vf, i = { code: t, startLine: s.startLine, startCol: s.startCol, startOffset: s.startOffset, endLine: n ? s.startLine : s.endLine, endCol: n ? s.startCol : s.endCol, endOffset: n ? s.startOffset : s.endOffset }; this.onParseError(i) } onItemPush(e, t, n) { var r, s; null === (s = (r = this.treeAdapter).onItemPush) || void 0 === s || s.call(r, e), n && this.openElements.stackTop > 0 && this._setContextModes(e, t) } onItemPop(e, t) { var n, r; if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), null === (r = (n = this.treeAdapter).onItemPop) || void 0 === r || r.call(n, e, this.openElements.current), t) { let e, t; 0 === this.openElements.stackTop && this.fragmentContext ? (e = this.fragmentContext, t = this.fragmentContextID) : ({ current: e, currentTagId: t } = this.openElements), this._setContextModes(e, t) } } _setContextModes(e, t) { const n = e === this.document || e && this.treeAdapter.getNamespaceURI(e) === Mp.HTML; this.currentNotInHTML = !n, this.tokenizer.inForeignNode = !n && void 0 !== e && void 0 !== t && !this._isIntegrationPoint(t, e) } _switchToTextParsing(e, t) { this._insertElement(e, Mp.HTML), this.tokenizer.state = t, this.originalInsertionMode = this.insertionMode, this.insertionMode = Yf.TEXT } switchToPlaintextParsing() { this.insertionMode = Yf.TEXT, this.originalInsertionMode = Yf.IN_BODY, this.tokenizer.state = sf.PLAINTEXT } _getAdjustedCurrentElement() { return 0 === this.openElements.stackTop && this.fragmentContext ? this.fragmentContext : this.openElements.current } _findFormInFragmentContext() { let e = this.fragmentContext; for (; e;) { if (this.treeAdapter.getTagName(e) === Gp.FORM) { this.formElement = e; break } e = this.treeAdapter.getParentNode(e) } } _initTokenizerForFragmentParsing() { if (this.fragmentContext && this.treeAdapter.getNamespaceURI(this.fragmentContext) === Mp.HTML) switch (this.fragmentContextID) { case Yp.TITLE: case Yp.TEXTAREA: this.tokenizer.state = sf.RCDATA; break; case Yp.STYLE: case Yp.XMP: case Yp.IFRAME: case Yp.NOEMBED: case Yp.NOFRAMES: case Yp.NOSCRIPT: this.tokenizer.state = sf.RAWTEXT; break; case Yp.SCRIPT: this.tokenizer.state = sf.SCRIPT_DATA; break; case Yp.PLAINTEXT: this.tokenizer.state = sf.PLAINTEXT } } _setDocumentType(e) { const t = e.name || "", n = e.publicId || "", r = e.systemId || ""; if (this.treeAdapter.setDocumentType(this.document, t, n, r), e.location) { const t = this.treeAdapter.getChildNodes(this.document).find(e => this.treeAdapter.isDocumentTypeNode(e)); t && this.treeAdapter.setNodeSourceCodeLocation(t, e.location) } } _attachElementToTree(e, t) { if (this.options.sourceCodeLocationInfo) { const n = t && { ...t, startTag: t }; this.treeAdapter.setNodeSourceCodeLocation(e, n) } if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(e); else { const t = this.openElements.currentTmplContentOrNode; this.treeAdapter.appendChild(null != t ? t : this.document, e) } } _appendElement(e, t) { const n = this.treeAdapter.createElement(e.tagName, t, e.attrs); this._attachElementToTree(n, e.location) } _insertElement(e, t) { const n = this.treeAdapter.createElement(e.tagName, t, e.attrs); this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID) } _insertFakeElement(e, t) { const n = this.treeAdapter.createElement(e, Mp.HTML, []); this._attachElementToTree(n, null), this.openElements.push(n, t) } _insertTemplate(e) { const t = this.treeAdapter.createElement(e.tagName, Mp.HTML, e.attrs), n = this.treeAdapter.createDocumentFragment(); this.treeAdapter.setTemplateContent(t, n), this._attachElementToTree(t, e.location), this.openElements.push(t, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, null) } _insertFakeRootElement() { const e = this.treeAdapter.createElement(Gp.HTML, Mp.HTML, []); this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, Yp.HTML) } _appendCommentNode(e, t) { const n = this.treeAdapter.createCommentNode(e.data); this.treeAdapter.appendChild(t, n), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, e.location) } _insertCharacters(e) { let t, n; if (this._shouldFosterParentOnInsertion() ? (({ parent: t, beforeElement: n } = this._findFosterParentingLocation()), n ? this.treeAdapter.insertTextBefore(t, e.chars, n) : this.treeAdapter.insertText(t, e.chars)) : (t = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(t, e.chars)), !e.location) return; const r = this.treeAdapter.getChildNodes(t), s = n ? r.lastIndexOf(n) : r.length, i = r[s - 1]; if (this.treeAdapter.getNodeSourceCodeLocation(i)) { const { endLine: t, endCol: n, endOffset: r } = e.location; this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: t, endCol: n, endOffset: r }) } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, e.location) } _adoptNodes(e, t) { for (let n = this.treeAdapter.getFirstChild(e); n; n = this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(n), this.treeAdapter.appendChild(t, n) } _setEndLocation(e, t) { if (this.treeAdapter.getNodeSourceCodeLocation(e) && t.location) { const n = t.location, r = this.treeAdapter.getTagName(e), s = t.type === bp.END_TAG && r === t.tagName ? { endTag: { ...n }, endLine: n.endLine, endCol: n.endCol, endOffset: n.endOffset } : { endLine: n.startLine, endCol: n.startCol, endOffset: n.startOffset }; this.treeAdapter.updateNodeSourceCodeLocation(e, s) } } shouldProcessStartTagTokenInForeignContent(e) { if (!this.currentNotInHTML) return !1; let t, n; return 0 === this.openElements.stackTop && this.fragmentContext ? (t = this.fragmentContext, n = this.fragmentContextID) : ({ current: t, currentTagId: n } = this.openElements), (e.tagID !== Yp.SVG || this.treeAdapter.getTagName(t) !== Gp.ANNOTATION_XML || this.treeAdapter.getNamespaceURI(t) !== Mp.MATHML) && (this.tokenizer.inForeignNode || (e.tagID === Yp.MGLYPH || e.tagID === Yp.MALIGNMARK) && void 0 !== n && !this._isIntegrationPoint(n, t, Mp.HTML)) } _processToken(e) { switch (e.type) { case bp.CHARACTER: this.onCharacter(e); break; case bp.NULL_CHARACTER: this.onNullCharacter(e); break; case bp.COMMENT: this.onComment(e); break; case bp.DOCTYPE: this.onDoctype(e); break; case bp.START_TAG: this._processStartTag(e); break; case bp.END_TAG: this.onEndTag(e); break; case bp.EOF: this.onEof(e); break; case bp.WHITESPACE_CHARACTER: this.onWhitespaceCharacter(e) } } _isIntegrationPoint(e, t, n) { return function (e, t, n, r) { return (!r || r === Mp.HTML) && function (e, t, n) { if (t === Mp.MATHML && e === Yp.ANNOTATION_XML) for (let r = 0; r < n.length; r++)if (n[r].name === Bp.ENCODING) { const e = n[r].value.toLowerCase(); return "text/html" === e || "application/xhtml+xml" === e } return t === Mp.SVG && (e === Yp.FOREIGN_OBJECT || e === Yp.DESC || e === Yp.TITLE) }(e, t, n) || (!r || r === Mp.MATHML) && function (e, t) { return t === Mp.MATHML && (e === Yp.MI || e === Yp.MO || e === Yp.MN || e === Yp.MS || e === Yp.MTEXT) }(e, t) }(e, this.treeAdapter.getNamespaceURI(t), this.treeAdapter.getAttrList(t), n) } _reconstructActiveFormattingElements() { const e = this.activeFormattingElements.entries.length; if (e) { const t = this.activeFormattingElements.entries.findIndex(e => e.type === Cf.Marker || this.openElements.contains(e.element)); for (let n = -1 === t ? e - 1 : t - 1; n >= 0; n--) { const e = this.activeFormattingElements.entries[n]; this._insertElement(e.token, this.treeAdapter.getNamespaceURI(e.element)), e.element = this.openElements.current } } } _closeTableCell() { this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = Yf.IN_ROW } _closePElement() { this.openElements.generateImpliedEndTagsWithExclusion(Yp.P), this.openElements.popUntilTagNamePopped(Yp.P) } _resetInsertionMode() { for (let e = this.openElements.stackTop; e >= 0; e--)switch (0 === e && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) { case Yp.TR: return void (this.insertionMode = Yf.IN_ROW); case Yp.TBODY: case Yp.THEAD: case Yp.TFOOT: return void (this.insertionMode = Yf.IN_TABLE_BODY); case Yp.CAPTION: return void (this.insertionMode = Yf.IN_CAPTION); case Yp.COLGROUP: return void (this.insertionMode = Yf.IN_COLUMN_GROUP); case Yp.TABLE: return void (this.insertionMode = Yf.IN_TABLE); case Yp.BODY: return void (this.insertionMode = Yf.IN_BODY); case Yp.FRAMESET: return void (this.insertionMode = Yf.IN_FRAMESET); case Yp.SELECT: return void this._resetInsertionModeForSelect(e); case Yp.TEMPLATE: return void (this.insertionMode = this.tmplInsertionModeStack[0]); case Yp.HTML: return void (this.insertionMode = this.headElement ? Yf.AFTER_HEAD : Yf.BEFORE_HEAD); case Yp.TD: case Yp.TH: if (e > 0) return void (this.insertionMode = Yf.IN_CELL); break; case Yp.HEAD: if (e > 0) return void (this.insertionMode = Yf.IN_HEAD) }this.insertionMode = Yf.IN_BODY } _resetInsertionModeForSelect(e) { if (e > 0) for (let t = e - 1; t > 0; t--) { const e = this.openElements.tagIDs[t]; if (e === Yp.TEMPLATE) break; if (e === Yp.TABLE) return void (this.insertionMode = Yf.IN_SELECT_IN_TABLE) } this.insertionMode = Yf.IN_SELECT } _isElementCausesFosterParenting(e) { return $f.has(e) } _shouldFosterParentOnInsertion() { return this.fosterParentingEnabled && void 0 !== this.openElements.currentTagId && this._isElementCausesFosterParenting(this.openElements.currentTagId) } _findFosterParentingLocation() { for (let e = this.openElements.stackTop; e >= 0; e--) { const t = this.openElements.items[e]; switch (this.openElements.tagIDs[e]) { case Yp.TEMPLATE: if (this.treeAdapter.getNamespaceURI(t) === Mp.HTML) return { parent: this.treeAdapter.getTemplateContent(t), beforeElement: null }; break; case Yp.TABLE: { const n = this.treeAdapter.getParentNode(t); return n ? { parent: n, beforeElement: t } : { parent: this.openElements.items[e - 1], beforeElement: null } } } } return { parent: this.openElements.items[0], beforeElement: null } } _fosterParentElement(e) { const t = this._findFosterParentingLocation(); t.beforeElement ? this.treeAdapter.insertBefore(t.parent, e, t.beforeElement) : this.treeAdapter.appendChild(t.parent, e) } _isSpecialElement(e, t) { const n = this.treeAdapter.getNamespaceURI(e); return ef[n].has(t) } onCharacter(e) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) !function (e, t) { e._insertCharacters(t), e.framesetOk = !1 }(this, e); else switch (this.insertionMode) { case Yf.INITIAL: im(this, e); break; case Yf.BEFORE_HTML: om(this, e); break; case Yf.BEFORE_HEAD: am(this, e); break; case Yf.IN_HEAD: um(this, e); break; case Yf.IN_HEAD_NO_SCRIPT: hm(this, e); break; case Yf.AFTER_HEAD: dm(this, e); break; case Yf.IN_BODY: case Yf.IN_CAPTION: case Yf.IN_CELL: case Yf.IN_TEMPLATE: mm(this, e); break; case Yf.TEXT: case Yf.IN_SELECT: case Yf.IN_SELECT_IN_TABLE: this._insertCharacters(e); break; case Yf.IN_TABLE: case Yf.IN_TABLE_BODY: case Yf.IN_ROW: km(this, e); break; case Yf.IN_TABLE_TEXT: xm(this, e); break; case Yf.IN_COLUMN_GROUP: Lm(this, e); break; case Yf.AFTER_BODY: Gm(this, e); break; case Yf.AFTER_AFTER_BODY: zm(this, e) } } onNullCharacter(e) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) !function (e, t) { t.chars = hp, e._insertCharacters(t) }(this, e); else switch (this.insertionMode) { case Yf.INITIAL: im(this, e); break; case Yf.BEFORE_HTML: om(this, e); break; case Yf.BEFORE_HEAD: am(this, e); break; case Yf.IN_HEAD: um(this, e); break; case Yf.IN_HEAD_NO_SCRIPT: hm(this, e); break; case Yf.AFTER_HEAD: dm(this, e); break; case Yf.TEXT: this._insertCharacters(e); break; case Yf.IN_TABLE: case Yf.IN_TABLE_BODY: case Yf.IN_ROW: km(this, e); break; case Yf.IN_COLUMN_GROUP: Lm(this, e); break; case Yf.AFTER_BODY: Gm(this, e); break; case Yf.AFTER_AFTER_BODY: zm(this, e) } } onComment(e) { if (this.skipNextNewLine = !1, this.currentNotInHTML) rm(this, e); else switch (this.insertionMode) { case Yf.INITIAL: case Yf.BEFORE_HTML: case Yf.BEFORE_HEAD: case Yf.IN_HEAD: case Yf.IN_HEAD_NO_SCRIPT: case Yf.AFTER_HEAD: case Yf.IN_BODY: case Yf.IN_TABLE: case Yf.IN_CAPTION: case Yf.IN_COLUMN_GROUP: case Yf.IN_TABLE_BODY: case Yf.IN_ROW: case Yf.IN_CELL: case Yf.IN_SELECT: case Yf.IN_SELECT_IN_TABLE: case Yf.IN_TEMPLATE: case Yf.IN_FRAMESET: case Yf.AFTER_FRAMESET: rm(this, e); break; case Yf.IN_TABLE_TEXT: Rm(this, e); break; case Yf.AFTER_BODY: !function (e, t) { e._appendCommentNode(t, e.openElements.items[0]) }(this, e); break; case Yf.AFTER_AFTER_BODY: case Yf.AFTER_AFTER_FRAMESET: !function (e, t) { e._appendCommentNode(t, e.document) }(this, e) } } onDoctype(e) { switch (this.skipNextNewLine = !1, this.insertionMode) { case Yf.INITIAL: !function (e, t) { e._setDocumentType(t); const n = t.forceQuirks ? Hp.QUIRKS : function (e) { if (e.name !== Rf) return Hp.QUIRKS; const { systemId: t } = e; if (t && "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd" === t.toLowerCase()) return Hp.QUIRKS; let { publicId: n } = e; if (null !== n) { if (n = n.toLowerCase(), Lf.has(n)) return Hp.QUIRKS; let e = null === t ? Df : vf; if (Mf(n, e)) return Hp.QUIRKS; if (e = null === t ? Pf : wf, Mf(n, e)) return Hp.LIMITED_QUIRKS } return Hp.NO_QUIRKS }(t); (function (e) { return e.name === Rf && null === e.publicId && (null === e.systemId || "about:legacy-compat" === e.systemId) })(t) || e._err(t, _p.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = Yf.BEFORE_HTML }(this, e); break; case Yf.BEFORE_HEAD: case Yf.IN_HEAD: case Yf.IN_HEAD_NO_SCRIPT: case Yf.AFTER_HEAD: this._err(e, _p.misplacedDoctype); break; case Yf.IN_TABLE_TEXT: Rm(this, e) } } onStartTag(e) { this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, _p.nonVoidHtmlElementStartTagWithTrailingSolidus) } _processStartTag(e) { this.shouldProcessStartTagTokenInForeignContent(e) ? function (e, t) { if (function (e) { const t = e.tagID; return t === Yp.FONT && e.attrs.some(({ name: e }) => e === Bp.COLOR || e === Bp.SIZE || e === Bp.FACE) || Hf.has(t) }(t)) Ym(e), e._startTagOutsideForeignContent(t); else { const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n); r === Mp.MATHML ? jf(t) : r === Mp.SVG && (function (e) { const t = Uf.get(e.tagName); null != t && (e.tagName = t, e.tagID = Jp(e.tagName)) }(t), Gf(t)), zf(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0 } }(this, e) : this._startTagOutsideForeignContent(e) } _startTagOutsideForeignContent(e) { switch (this.insertionMode) { case Yf.INITIAL: im(this, e); break; case Yf.BEFORE_HTML: !function (e, t) { t.tagID === Yp.HTML ? (e._insertElement(t, Mp.HTML), e.insertionMode = Yf.BEFORE_HEAD) : om(e, t) }(this, e); break; case Yf.BEFORE_HEAD: !function (e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.HEAD: e._insertElement(t, Mp.HTML), e.headElement = e.openElements.current, e.insertionMode = Yf.IN_HEAD; break; default: am(e, t) } }(this, e); break; case Yf.IN_HEAD: lm(this, e); break; case Yf.IN_HEAD_NO_SCRIPT: !function (e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.BASEFONT: case Yp.BGSOUND: case Yp.HEAD: case Yp.LINK: case Yp.META: case Yp.NOFRAMES: case Yp.STYLE: lm(e, t); break; case Yp.NOSCRIPT: e._err(t, _p.nestedNoscriptInHead); break; default: hm(e, t) } }(this, e); break; case Yf.AFTER_HEAD: !function (e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.BODY: e._insertElement(t, Mp.HTML), e.framesetOk = !1, e.insertionMode = Yf.IN_BODY; break; case Yp.FRAMESET: e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_FRAMESET; break; case Yp.BASE: case Yp.BASEFONT: case Yp.BGSOUND: case Yp.LINK: case Yp.META: case Yp.NOFRAMES: case Yp.SCRIPT: case Yp.STYLE: case Yp.TEMPLATE: case Yp.TITLE: e._err(t, _p.abandonedHeadElementChild), e.openElements.push(e.headElement, Yp.HEAD), lm(e, t), e.openElements.remove(e.headElement); break; case Yp.HEAD: e._err(t, _p.misplacedStartTagForHeadElement); break; default: dm(e, t) } }(this, e); break; case Yf.IN_BODY: _m(this, e); break; case Yf.IN_TABLE: Cm(this, e); break; case Yf.IN_TABLE_TEXT: Rm(this, e); break; case Yf.IN_CAPTION: !function (e, t) { const n = t.tagID; vm.has(n) ? e.openElements.hasInTableScope(Yp.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Yp.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Yf.IN_TABLE, Cm(e, t)) : _m(e, t) }(this, e); break; case Yf.IN_COLUMN_GROUP: Dm(this, e); break; case Yf.IN_TABLE_BODY: Pm(this, e); break; case Yf.IN_ROW: Mm(this, e); break; case Yf.IN_CELL: !function (e, t) { const n = t.tagID; vm.has(n) ? (e.openElements.hasInTableScope(Yp.TD) || e.openElements.hasInTableScope(Yp.TH)) && (e._closeTableCell(), Mm(e, t)) : _m(e, t) }(this, e); break; case Yf.IN_SELECT: Bm(this, e); break; case Yf.IN_SELECT_IN_TABLE: !function (e, t) { const n = t.tagID; n === Yp.CAPTION || n === Yp.TABLE || n === Yp.TBODY || n === Yp.TFOOT || n === Yp.THEAD || n === Yp.TR || n === Yp.TD || n === Yp.TH ? (e.openElements.popUntilTagNamePopped(Yp.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : Bm(e, t) }(this, e); break; case Yf.IN_TEMPLATE: !function (e, t) { switch (t.tagID) { case Yp.BASE: case Yp.BASEFONT: case Yp.BGSOUND: case Yp.LINK: case Yp.META: case Yp.NOFRAMES: case Yp.SCRIPT: case Yp.STYLE: case Yp.TEMPLATE: case Yp.TITLE: lm(e, t); break; case Yp.CAPTION: case Yp.COLGROUP: case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: e.tmplInsertionModeStack[0] = Yf.IN_TABLE, e.insertionMode = Yf.IN_TABLE, Cm(e, t); break; case Yp.COL: e.tmplInsertionModeStack[0] = Yf.IN_COLUMN_GROUP, e.insertionMode = Yf.IN_COLUMN_GROUP, Dm(e, t); break; case Yp.TR: e.tmplInsertionModeStack[0] = Yf.IN_TABLE_BODY, e.insertionMode = Yf.IN_TABLE_BODY, Pm(e, t); break; case Yp.TD: case Yp.TH: e.tmplInsertionModeStack[0] = Yf.IN_ROW, e.insertionMode = Yf.IN_ROW, Mm(e, t); break; default: e.tmplInsertionModeStack[0] = Yf.IN_BODY, e.insertionMode = Yf.IN_BODY, _m(e, t) } }(this, e); break; case Yf.AFTER_BODY: !function (e, t) { t.tagID === Yp.HTML ? _m(e, t) : Gm(e, t) }(this, e); break; case Yf.IN_FRAMESET: !function (e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.FRAMESET: e._insertElement(t, Mp.HTML); break; case Yp.FRAME: e._appendElement(t, Mp.HTML), t.ackSelfClosing = !0; break; case Yp.NOFRAMES: lm(e, t) } }(this, e); break; case Yf.AFTER_FRAMESET: !function (e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.NOFRAMES: lm(e, t) } }(this, e); break; case Yf.AFTER_AFTER_BODY: !function (e, t) { t.tagID === Yp.HTML ? _m(e, t) : zm(e, t) }(this, e); break; case Yf.AFTER_AFTER_FRAMESET: !function (e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.NOFRAMES: lm(e, t) } }(this, e) } } onEndTag(e) { this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? function (e, t) { if (t.tagID === Yp.P || t.tagID === Yp.BR) return Ym(e), void e._endTagOutsideForeignContent(t); for (let n = e.openElements.stackTop; n > 0; n--) { const r = e.openElements.items[n]; if (e.treeAdapter.getNamespaceURI(r) === Mp.HTML) { e._endTagOutsideForeignContent(t); break } const s = e.treeAdapter.getTagName(r); if (s.toLowerCase() === t.tagName) { t.tagName = s, e.openElements.shortenToLength(n); break } } }(this, e) : this._endTagOutsideForeignContent(e) } _endTagOutsideForeignContent(e) { switch (this.insertionMode) { case Yf.INITIAL: im(this, e); break; case Yf.BEFORE_HTML: !function (e, t) { const n = t.tagID; n !== Yp.HTML && n !== Yp.HEAD && n !== Yp.BODY && n !== Yp.BR || om(e, t) }(this, e); break; case Yf.BEFORE_HEAD: !function (e, t) { const n = t.tagID; n === Yp.HEAD || n === Yp.BODY || n === Yp.HTML || n === Yp.BR ? am(e, t) : e._err(t, _p.endTagWithoutMatchingOpenElement) }(this, e); break; case Yf.IN_HEAD: !function (e, t) { switch (t.tagID) { case Yp.HEAD: e.openElements.pop(), e.insertionMode = Yf.AFTER_HEAD; break; case Yp.BODY: case Yp.BR: case Yp.HTML: um(e, t); break; case Yp.TEMPLATE: cm(e, t); break; default: e._err(t, _p.endTagWithoutMatchingOpenElement) } }(this, e); break; case Yf.IN_HEAD_NO_SCRIPT: !function (e, t) { switch (t.tagID) { case Yp.NOSCRIPT: e.openElements.pop(), e.insertionMode = Yf.IN_HEAD; break; case Yp.BR: hm(e, t); break; default: e._err(t, _p.endTagWithoutMatchingOpenElement) } }(this, e); break; case Yf.AFTER_HEAD: !function (e, t) { switch (t.tagID) { case Yp.BODY: case Yp.HTML: case Yp.BR: dm(e, t); break; case Yp.TEMPLATE: cm(e, t); break; default: e._err(t, _p.endTagWithoutMatchingOpenElement) } }(this, e); break; case Yf.IN_BODY: bm(this, e); break; case Yf.TEXT: !function (e, t) { var n; t.tagID === Yp.SCRIPT && (null === (n = e.scriptHandler) || void 0 === n || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode }(this, e); break; case Yf.IN_TABLE: Nm(this, e); break; case Yf.IN_TABLE_TEXT: Rm(this, e); break; case Yf.IN_CAPTION: !function (e, t) { const n = t.tagID; switch (n) { case Yp.CAPTION: case Yp.TABLE: e.openElements.hasInTableScope(Yp.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Yp.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Yf.IN_TABLE, n === Yp.TABLE && Nm(e, t)); break; case Yp.BODY: case Yp.COL: case Yp.COLGROUP: case Yp.HTML: case Yp.TBODY: case Yp.TD: case Yp.TFOOT: case Yp.TH: case Yp.THEAD: case Yp.TR: break; default: bm(e, t) } }(this, e); break; case Yf.IN_COLUMN_GROUP: !function (e, t) { switch (t.tagID) { case Yp.COLGROUP: e.openElements.currentTagId === Yp.COLGROUP && (e.openElements.pop(), e.insertionMode = Yf.IN_TABLE); break; case Yp.TEMPLATE: cm(e, t); break; case Yp.COL: break; default: Lm(e, t) } }(this, e); break; case Yf.IN_TABLE_BODY: wm(this, e); break; case Yf.IN_ROW: Fm(this, e); break; case Yf.IN_CELL: !function (e, t) { const n = t.tagID; switch (n) { case Yp.TD: case Yp.TH: e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Yf.IN_ROW); break; case Yp.TABLE: case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: case Yp.TR: e.openElements.hasInTableScope(n) && (e._closeTableCell(), Fm(e, t)); break; case Yp.BODY: case Yp.CAPTION: case Yp.COL: case Yp.COLGROUP: case Yp.HTML: break; default: bm(e, t) } }(this, e); break; case Yf.IN_SELECT: Um(this, e); break; case Yf.IN_SELECT_IN_TABLE: !function (e, t) { const n = t.tagID; n === Yp.CAPTION || n === Yp.TABLE || n === Yp.TBODY || n === Yp.TFOOT || n === Yp.THEAD || n === Yp.TR || n === Yp.TD || n === Yp.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(Yp.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : Um(e, t) }(this, e); break; case Yf.IN_TEMPLATE: !function (e, t) { t.tagID === Yp.TEMPLATE && cm(e, t) }(this, e); break; case Yf.AFTER_BODY: jm(this, e); break; case Yf.IN_FRAMESET: !function (e, t) { t.tagID !== Yp.FRAMESET || e.openElements.isRootHtmlElementCurrent() || (e.openElements.pop(), e.fragmentContext || e.openElements.currentTagId === Yp.FRAMESET || (e.insertionMode = Yf.AFTER_FRAMESET)) }(this, e); break; case Yf.AFTER_FRAMESET: !function (e, t) { t.tagID === Yp.HTML && (e.insertionMode = Yf.AFTER_AFTER_FRAMESET) }(this, e); break; case Yf.AFTER_AFTER_BODY: zm(this, e) } } onEof(e) { switch (this.insertionMode) { case Yf.INITIAL: im(this, e); break; case Yf.BEFORE_HTML: om(this, e); break; case Yf.BEFORE_HEAD: am(this, e); break; case Yf.IN_HEAD: um(this, e); break; case Yf.IN_HEAD_NO_SCRIPT: hm(this, e); break; case Yf.AFTER_HEAD: dm(this, e); break; case Yf.IN_BODY: case Yf.IN_TABLE: case Yf.IN_CAPTION: case Yf.IN_COLUMN_GROUP: case Yf.IN_TABLE_BODY: case Yf.IN_ROW: case Yf.IN_CELL: case Yf.IN_SELECT: case Yf.IN_SELECT_IN_TABLE: Sm(this, e); break; case Yf.TEXT: !function (e, t) { e._err(t, _p.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t) }(this, e); break; case Yf.IN_TABLE_TEXT: Rm(this, e); break; case Yf.IN_TEMPLATE: Hm(this, e); break; case Yf.AFTER_BODY: case Yf.IN_FRAMESET: case Yf.AFTER_FRAMESET: case Yf.AFTER_AFTER_BODY: case Yf.AFTER_AFTER_FRAMESET: sm(this, e) } } onWhitespaceCharacter(e) { if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === dp.LINE_FEED)) { if (1 === e.chars.length) return; e.chars = e.chars.substr(1) } if (this.tokenizer.inForeignNode) this._insertCharacters(e); else switch (this.insertionMode) { case Yf.IN_HEAD: case Yf.IN_HEAD_NO_SCRIPT: case Yf.AFTER_HEAD: case Yf.TEXT: case Yf.IN_COLUMN_GROUP: case Yf.IN_SELECT: case Yf.IN_SELECT_IN_TABLE: case Yf.IN_FRAMESET: case Yf.AFTER_FRAMESET: this._insertCharacters(e); break; case Yf.IN_BODY: case Yf.IN_CAPTION: case Yf.IN_CELL: case Yf.IN_TEMPLATE: case Yf.AFTER_BODY: case Yf.AFTER_AFTER_BODY: case Yf.AFTER_AFTER_FRAMESET: fm(this, e); break; case Yf.IN_TABLE: case Yf.IN_TABLE_BODY: case Yf.IN_ROW: km(this, e); break; case Yf.IN_TABLE_TEXT: Om(this, e) } } } function Qf(e, t) { let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName); return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : ym(e, t), n } function Xf(e, t) { let n = null, r = e.openElements.stackTop; for (; r >= 0; r--) { const s = e.openElements.items[r]; if (s === t.element) break; e._isSpecialElement(s, e.openElements.tagIDs[r]) && (n = s) } return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n } function Jf(e, t, n) { let r = t, s = e.openElements.getCommonAncestor(t); for (let i = 0, o = s; o !== n; i++, o = s) { s = e.openElements.getCommonAncestor(o); const n = e.activeFormattingElements.getElementEntry(o), a = n && i >= 3; !n || a ? (a && e.activeFormattingElements.removeEntry(n), e.openElements.remove(o)) : (o = Zf(e, n), r === t && (e.activeFormattingElements.bookmark = n), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(o, r), r = o) } return r } function Zf(e, t) { const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs); return e.openElements.replace(t.element, r), t.element = r, r } function em(e, t, n) { const r = Jp(e.treeAdapter.getTagName(t)); if (e._isElementCausesFosterParenting(r)) e._fosterParentElement(n); else { const s = e.treeAdapter.getNamespaceURI(t); r === Yp.TEMPLATE && s === Mp.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n) } } function tm(e, t, n) { const r = e.treeAdapter.getNamespaceURI(n.element), { token: s } = n, i = e.treeAdapter.createElement(s.tagName, r, s.attrs); e._adoptNodes(t, i), e.treeAdapter.appendChild(t, i), e.activeFormattingElements.insertElementAfterBookmark(i, s), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, i, s.tagID) } function nm(e, t) { for (let n = 0; n < 8; n++) { const n = Qf(e, t); if (!n) break; const r = Xf(e, n); if (!r) break; e.activeFormattingElements.bookmark = n; const s = Jf(e, r, n.element), i = e.openElements.getCommonAncestor(n.element); e.treeAdapter.detachNode(s), i && em(e, i, s), tm(e, r, n) } } function rm(e, t) { e._appendCommentNode(t, e.openElements.currentTmplContentOrNode) } function sm(e, t) { if (e.stopped = !0, t.location) { const n = e.fragmentContext ? 0 : 2; for (let r = e.openElements.stackTop; r >= n; r--)e._setEndLocation(e.openElements.items[r], t); if (!e.fragmentContext && e.openElements.stackTop >= 0) { const n = e.openElements.items[0], r = e.treeAdapter.getNodeSourceCodeLocation(n); if (r && !r.endTag && (e._setEndLocation(n, t), e.openElements.stackTop >= 1)) { const n = e.openElements.items[1], r = e.treeAdapter.getNodeSourceCodeLocation(n); r && !r.endTag && e._setEndLocation(n, t) } } } } function im(e, t) { e._err(t, _p.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Hp.QUIRKS), e.insertionMode = Yf.BEFORE_HTML, e._processToken(t) } function om(e, t) { e._insertFakeRootElement(), e.insertionMode = Yf.BEFORE_HEAD, e._processToken(t) } function am(e, t) { e._insertFakeElement(Gp.HEAD, Yp.HEAD), e.headElement = e.openElements.current, e.insertionMode = Yf.IN_HEAD, e._processToken(t) } function lm(e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.BASE: case Yp.BASEFONT: case Yp.BGSOUND: case Yp.LINK: case Yp.META: e._appendElement(t, Mp.HTML), t.ackSelfClosing = !0; break; case Yp.TITLE: e._switchToTextParsing(t, sf.RCDATA); break; case Yp.NOSCRIPT: e.options.scriptingEnabled ? e._switchToTextParsing(t, sf.RAWTEXT) : (e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_HEAD_NO_SCRIPT); break; case Yp.NOFRAMES: case Yp.STYLE: e._switchToTextParsing(t, sf.RAWTEXT); break; case Yp.SCRIPT: e._switchToTextParsing(t, sf.SCRIPT_DATA); break; case Yp.TEMPLATE: e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = Yf.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(Yf.IN_TEMPLATE); break; case Yp.HEAD: e._err(t, _p.misplacedStartTagForHeadElement); break; default: um(e, t) } } function cm(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== Yp.TEMPLATE && e._err(t, _p.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(Yp.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, _p.endTagWithoutMatchingOpenElement) } function um(e, t) { e.openElements.pop(), e.insertionMode = Yf.AFTER_HEAD, e._processToken(t) } function hm(e, t) { const n = t.type === bp.EOF ? _p.openElementsLeftAfterEof : _p.disallowedContentInNoscriptInHead; e._err(t, n), e.openElements.pop(), e.insertionMode = Yf.IN_HEAD, e._processToken(t) } function dm(e, t) { e._insertFakeElement(Gp.BODY, Yp.BODY), e.insertionMode = Yf.IN_BODY, pm(e, t) } function pm(e, t) { switch (t.type) { case bp.CHARACTER: mm(e, t); break; case bp.WHITESPACE_CHARACTER: fm(e, t); break; case bp.COMMENT: rm(e, t); break; case bp.START_TAG: _m(e, t); break; case bp.END_TAG: bm(e, t); break; case bp.EOF: Sm(e, t) } } function fm(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t) } function mm(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1 } function gm(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, Mp.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function Em(e) { const t = Cp(e, Bp.TYPE); return null != t && "hidden" === t.toLowerCase() } function Tm(e, t) { e._switchToTextParsing(t, sf.RAWTEXT) } function Am(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML) } function _m(e, t) { switch (t.tagID) { case Yp.I: case Yp.S: case Yp.B: case Yp.U: case Yp.EM: case Yp.TT: case Yp.BIG: case Yp.CODE: case Yp.FONT: case Yp.SMALL: case Yp.STRIKE: case Yp.STRONG: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Yp.A: !function (e, t) { const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(Gp.A); n && (nm(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Yp.H1: case Yp.H2: case Yp.H3: case Yp.H4: case Yp.H5: case Yp.H6: !function (e, t) { e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), void 0 !== e.openElements.currentTagId && tf.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, Mp.HTML) }(e, t); break; case Yp.P: case Yp.DL: case Yp.OL: case Yp.UL: case Yp.DIV: case Yp.DIR: case Yp.NAV: case Yp.MAIN: case Yp.MENU: case Yp.ASIDE: case Yp.CENTER: case Yp.FIGURE: case Yp.FOOTER: case Yp.HEADER: case Yp.HGROUP: case Yp.DIALOG: case Yp.DETAILS: case Yp.ADDRESS: case Yp.ARTICLE: case Yp.SEARCH: case Yp.SECTION: case Yp.SUMMARY: case Yp.FIELDSET: case Yp.BLOCKQUOTE: case Yp.FIGCAPTION: !function (e, t) { e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._insertElement(t, Mp.HTML) }(e, t); break; case Yp.LI: case Yp.DD: case Yp.DT: !function (e, t) { e.framesetOk = !1; const n = t.tagID; for (let r = e.openElements.stackTop; r >= 0; r--) { const t = e.openElements.tagIDs[r]; if (n === Yp.LI && t === Yp.LI || (n === Yp.DD || n === Yp.DT) && (t === Yp.DD || t === Yp.DT)) { e.openElements.generateImpliedEndTagsWithExclusion(t), e.openElements.popUntilTagNamePopped(t); break } if (t !== Yp.ADDRESS && t !== Yp.DIV && t !== Yp.P && e._isSpecialElement(e.openElements.items[r], t)) break } e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._insertElement(t, Mp.HTML) }(e, t); break; case Yp.BR: case Yp.IMG: case Yp.WBR: case Yp.AREA: case Yp.EMBED: case Yp.KEYGEN: gm(e, t); break; case Yp.HR: !function (e, t) { e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._appendElement(t, Mp.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 }(e, t); break; case Yp.RB: case Yp.RTC: !function (e, t) { e.openElements.hasInScope(Yp.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, Mp.HTML) }(e, t); break; case Yp.RT: case Yp.RP: !function (e, t) { e.openElements.hasInScope(Yp.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(Yp.RTC), e._insertElement(t, Mp.HTML) }(e, t); break; case Yp.PRE: case Yp.LISTING: !function (e, t) { e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._insertElement(t, Mp.HTML), e.skipNextNewLine = !0, e.framesetOk = !1 }(e, t); break; case Yp.XMP: !function (e, t) { e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, sf.RAWTEXT) }(e, t); break; case Yp.SVG: !function (e, t) { e._reconstructActiveFormattingElements(), Gf(t), zf(t), t.selfClosing ? e._appendElement(t, Mp.SVG) : e._insertElement(t, Mp.SVG), t.ackSelfClosing = !0 }(e, t); break; case Yp.HTML: !function (e, t) { 0 === e.openElements.tmplCount && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs) }(e, t); break; case Yp.BASE: case Yp.LINK: case Yp.META: case Yp.STYLE: case Yp.TITLE: case Yp.SCRIPT: case Yp.BGSOUND: case Yp.BASEFONT: case Yp.TEMPLATE: lm(e, t); break; case Yp.BODY: !function (e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && 0 === e.openElements.tmplCount && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs)) }(e, t); break; case Yp.FORM: !function (e, t) { const n = e.openElements.tmplCount > 0; e.formElement && !n || (e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._insertElement(t, Mp.HTML), n || (e.formElement = e.openElements.current)) }(e, t); break; case Yp.NOBR: !function (e, t) { e._reconstructActiveFormattingElements(), e.openElements.hasInScope(Yp.NOBR) && (nm(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, Mp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Yp.MATH: !function (e, t) { e._reconstructActiveFormattingElements(), jf(t), zf(t), t.selfClosing ? e._appendElement(t, Mp.MATHML) : e._insertElement(t, Mp.MATHML), t.ackSelfClosing = !0 }(e, t); break; case Yp.TABLE: !function (e, t) { e.treeAdapter.getDocumentMode(e.document) !== Hp.QUIRKS && e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._insertElement(t, Mp.HTML), e.framesetOk = !1, e.insertionMode = Yf.IN_TABLE }(e, t); break; case Yp.INPUT: !function (e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, Mp.HTML), Em(t) || (e.framesetOk = !1), t.ackSelfClosing = !0 }(e, t); break; case Yp.PARAM: case Yp.TRACK: case Yp.SOURCE: !function (e, t) { e._appendElement(t, Mp.HTML), t.ackSelfClosing = !0 }(e, t); break; case Yp.IMAGE: !function (e, t) { t.tagName = Gp.IMG, t.tagID = Yp.IMG, gm(e, t) }(e, t); break; case Yp.BUTTON: !function (e, t) { e.openElements.hasInScope(Yp.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Yp.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML), e.framesetOk = !1 }(e, t); break; case Yp.APPLET: case Yp.OBJECT: case Yp.MARQUEE: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1 }(e, t); break; case Yp.IFRAME: !function (e, t) { e.framesetOk = !1, e._switchToTextParsing(t, sf.RAWTEXT) }(e, t); break; case Yp.SELECT: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === Yf.IN_TABLE || e.insertionMode === Yf.IN_CAPTION || e.insertionMode === Yf.IN_TABLE_BODY || e.insertionMode === Yf.IN_ROW || e.insertionMode === Yf.IN_CELL ? Yf.IN_SELECT_IN_TABLE : Yf.IN_SELECT }(e, t); break; case Yp.OPTION: case Yp.OPTGROUP: !function (e, t) { e.openElements.currentTagId === Yp.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, Mp.HTML) }(e, t); break; case Yp.NOEMBED: case Yp.NOFRAMES: Tm(e, t); break; case Yp.FRAMESET: !function (e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_FRAMESET) }(e, t); break; case Yp.TEXTAREA: !function (e, t) { e._insertElement(t, Mp.HTML), e.skipNextNewLine = !0, e.tokenizer.state = sf.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = Yf.TEXT }(e, t); break; case Yp.NOSCRIPT: e.options.scriptingEnabled ? Tm(e, t) : Am(e, t); break; case Yp.PLAINTEXT: !function (e, t) { e.openElements.hasInButtonScope(Yp.P) && e._closePElement(), e._insertElement(t, Mp.HTML), e.tokenizer.state = sf.PLAINTEXT }(e, t); break; case Yp.COL: case Yp.TH: case Yp.TD: case Yp.TR: case Yp.HEAD: case Yp.FRAME: case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: case Yp.CAPTION: case Yp.COLGROUP: break; default: Am(e, t) } } function ym(e, t) { const n = t.tagName, r = t.tagID; for (let s = e.openElements.stackTop; s > 0; s--) { const t = e.openElements.items[s], i = e.openElements.tagIDs[s]; if (r === i && (r !== Yp.UNKNOWN || e.treeAdapter.getTagName(t) === n)) { e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= s && e.openElements.shortenToLength(s); break } if (e._isSpecialElement(t, i)) break } } function bm(e, t) { switch (t.tagID) { case Yp.A: case Yp.B: case Yp.I: case Yp.S: case Yp.U: case Yp.EM: case Yp.TT: case Yp.BIG: case Yp.CODE: case Yp.FONT: case Yp.NOBR: case Yp.SMALL: case Yp.STRIKE: case Yp.STRONG: nm(e, t); break; case Yp.P: !function (e) { e.openElements.hasInButtonScope(Yp.P) || e._insertFakeElement(Gp.P, Yp.P), e._closePElement() }(e); break; case Yp.DL: case Yp.UL: case Yp.OL: case Yp.DIR: case Yp.DIV: case Yp.NAV: case Yp.PRE: case Yp.MAIN: case Yp.MENU: case Yp.ASIDE: case Yp.BUTTON: case Yp.CENTER: case Yp.FIGURE: case Yp.FOOTER: case Yp.HEADER: case Yp.HGROUP: case Yp.DIALOG: case Yp.ADDRESS: case Yp.ARTICLE: case Yp.DETAILS: case Yp.SEARCH: case Yp.SECTION: case Yp.SUMMARY: case Yp.LISTING: case Yp.FIELDSET: case Yp.BLOCKQUOTE: case Yp.FIGCAPTION: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n)) }(e, t); break; case Yp.LI: !function (e) { e.openElements.hasInListItemScope(Yp.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(Yp.LI), e.openElements.popUntilTagNamePopped(Yp.LI)) }(e); break; case Yp.DD: case Yp.DT: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n)) }(e, t); break; case Yp.H1: case Yp.H2: case Yp.H3: case Yp.H4: case Yp.H5: case Yp.H6: !function (e) { e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped()) }(e); break; case Yp.BR: !function (e) { e._reconstructActiveFormattingElements(), e._insertFakeElement(Gp.BR, Yp.BR), e.openElements.pop(), e.framesetOk = !1 }(e); break; case Yp.BODY: !function (e, t) { if (e.openElements.hasInScope(Yp.BODY) && (e.insertionMode = Yf.AFTER_BODY, e.options.sourceCodeLocationInfo)) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e._setEndLocation(n, t) } }(e, t); break; case Yp.HTML: !function (e, t) { e.openElements.hasInScope(Yp.BODY) && (e.insertionMode = Yf.AFTER_BODY, jm(e, t)) }(e, t); break; case Yp.FORM: !function (e) { const t = e.openElements.tmplCount > 0, { formElement: n } = e; t || (e.formElement = null), (n || t) && e.openElements.hasInScope(Yp.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(Yp.FORM) : n && e.openElements.remove(n)) }(e); break; case Yp.APPLET: case Yp.OBJECT: case Yp.MARQUEE: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker()) }(e, t); break; case Yp.TEMPLATE: cm(e, t); break; default: ym(e, t) } } function Sm(e, t) { e.tmplInsertionModeStack.length > 0 ? Hm(e, t) : sm(e, t) } function km(e, t) { if (void 0 !== e.openElements.currentTagId && $f.has(e.openElements.currentTagId)) switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = Yf.IN_TABLE_TEXT, t.type) { case bp.CHARACTER: xm(e, t); break; case bp.WHITESPACE_CHARACTER: Om(e, t) } else Im(e, t) } function Cm(e, t) { switch (t.tagID) { case Yp.TD: case Yp.TH: case Yp.TR: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(Gp.TBODY, Yp.TBODY), e.insertionMode = Yf.IN_TABLE_BODY, Pm(e, t) }(e, t); break; case Yp.STYLE: case Yp.SCRIPT: case Yp.TEMPLATE: lm(e, t); break; case Yp.COL: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(Gp.COLGROUP, Yp.COLGROUP), e.insertionMode = Yf.IN_COLUMN_GROUP, Dm(e, t) }(e, t); break; case Yp.FORM: !function (e, t) { e.formElement || 0 !== e.openElements.tmplCount || (e._insertElement(t, Mp.HTML), e.formElement = e.openElements.current, e.openElements.pop()) }(e, t); break; case Yp.TABLE: !function (e, t) { e.openElements.hasInTableScope(Yp.TABLE) && (e.openElements.popUntilTagNamePopped(Yp.TABLE), e._resetInsertionMode(), e._processStartTag(t)) }(e, t); break; case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_TABLE_BODY }(e, t); break; case Yp.INPUT: !function (e, t) { Em(t) ? e._appendElement(t, Mp.HTML) : Im(e, t), t.ackSelfClosing = !0 }(e, t); break; case Yp.CAPTION: !function (e, t) { e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_CAPTION }(e, t); break; case Yp.COLGROUP: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_COLUMN_GROUP }(e, t); break; default: Im(e, t) } } function Nm(e, t) { switch (t.tagID) { case Yp.TABLE: e.openElements.hasInTableScope(Yp.TABLE) && (e.openElements.popUntilTagNamePopped(Yp.TABLE), e._resetInsertionMode()); break; case Yp.TEMPLATE: cm(e, t); break; case Yp.BODY: case Yp.CAPTION: case Yp.COL: case Yp.COLGROUP: case Yp.HTML: case Yp.TBODY: case Yp.TD: case Yp.TFOOT: case Yp.TH: case Yp.THEAD: case Yp.TR: break; default: Im(e, t) } } function Im(e, t) { const n = e.fosterParentingEnabled; e.fosterParentingEnabled = !0, pm(e, t), e.fosterParentingEnabled = n } function Om(e, t) { e.pendingCharacterTokens.push(t) } function xm(e, t) { e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0 } function Rm(e, t) { let n = 0; if (e.hasNonWhitespacePendingCharacterToken) for (; n < e.pendingCharacterTokens.length; n++)Im(e, e.pendingCharacterTokens[n]); else for (; n < e.pendingCharacterTokens.length; n++)e._insertCharacters(e.pendingCharacterTokens[n]); e.insertionMode = e.originalInsertionMode, e._processToken(t) } const vm = new Set([Yp.CAPTION, Yp.COL, Yp.COLGROUP, Yp.TBODY, Yp.TD, Yp.TFOOT, Yp.TH, Yp.THEAD, Yp.TR]); function Dm(e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.COL: e._appendElement(t, Mp.HTML), t.ackSelfClosing = !0; break; case Yp.TEMPLATE: lm(e, t); break; default: Lm(e, t) } } function Lm(e, t) { e.openElements.currentTagId === Yp.COLGROUP && (e.openElements.pop(), e.insertionMode = Yf.IN_TABLE, e._processToken(t)) } function Pm(e, t) { switch (t.tagID) { case Yp.TR: e.openElements.clearBackToTableBodyContext(), e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_ROW; break; case Yp.TH: case Yp.TD: e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(Gp.TR, Yp.TR), e.insertionMode = Yf.IN_ROW, Mm(e, t); break; case Yp.CAPTION: case Yp.COL: case Yp.COLGROUP: case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE, Cm(e, t)); break; default: Cm(e, t) } } function wm(e, t) { const n = t.tagID; switch (t.tagID) { case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE); break; case Yp.TABLE: e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE, Nm(e, t)); break; case Yp.BODY: case Yp.CAPTION: case Yp.COL: case Yp.COLGROUP: case Yp.HTML: case Yp.TD: case Yp.TH: case Yp.TR: break; default: Nm(e, t) } } function Mm(e, t) { switch (t.tagID) { case Yp.TH: case Yp.TD: e.openElements.clearBackToTableRowContext(), e._insertElement(t, Mp.HTML), e.insertionMode = Yf.IN_CELL, e.activeFormattingElements.insertMarker(); break; case Yp.CAPTION: case Yp.COL: case Yp.COLGROUP: case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: case Yp.TR: e.openElements.hasInTableScope(Yp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE_BODY, Pm(e, t)); break; default: Cm(e, t) } } function Fm(e, t) { switch (t.tagID) { case Yp.TR: e.openElements.hasInTableScope(Yp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE_BODY); break; case Yp.TABLE: e.openElements.hasInTableScope(Yp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE_BODY, wm(e, t)); break; case Yp.TBODY: case Yp.TFOOT: case Yp.THEAD: (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(Yp.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Yf.IN_TABLE_BODY, wm(e, t)); break; case Yp.BODY: case Yp.CAPTION: case Yp.COL: case Yp.COLGROUP: case Yp.HTML: case Yp.TD: case Yp.TH: break; default: Nm(e, t) } } function Bm(e, t) { switch (t.tagID) { case Yp.HTML: _m(e, t); break; case Yp.OPTION: e.openElements.currentTagId === Yp.OPTION && e.openElements.pop(), e._insertElement(t, Mp.HTML); break; case Yp.OPTGROUP: e.openElements.currentTagId === Yp.OPTION && e.openElements.pop(), e.openElements.currentTagId === Yp.OPTGROUP && e.openElements.pop(), e._insertElement(t, Mp.HTML); break; case Yp.HR: e.openElements.currentTagId === Yp.OPTION && e.openElements.pop(), e.openElements.currentTagId === Yp.OPTGROUP && e.openElements.pop(), e._appendElement(t, Mp.HTML), t.ackSelfClosing = !0; break; case Yp.INPUT: case Yp.KEYGEN: case Yp.TEXTAREA: case Yp.SELECT: e.openElements.hasInSelectScope(Yp.SELECT) && (e.openElements.popUntilTagNamePopped(Yp.SELECT), e._resetInsertionMode(), t.tagID !== Yp.SELECT && e._processStartTag(t)); break; case Yp.SCRIPT: case Yp.TEMPLATE: lm(e, t) } } function Um(e, t) { switch (t.tagID) { case Yp.OPTGROUP: e.openElements.stackTop > 0 && e.openElements.currentTagId === Yp.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === Yp.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === Yp.OPTGROUP && e.openElements.pop(); break; case Yp.OPTION: e.openElements.currentTagId === Yp.OPTION && e.openElements.pop(); break; case Yp.SELECT: e.openElements.hasInSelectScope(Yp.SELECT) && (e.openElements.popUntilTagNamePopped(Yp.SELECT), e._resetInsertionMode()); break; case Yp.TEMPLATE: cm(e, t) } } function Hm(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(Yp.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : sm(e, t) } function jm(e, t) { var n; if (t.tagID === Yp.HTML) { if (e.fragmentContext || (e.insertionMode = Yf.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === Yp.HTML) { e._setEndLocation(e.openElements.items[0], t); const r = e.openElements.items[1]; r && !(null === (n = e.treeAdapter.getNodeSourceCodeLocation(r)) || void 0 === n ? void 0 : n.endTag) && e._setEndLocation(r, t) } } else Gm(e, t) } function Gm(e, t) { e.insertionMode = Yf.IN_BODY, pm(e, t) } function zm(e, t) { e.insertionMode = Yf.IN_BODY, pm(e, t) } function Ym(e) { for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== Mp.HTML && void 0 !== e.openElements.currentTagId && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);)e.openElements.pop() } Gp.AREA, Gp.BASE, Gp.BASEFONT, Gp.BGSOUND, Gp.BR, Gp.COL, Gp.EMBED, Gp.FRAME, Gp.HR, Gp.IMG, Gp.INPUT, Gp.KEYGEN, Gp.LINK, Gp.META, Gp.PARAM, Gp.SOURCE, Gp.TRACK, Gp.WBR; const qm = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, Vm = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]), $m = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }; function Wm(e, t) { const n = function (e) { const t = "root" === e.type ? e.children[0] : e; return Boolean(t && ("doctype" === t.type || "element" === t.type && "html" === t.tagName.toLowerCase())) }(e), r = Oh("type", { handlers: { root: Qm, element: Xm, text: Jm, comment: eg, doctype: Zm, raw: tg }, unknown: ng }), s = { parser: n ? new Kf($m) : Kf.getFragmentParser(void 0, $m), handle(e) { r(e, s) }, stitches: !1, options: t || {} }; r(e, s), rg(s, oa()); const i = function (e, t) { const n = t || {}; return Jd({ file: n.file || void 0, location: !1, schema: "svg" === n.space ? vo : Ro, verbose: n.verbose || !1 }, e) }(n ? s.parser.document : s.parser.getFragment(), { file: s.options.file }); return s.stitches && Wc(i, "comment", function (e, t, n) { const r = e; if (r.value.stitch && n && void 0 !== t) return n.children[t] = r.value.stitch, t }), "root" === i.type && 1 === i.children.length && i.children[0].type === e.type ? i.children[0] : i } function Km(e, t) { let n = -1; if (e) for (; ++n < e.length;)t.handle(e[n]) } function Qm(e, t) { Km(e.children, t) } function Xm(e, t) { !function (e, t) { const n = e.tagName.toLowerCase(); if (t.parser.tokenizer.state === sf.PLAINTEXT) return; rg(t, oa(e)); const r = t.parser.openElements.current; let s = "namespaceURI" in r ? r.namespaceURI : Kd.html; s === Kd.html && "svg" === n && (s = Kd.svg); const i = (a = { ...e, children: [] }, ip(a, "svg" === ({ space: s === Kd.svg ? "svg" : "html" } || rp).space ? vo : Ro)), o = { type: bp.START_TAG, tagName: n, tagID: Jp(n), selfClosing: !1, ackSelfClosing: !1, attrs: "attrs" in i ? i.attrs : [], location: ig(e) }; var a; t.parser.currentToken = o, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n }(e, t), Km(e.children, t), function (e, t) { const n = e.tagName.toLowerCase(); if (!t.parser.tokenizer.inForeignNode && cp.includes(n)) return; if (t.parser.tokenizer.state === sf.PLAINTEXT) return; rg(t, ia(e)); const r = { type: bp.END_TAG, tagName: n, tagID: Jp(n), selfClosing: !1, ackSelfClosing: !1, attrs: [], location: ig(e) }; t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), n !== t.parser.tokenizer.lastStartTagName || t.parser.tokenizer.state !== sf.RCDATA && t.parser.tokenizer.state !== sf.RAWTEXT && t.parser.tokenizer.state !== sf.SCRIPT_DATA || (t.parser.tokenizer.state = sf.DATA) }(e, t) } function Jm(e, t) { t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0); const n = { type: bp.CHARACTER, chars: e.value, location: ig(e) }; rg(t, oa(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function Zm(e, t) { const n = { type: bp.DOCTYPE, name: "html", forceQuirks: !1, publicId: "", systemId: "", location: ig(e) }; rg(t, oa(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function eg(e, t) { const n = e.value, r = { type: bp.COMMENT, data: n, location: ig(e) }; rg(t, oa(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken) } function tg(e, t) { if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, sg(t, oa(e)), t.parser.tokenizer.write(t.options.tagfilter ? e.value.replace(qm, "&lt;$1$2") : e.value, !1), t.parser.tokenizer._runParsingLoop(), 72 === t.parser.tokenizer.state || 78 === t.parser.tokenizer.state) { t.parser.tokenizer.preprocessor.lastChunkWritten = !0; const e = t.parser.tokenizer._consume(); t.parser.tokenizer._callState(e) } } function ng(e, t) { const n = e; if (!t.options.passThrough || !t.options.passThrough.includes(n.type)) { let e = ""; throw Vm.has(n.type) && (e = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + e) } !function (e, t) { t.stitches = !0; const n = function (e) { return Uc("children" in e ? { ...e, children: [] } : e) }(e); if ("children" in e && "children" in n) { const r = Wm({ type: "root", children: e.children }, t.options); n.children = r.children } eg({ type: "comment", value: { stitch: n } }, t) }(n, t) } function rg(e, t) { sg(e, t); const n = e.parser.tokenizer.currentCharacterToken; n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = sf.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" } } function sg(e, t) { if (t && void 0 !== t.offset) { const n = { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: -1, endCol: -1, endOffset: -1 }; e.parser.tokenizer.preprocessor.lineStartPos = 1 - t.column, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n } } function ig(e) { const t = oa(e) || { line: void 0, column: void 0, offset: void 0 }, n = ia(e) || { line: void 0, column: void 0, offset: void 0 }; return { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: n.line, endCol: n.column, endOffset: n.offset } } const og = Object.freeze(Object.defineProperty({ __proto__: null, default: function (e) { return function (t, n) { return Wm(t, { ...e, file: n }) } } }, Symbol.toStringTag, { value: "Module" }));</script>
    <style rel="stylesheet" crossorigin>
        @font-face {
            font-family: ChiayiCity;
            src: url(https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/main/assets/fonts/ChiayiCity.ttf) format("truetype");
            font-weight: 400;
            font-style: normal;
            font-display: swap
        }

        *,
        :before,
        :after {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / .5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style:
        }

        ::backdrop {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / .5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style:
        }

        *,
        :before,
        :after {
            box-sizing: border-box;
            border-width: 0;
            border-style: solid;
            border-color: #e5e7eb
        }

        :before,
        :after {
            --tw-content: ""
        }

        html,
        :host {
            line-height: 1.5;
            -webkit-text-size-adjust: 100%;
            -moz-tab-size: 4;
            -o-tab-size: 4;
            tab-size: 4;
            font-family: Huninn, Times New Roman, serif;
            font-feature-settings: normal;
            font-variation-settings: normal;
            -webkit-tap-highlight-color: transparent
        }

        body {
            margin: 0;
            line-height: inherit
        }

        hr {
            height: 0;
            color: inherit;
            border-top-width: 1px
        }

        abbr:where([title]) {
            -webkit-text-decoration: underline dotted;
            text-decoration: underline dotted
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-size: inherit;
            font-weight: inherit
        }

        a {
            color: inherit;
            text-decoration: inherit
        }

        b,
        strong {
            font-weight: bolder
        }

        code,
        kbd,
        samp,
        pre {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
            font-feature-settings: normal;
            font-variation-settings: normal;
            font-size: 1em
        }

        small {
            font-size: 80%
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative;
            vertical-align: baseline
        }

        sub {
            bottom: -.25em
        }

        sup {
            top: -.5em
        }

        table {
            text-indent: 0;
            border-color: inherit;
            border-collapse: collapse
        }

        button,
        input,
        optgroup,
        select,
        textarea {
            font-family: inherit;
            font-feature-settings: inherit;
            font-variation-settings: inherit;
            font-size: 100%;
            font-weight: inherit;
            line-height: inherit;
            letter-spacing: inherit;
            color: inherit;
            margin: 0;
            padding: 0
        }

        button,
        select {
            text-transform: none
        }

        button,
        input:where([type=button]),
        input:where([type=reset]),
        input:where([type=submit]) {
            -webkit-appearance: button;
            background-color: transparent;
            background-image: none
        }

        :-moz-focusring {
            outline: auto
        }

        :-moz-ui-invalid {
            box-shadow: none
        }

        progress {
            vertical-align: baseline
        }

        ::-webkit-inner-spin-button,
        ::-webkit-outer-spin-button {
            height: auto
        }

        [type=search] {
            -webkit-appearance: textfield;
            outline-offset: -2px
        }

        ::-webkit-search-decoration {
            -webkit-appearance: none
        }

        ::-webkit-file-upload-button {
            -webkit-appearance: button;
            font: inherit
        }

        summary {
            display: list-item
        }

        blockquote,
        dl,
        dd,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        hr,
        figure,
        p,
        pre {
            margin: 0
        }

        fieldset {
            margin: 0;
            padding: 0
        }

        legend {
            padding: 0
        }

        ol,
        ul,
        menu {
            list-style: none;
            margin: 0;
            padding: 0
        }

        dialog {
            padding: 0
        }

        textarea {
            resize: vertical
        }

        input::-moz-placeholder,
        textarea::-moz-placeholder {
            opacity: 1;
            color: #9ca3af
        }

        input::placeholder,
        textarea::placeholder {
            opacity: 1;
            color: #9ca3af
        }

        button,
        [role=button] {
            cursor: pointer
        }

        :disabled {
            cursor: default
        }

        img,
        svg,
        video,
        canvas,
        audio,
        iframe,
        embed,
        object {
            display: block;
            vertical-align: middle
        }

        img,
        video {
            max-width: 100%;
            height: auto
        }

        [hidden]:where(:not([hidden=until-found])) {
            display: none
        }

        :root {
            --text-base: 1rem;
            --text-scale: 1
        }

        [data-text-size=small] {
            --text-scale: .875
        }

        [data-text-size=medium] {
            --text-scale: 1
        }

        [data-text-size=large] {
            --text-scale: 1.125
        }

        [data-text-size=xlarge] {
            --text-scale: 1.25
        }

        [data-text-size=xxlarge] {
            --text-scale: 1.4
        }

        [data-text-size=xxxlarge] {
            --text-scale: 1.6
        }

        html {
            scroll-behavior: smooth
        }

        body {
            --tw-bg-opacity: 1;
            background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1));
            font-family: Huninn, Times New Roman, serif;
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1));
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .3s
        }

        body *::-moz-selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body *::selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body::-moz-selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body::selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        body {
            font-size: calc(1rem * var(--text-scale))
        }

        p,
        span,
        a,
        li,
        td,
        th,
        label,
        button {
            font-size: inherit
        }

        h1 {
            font-size: calc(3rem * var(--text-scale))
        }

        h2 {
            font-size: calc(2.25rem * var(--text-scale))
        }

        h3 {
            font-size: calc(1.75rem * var(--text-scale))
        }

        h4 {
            font-size: calc(1.5rem * var(--text-scale))
        }

        h5 {
            font-size: calc(1.25rem * var(--text-scale))
        }

        h6 {
            font-size: calc(1rem * var(--text-scale))
        }

        small,
        .text-xs {
            font-size: calc(.75rem * var(--text-scale))
        }

        .text-sm {
            font-size: calc(.875rem * var(--text-scale))
        }

        ruby {
            ruby-position: over;
            ruby-align: center
        }

        rt {
            font-size: .6em;
            font-weight: 400;
            opacity: .9
        }

        .prose {
            color: var(--tw-prose-body);
            max-width: 65ch
        }

        .prose :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-lead);
            font-size: 1.25em;
            line-height: 1.6;
            margin-top: 1.2em;
            margin-bottom: 1.2em
        }

        .prose :where(a):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-links);
            text-decoration: underline;
            font-weight: 500
        }

        .prose :where(strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-bold);
            font-weight: 600
        }

        .prose :where(a strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(blockquote strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(thead th strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: decimal;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose :where(ol[type=A]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-alpha
        }

        .prose :where(ol[type=a]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-alpha
        }

        .prose :where(ol[type=A s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-alpha
        }

        .prose :where(ol[type=a s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-alpha
        }

        .prose :where(ol[type=I]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-roman
        }

        .prose :where(ol[type=i]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-roman
        }

        .prose :where(ol[type=I s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-roman
        }

        .prose :where(ol[type=i s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-roman
        }

        .prose :where(ol[type="1"]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: decimal
        }

        .prose :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: disc;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
            font-weight: 400;
            color: var(--tw-prose-counters)
        }

        .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
            color: var(--tw-prose-bullets)
        }

        .prose :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            margin-top: 1.25em
        }

        .prose :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-color: var(--tw-prose-hr);
            border-top-width: 1px;
            margin-top: 3em;
            margin-bottom: 3em
        }

        .prose :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 500;
            font-style: italic;
            color: var(--tw-prose-quotes);
            border-inline-start-width: .25rem;
            border-inline-start-color: var(--tw-prose-quote-borders);
            quotes: "" "" "" "";
            margin-top: 1.6em;
            margin-bottom: 1.6em;
            padding-inline-start: 1em
        }

        .prose :where(blockquote p:first-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: open-quote
        }

        .prose :where(blockquote p:last-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: close-quote
        }

        .prose :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 800;
            font-size: 2.25em;
            margin-top: 0;
            margin-bottom: .8888889em;
            line-height: 1.1111111
        }

        .prose :where(h1 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 900;
            color: inherit
        }

        .prose :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 700;
            font-size: 1.5em;
            margin-top: 2em;
            margin-bottom: 1em;
            line-height: 1.3333333
        }

        .prose :where(h2 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 800;
            color: inherit
        }

        .prose :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            font-size: 1.25em;
            margin-top: 1.6em;
            margin-bottom: .6em;
            line-height: 1.6
        }

        .prose :where(h3 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 700;
            color: inherit
        }

        .prose :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: .5em;
            line-height: 1.5
        }

        .prose :where(h4 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 700;
            color: inherit
        }

        .prose :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            display: block;
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 500;
            font-family: inherit;
            color: var(--tw-prose-kbd);
            box-shadow: 0 0 0 1px var(--tw-prose-kbd-shadows), 0 3px 0 var(--tw-prose-kbd-shadows);
            font-size: .875em;
            border-radius: .3125rem;
            padding-top: .1875em;
            padding-inline-end: .375em;
            padding-bottom: .1875em;
            padding-inline-start: .375em
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-code);
            font-weight: 600;
            font-size: .875em
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: "`"
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: "`"
        }

        .prose :where(a code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(h1 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit;
            font-size: .875em
        }

        .prose :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit;
            font-size: .9em
        }

        .prose :where(h4 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(blockquote code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(thead th code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-pre-code);
            background-color: var(--tw-prose-pre-bg);
            overflow-x: auto;
            font-weight: 400;
            font-size: .875em;
            line-height: 1.7142857;
            margin-top: 1.7142857em;
            margin-bottom: 1.7142857em;
            border-radius: .375rem;
            padding-top: .8571429em;
            padding-inline-end: 1.1428571em;
            padding-bottom: .8571429em;
            padding-inline-start: 1.1428571em
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            background-color: transparent;
            border-width: 0;
            border-radius: 0;
            padding: 0;
            font-weight: inherit;
            color: inherit;
            font-size: inherit;
            font-family: inherit;
            line-height: inherit
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: none
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: none
        }

        .prose :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            width: 100%;
            table-layout: auto;
            margin-top: 2em;
            margin-bottom: 2em;
            font-size: .875em;
            line-height: 1.7142857
        }

        .prose :where(thead):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 1px;
            border-bottom-color: var(--tw-prose-th-borders)
        }

        .prose :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            vertical-align: bottom;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose :where(tbody tr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 1px;
            border-bottom-color: var(--tw-prose-td-borders)
        }

        .prose :where(tbody tr:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 0
        }

        .prose :where(tbody td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            vertical-align: baseline
        }

        .prose :where(tfoot):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-top-width: 1px;
            border-top-color: var(--tw-prose-th-borders)
        }

        .prose :where(tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            vertical-align: top
        }

        .prose :where(th, td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            text-align: start
        }

        .prose :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-captions);
            font-size: .875em;
            line-height: 1.4285714;
            margin-top: .8571429em
        }

        .prose {
            --tw-prose-body: #374151;
            --tw-prose-headings: #111827;
            --tw-prose-lead: #4b5563;
            --tw-prose-links: #111827;
            --tw-prose-bold: #111827;
            --tw-prose-counters: #6b7280;
            --tw-prose-bullets: #d1d5db;
            --tw-prose-hr: #e5e7eb;
            --tw-prose-quotes: #111827;
            --tw-prose-quote-borders: #e5e7eb;
            --tw-prose-captions: #6b7280;
            --tw-prose-kbd: #111827;
            --tw-prose-kbd-shadows: rgb(17 24 39 / 10%);
            --tw-prose-code: #111827;
            --tw-prose-pre-code: #e5e7eb;
            --tw-prose-pre-bg: #1f2937;
            --tw-prose-th-borders: #d1d5db;
            --tw-prose-td-borders: #e5e7eb;
            --tw-prose-invert-body: #d1d5db;
            --tw-prose-invert-headings: #fff;
            --tw-prose-invert-lead: #9ca3af;
            --tw-prose-invert-links: #fff;
            --tw-prose-invert-bold: #fff;
            --tw-prose-invert-counters: #9ca3af;
            --tw-prose-invert-bullets: #4b5563;
            --tw-prose-invert-hr: #374151;
            --tw-prose-invert-quotes: #f3f4f6;
            --tw-prose-invert-quote-borders: #374151;
            --tw-prose-invert-captions: #9ca3af;
            --tw-prose-invert-kbd: #fff;
            --tw-prose-invert-kbd-shadows: rgb(255 255 255 / 10%);
            --tw-prose-invert-code: #fff;
            --tw-prose-invert-pre-code: #d1d5db;
            --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
            --tw-prose-invert-th-borders: #4b5563;
            --tw-prose-invert-td-borders: #374151;
            font-size: 1rem;
            line-height: 1.75
        }

        .prose :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            margin-bottom: .5em
        }

        .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose :where(.prose>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            padding-inline-start: 1.625em
        }

        .prose :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .5714286em;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(.prose>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(.prose>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .prose-lg {
            font-size: 1.125rem;
            line-height: 1.7777778
        }

        .prose-lg :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em
        }

        .prose-lg :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.2222222em;
            line-height: 1.4545455;
            margin-top: 1.0909091em;
            margin-bottom: 1.0909091em
        }

        .prose-lg :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.6666667em;
            margin-bottom: 1.6666667em;
            padding-inline-start: 1em
        }

        .prose-lg :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 2.6666667em;
            margin-top: 0;
            margin-bottom: .8333333em;
            line-height: 1
        }

        .prose-lg :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.6666667em;
            margin-top: 1.8666667em;
            margin-bottom: 1.0666667em;
            line-height: 1.3333333
        }

        .prose-lg :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.3333333em;
            margin-top: 1.6666667em;
            margin-bottom: .6666667em;
            line-height: 1.5
        }

        .prose-lg :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: .4444444em;
            line-height: 1.5555556
        }

        .prose-lg :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-lg :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            border-radius: .3125rem;
            padding-top: .2222222em;
            padding-inline-end: .4444444em;
            padding-bottom: .2222222em;
            padding-inline-start: .4444444em
        }

        .prose-lg :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em
        }

        .prose-lg :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8666667em
        }

        .prose-lg :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em
        }

        .prose-lg :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.75;
            margin-top: 2em;
            margin-bottom: 2em;
            border-radius: .375rem;
            padding-top: 1em;
            padding-inline-end: 1.5em;
            padding-bottom: 1em;
            padding-inline-start: 1.5em
        }

        .prose-lg :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .6666667em;
            margin-bottom: .6666667em
        }

        .prose-lg :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .4444444em
        }

        .prose-lg :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .4444444em
        }

        .prose-lg :where(.prose-lg>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .8888889em;
            margin-bottom: .8888889em
        }

        .prose-lg :where(.prose-lg>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .8888889em;
            margin-bottom: .8888889em
        }

        .prose-lg :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .6666667em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 3.1111111em;
            margin-bottom: 3.1111111em
        }

        .prose-lg :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.5
        }

        .prose-lg :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: .75em;
            padding-bottom: .75em;
            padding-inline-start: .75em
        }

        .prose-lg :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-lg :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-lg :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .75em;
            padding-inline-end: .75em;
            padding-bottom: .75em;
            padding-inline-start: .75em
        }

        .prose-lg :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-lg :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-lg :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-lg :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.5;
            margin-top: 1em
        }

        .prose-lg :where(.prose-lg>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(.prose-lg>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .pointer-events-none {
            pointer-events: none
        }

        .visible {
            visibility: visible
        }

        .collapse {
            visibility: collapse
        }

        .static {
            position: static
        }

        .fixed {
            position: fixed
        }

        .absolute {
            position: absolute
        }

        .relative {
            position: relative
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0
        }

        .-right-1 {
            right: -.25rem
        }

        .-top-1 {
            top: -.25rem
        }

        .bottom-0 {
            bottom: 0
        }

        .left-0 {
            left: 0
        }

        .left-4 {
            left: 1rem
        }

        .right-0 {
            right: 0
        }

        .right-4 {
            right: 1rem
        }

        .top-16 {
            top: 4rem
        }

        .top-4 {
            top: 1rem
        }

        .z-10 {
            z-index: 10
        }

        .z-20 {
            z-index: 20
        }

        .z-40 {
            z-index: 40
        }

        .z-50 {
            z-index: 50
        }

        .z-\[60\] {
            z-index: 60
        }

        .col-span-full {
            grid-column: 1 / -1
        }

        .mx-1 {
            margin-left: .25rem;
            margin-right: .25rem
        }

        .mx-4 {
            margin-left: 1rem;
            margin-right: 1rem
        }

        .mx-auto {
            margin-left: auto;
            margin-right: auto
        }

        .mb-1 {
            margin-bottom: .25rem
        }

        .mb-12 {
            margin-bottom: 3rem
        }

        .mb-16 {
            margin-bottom: 4rem
        }

        .mb-2 {
            margin-bottom: .5rem
        }

        .mb-3 {
            margin-bottom: .75rem
        }

        .mb-4 {
            margin-bottom: 1rem
        }

        .mb-6 {
            margin-bottom: 1.5rem
        }

        .mb-8 {
            margin-bottom: 2rem
        }

        .mb-\[1px\] {
            margin-bottom: 1px
        }

        .ml-2 {
            margin-left: .5rem
        }

        .ml-auto {
            margin-left: auto
        }

        .mr-2 {
            margin-right: .5rem
        }

        .mr-3 {
            margin-right: .75rem
        }

        .mt-1 {
            margin-top: .25rem
        }

        .mt-16 {
            margin-top: 4rem
        }

        .mt-2 {
            margin-top: .5rem
        }

        .mt-20 {
            margin-top: 5rem
        }

        .mt-3 {
            margin-top: .75rem
        }

        .mt-4 {
            margin-top: 1rem
        }

        .mt-8 {
            margin-top: 2rem
        }

        .mt-auto {
            margin-top: auto
        }

        .line-clamp-2 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2
        }

        .line-clamp-3 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3
        }

        .block {
            display: block
        }

        .inline-block {
            display: inline-block
        }

        .inline {
            display: inline
        }

        .flex {
            display: flex
        }

        .grid {
            display: grid
        }

        .contents {
            display: contents
        }

        .hidden {
            display: none
        }

        .aspect-\[16\/10\] {
            aspect-ratio: 16/10
        }

        .aspect-\[4\/3\] {
            aspect-ratio: 4/3
        }

        .aspect-video {
            aspect-ratio: 16 / 9
        }

        .h-10 {
            height: 2.5rem
        }

        .h-12 {
            height: 3rem
        }

        .h-16 {
            height: 4rem
        }

        .h-3 {
            height: .75rem
        }

        .h-4 {
            height: 1rem
        }

        .h-5 {
            height: 1.25rem
        }

        .h-6 {
            height: 1.5rem
        }

        .h-8 {
            height: 2rem
        }

        .h-\[50vh\] {
            height: 50vh
        }

        .h-\[calc\(100vh-350px\)\] {
            height: calc(100vh - 350px)
        }

        .h-\[calc\(100vh-64px\)\] {
            height: calc(100vh - 64px)
        }

        .h-full {
            height: 100%
        }

        .max-h-\[80vh\] {
            max-height: 80vh
        }

        .max-h-\[90vh\] {
            max-height: 90vh
        }

        .min-h-32 {
            min-height: 8rem
        }

        .min-h-\[400px\] {
            min-height: 400px
        }

        .min-h-\[60px\] {
            min-height: 60px
        }

        .min-h-screen {
            min-height: 100vh
        }

        .w-1\/2 {
            width: 50%
        }

        .w-1\/4 {
            width: 25%
        }

        .w-10 {
            width: 2.5rem
        }

        .w-12 {
            width: 3rem
        }

        .w-16 {
            width: 4rem
        }

        .w-3 {
            width: .75rem
        }

        .w-3\/4 {
            width: 75%
        }

        .w-4 {
            width: 1rem
        }

        .w-48 {
            width: 12rem
        }

        .w-5 {
            width: 1.25rem
        }

        .w-6 {
            width: 1.5rem
        }

        .w-64 {
            width: 16rem
        }

        .w-8 {
            width: 2rem
        }

        .w-full {
            width: 100%
        }

        .w-px {
            width: 1px
        }

        .min-w-0 {
            min-width: 0px
        }

        .min-w-\[150px\] {
            min-width: 150px
        }

        .min-w-\[60px\] {
            min-width: 60px
        }

        .max-w-2xl {
            max-width: 42rem
        }

        .max-w-3xl {
            max-width: 48rem
        }

        .max-w-4xl {
            max-width: 56rem
        }

        .max-w-6xl {
            max-width: 72rem
        }

        .max-w-lg {
            max-width: 32rem
        }

        .max-w-sm {
            max-width: 24rem
        }

        .max-w-xs {
            max-width: 20rem
        }

        .flex-1 {
            flex: 1 1 0%
        }

        .flex-shrink-0 {
            flex-shrink: 0
        }

        .-translate-x-2 {
            --tw-translate-x: -.5rem;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .rotate-180 {
            --tw-rotate: 180deg;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        @keyframes pulse {
            50% {
                opacity: .5
            }
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(.4, 0, .6, 1) infinite
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        .animate-spin {
            animation: spin 1s linear infinite
        }

        .cursor-not-allowed {
            cursor: not-allowed
        }

        .cursor-pointer {
            cursor: pointer
        }

        .resize-none {
            resize: none
        }

        .list-inside {
            list-style-position: inside
        }

        .list-disc {
            list-style-type: disc
        }

        .appearance-none {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none
        }

        .grid-cols-1 {
            grid-template-columns: repeat(1, minmax(0, 1fr))
        }

        .flex-col {
            flex-direction: column
        }

        .flex-wrap {
            flex-wrap: wrap
        }

        .items-end {
            align-items: flex-end
        }

        .items-center {
            align-items: center
        }

        .justify-end {
            justify-content: flex-end
        }

        .justify-center {
            justify-content: center
        }

        .justify-between {
            justify-content: space-between
        }

        .gap-1 {
            gap: .25rem
        }

        .gap-2 {
            gap: .5rem
        }

        .gap-3 {
            gap: .75rem
        }

        .gap-4 {
            gap: 1rem
        }

        .gap-8 {
            gap: 2rem
        }

        .space-x-1>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(.25rem * var(--tw-space-x-reverse));
            margin-left: calc(.25rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-2>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(.5rem * var(--tw-space-x-reverse));
            margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-4>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(1rem * var(--tw-space-x-reverse));
            margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-6>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(1.5rem * var(--tw-space-x-reverse));
            margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-y-1>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.25rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.25rem * var(--tw-space-y-reverse))
        }

        .space-y-2>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.5rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.5rem * var(--tw-space-y-reverse))
        }

        .space-y-3>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.75rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.75rem * var(--tw-space-y-reverse))
        }

        .space-y-4>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(1rem * var(--tw-space-y-reverse))
        }

        .space-y-6>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(1.5rem * var(--tw-space-y-reverse))
        }

        .overflow-auto {
            overflow: auto
        }

        .overflow-hidden {
            overflow: hidden
        }

        .overflow-y-auto {
            overflow-y: auto
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap
        }

        .whitespace-pre-wrap {
            white-space: pre-wrap
        }

        .break-words {
            overflow-wrap: break-word
        }

        .rounded {
            border-radius: 0
        }

        .rounded-full {
            border-radius: 9999px
        }

        .rounded-lg {
            border-radius: 8px
        }

        .rounded-sm {
            border-radius: 2px
        }

        .rounded-l {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0
        }

        .rounded-r {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0
        }

        .rounded-t {
            border-top-left-radius: 0;
            border-top-right-radius: 0
        }

        .border {
            border-width: 1px
        }

        .border-2 {
            border-width: 2px
        }

        .border-4 {
            border-width: 4px
        }

        .border-y {
            border-top-width: 1px;
            border-bottom-width: 1px
        }

        .border-b {
            border-bottom-width: 1px
        }

        .border-b-2 {
            border-bottom-width: 2px
        }

        .border-r {
            border-right-width: 1px
        }

        .border-t {
            border-top-width: 1px
        }

        .border-dashed {
            border-style: dashed
        }

        .border-none {
            border-style: none
        }

        .border-accent {
            --tw-border-opacity: 1;
            border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
        }

        .border-blue-400 {
            --tw-border-opacity: 1;
            border-color: rgb(96 165 250 / var(--tw-border-opacity, 1))
        }

        .border-blue-500 {
            --tw-border-opacity: 1;
            border-color: rgb(59 130 246 / var(--tw-border-opacity, 1))
        }

        .border-gray-100 {
            --tw-border-opacity: 1;
            border-color: rgb(243 244 246 / var(--tw-border-opacity, 1))
        }

        .border-gray-200 {
            --tw-border-opacity: 1;
            border-color: rgb(229 231 235 / var(--tw-border-opacity, 1))
        }

        .border-gray-300 {
            --tw-border-opacity: 1;
            border-color: rgb(209 213 219 / var(--tw-border-opacity, 1))
        }

        .border-primary {
            --tw-border-opacity: 1;
            border-color: rgb(17 24 39 / var(--tw-border-opacity, 1))
        }

        .border-red-300 {
            --tw-border-opacity: 1;
            border-color: rgb(252 165 165 / var(--tw-border-opacity, 1))
        }

        .border-yellow-300 {
            --tw-border-opacity: 1;
            border-color: rgb(253 224 71 / var(--tw-border-opacity, 1))
        }

        .border-t-transparent {
            border-top-color: transparent
        }

        .bg-accent\/30 {
            background-color: #0f766e4d
        }

        .bg-accent\/80 {
            background-color: #0f766ecc
        }

        .bg-background-light {
            --tw-bg-opacity: 1;
            background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1))
        }

        .bg-black {
            --tw-bg-opacity: 1;
            background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1))
        }

        .bg-black\/50 {
            background-color: #00000080
        }

        .bg-black\/70 {
            background-color: #000000b3
        }

        .bg-blue-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
        }

        .bg-blue-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
        }

        .bg-blue-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-200 {
            --tw-bg-opacity: 1;
            background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-300 {
            --tw-bg-opacity: 1;
            background-color: rgb(209 213 219 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-900 {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .bg-green-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1))
        }

        .bg-green-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(255 237 213 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-400 {
            --tw-bg-opacity: 1;
            background-color: rgb(251 146 60 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(249 115 22 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-500\/80 {
            background-color: #f97316cc
        }

        .bg-primary {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .bg-red-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1))
        }

        .bg-red-600 {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
        }

        .bg-surface-light {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .bg-transparent {
            background-color: transparent
        }

        .bg-white {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-300 {
            --tw-bg-opacity: 1;
            background-color: rgb(253 224 71 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-600\/90 {
            background-color: #ca8a04e6
        }

        .bg-\[url\(\'data\:image\/svg\+xml\;charset\=US-ASCII\,\%3Csvg\%20xmlns\%3D\%22http\%3A\%2F\%2Fwww\.w3\.org\%2F2000\%2Fsvg\%22\%20width\%3D\%22292\.4\%22\%20height\%3D\%22292\.4\%22\%3E\%3Cpath\%20fill\%3D\%22\%239CA3AF\%22\%20d\%3D\%22M287\%2069\.4a17\.6\%2017\.6\%200\%200\%200-13-5\.4H18\.4c-5\%200-9\.3\%201\.8-12\.9\%205\.4A17\.6\%2017\.6\%200\%200\%200\%200\%2082\.2c0\%205\%201\.8\%209\.3\%205\.4\%2012\.9l128\%20127\.9c3\.6\%203\.6\%207\.8\%205\.4\%2012\.8\%205\.4s9\.2-1\.8\%2012\.8-5\.4L287\%2095c3\.5-3\.5\%205\.4-7\.8\%205\.4-12\.8\%200-5-1\.9-9\.2-5\.5-12\.8z\%22\%2F\%3E\%3C\%2Fsvg\%3E\'\)\] {
            background-image: url(data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E)
        }

        .bg-gradient-to-t {
            background-image: linear-gradient(to top, var(--tw-gradient-stops))
        }

        .from-background-light {
            --tw-gradient-from: #FAFAFA var(--tw-gradient-from-position);
            --tw-gradient-to: rgb(250 250 250 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
        }

        .via-transparent {
            --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), transparent var(--tw-gradient-via-position), var(--tw-gradient-to)
        }

        .to-transparent {
            --tw-gradient-to: transparent var(--tw-gradient-to-position)
        }

        .bg-\[length\:0\.7em\] {
            background-size: .7em
        }

        .bg-\[right_0_center\] {
            background-position: right 0 center
        }

        .bg-no-repeat {
            background-repeat: no-repeat
        }

        .object-cover {
            -o-object-fit: cover;
            object-fit: cover
        }

        .p-0 {
            padding: 0
        }

        .p-0\.5 {
            padding: .125rem
        }

        .p-2 {
            padding: .5rem
        }

        .p-3 {
            padding: .75rem
        }

        .p-4 {
            padding: 1rem
        }

        .p-6 {
            padding: 1.5rem
        }

        .p-8 {
            padding: 2rem
        }

        .px-1 {
            padding-left: .25rem;
            padding-right: .25rem
        }

        .px-2 {
            padding-left: .5rem;
            padding-right: .5rem
        }

        .px-3 {
            padding-left: .75rem;
            padding-right: .75rem
        }

        .px-4 {
            padding-left: 1rem;
            padding-right: 1rem
        }

        .py-1 {
            padding-top: .25rem;
            padding-bottom: .25rem
        }

        .py-1\.5 {
            padding-top: .375rem;
            padding-bottom: .375rem
        }

        .py-10 {
            padding-top: 2.5rem;
            padding-bottom: 2.5rem
        }

        .py-12 {
            padding-top: 3rem;
            padding-bottom: 3rem
        }

        .py-16 {
            padding-top: 4rem;
            padding-bottom: 4rem
        }

        .py-2 {
            padding-top: .5rem;
            padding-bottom: .5rem
        }

        .py-3 {
            padding-top: .75rem;
            padding-bottom: .75rem
        }

        .py-4 {
            padding-top: 1rem;
            padding-bottom: 1rem
        }

        .pb-1 {
            padding-bottom: .25rem
        }

        .pr-6 {
            padding-right: 1.5rem
        }

        .pt-10 {
            padding-top: 2.5rem
        }

        .pt-3 {
            padding-top: .75rem
        }

        .pt-8 {
            padding-top: 2rem
        }

        .text-left {
            text-align: left
        }

        .text-center {
            text-align: center
        }

        .font-display {
            font-family: ChiayiCity, Times New Roman, serif
        }

        .font-mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace
        }

        .text-2xl {
            font-size: 1.5rem;
            line-height: 2rem
        }

        .text-3xl {
            font-size: 1.875rem;
            line-height: 2.25rem
        }

        .text-4xl {
            font-size: 2.25rem;
            line-height: 2.5rem
        }

        .text-\[10px\] {
            font-size: 10px
        }

        .text-base {
            font-size: 1rem;
            line-height: 1.5rem
        }

        .text-lg {
            font-size: 1.125rem;
            line-height: 1.75rem
        }

        .text-sm {
            font-size: .875rem;
            line-height: 1.25rem
        }

        .text-xl {
            font-size: 1.25rem;
            line-height: 1.75rem
        }

        .text-xs {
            font-size: .75rem;
            line-height: 1rem
        }

        .font-bold {
            font-weight: 700
        }

        .font-medium {
            font-weight: 500
        }

        .uppercase {
            text-transform: uppercase
        }

        .italic {
            font-style: italic
        }

        .leading-tight {
            line-height: 1.25
        }

        .tracking-\[0\.2em\] {
            letter-spacing: .2em
        }

        .tracking-wider {
            letter-spacing: .05em
        }

        .text-accent {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .text-blue-500 {
            --tw-text-opacity: 1;
            color: rgb(59 130 246 / var(--tw-text-opacity, 1))
        }

        .text-blue-600 {
            --tw-text-opacity: 1;
            color: rgb(37 99 235 / var(--tw-text-opacity, 1))
        }

        .text-blue-700 {
            --tw-text-opacity: 1;
            color: rgb(29 78 216 / var(--tw-text-opacity, 1))
        }

        .text-gray-300 {
            --tw-text-opacity: 1;
            color: rgb(209 213 219 / var(--tw-text-opacity, 1))
        }

        .text-gray-500 {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1))
        }

        .text-green-600 {
            --tw-text-opacity: 1;
            color: rgb(22 163 74 / var(--tw-text-opacity, 1))
        }

        .text-green-700 {
            --tw-text-opacity: 1;
            color: rgb(21 128 61 / var(--tw-text-opacity, 1))
        }

        .text-muted-light {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1))
        }

        .text-orange-500 {
            --tw-text-opacity: 1;
            color: rgb(249 115 22 / var(--tw-text-opacity, 1))
        }

        .text-orange-700 {
            --tw-text-opacity: 1;
            color: rgb(194 65 12 / var(--tw-text-opacity, 1))
        }

        .text-red-500 {
            --tw-text-opacity: 1;
            color: rgb(239 68 68 / var(--tw-text-opacity, 1))
        }

        .text-red-600 {
            --tw-text-opacity: 1;
            color: rgb(220 38 38 / var(--tw-text-opacity, 1))
        }

        .text-text-light {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .text-transparent {
            color: transparent
        }

        .text-white {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        .text-white\/80 {
            color: #fffc
        }

        .text-white\/90 {
            color: #ffffffe6
        }

        .text-yellow-600 {
            --tw-text-opacity: 1;
            color: rgb(202 138 4 / var(--tw-text-opacity, 1))
        }

        .text-yellow-700 {
            --tw-text-opacity: 1;
            color: rgb(161 98 7 / var(--tw-text-opacity, 1))
        }

        .opacity-0 {
            opacity: 0
        }

        .opacity-30 {
            opacity: .3
        }

        .opacity-50 {
            opacity: .5
        }

        .opacity-70 {
            opacity: .7
        }

        .opacity-80 {
            opacity: .8
        }

        .opacity-90 {
            opacity: .9
        }

        .shadow-lg {
            --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-sm {
            --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);
            --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-xl {
            --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .outline-none {
            outline: 2px solid transparent;
            outline-offset: 2px
        }

        .ring-1 {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .ring-white\/20 {
            --tw-ring-color: rgb(255 255 255 / .2)
        }

        .blur {
            --tw-blur: blur(8px);
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .filter {
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .backdrop-blur-sm {
            --tw-backdrop-blur: blur(4px);
            -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
            backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
        }

        .transition-all {
            transition-property: all;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-colors {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-opacity {
            transition-property: opacity;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-transform {
            transition-property: transform;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .delay-100 {
            transition-delay: .1s
        }

        .delay-200 {
            transition-delay: .2s
        }

        .duration-200 {
            transition-duration: .2s
        }

        .duration-300 {
            transition-duration: .3s
        }

        .duration-700 {
            transition-duration: .7s
        }

        .ease-out {
            transition-timing-function: cubic-bezier(0, 0, .2, 1)
        }

        ::-webkit-scrollbar {
            width: 8px
        }

        ::-webkit-scrollbar-track {
            background: transparent
        }

        ::-webkit-scrollbar-thumb {
            background-color: #d1d5db;
            border-radius: 20px
        }

        .dark ::-webkit-scrollbar-thumb {
            background-color: #374151
        }

        .prose {
            max-width: 70ch
        }

        .prose p {
            margin-bottom: 2em;
            line-height: var(--prose-body-line-height, 2);
            font-weight: 400;
            font-size: calc(1.125rem * var(--text-scale));
            color: inherit
        }

        .prose h2 {
            font-family: ChiayiCity, Times New Roman, serif;
            font-size: calc(2.25rem * var(--text-scale));
            margin-top: 3em;
            margin-bottom: 1em;
            line-height: 1.25;
            font-weight: 400;
            letter-spacing: -.02em
        }

        .prose h3 {
            font-family: ChiayiCity, Times New Roman, serif;
            font-size: calc(1.75rem * var(--text-scale));
            margin-top: 2.5em;
            margin-bottom: .8em;
            line-height: 1.3;
            font-weight: 400;
            letter-spacing: -.01em
        }

        .prose blockquote {
            border-left: 4px solid var(--tw-prose-quote-borders, #0F766E);
            padding-left: 1.5rem;
            font-style: italic;
            margin: 2.5rem 0;
            color: #4b5563;
            font-size: calc(1.25rem * var(--text-scale));
            line-height: var(--prose-blockquote-line-height, 1.8);
            font-family: ChiayiCity, Times New Roman, serif
        }

        .dark .prose blockquote {
            border-color: #0f766e;
            color: #d1d5db
        }

        .prose ul,
        .prose ol {
            padding-left: 1.75rem;
            margin-bottom: 2em
        }

        .prose ul {
            list-style-type: disc
        }

        .prose ol {
            list-style-type: decimal
        }

        .prose li {
            margin-bottom: .75em;
            line-height: var(--prose-list-line-height, 1.8);
            font-size: calc(1.0625rem * var(--text-scale))
        }

        .prose code {
            font-size: .85em;
            padding: .25em .4em;
            background-color: #f1f5f9;
            border-radius: 4px;
            font-family: Menlo, Monaco, Courier New, monospace;
            color: #0f766e;
            font-weight: 500
        }

        .dark .prose code {
            background-color: #2d333b;
            color: #5eead4
        }

        .prose pre {
            margin: 2em 0;
            padding: 1.25rem;
            overflow-x: auto;
            border-radius: 4px
        }

        .prose a {
            color: inherit;
            text-decoration: underline;
            text-decoration-thickness: 1px;
            text-underline-offset: 3px;
            transition: opacity .2s
        }

        .prose a:hover {
            opacity: .7
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none
        }

        .dark\:prose-invert:is(.dark *) {
            --tw-prose-body: var(--tw-prose-invert-body);
            --tw-prose-headings: var(--tw-prose-invert-headings);
            --tw-prose-lead: var(--tw-prose-invert-lead);
            --tw-prose-links: var(--tw-prose-invert-links);
            --tw-prose-bold: var(--tw-prose-invert-bold);
            --tw-prose-counters: var(--tw-prose-invert-counters);
            --tw-prose-bullets: var(--tw-prose-invert-bullets);
            --tw-prose-hr: var(--tw-prose-invert-hr);
            --tw-prose-quotes: var(--tw-prose-invert-quotes);
            --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
            --tw-prose-captions: var(--tw-prose-invert-captions);
            --tw-prose-kbd: var(--tw-prose-invert-kbd);
            --tw-prose-kbd-shadows: var(--tw-prose-invert-kbd-shadows);
            --tw-prose-code: var(--tw-prose-invert-code);
            --tw-prose-pre-code: var(--tw-prose-invert-pre-code);
            --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
            --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
            --tw-prose-td-borders: var(--tw-prose-invert-td-borders)
        }

        @media (min-width: 768px) {
            .md\:prose-xl {
                font-size: 1.25rem;
                line-height: 1.8
            }

            .md\:prose-xl :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.2em;
                line-height: 1.5;
                margin-top: 1em;
                margin-bottom: 1em
            }

            .md\:prose-xl :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.6em;
                margin-bottom: 1.6em;
                padding-inline-start: 1.0666667em
            }

            .md\:prose-xl :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 2.8em;
                margin-top: 0;
                margin-bottom: .8571429em;
                line-height: 1
            }

            .md\:prose-xl :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.8em;
                margin-top: 1.5555556em;
                margin-bottom: .8888889em;
                line-height: 1.1111111
            }

            .md\:prose-xl :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.5em;
                margin-top: 1.6em;
                margin-bottom: .6666667em;
                line-height: 1.3333333
            }

            .md\:prose-xl :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.8em;
                margin-bottom: .6em;
                line-height: 1.6
            }

            .md\:prose-xl :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0;
                margin-bottom: 0
            }

            .md\:prose-xl :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                border-radius: .3125rem;
                padding-top: .25em;
                padding-inline-end: .4em;
                padding-bottom: .25em;
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em
            }

            .md\:prose-xl :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .8611111em
            }

            .md\:prose-xl :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em
            }

            .md\:prose-xl :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.7777778;
                margin-top: 2em;
                margin-bottom: 2em;
                border-radius: .5rem;
                padding-top: 1.1111111em;
                padding-inline-end: 1.3333333em;
                padding-bottom: 1.1111111em;
                padding-inline-start: 1.3333333em
            }

            .md\:prose-xl :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .6em;
                margin-bottom: .6em
            }

            .md\:prose-xl :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .8em;
                margin-bottom: .8em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .8em;
                margin-bottom: .8em
            }

            .md\:prose-xl :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .6em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2.8em;
                margin-bottom: 2.8em
            }

            .md\:prose-xl :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.5555556
            }

            .md\:prose-xl :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: .6666667em;
                padding-bottom: .8888889em;
                padding-inline-start: .6666667em
            }

            .md\:prose-xl :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: 0
            }

            .md\:prose-xl :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: 0
            }

            .md\:prose-xl :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-top: .8888889em;
                padding-inline-end: .6666667em;
                padding-bottom: .8888889em;
                padding-inline-start: .6666667em
            }

            .md\:prose-xl :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: 0
            }

            .md\:prose-xl :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: 0
            }

            .md\:prose-xl :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0;
                margin-bottom: 0
            }

            .md\:prose-xl :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.5555556;
                margin-top: 1em
            }

            .md\:prose-xl :where(.md\:prose-xl>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(.md\:prose-xl>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 0
            }
        }

        .hover\:border-accent:hover {
            --tw-border-opacity: 1;
            border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
        }

        .hover\:bg-blue-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-blue-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-blue-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(37 99 235 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-200:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-800:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-green-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(22 163 74 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-orange-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(234 88 12 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(254 226 226 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-700:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(185 28 28 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-white:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .hover\:text-accent:hover {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .hover\:text-gray-800:hover {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .hover\:text-gray-900:hover {
            --tw-text-opacity: 1;
            color: rgb(17 24 39 / var(--tw-text-opacity, 1))
        }

        .hover\:text-red-700:hover {
            --tw-text-opacity: 1;
            color: rgb(185 28 28 / var(--tw-text-opacity, 1))
        }

        .hover\:text-text-light:hover {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .hover\:opacity-70:hover {
            opacity: .7
        }

        .hover\:opacity-80:hover {
            opacity: .8
        }

        .focus\:border-gray-400:focus {
            --tw-border-opacity: 1;
            border-color: rgb(156 163 175 / var(--tw-border-opacity, 1))
        }

        .focus\:outline-none:focus {
            outline: 2px solid transparent;
            outline-offset: 2px
        }

        .focus\:ring-0:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-2:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-black:focus {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity, 1))
        }

        .disabled\:cursor-not-allowed:disabled {
            cursor: not-allowed
        }

        .disabled\:opacity-30:disabled {
            opacity: .3
        }

        .disabled\:opacity-50:disabled {
            opacity: .5
        }

        .group:hover .group-hover\:translate-x-0 {
            --tw-translate-x: 0px;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:translate-y-\[-2px\] {
            --tw-translate-y: -2px;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:scale-105 {
            --tw-scale-x: 1.05;
            --tw-scale-y: 1.05;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:text-accent {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .group:hover .group-hover\:opacity-100 {
            opacity: 1
        }

        .group:hover .group-hover\:shadow-md {
            --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .dark\:border-gray-600:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(75 85 99 / var(--tw-border-opacity, 1))
        }

        .dark\:border-gray-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(55 65 81 / var(--tw-border-opacity, 1))
        }

        .dark\:border-gray-800:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(31 41 55 / var(--tw-border-opacity, 1))
        }

        .dark\:border-yellow-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(161 98 7 / var(--tw-border-opacity, 1))
        }

        .dark\:bg-background-dark:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-blue-900\/20:is(.dark *) {
            background-color: #1e3a8a33
        }

        .dark\:bg-blue-900\/40:is(.dark *) {
            background-color: #1e3a8a66
        }

        .dark\:bg-gray-600:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(75 85 99 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-700:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-800:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-800\/30:is(.dark *) {
            background-color: #1f29374d
        }

        .dark\:bg-gray-800\/50:is(.dark *) {
            background-color: #1f293780
        }

        .dark\:bg-gray-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-green-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(20 83 45 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-orange-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(124 45 18 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-surface-dark:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(24 27 33 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-white:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-yellow-900\/20:is(.dark *) {
            background-color: #713f1233
        }

        .dark\:from-background-dark:is(.dark *) {
            --tw-gradient-from: #0f1115 var(--tw-gradient-from-position);
            --tw-gradient-to: rgb(15 17 21 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
        }

        .dark\:text-black:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(0 0 0 / var(--tw-text-opacity, 1))
        }

        .dark\:text-blue-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(147 197 253 / var(--tw-text-opacity, 1))
        }

        .dark\:text-gray-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1))
        }

        .dark\:text-green-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(134 239 172 / var(--tw-text-opacity, 1))
        }

        .dark\:text-muted-dark:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1))
        }

        .dark\:text-orange-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(253 186 116 / var(--tw-text-opacity, 1))
        }

        .dark\:text-text-dark:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(253 224 71 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(250 204 21 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-500:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(234 179 8 / var(--tw-text-opacity, 1))
        }

        .dark\:invert:is(.dark *) {
            --tw-invert: invert(100%);
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .dark\:hover\:bg-blue-900\/20:hover:is(.dark *) {
            background-color: #1e3a8a33
        }

        .dark\:hover\:bg-blue-900\/30:hover:is(.dark *) {
            background-color: #1e3a8a4d
        }

        .dark\:hover\:bg-gray-700:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-gray-800:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-red-900:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(127 29 29 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-red-900\/30:hover:is(.dark *) {
            background-color: #7f1d1d4d
        }

        .dark\:hover\:text-accent:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-gray-200:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(229 231 235 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-text-dark:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-white:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        .dark\:focus\:ring-white:focus:is(.dark *) {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity, 1))
        }

        @media (min-width: 640px) {
            .sm\:flex {
                display: flex
            }

            .sm\:px-6 {
                padding-left: 1.5rem;
                padding-right: 1.5rem
            }
        }

        @media (min-width: 768px) {
            .md\:static {
                position: static
            }

            .md\:z-auto {
                z-index: auto
            }

            .md\:mb-0 {
                margin-bottom: 0
            }

            .md\:inline {
                display: inline
            }

            .md\:flex {
                display: flex
            }

            .md\:grid {
                display: grid
            }

            .md\:hidden {
                display: none
            }

            .md\:aspect-auto {
                aspect-ratio: auto
            }

            .md\:h-\[60vh\] {
                height: 60vh
            }

            .md\:h-full {
                height: 100%
            }

            .md\:max-h-\[calc\(100vh-64px\)\] {
                max-height: calc(100vh - 64px)
            }

            .md\:grid-cols-2 {
                grid-template-columns: repeat(2, minmax(0, 1fr))
            }

            .md\:gap-8 {
                gap: 2rem
            }

            .md\:space-x-2>:not([hidden])~:not([hidden]) {
                --tw-space-x-reverse: 0;
                margin-right: calc(.5rem * var(--tw-space-x-reverse));
                margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
            }

            .md\:p-12 {
                padding: 3rem
            }

            .md\:px-3 {
                padding-left: .75rem;
                padding-right: .75rem
            }

            .md\:px-4 {
                padding-left: 1rem;
                padding-right: 1rem
            }

            .md\:py-4 {
                padding-top: 1rem;
                padding-bottom: 1rem
            }

            .md\:text-4xl {
                font-size: 2.25rem;
                line-height: 2.5rem
            }

            .md\:text-6xl {
                font-size: 3.75rem;
                line-height: 1
            }

            .md\:text-base {
                font-size: 1rem;
                line-height: 1.5rem
            }
        }

        @media (min-width: 1024px) {
            .lg\:grid-cols-3 {
                grid-template-columns: repeat(3, minmax(0, 1fr))
            }

            .lg\:px-8 {
                padding-left: 2rem;
                padding-right: 2rem
            }

            .lg\:text-7xl {
                font-size: 4.5rem;
                line-height: 1
            }
        }
    </style>
</head>

<body>
    <!-- Loading skeleton - replaced by React when app loads -->
    <div id="root">
        <div class="skeleton-loader">
            <nav class="skeleton-nav">
                <div class="skeleton-logo"></div>
            </nav>
            <main class="skeleton-content">
                <div class="skeleton-title"></div>
                <div class="skeleton-grid">
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

</body>

</html>