---
layout: null
title: Blog
version: v0.2f
updated: 2026-01-17
permalink: /blog-app
note: Fix language selector z-index issue
---
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Blog</title>
    <style>
        html.font-loading body {
            opacity: 0;
            visibility: hidden;
        }

        body {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
        }
    </style>
    <script>
        (function () {
            document.documentElement.classList.add('font-loading');

            if (document.fonts) {
                document.fonts.ready.then(function () {
                    document.documentElement.classList.remove('font-loading');
                }).catch(function () {
                    document.documentElement.classList.remove('font-loading');
                });

                setTimeout(function () {
                    document.documentElement.classList.remove('font-loading');
                }, 3000);
            } else {
                document.documentElement.classList.remove('font-loading');
            }
        })();
    </script>
    <link rel="icon" type="image/svg+xml" href="./logo.svg" />

    <!-- Preconnect to API for faster first request -->
    <link rel="preconnect" href="https://cr-next-blog-firestore-276616043493.asia-east1.run.app" crossorigin />
    <link rel="dns-prefetch" href="https://cr-next-blog-firestore-276616043493.asia-east1.run.app" />

    <style>
        @font-face {
            font-family: 'ChiayiCity';
            src: url('https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/main/assets/fonts/ChiayiCity.ttf') format('truetype');
            font-weight: normal;
            font-style: normal;
            font-display: swap;
        }
    </style>

    <!-- CDN Libraries - React only (other libs bundled for reliability) -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>

    <!-- Loading skeleton styles - displays instantly before JS loads -->
    <style>
        .skeleton-loader {
            min-height: 100vh;
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            display: flex;
            flex-direction: column;
        }

        .skeleton-nav {
            height: 64px;
            background: white;
            border-bottom: 1px solid #e2e8f0;
            display: flex;
            align-items: center;
            padding: 0 24px;
        }

        .skeleton-logo {
            width: 120px;
            height: 24px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
        }

        .skeleton-content {
            flex: 1;
            max-width: 1200px;
            margin: 48px auto;
            padding: 0 24px;
            width: 100%;
        }

        .skeleton-title {
            width: 60%;
            height: 32px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 6px;
            margin-bottom: 32px;
        }

        .skeleton-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 24px;
        }

        .skeleton-card {
            background: white;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }

        .skeleton-image {
            aspect-ratio: 16/10;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }

        .skeleton-text {
            padding: 16px;
        }

        .skeleton-line {
            height: 16px;
            background: linear-gradient(90deg, #e2e8f0 25%, #f1f5f9 50%, #e2e8f0 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 4px;
            margin-bottom: 8px;
        }

        .skeleton-line:last-child {
            width: 60%;
            margin-bottom: 0;
        }

        @keyframes shimmer {
            0% {
                background-position: 200% 0;
            }

            100% {
                background-position: -200% 0;
            }
        }
    </style>
    {% raw %}
    <script type="module"
        crossorigin>var e, t, n = Object.defineProperty, r = (e, t, r) => ((e, t, r) => t in e ? n(e, t, { enumerable: !0, configurable: !0, writable: !0, value: r }) : e[t] = r)(e, "symbol" != typeof t ? t + "" : t, r); !function () { const e = document.createElement("link").relList; if (!(e && e.supports && e.supports("modulepreload"))) { for (const e of document.querySelectorAll('link[rel="modulepreload"]')) t(e); new MutationObserver(e => { for (const n of e) if ("childList" === n.type) for (const e of n.addedNodes) "LINK" === e.tagName && "modulepreload" === e.rel && t(e) }).observe(document, { childList: !0, subtree: !0 }) } function t(e) { if (e.ep) return; e.ep = !0; const t = function (e) { const t = {}; return e.integrity && (t.integrity = e.integrity), e.referrerPolicy && (t.referrerPolicy = e.referrerPolicy), "use-credentials" === e.crossOrigin ? t.credentials = "include" : "anonymous" === e.crossOrigin ? t.credentials = "omit" : t.credentials = "same-origin", t }(e); fetch(e.href, t) } }(); var s = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof window ? window : "undefined" != typeof global ? global : "undefined" != typeof self ? self : {}; function i(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var o = { exports: {} }, a = {}, l = React, c = l, u = Symbol.for("react.element"), h = Symbol.for("react.fragment"), d = Object.prototype.hasOwnProperty, p = c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, f = { key: !0, ref: !0, __self: !0, __source: !0 }; function m(e, t, n) { var r, s = {}, i = null, o = null; for (r in void 0 !== n && (i = "" + n), void 0 !== t.key && (i = "" + t.key), void 0 !== t.ref && (o = t.ref), t) d.call(t, r) && !f.hasOwnProperty(r) && (s[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps) void 0 === s[r] && (s[r] = t[r]); return { $$typeof: u, type: e, key: i, ref: o, props: s, _owner: p.current } } a.Fragment = h, a.jsx = m, a.jsxs = m, o.exports = a; var g, E, T = o.exports;
/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function A() { return A = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, A.apply(this, arguments) } (E = g || (g = {})).Pop = "POP", E.Push = "PUSH", E.Replace = "REPLACE"; const _ = "popstate"; function y(e) { return void 0 === e && (e = {}), function (e, t, n, r) { void 0 === r && (r = {}); let { window: s = document.defaultView, v5Compat: i = !1 } = r, o = s.history, a = g.Pop, l = null, c = u(); function u() { return (o.state || { idx: null }).idx } function h() { a = g.Pop; let e = u(), t = null == e ? null : e - c; c = e, l && l({ action: a, location: p.location, delta: t }) } function d(e) { let t = "null" !== s.location.origin ? s.location.origin : s.location.href, n = "string" == typeof e ? e : N(e); return n = n.replace(/ $/, "%20"), b(t, "No window.location.(origin|href) available to create URL for href: " + n), new URL(n, t) } null == c && (c = 0, o.replaceState(A({}, o.state, { idx: c }), "")); let p = { get action() { return a }, get location() { return function (e, t) { let { pathname: n = "/", search: r = "", hash: s = "" } = I(e.location.hash.substr(1)); return n.startsWith("/") || n.startsWith(".") || (n = "/" + n), C("", { pathname: n, search: r, hash: s }, t.state && t.state.usr || null, t.state && t.state.key || "default") }(s, o) }, listen(e) { if (l) throw new Error("A history only accepts one active listener"); return s.addEventListener(_, h), l = e, () => { s.removeEventListener(_, h), l = null } }, createHref: e => function (e, t) { let n = e.document.querySelector("base"), r = ""; if (n && n.getAttribute("href")) { let t = e.location.href, n = t.indexOf("#"); r = -1 === n ? t : t.slice(0, n) } return r + "#" + ("string" == typeof t ? t : N(t)) }(s, e), createURL: d, encodeLocation(e) { let t = d(e); return { pathname: t.pathname, search: t.search, hash: t.hash } }, push: function (e, t) { a = g.Push; let r = C(p.location, e, t); n && n(r, e), c = u() + 1; let h = k(r, c), d = p.createHref(r); try { o.pushState(h, "", d) } catch (f) { if (f instanceof DOMException && "DataCloneError" === f.name) throw f; s.location.assign(d) } i && l && l({ action: a, location: p.location, delta: 1 }) }, replace: function (e, t) { a = g.Replace; let r = C(p.location, e, t); n && n(r, e), c = u(); let s = k(r, c), h = p.createHref(r); o.replaceState(s, "", h), i && l && l({ action: a, location: p.location, delta: 0 }) }, go: e => o.go(e) }; return p }(0, 0, function (e, t) { S("/" === e.pathname.charAt(0), "relative pathnames are not supported in hash history.push(" + JSON.stringify(t) + ")") }, e) } function b(e, t) { if (!1 === e || null == e) throw new Error(t) } function S(e, t) { if (!e) { "undefined" != typeof console && console.warn(t); try { throw new Error(t) } catch (n) { } } } function k(e, t) { return { usr: e.state, key: e.key, idx: t } } function C(e, t, n, r) { return void 0 === n && (n = null), A({ pathname: "string" == typeof e ? e : e.pathname, search: "", hash: "" }, "string" == typeof t ? I(t) : t, { state: n, key: t && t.key || r || Math.random().toString(36).substr(2, 8) }) } function N(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && "?" !== n && (t += "?" === n.charAt(0) ? n : "?" + n), r && "#" !== r && (t += "#" === r.charAt(0) ? r : "#" + r), t } function I(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } var O, x; function v(e, t, n) { return void 0 === n && (n = "/"), function (e, t, n) { let r = Y(("string" == typeof t ? I(t) : t).pathname || "/", n); if (null == r) return null; let s = R(e); !function (e) { e.sort((e, t) => e.score !== t.score ? t.score - e.score : function (e, t) { return e.length === t.length && e.slice(0, -1).every((e, n) => e === t[n]) ? e[e.length - 1] - t[t.length - 1] : 0 }(e.routesMeta.map(e => e.childrenIndex), t.routesMeta.map(e => e.childrenIndex))) }(s); let i = null; for (let o = 0; null == i && o < s.length; ++o) { let e = z(r); i = j(s[o], e) } return i }(e, t, n) } function R(e, t, n, r) { void 0 === t && (t = []), void 0 === n && (n = []), void 0 === r && (r = ""); let s = (e, s, i) => { let o = { relativePath: void 0 === i ? e.path || "" : i, caseSensitive: !0 === e.caseSensitive, childrenIndex: s, route: e }; o.relativePath.startsWith("/") && (b(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path "' + r + '" is not valid. An absolute child route path must start with the combined path of all its parent routes.'), o.relativePath = o.relativePath.slice(r.length)); let a = Q([r, o.relativePath]), l = n.concat(o); e.children && e.children.length > 0 && (b(!0 !== e.index, 'Index routes must not have child routes. Please remove all child routes from route path "' + a + '".'), R(e.children, t, l, a)), (null != e.path || e.index) && t.push({ path: a, score: H(a, e.index), routesMeta: l }) }; return e.forEach((e, t) => { var n; if ("" !== e.path && null != (n = e.path) && n.includes("?")) for (let r of D(e.path)) s(e, t, r); else s(e, t) }), t } function D(e) { let t = e.split("/"); if (0 === t.length) return []; let [n, ...r] = t, s = n.endsWith("?"), i = n.replace(/\?$/, ""); if (0 === r.length) return s ? [i, ""] : [i]; let o = D(r.join("/")), a = []; return a.push(...o.map(e => "" === e ? i : [i, e].join("/"))), s && a.push(...o), a.map(t => e.startsWith("/") && "" === t ? "/" : t) } (x = O || (O = {})).data = "data", x.deferred = "deferred", x.redirect = "redirect", x.error = "error"; const L = /^:[\w-]+$/, P = 3, w = 2, M = 1, F = 10, B = -2, U = e => "*" === e; function H(e, t) { let n = e.split("/"), r = n.length; return n.some(U) && (r += B), t && (r += w), n.filter(e => !U(e)).reduce((e, t) => e + (L.test(t) ? P : "" === t ? M : F), r) } function j(e, t, n) { let { routesMeta: r } = e, s = {}, i = "/", o = []; for (let a = 0; a < r.length; ++a) { let e = r[a], n = a === r.length - 1, l = "/" === i ? t : t.slice(i.length) || "/", c = G({ path: e.relativePath, caseSensitive: e.caseSensitive, end: n }, l), u = e.route; if (!c) return null; Object.assign(s, c.params), o.push({ params: s, pathname: Q([i, c.pathname]), pathnameBase: X(Q([i, c.pathnameBase])), route: u }), "/" !== c.pathnameBase && (i = Q([i, c.pathnameBase])) } return o } function G(e, t) { "string" == typeof e && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = function (e, t, n) { void 0 === t && (t = !1), void 0 === n && (n = !0), S("*" === e || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were "' + e.replace(/\*$/, "/*") + '" because the `*` character must always follow a `/` in the pattern. To get rid of this warning, please change the route path to "' + e.replace(/\*$/, "/*") + '".'); let r = [], s = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (e, t, n) => (r.push({ paramName: t, isOptional: null != n }), n ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), s += "*" === e || "/*" === e ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? s += "\\/*$" : "" !== e && "/" !== e && (s += "(?:(?=\\/|$))"), [new RegExp(s, t ? void 0 : "i"), r] }(e.path, e.caseSensitive, e.end), s = t.match(n); if (!s) return null; let i = s[0], o = i.replace(/(.)\/+$/, "$1"), a = s.slice(1); return { params: r.reduce((e, t, n) => { let { paramName: r, isOptional: s } = t; if ("*" === r) { let e = a[n] || ""; o = i.slice(0, i.length - e.length).replace(/(.)\/+$/, "$1") } const l = a[n]; return e[r] = s && !l ? void 0 : (l || "").replace(/%2F/g, "/"), e }, {}), pathname: i, pathnameBase: o, pattern: e } } function z(e) { try { return e.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/") } catch (t) { return S(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent encoding (' + t + ")."), e } } function Y(e, t) { if ("/" === t) return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && "/" !== r ? null : e.slice(n) || "/" } const q = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i; function V(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(e => { ".." === e ? n.length > 1 && n.pop() : "." !== e && n.push(e) }), n.length > 1 ? n.join("/") : "/" } function $(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified `to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the `to." + n + '` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.' } function W(e, t) { let n = function (e) { return e.filter((e, t) => 0 === t || e.route.path && e.route.path.length > 0) }(e); return t ? n.map((e, t) => t === n.length - 1 ? e.pathname : e.pathnameBase) : n.map(e => e.pathnameBase) } function K(e, t, n, r) { let s; void 0 === r && (r = !1), "string" == typeof e ? s = I(e) : (s = A({}, e), b(!s.pathname || !s.pathname.includes("?"), $("?", "pathname", "search", s)), b(!s.pathname || !s.pathname.includes("#"), $("#", "pathname", "hash", s)), b(!s.search || !s.search.includes("#"), $("#", "search", "hash", s))); let i, o = "" === e || "" === s.pathname, a = o ? "/" : s.pathname; if (null == a) i = n; else { let e = t.length - 1; if (!r && a.startsWith("..")) { let t = a.split("/"); for (; ".." === t[0];)t.shift(), e -= 1; s.pathname = t.join("/") } i = e >= 0 ? t[e] : "/" } let l = function (e, t) { void 0 === t && (t = "/"); let n, { pathname: r, search: s = "", hash: i = "" } = "string" == typeof e ? I(e) : e; if (r) if (o = r, q.test(o)) n = r; else { if (r.includes("//")) { let e = r; r = r.replace(/\/\/+/g, "/"), S(!1, "Pathnames cannot have embedded double slashes - normalizing " + e + " -> " + r) } n = r.startsWith("/") ? V(r.substring(1), "/") : V(r, t) } else n = t; var o; return { pathname: n, search: J(s), hash: Z(i) } }(s, i), c = a && "/" !== a && a.endsWith("/"), u = (o || "." === a) && n.endsWith("/"); return l.pathname.endsWith("/") || !c && !u || (l.pathname += "/"), l } const Q = e => e.join("/").replace(/\/\/+/g, "/"), X = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), J = e => e && "?" !== e ? e.startsWith("?") ? e : "?" + e : "", Z = e => e && "#" !== e ? e.startsWith("#") ? e : "#" + e : ""; Error; const ee = ["post", "put", "patch", "delete"]; new Set(ee); const te = ["get", ...ee];
            /**
             * React Router v6.30.2
             *
             * Copyright (c) Remix Software Inc.
             *
             * This source code is licensed under the MIT license found in the
             * LICENSE.md file in the root directory of this source tree.
             *
             * @license MIT
             */
            function ne() { return ne = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, ne.apply(this, arguments) } new Set(te); const re = React.createContext(null), se = React.createContext(null), ie = React.createContext(null), oe = React.createContext(null), ae = React.createContext({ outlet: null, matches: [], isDataRoute: !1 }), le = React.createContext(null); function ce() { return null != React.useContext(oe) } function ue() { return ce() || b(!1), React.useContext(oe).location } function he(e) { React.useContext(ie).static || React.useLayoutEffect(e) } function de() { let { isDataRoute: e } = React.useContext(ae); return e ? function () { let { router: e } = function () { let e = React.useContext(re); return e || b(!1), e }(Ae.UseNavigateStable), t = ye(_e.UseNavigateStable), n = React.useRef(!1); return he(() => { n.current = !0 }), React.useCallback(function (r, s) { void 0 === s && (s = {}), n.current && ("number" == typeof r ? e.navigate(r) : e.navigate(r, ne({ fromRouteId: t }, s))) }, [e, t]) }() : function () { ce() || b(!1); let e = React.useContext(re), { basename: t, future: n, navigator: r } = React.useContext(ie), { matches: s } = React.useContext(ae), { pathname: i } = ue(), o = JSON.stringify(W(s, n.v7_relativeSplatPath)), a = React.useRef(!1); return he(() => { a.current = !0 }), React.useCallback(function (n, s) { if (void 0 === s && (s = {}), !a.current) return; if ("number" == typeof n) return void r.go(n); let l = K(n, JSON.parse(o), i, "path" === s.relative); null == e && "/" !== t && (l.pathname = "/" === l.pathname ? t : Q([t, l.pathname])), (s.replace ? r.replace : r.push)(l, s.state, s) }, [t, r, o, i, e]) }() } function pe() { let { matches: e } = React.useContext(ae), t = e[e.length - 1]; return t ? t.params : {} } function fe(e, t) { let { relative: n } = void 0 === t ? {} : t, { future: r } = React.useContext(ie), { matches: s } = React.useContext(ae), { pathname: i } = ue(), o = JSON.stringify(W(s, r.v7_relativeSplatPath)); return React.useMemo(() => K(e, JSON.parse(o), i, "path" === n), [e, o, i, n]) } function me() { let e = function () { var e; let t = React.useContext(le), n = function () { let e = React.useContext(se); return e || b(!1), e }(), r = ye(); return void 0 !== t ? t : null == (e = n.errors) ? void 0 : e[r] }(), t = function (e) { return null != e && "number" == typeof e.status && "string" == typeof e.statusText && "boolean" == typeof e.internal && "data" in e }(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null; return React.createElement(React.Fragment, null, React.createElement("h2", null, "Unexpected Application Error!"), React.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? React.createElement("pre", { style: { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" } }, n) : null, null) } const ge = React.createElement(me, null); class Ee extends React.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || "idle" !== t.revalidation && "idle" === e.revalidation ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: void 0 !== e.error ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { console.error("React Router caught the following error during render", e, t) } render() { return void 0 !== this.state.error ? React.createElement(ae.Provider, { value: this.props.routeContext }, React.createElement(le.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function Te(e) { let { routeContext: t, match: n, children: r } = e, s = React.useContext(re); return s && s.static && s.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = n.route.id), React.createElement(ae.Provider, { value: t }, r) } var Ae = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(Ae || {}), _e = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(_e || {}); function ye(e) { let t = function () { let e = React.useContext(ae); return e || b(!1), e }(), n = t.matches[t.matches.length - 1]; return n.route.id || b(!1), n.route.id } const be = {}; function Se(e) { let { to: t, replace: n, state: r, relative: s } = e; ce() || b(!1); let { future: i, static: o } = React.useContext(ie), { matches: a } = React.useContext(ae), { pathname: l } = ue(), c = de(), u = K(t, W(a, i.v7_relativeSplatPath), l, "path" === s), h = JSON.stringify(u); return React.useEffect(() => c(JSON.parse(h), { replace: n, state: r, relative: s }), [c, h, s, n, r]), null } function ke(e) { b(!1) } function Ce(e) { let { basename: t = "/", children: n = null, location: r, navigationType: s = g.Pop, navigator: i, static: o = !1, future: a } = e; ce() && b(!1); let l = t.replace(/^\/*/, "/"), c = React.useMemo(() => ({ basename: l, navigator: i, static: o, future: ne({ v7_relativeSplatPath: !1 }, a) }), [l, a, i, o]); "string" == typeof r && (r = I(r)); let { pathname: u = "/", search: h = "", hash: d = "", state: p = null, key: f = "default" } = r, m = React.useMemo(() => { let e = Y(u, l); return null == e ? null : { location: { pathname: e, search: h, hash: d, state: p, key: f }, navigationType: s } }, [l, u, h, d, p, f, s]); return null == m ? null : React.createElement(ie.Provider, { value: c }, React.createElement(oe.Provider, { children: n, value: m })) } function Ne(e) { let { children: t, location: n } = e; return function (e, t) { ce() || b(!1); let { navigator: n } = React.useContext(ie), { matches: r } = React.useContext(ae), s = r[r.length - 1], i = s ? s.params : {}; !s || s.pathname; let o = s ? s.pathnameBase : "/"; s && s.route; let a, l = ue(); if (t) { var c; let e = "string" == typeof t ? I(t) : t; "/" === o || (null == (c = e.pathname) ? void 0 : c.startsWith(o)) || b(!1), a = e } else a = l; let u = a.pathname || "/", h = u; if ("/" !== o) { let e = o.replace(/^\//, "").split("/"); h = "/" + u.replace(/^\//, "").split("/").slice(e.length).join("/") } let d = v(e, { pathname: h }), p = function (e, t, n, r) { var s; if (void 0 === t && (t = []), void 0 === n && (n = null), void 0 === r && (r = null), null == e) { var i; if (!n) return null; if (n.errors) e = n.matches; else { if (!(null != (i = r) && i.v7_partialHydration && 0 === t.length && !n.initialized && n.matches.length > 0)) return null; e = n.matches } } let o = e, a = null == (s = n) ? void 0 : s.errors; if (null != a) { let e = o.findIndex(e => e.route.id && void 0 !== (null == a ? void 0 : a[e.route.id])); e >= 0 || b(!1), o = o.slice(0, Math.min(o.length, e + 1)) } let l = !1, c = -1; if (n && r && r.v7_partialHydration) for (let u = 0; u < o.length; u++) { let e = o[u]; if ((e.route.HydrateFallback || e.route.hydrateFallbackElement) && (c = u), e.route.id) { let { loaderData: t, errors: r } = n, s = e.route.loader && void 0 === t[e.route.id] && (!r || void 0 === r[e.route.id]); if (e.route.lazy || s) { l = !0, o = c >= 0 ? o.slice(0, c + 1) : [o[0]]; break } } } return o.reduceRight((e, r, s) => { let i, u = !1, h = null, d = null; n && (i = a && r.route.id ? a[r.route.id] : void 0, h = r.route.errorElement || ge, l && (c < 0 && 0 === s ? (be["route-fallback"] || (be["route-fallback"] = !0), u = !0, d = null) : c === s && (u = !0, d = r.route.hydrateFallbackElement || null))); let p = t.concat(o.slice(0, s + 1)), f = () => { let t; return t = i ? h : u ? d : r.route.Component ? React.createElement(r.route.Component, null) : r.route.element ? r.route.element : e, React.createElement(Te, { match: r, routeContext: { outlet: e, matches: p, isDataRoute: null != n }, children: t }) }; return n && (r.route.ErrorBoundary || r.route.errorElement || 0 === s) ? React.createElement(Ee, { location: n.location, revalidation: n.revalidation, component: h, error: i, children: f(), routeContext: { outlet: null, matches: p, isDataRoute: !0 } }) : f() }, null) }(d && d.map(e => Object.assign({}, e, { params: Object.assign({}, i, e.params), pathname: Q([o, n.encodeLocation ? n.encodeLocation(e.pathname).pathname : e.pathname]), pathnameBase: "/" === e.pathnameBase ? o : Q([o, n.encodeLocation ? n.encodeLocation(e.pathnameBase).pathname : e.pathnameBase]) })), r, void 0, void 0); return t && p ? React.createElement(oe.Provider, { value: { location: ne({ pathname: "/", search: "", hash: "", state: null, key: "default" }, a), navigationType: g.Pop } }, p) : p }(Ie(t), n) } function Ie(e, t) { void 0 === t && (t = []); let n = []; return React.Children.forEach(e, (e, r) => { if (!React.isValidElement(e)) return; let s = [...t, r]; if (e.type === React.Fragment) return void n.push.apply(n, Ie(e.props.children, s)); e.type !== ke && b(!1), e.props.index && e.props.children && b(!1); let i = { id: e.props.id || s.join("-"), caseSensitive: e.props.caseSensitive, element: e.props.element, Component: e.props.Component, index: e.props.index, path: e.props.path, loader: e.props.loader, action: e.props.action, errorElement: e.props.errorElement, ErrorBoundary: e.props.ErrorBoundary, hasErrorBoundary: null != e.props.ErrorBoundary || null != e.props.errorElement, shouldRevalidate: e.props.shouldRevalidate, handle: e.props.handle, lazy: e.props.lazy }; e.props.children && (i.children = Ie(e.props.children, s)), n.push(i) }), n }
/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Oe() { return Oe = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Oe.apply(this, arguments) } React.startTransition, new Promise(() => { }), React.Component; const xe = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]; try { window.__reactRouterVersion = "6" } catch (mg) { } const ve = React.startTransition; function Re(e) { let { basename: t, children: n, future: r, window: s } = e, i = React.useRef(); null == i.current && (i.current = y({ window: s, v5Compat: !0 })); let o = i.current, [a, l] = React.useState({ action: o.action, location: o.location }), { v7_startTransition: c } = r || {}, u = React.useCallback(e => { c && ve ? ve(() => l(e)) : l(e) }, [l, c]); return React.useLayoutEffect(() => o.listen(u), [o, u]), React.useEffect(() => { return null == (e = r) || e.v7_startTransition, void (null == e || e.v7_relativeSplatPath); var e }, [r]), React.createElement(Ce, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: o, future: r }) } ReactDOM.flushSync, React.useId; const De = "undefined" != typeof window && void 0 !== window.document && void 0 !== window.document.createElement, Le = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Pe = React.forwardRef(function (e, t) { let n, { onClick: r, relative: s, reloadDocument: i, replace: o, state: a, target: l, to: c, preventScrollReset: u, viewTransition: h } = e, d = function (e, t) { if (null == e) return {}; var n, r, s = {}, i = Object.keys(e); for (r = 0; r < i.length; r++)n = i[r], t.indexOf(n) >= 0 || (s[n] = e[n]); return s }(e, xe), { basename: p } = React.useContext(ie), f = !1; if ("string" == typeof c && Le.test(c) && (n = c, De)) try { let e = new URL(window.location.href), t = c.startsWith("//") ? new URL(e.protocol + c) : new URL(c), n = Y(t.pathname, p); t.origin === e.origin && null != n ? c = n + t.search + t.hash : f = !0 } catch (mg) { } let m = function (e, t) { let { relative: n } = void 0 === t ? {} : t; ce() || b(!1); let { basename: r, navigator: s } = React.useContext(ie), { hash: i, pathname: o, search: a } = fe(e, { relative: n }), l = o; return "/" !== r && (l = "/" === o ? r : Q([r, o])), s.createHref({ pathname: l, search: a, hash: i }) }(c, { relative: s }), g = function (e, t) { let { target: n, replace: r, state: s, preventScrollReset: i, relative: o, viewTransition: a } = void 0 === t ? {} : t, l = de(), c = ue(), u = fe(e, { relative: o }); return React.useCallback(t => { if (function (e, t) { return !(0 !== e.button || t && "_self" !== t || function (e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) }(e)) }(t, n)) { t.preventDefault(); let n = void 0 !== r ? r : N(c) === N(u); l(e, { replace: n, state: s, preventScrollReset: i, relative: o, viewTransition: a }) } }, [c, l, u, r, s, n, e, i, o, a]) }(c, { replace: o, state: a, target: l, preventScrollReset: u, relative: s, viewTransition: h }); return React.createElement("a", Oe({}, d, { href: n || m, onClick: f || i ? r : function (e) { r && r(e), e.defaultPrevented || g(e) }, ref: t, target: l })) }); var we, Me, Fe, Be; (Me = we || (we = {})).UseScrollRestoration = "useScrollRestoration", Me.UseSubmit = "useSubmit", Me.UseSubmitFetcher = "useSubmitFetcher", Me.UseFetcher = "useFetcher", Me.useViewTransitionState = "useViewTransitionState", (Be = Fe || (Fe = {})).UseFetcher = "useFetcher", Be.UseFetchers = "useFetchers", Be.UseScrollRestoration = "useScrollRestoration"; var Ue = "undefined" != typeof Element, He = "function" == typeof Map, je = "function" == typeof Set, Ge = "function" == typeof ArrayBuffer && !!ArrayBuffer.isView; function ze(e, t) { if (e === t) return !0; if (e && t && "object" == typeof e && "object" == typeof t) { if (e.constructor !== t.constructor) return !1; var n, r, s, i; if (Array.isArray(e)) { if ((n = e.length) != t.length) return !1; for (r = n; 0 !== r--;)if (!ze(e[r], t[r])) return !1; return !0 } if (He && e instanceof Map && t instanceof Map) { if (e.size !== t.size) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!t.has(r.value[0])) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!ze(r.value[1], t.get(r.value[0]))) return !1; return !0 } if (je && e instanceof Set && t instanceof Set) { if (e.size !== t.size) return !1; for (i = e.entries(); !(r = i.next()).done;)if (!t.has(r.value[0])) return !1; return !0 } if (Ge && ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) { if ((n = e.length) != t.length) return !1; for (r = n; 0 !== r--;)if (e[r] !== t[r]) return !1; return !0 } if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags; if (e.valueOf !== Object.prototype.valueOf && "function" == typeof e.valueOf && "function" == typeof t.valueOf) return e.valueOf() === t.valueOf(); if (e.toString !== Object.prototype.toString && "function" == typeof e.toString && "function" == typeof t.toString) return e.toString() === t.toString(); if ((n = (s = Object.keys(e)).length) !== Object.keys(t).length) return !1; for (r = n; 0 !== r--;)if (!Object.prototype.hasOwnProperty.call(t, s[r])) return !1; if (Ue && e instanceof Element) return !1; for (r = n; 0 !== r--;)if (("_owner" !== s[r] && "__v" !== s[r] && "__o" !== s[r] || !e.$$typeof) && !ze(e[s[r]], t[s[r]])) return !1; return !0 } return e != e && t != t } const Ye = i(function (e, t) { try { return ze(e, t) } catch (n) { if ((n.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1; throw n } }), qe = i(function (e, t, n, r, s, i, o, a) { if (!e) { var l; if (void 0 === t) l = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var c = [n, r, s, i, o, a], u = 0; (l = new Error(t.replace(/%s/g, function () { return c[u++] }))).name = "Invariant Violation" } throw l.framesToPop = 1, l } }), Ve = i(function (e, t, n, r) { var s = n ? n.call(r, e, t) : void 0; if (void 0 !== s) return !!s; if (e === t) return !0; if ("object" != typeof e || !e || "object" != typeof t || !t) return !1; var i = Object.keys(e), o = Object.keys(t); if (i.length !== o.length) return !1; for (var a = Object.prototype.hasOwnProperty.bind(t), l = 0; l < i.length; l++) { var c = i[l]; if (!a(c)) return !1; var u = e[c], h = t[c]; if (!1 === (s = n ? n.call(r, u, h, c) : void 0) || void 0 === s && u !== h) return !1 } return !0 }); var $e = (e => (e.BASE = "base", e.BODY = "body", e.HEAD = "head", e.HTML = "html", e.LINK = "link", e.META = "meta", e.NOSCRIPT = "noscript", e.SCRIPT = "script", e.STYLE = "style", e.TITLE = "title", e.FRAGMENT = "Symbol(react.fragment)", e))($e || {}), We = { rel: ["amphtml", "canonical", "alternate"] }, Ke = { type: ["application/ld+json"] }, Qe = { charset: "", name: ["generator", "robots", "description"], property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"] }, Xe = Object.values($e), Je = { accesskey: "accessKey", charset: "charSet", class: "className", contenteditable: "contentEditable", contextmenu: "contextMenu", "http-equiv": "httpEquiv", itemprop: "itemProp", tabindex: "tabIndex" }, Ze = Object.entries(Je).reduce((e, [t, n]) => (e[n] = t, e), {}), et = "data-rh", tt = (e, t) => { for (let n = e.length - 1; n >= 0; n -= 1) { const r = e[n]; if (Object.prototype.hasOwnProperty.call(r, t)) return r[t] } return null }, nt = e => { let t = tt(e, "title"); const n = tt(e, "titleTemplate"); if (Array.isArray(t) && (t = t.join("")), n && t) return n.replace(/%s/g, () => t); const r = tt(e, "defaultTitle"); return t || r || void 0 }, rt = e => tt(e, "onChangeClientState") || (() => { }), st = (e, t) => t.filter(t => void 0 !== t[e]).map(t => t[e]).reduce((e, t) => ({ ...e, ...t }), {}), it = (e, t) => t.filter(e => void 0 !== e.base).map(e => e.base).reverse().reduce((t, n) => { if (!t.length) { const r = Object.keys(n); for (let s = 0; s < r.length; s += 1) { const i = r[s].toLowerCase(); if (-1 !== e.indexOf(i) && n[i]) return t.concat(n) } } return t }, []), ot = (e, t, n) => { const r = {}; return n.filter(t => { return !!Array.isArray(t[e]) || (void 0 !== t[e] && (n = `Helmet: ${e} should be of type "Array". Instead found type "${typeof t[e]}"`, console && "function" == typeof console.warn && console.warn(n)), !1); var n }).map(t => t[e]).reverse().reduce((e, n) => { const s = {}; n.filter(e => { let n; const i = Object.keys(e); for (let r = 0; r < i.length; r += 1) { const s = i[r], o = s.toLowerCase(); -1 === t.indexOf(o) || "rel" === n && "canonical" === e[n].toLowerCase() || "rel" === o && "stylesheet" === e[o].toLowerCase() || (n = o), -1 === t.indexOf(s) || "innerHTML" !== s && "cssText" !== s && "itemprop" !== s || (n = s) } if (!n || !e[n]) return !1; const o = e[n].toLowerCase(); return r[n] || (r[n] = {}), s[n] || (s[n] = {}), !r[n][o] && (s[n][o] = !0, !0) }).reverse().forEach(t => e.push(t)); const i = Object.keys(s); for (let t = 0; t < i.length; t += 1) { const e = i[t], n = { ...r[e], ...s[e] }; r[e] = n } return e }, []).reverse() }, at = (e, t) => { if (Array.isArray(e) && e.length) for (let n = 0; n < e.length; n += 1)if (e[n][t]) return !0; return !1 }, lt = e => Array.isArray(e) ? e.join("") : e, ct = (e, t) => Array.isArray(e) ? e.reduce((e, n) => (((e, t) => { const n = Object.keys(e); for (let r = 0; r < n.length; r += 1)if (t[n[r]] && t[n[r]].includes(e[n[r]])) return !0; return !1 })(n, t) ? e.priority.push(n) : e.default.push(n), e), { priority: [], default: [] }) : { default: e, priority: [] }, ut = (e, t) => ({ ...e, [t]: void 0 }), ht = ["noscript", "script", "style"], dt = (e, t = !0) => !1 === t ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"), pt = e => Object.keys(e).reduce((t, n) => { const r = void 0 !== e[n] ? `${n}="${e[n]}"` : `${n}`; return t ? `${t} ${r}` : r }, ""), ft = (e, t = {}) => Object.keys(e).reduce((t, n) => (t[Je[n] || n] = e[n], t), t), mt = (e, t) => t.map((t, n) => { const r = { key: n, [et]: !0 }; return Object.keys(t).forEach(e => { const n = Je[e] || e; if ("innerHTML" === n || "cssText" === n) { const e = t.innerHTML || t.cssText; r.dangerouslySetInnerHTML = { __html: e } } else r[n] = t[e] }), React.createElement(e, r) }), gt = (e, t, n = !0) => { switch (e) { case "title": return { toComponent: () => ((e, t, n) => { const r = ft(n, { key: t, [et]: !0 }); return [React.createElement("title", r, t)] })(0, t.title, t.titleAttributes), toString: () => ((e, t, n, r) => { const s = pt(n), i = lt(t); return s ? `<${e} ${et}="true" ${s}>${dt(i, r)}</${e}>` : `<${e} ${et}="true">${dt(i, r)}</${e}>` })(e, t.title, t.titleAttributes, n) }; case "bodyAttributes": case "htmlAttributes": return { toComponent: () => ft(t), toString: () => pt(t) }; default: return { toComponent: () => mt(e, t), toString: () => ((e, t, n = !0) => t.reduce((t, r) => { const s = r, i = Object.keys(s).filter(e => !("innerHTML" === e || "cssText" === e)).reduce((e, t) => { const r = void 0 === s[t] ? t : `${t}="${dt(s[t], n)}"`; return e ? `${e} ${r}` : r }, ""), o = s.innerHTML || s.cssText || "", a = -1 === ht.indexOf(e); return `${t}<${e} ${et}="true" ${i}${a ? "/>" : `>${o}</${e}>`}` }, ""))(e, t, n) } } }, Et = e => { const { baseTag: t, bodyAttributes: n, encode: r = !0, htmlAttributes: s, noscriptTags: i, styleTags: o, title: a = "", titleAttributes: l, prioritizeSeoTags: c } = e; let { linkTags: u, metaTags: h, scriptTags: d } = e, p = { toComponent: () => { }, toString: () => "" }; return c && ({ priorityMethods: p, linkTags: u, metaTags: h, scriptTags: d } = (({ metaTags: e, linkTags: t, scriptTags: n, encode: r }) => { const s = ct(e, Qe), i = ct(t, We), o = ct(n, Ke); return { priorityMethods: { toComponent: () => [...mt("meta", s.priority), ...mt("link", i.priority), ...mt("script", o.priority)], toString: () => `${gt("meta", s.priority, r)} ${gt("link", i.priority, r)} ${gt("script", o.priority, r)}` }, metaTags: s.default, linkTags: i.default, scriptTags: o.default } })(e)), { priority: p, base: gt("base", t, r), bodyAttributes: gt("bodyAttributes", n, r), htmlAttributes: gt("htmlAttributes", s, r), link: gt("link", u, r), meta: gt("meta", h, r), noscript: gt("noscript", i, r), script: gt("script", d, r), style: gt("style", o, r), title: gt("title", { title: a, titleAttributes: l }, r) } }, Tt = [], At = !("undefined" == typeof window || !window.document || !window.document.createElement), _t = class { constructor(e, t) { r(this, "instances", []), r(this, "canUseDOM", At), r(this, "context"), r(this, "value", { setHelmet: e => { this.context.helmet = e }, helmetInstances: { get: () => this.canUseDOM ? Tt : this.instances, add: e => { (this.canUseDOM ? Tt : this.instances).push(e) }, remove: e => { const t = (this.canUseDOM ? Tt : this.instances).indexOf(e); (this.canUseDOM ? Tt : this.instances).splice(t, 1) } } }), this.context = e, this.canUseDOM = t || !1, t || (e.helmet = Et({ baseTag: [], bodyAttributes: {}, htmlAttributes: {}, linkTags: [], metaTags: [], noscriptTags: [], scriptTags: [], styleTags: [], title: "", titleAttributes: {} })) } }, yt = React.createContext({}), bt = (e = class extends React.Component { constructor(t) { super(t), r(this, "helmetData"), this.helmetData = new _t(this.props.context || {}, e.canUseDOM) } render() { return React.createElement(yt.Provider, { value: this.helmetData.value }, this.props.children) } }, r(e, "canUseDOM", At), e), St = (e, t) => { const n = document.head || document.querySelector("head"), r = n.querySelectorAll(`${e}[${et}]`), s = [].slice.call(r), i = []; let o; return t && t.length && t.forEach(t => { const n = document.createElement(e); for (const e in t) if (Object.prototype.hasOwnProperty.call(t, e)) if ("innerHTML" === e) n.innerHTML = t.innerHTML; else if ("cssText" === e) n.styleSheet ? n.styleSheet.cssText = t.cssText : n.appendChild(document.createTextNode(t.cssText)); else { const r = e, s = void 0 === t[r] ? "" : t[r]; n.setAttribute(e, s) } n.setAttribute(et, "true"), s.some((e, t) => (o = t, n.isEqualNode(e))) ? s.splice(o, 1) : i.push(n) }), s.forEach(e => { var t; return null == (t = e.parentNode) ? void 0 : t.removeChild(e) }), i.forEach(e => n.appendChild(e)), { oldTags: s, newTags: i } }, kt = (e, t) => { const n = document.getElementsByTagName(e)[0]; if (!n) return; const r = n.getAttribute(et), s = r ? r.split(",") : [], i = [...s], o = Object.keys(t); for (const a of o) { const e = t[a] || ""; n.getAttribute(a) !== e && n.setAttribute(a, e), -1 === s.indexOf(a) && s.push(a); const r = i.indexOf(a); -1 !== r && i.splice(r, 1) } for (let a = i.length - 1; a >= 0; a -= 1)n.removeAttribute(i[a]); s.length === i.length ? n.removeAttribute(et) : n.getAttribute(et) !== o.join(",") && n.setAttribute(et, o.join(",")) }, Ct = (e, t) => { const { baseTag: n, bodyAttributes: r, htmlAttributes: s, linkTags: i, metaTags: o, noscriptTags: a, onChangeClientState: l, scriptTags: c, styleTags: u, title: h, titleAttributes: d } = e; kt("body", r), kt("html", s), ((e, t) => { void 0 !== e && document.title !== e && (document.title = lt(e)), kt("title", t) })(h, d); const p = { baseTag: St("base", n), linkTags: St("link", i), metaTags: St("meta", o), noscriptTags: St("noscript", a), scriptTags: St("script", c), styleTags: St("style", u) }, f = {}, m = {}; Object.keys(p).forEach(e => { const { newTags: t, oldTags: n } = p[e]; t.length && (f[e] = t), n.length && (m[e] = p[e].oldTags) }), t && t(), l(e, f, m) }, Nt = null, It = class extends React.Component { constructor() { super(...arguments), r(this, "rendered", !1) } shouldComponentUpdate(e) { return !Ve(e, this.props) } componentDidUpdate() { this.emitChange() } componentWillUnmount() { const { helmetInstances: e } = this.props.context; e.remove(this), this.emitChange() } emitChange() { const { helmetInstances: e, setHelmet: t } = this.props.context; let n = null; const r = (s = e.get().map(e => { const t = { ...e.props }; return delete t.context, t }), { baseTag: it(["href"], s), bodyAttributes: st("bodyAttributes", s), defer: tt(s, "defer"), encode: tt(s, "encodeSpecialCharacters"), htmlAttributes: st("htmlAttributes", s), linkTags: ot("link", ["rel", "href"], s), metaTags: ot("meta", ["name", "charset", "http-equiv", "property", "itemprop"], s), noscriptTags: ot("noscript", ["innerHTML"], s), onChangeClientState: rt(s), scriptTags: ot("script", ["src", "innerHTML"], s), styleTags: ot("style", ["cssText"], s), title: nt(s), titleAttributes: st("titleAttributes", s), prioritizeSeoTags: at(s, "prioritizeSeoTags") }); var s, i; bt.canUseDOM ? (i = r, Nt && cancelAnimationFrame(Nt), i.defer ? Nt = requestAnimationFrame(() => { Ct(i, () => { Nt = null }) }) : (Ct(i), Nt = null)) : Et && (n = Et(r)), t(n) } init() { if (this.rendered) return; this.rendered = !0; const { helmetInstances: e } = this.props.context; e.add(this), this.emitChange() } render() { return this.init(), null } }, Ot = (t = class extends React.Component { shouldComponentUpdate(e) { return !Ye(ut(this.props, "helmetData"), ut(e, "helmetData")) } mapNestedChildrenToProps(e, t) { if (!t) return null; switch (e.type) { case "script": case "noscript": return { innerHTML: t }; case "style": return { cssText: t }; default: throw new Error(`<${e.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`) } } flattenArrayTypeChildren(e, t, n, r) { return { ...t, [e.type]: [...t[e.type] || [], { ...n, ...this.mapNestedChildrenToProps(e, r) }] } } mapObjectTypeChildren(e, t, n, r) { switch (e.type) { case "title": return { ...t, [e.type]: r, titleAttributes: { ...n } }; case "body": return { ...t, bodyAttributes: { ...n } }; case "html": return { ...t, htmlAttributes: { ...n } }; default: return { ...t, [e.type]: { ...n } } } } mapArrayTypeChildrenToProps(e, t) { let n = { ...t }; return Object.keys(e).forEach(t => { n = { ...n, [t]: e[t] } }), n } warnOnInvalidChildren(e, t) { return qe(Xe.some(t => e.type === t), "function" == typeof e.type ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${Xe.join(", ")} are allowed. Helmet does not support rendering <${e.type}> elements. Refer to our API for more information.`), qe(!t || "string" == typeof t || Array.isArray(t) && !t.some(e => "string" != typeof e), `Helmet expects a string as a child of <${e.type}>. Did you forget to wrap your children in braces? ( <${e.type}>{\`\`}</${e.type}> ) Refer to our API for more information.`), !0 } mapChildrenToProps(e, t) { let n = {}; return React.Children.forEach(e, e => { if (!e || !e.props) return; const { children: r, ...s } = e.props, i = Object.keys(s).reduce((e, t) => (e[Ze[t] || t] = s[t], e), {}); let { type: o } = e; switch ("symbol" == typeof o ? o = o.toString() : this.warnOnInvalidChildren(e, r), o) { case "Symbol(react.fragment)": t = this.mapChildrenToProps(r, t); break; case "link": case "meta": case "noscript": case "script": case "style": n = this.flattenArrayTypeChildren(e, n, i, r); break; default: t = this.mapObjectTypeChildren(e, t, i, r) } }), this.mapArrayTypeChildrenToProps(n, t) } render() { const { children: e, ...t } = this.props; let n = { ...t }, { helmetData: r } = t; return e && (n = this.mapChildrenToProps(e, n)), !r || r instanceof _t || (r = new _t(r.context, !0), delete n.helmetData), r ? React.createElement(It, { ...n, context: r.value }) : React.createElement(yt.Consumer, null, e => React.createElement(It, { ...n, context: e })) } }, r(t, "defaultProps", { defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1 }), t); const xt = "blog_language_mode", vt = React.createContext(void 0); function Rt({ children: e }) { const [t, n] = React.useState(() => { try { const e = localStorage.getItem("cr-blog-theme") || localStorage.getItem("theme"); if ("dark" === e || "light" === e) return e } catch (mg) { console.warn("LocalStorage access denied:", mg) } return "light" }), [r, s] = React.useState(() => { try { const e = localStorage.getItem("cr-blog-text-size") || localStorage.getItem("textSize"); if ("small" === e || "medium" === e || "large" === e || "xlarge" === e || "xxlarge" === e || "xxxlarge" === e) return e } catch (mg) { console.warn("LocalStorage access denied:", mg) } return "medium" }); return React.useEffect(() => { const e = document.documentElement; e.classList.remove("light", "dark"), e.classList.add(t); try { localStorage.setItem("cr-blog-theme", t), localStorage.removeItem("theme") } catch (mg) { } }, [t]), React.useEffect(() => { document.documentElement.setAttribute("data-text-size", r); try { localStorage.setItem("cr-blog-text-size", r), localStorage.removeItem("textSize") } catch (mg) { } }, [r]), React.useEffect(() => { const e = document.documentElement; e.style.setProperty("--prose-body-line-height", String(1.8)), e.style.setProperty("--prose-list-line-height", String(1.65)), e.style.setProperty("--prose-blockquote-line-height", String(1.65)) }, []), T.jsx(vt.Provider, { value: { theme: t, textSize: r, toggleTheme: () => { n(e => "light" === e ? "dark" : "light") }, setTextSize: e => { s(e) } }, children: e }) } const Dt = e => "string" == typeof e, Lt = () => { let e, t; const n = new Promise((n, r) => { e = n, t = r }); return n.resolve = e, n.reject = t, n }, Pt = e => null == e ? "" : "" + e, wt = /###/g, Mt = e => e && e.indexOf("###") > -1 ? e.replace(wt, ".") : e, Ft = e => !e || Dt(e), Bt = (e, t, n) => { const r = Dt(t) ? t.split(".") : t; let s = 0; for (; s < r.length - 1;) { if (Ft(e)) return {}; const t = Mt(r[s]); !e[t] && n && (e[t] = new n), e = Object.prototype.hasOwnProperty.call(e, t) ? e[t] : {}, ++s } return Ft(e) ? {} : { obj: e, k: Mt(r[s]) } }, Ut = (e, t, n) => { const { obj: r, k: s } = Bt(e, t, Object); if (void 0 !== r || 1 === t.length) return void (r[s] = n); let i = t[t.length - 1], o = t.slice(0, t.length - 1), a = Bt(e, o, Object); for (; void 0 === a.obj && o.length;)i = `${o[o.length - 1]}.${i}`, o = o.slice(0, o.length - 1), a = Bt(e, o, Object), (null == a ? void 0 : a.obj) && void 0 !== a.obj[`${a.k}.${i}`] && (a.obj = void 0); a.obj[`${a.k}.${i}`] = n }, Ht = (e, t) => { const { obj: n, k: r } = Bt(e, t); if (n && Object.prototype.hasOwnProperty.call(n, r)) return n[r] }, jt = (e, t, n) => { for (const r in t) "__proto__" !== r && "constructor" !== r && (r in e ? Dt(e[r]) || e[r] instanceof String || Dt(t[r]) || t[r] instanceof String ? n && (e[r] = t[r]) : jt(e[r], t[r], n) : e[r] = t[r]); return e }, Gt = e => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"); var zt = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" }; const Yt = e => Dt(e) ? e.replace(/[&<>"'\/]/g, e => zt[e]) : e, qt = [" ", ",", "?", "!", ";"], Vt = new class { constructor(e) { this.capacity = e, this.regExpMap = new Map, this.regExpQueue = [] } getRegExp(e) { const t = this.regExpMap.get(e); if (void 0 !== t) return t; const n = new RegExp(e); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(e, n), this.regExpQueue.push(e), n } }(20), $t = (e, t, n = ".") => { if (!e) return; if (e[t]) { if (!Object.prototype.hasOwnProperty.call(e, t)) return; return e[t] } const r = t.split(n); let s = e; for (let i = 0; i < r.length;) { if (!s || "object" != typeof s) return; let e, t = ""; for (let o = i; o < r.length; ++o)if (o !== i && (t += n), t += r[o], e = s[t], void 0 !== e) { if (["string", "number", "boolean"].indexOf(typeof e) > -1 && o < r.length - 1) continue; i += o - i + 1; break } s = e } return s }, Wt = e => null == e ? void 0 : e.replace("_", "-"), Kt = { type: "logger", log(e) { this.output("log", e) }, warn(e) { this.output("warn", e) }, error(e) { this.output("error", e) }, output(e, t) { var n, r; null == (r = null == (n = null == console ? void 0 : console[e]) ? void 0 : n.apply) || r.call(n, console, t) } }; class Qt { constructor(e, t = {}) { this.init(e, t) } init(e, t = {}) { this.prefix = t.prefix || "i18next:", this.logger = e || Kt, this.options = t, this.debug = t.debug } log(...e) { return this.forward(e, "log", "", !0) } warn(...e) { return this.forward(e, "warn", "", !0) } error(...e) { return this.forward(e, "error", "") } deprecate(...e) { return this.forward(e, "warn", "WARNING DEPRECATED: ", !0) } forward(e, t, n, r) { return r && !this.debug ? null : (Dt(e[0]) && (e[0] = `${n}${this.prefix} ${e[0]}`), this.logger[t](e)) } create(e) { return new Qt(this.logger, { prefix: `${this.prefix}:${e}:`, ...this.options }) } clone(e) { return (e = e || this.options).prefix = e.prefix || this.prefix, new Qt(this.logger, e) } } var Xt = new Qt; class Jt { constructor() { this.observers = {} } on(e, t) { return e.split(" ").forEach(e => { this.observers[e] || (this.observers[e] = new Map); const n = this.observers[e].get(t) || 0; this.observers[e].set(t, n + 1) }), this } off(e, t) { this.observers[e] && (t ? this.observers[e].delete(t) : delete this.observers[e]) } emit(e, ...t) { this.observers[e] && Array.from(this.observers[e].entries()).forEach(([e, n]) => { for (let r = 0; r < n; r++)e(...t) }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([n, r]) => { for (let s = 0; s < r; s++)n.apply(n, [e, ...t]) }) } } class Zt extends Jt { constructor(e, t = { ns: ["translation"], defaultNS: "translation" }) { super(), this.data = e || {}, this.options = t, void 0 === this.options.keySeparator && (this.options.keySeparator = "."), void 0 === this.options.ignoreJSONStructure && (this.options.ignoreJSONStructure = !0) } addNamespaces(e) { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) } removeNamespaces(e) { const t = this.options.ns.indexOf(e); t > -1 && this.options.ns.splice(t, 1) } getResource(e, t, n, r = {}) { var s, i; const o = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, a = void 0 !== r.ignoreJSONStructure ? r.ignoreJSONStructure : this.options.ignoreJSONStructure; let l; e.indexOf(".") > -1 ? l = e.split(".") : (l = [e, t], n && (Array.isArray(n) ? l.push(...n) : Dt(n) && o ? l.push(...n.split(o)) : l.push(n))); const c = Ht(this.data, l); return !c && !t && !n && e.indexOf(".") > -1 && (e = l[0], t = l[1], n = l.slice(2).join(".")), !c && a && Dt(n) ? $t(null == (i = null == (s = this.data) ? void 0 : s[e]) ? void 0 : i[t], n, o) : c } addResource(e, t, n, r, s = { silent: !1 }) { const i = void 0 !== s.keySeparator ? s.keySeparator : this.options.keySeparator; let o = [e, t]; n && (o = o.concat(i ? n.split(i) : n)), e.indexOf(".") > -1 && (o = e.split("."), r = t, t = o[1]), this.addNamespaces(t), Ut(this.data, o, r), s.silent || this.emit("added", e, t, n, r) } addResources(e, t, n, r = { silent: !1 }) { for (const s in n) (Dt(n[s]) || Array.isArray(n[s])) && this.addResource(e, t, s, n[s], { silent: !0 }); r.silent || this.emit("added", e, t, n) } addResourceBundle(e, t, n, r, s, i = { silent: !1, skipCopy: !1 }) { let o = [e, t]; e.indexOf(".") > -1 && (o = e.split("."), r = n, n = t, t = o[1]), this.addNamespaces(t); let a = Ht(this.data, o) || {}; i.skipCopy || (n = JSON.parse(JSON.stringify(n))), r ? jt(a, n, s) : a = { ...a, ...n }, Ut(this.data, o, a), i.silent || this.emit("added", e, t, n) } removeResourceBundle(e, t) { this.hasResourceBundle(e, t) && delete this.data[e][t], this.removeNamespaces(t), this.emit("removed", e, t) } hasResourceBundle(e, t) { return void 0 !== this.getResource(e, t) } getResourceBundle(e, t) { return t || (t = this.options.defaultNS), this.getResource(e, t) } getDataByLanguage(e) { return this.data[e] } hasLanguageSomeTranslations(e) { const t = this.getDataByLanguage(e); return !!(t && Object.keys(t) || []).find(e => t[e] && Object.keys(t[e]).length > 0) } toJSON() { return this.data } } var en = { processors: {}, addPostProcessor(e) { this.processors[e.name] = e }, handle(e, t, n, r, s) { return e.forEach(e => { var i; t = (null == (i = this.processors[e]) ? void 0 : i.process(t, n, r, s)) ?? t }), t } }; const tn = Symbol("i18next/PATH_KEY"); function nn(e, t) { const { [tn]: n } = e(function () { const e = [], t = Object.create(null); let n; return t.get = (r, s) => { var i; return null == (i = null == n ? void 0 : n.revoke) || i.call(n), s === tn ? e : (e.push(s), n = Proxy.revocable(r, t), n.proxy) }, Proxy.revocable(Object.create(null), t).proxy }()); return n.join((null == t ? void 0 : t.keySeparator) ?? ".") } const rn = {}, sn = e => !Dt(e) && "boolean" != typeof e && "number" != typeof e; class on extends Jt { constructor(e, t = {}) { var n, r; super(), n = e, r = this, ["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"].forEach(e => { n[e] && (r[e] = n[e]) }), this.options = t, void 0 === this.options.keySeparator && (this.options.keySeparator = "."), this.logger = Xt.create("translator") } changeLanguage(e) { e && (this.language = e) } exists(e, t = { interpolation: {} }) { const n = { ...t }; if (null == e) return !1; const r = this.resolve(e, n); if (void 0 === (null == r ? void 0 : r.res)) return !1; const s = sn(r.res); return !1 !== n.returnObjects || !s } extractFromKey(e, t) { let n = void 0 !== t.nsSeparator ? t.nsSeparator : this.options.nsSeparator; void 0 === n && (n = ":"); const r = void 0 !== t.keySeparator ? t.keySeparator : this.options.keySeparator; let s = t.ns || this.options.defaultNS || []; const i = n && e.indexOf(n) > -1, o = !(this.options.userDefinedKeySeparator || t.keySeparator || this.options.userDefinedNsSeparator || t.nsSeparator || ((e, t, n) => { t = t || "", n = n || ""; const r = qt.filter(e => t.indexOf(e) < 0 && n.indexOf(e) < 0); if (0 === r.length) return !0; const s = Vt.getRegExp(`(${r.map(e => "?" === e ? "\\?" : e).join("|")})`); let i = !s.test(e); if (!i) { const t = e.indexOf(n); t > 0 && !s.test(e.substring(0, t)) && (i = !0) } return i })(e, n, r)); if (i && !o) { const t = e.match(this.interpolator.nestingRegexp); if (t && t.length > 0) return { key: e, namespaces: Dt(s) ? [s] : s }; const i = e.split(n); (n !== r || n === r && this.options.ns.indexOf(i[0]) > -1) && (s = i.shift()), e = i.join(r) } return { key: e, namespaces: Dt(s) ? [s] : s } } translate(e, t, n) { let r = "object" == typeof t ? { ...t } : t; if ("object" != typeof r && this.options.overloadTranslationOptionHandler && (r = this.options.overloadTranslationOptionHandler(arguments)), "object" == typeof r && (r = { ...r }), r || (r = {}), null == e) return ""; "function" == typeof e && (e = nn(e, { ...this.options, ...r })), Array.isArray(e) || (e = [String(e)]); const s = void 0 !== r.returnDetails ? r.returnDetails : this.options.returnDetails, i = void 0 !== r.keySeparator ? r.keySeparator : this.options.keySeparator, { key: o, namespaces: a } = this.extractFromKey(e[e.length - 1], r), l = a[a.length - 1]; let c = void 0 !== r.nsSeparator ? r.nsSeparator : this.options.nsSeparator; void 0 === c && (c = ":"); const u = r.lng || this.language, h = r.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if ("cimode" === (null == u ? void 0 : u.toLowerCase())) return h ? s ? { res: `${l}${c}${o}`, usedKey: o, exactUsedKey: o, usedLng: u, usedNS: l, usedParams: this.getUsedParamsDetails(r) } : `${l}${c}${o}` : s ? { res: o, usedKey: o, exactUsedKey: o, usedLng: u, usedNS: l, usedParams: this.getUsedParamsDetails(r) } : o; const d = this.resolve(e, r); let p = null == d ? void 0 : d.res; const f = (null == d ? void 0 : d.usedKey) || o, m = (null == d ? void 0 : d.exactUsedKey) || o, g = void 0 !== r.joinArrays ? r.joinArrays : this.options.joinArrays, E = !this.i18nFormat || this.i18nFormat.handleAsObject, T = void 0 !== r.count && !Dt(r.count), A = on.hasDefaultValue(r), _ = T ? this.pluralResolver.getSuffix(u, r.count, r) : "", y = r.ordinal && T ? this.pluralResolver.getSuffix(u, r.count, { ordinal: !1 }) : "", b = T && !r.ordinal && 0 === r.count, S = b && r[`defaultValue${this.options.pluralSeparator}zero`] || r[`defaultValue${_}`] || r[`defaultValue${y}`] || r.defaultValue; let k = p; E && !p && A && (k = S); const C = sn(k), N = Object.prototype.toString.apply(k); if (!(E && k && C && ["[object Number]", "[object Function]", "[object RegExp]"].indexOf(N) < 0) || Dt(g) && Array.isArray(k)) if (E && Dt(g) && Array.isArray(p)) p = p.join(g), p && (p = this.extendTranslation(p, e, r, n)); else { let t = !1, s = !1; !this.isValidLookup(p) && A && (t = !0, p = S), this.isValidLookup(p) || (s = !0, p = o); const a = (r.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && s ? void 0 : p, h = A && S !== p && this.options.updateMissing; if (s || t || h) { if (this.logger.log(h ? "updateKey" : "missingKey", u, l, o, h ? S : p), i) { const e = this.resolve(o, { ...r, keySeparator: !1 }); e && e.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.") } let e = []; const t = this.languageUtils.getFallbackCodes(this.options.fallbackLng, r.lng || this.language); if ("fallback" === this.options.saveMissingTo && t && t[0]) for (let r = 0; r < t.length; r++)e.push(t[r]); else "all" === this.options.saveMissingTo ? e = this.languageUtils.toResolveHierarchy(r.lng || this.language) : e.push(r.lng || this.language); const n = (e, t, n) => { var s; const i = A && n !== p ? n : a; this.options.missingKeyHandler ? this.options.missingKeyHandler(e, l, t, i, h, r) : (null == (s = this.backendConnector) ? void 0 : s.saveMissing) && this.backendConnector.saveMissing(e, l, t, i, h, r), this.emit("missingKey", e, l, t, p) }; this.options.saveMissing && (this.options.saveMissingPlurals && T ? e.forEach(e => { const t = this.pluralResolver.getSuffixes(e, r); b && r[`defaultValue${this.options.pluralSeparator}zero`] && t.indexOf(`${this.options.pluralSeparator}zero`) < 0 && t.push(`${this.options.pluralSeparator}zero`), t.forEach(t => { n([e], o + t, r[`defaultValue${t}`] || S) }) }) : n(e, o, S)) } p = this.extendTranslation(p, e, r, d, n), s && p === o && this.options.appendNamespaceToMissingKey && (p = `${l}${c}${o}`), (s || t) && this.options.parseMissingKeyHandler && (p = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}${c}${o}` : o, t ? p : void 0, r)) } else { if (!r.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"); const e = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(f, k, { ...r, ns: a }) : `key '${o} (${this.language})' returned an object instead of string.`; return s ? (d.res = e, d.usedParams = this.getUsedParamsDetails(r), d) : e } if (i) { const e = Array.isArray(k), t = e ? [] : {}, n = e ? m : f; for (const s in k) if (Object.prototype.hasOwnProperty.call(k, s)) { const e = `${n}${i}${s}`; t[s] = A && !p ? this.translate(e, { ...r, defaultValue: sn(S) ? S[s] : void 0, joinArrays: !1, ns: a }) : this.translate(e, { ...r, joinArrays: !1, ns: a }), t[s] === e && (t[s] = k[s]) } p = t } } return s ? (d.res = p, d.usedParams = this.getUsedParamsDetails(r), d) : p } extendTranslation(e, t, n, r, s) { var i, o; if (null == (i = this.i18nFormat) ? void 0 : i.parse) e = this.i18nFormat.parse(e, { ...this.options.interpolation.defaultVariables, ...n }, n.lng || this.language || r.usedLng, r.usedNS, r.usedKey, { resolved: r }); else if (!n.skipInterpolation) { n.interpolation && this.interpolator.init({ ...n, interpolation: { ...this.options.interpolation, ...n.interpolation } }); const i = Dt(e) && (void 0 !== (null == (o = null == n ? void 0 : n.interpolation) ? void 0 : o.skipOnVariables) ? n.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let a; if (i) { const t = e.match(this.interpolator.nestingRegexp); a = t && t.length } let l = n.replace && !Dt(n.replace) ? n.replace : n; if (this.options.interpolation.defaultVariables && (l = { ...this.options.interpolation.defaultVariables, ...l }), e = this.interpolator.interpolate(e, l, n.lng || this.language || r.usedLng, n), i) { const t = e.match(this.interpolator.nestingRegexp); a < (t && t.length) && (n.nest = !1) } !n.lng && r && r.res && (n.lng = this.language || r.usedLng), !1 !== n.nest && (e = this.interpolator.nest(e, (...e) => (null == s ? void 0 : s[0]) !== e[0] || n.context ? this.translate(...e, t) : (this.logger.warn(`It seems you are nesting recursively key: ${e[0]} in key: ${t[0]}`), null), n)), n.interpolation && this.interpolator.reset() } const a = n.postProcess || this.options.postProcess, l = Dt(a) ? [a] : a; return null != e && (null == l ? void 0 : l.length) && !1 !== n.applyPostProcessor && (e = en.handle(l, e, t, this.options && this.options.postProcessPassResolved ? { i18nResolved: { ...r, usedParams: this.getUsedParamsDetails(n) }, ...n } : n, this)), e } resolve(e, t = {}) { let n, r, s, i, o; return Dt(e) && (e = [e]), e.forEach(e => { if (this.isValidLookup(n)) return; const a = this.extractFromKey(e, t), l = a.key; r = l; let c = a.namespaces; this.options.fallbackNS && (c = c.concat(this.options.fallbackNS)); const u = void 0 !== t.count && !Dt(t.count), h = u && !t.ordinal && 0 === t.count, d = void 0 !== t.context && (Dt(t.context) || "number" == typeof t.context) && "" !== t.context, p = t.lngs ? t.lngs : this.languageUtils.toResolveHierarchy(t.lng || this.language, t.fallbackLng); c.forEach(e => { var a, c; this.isValidLookup(n) || (o = e, rn[`${p[0]}-${e}`] || !(null == (a = this.utils) ? void 0 : a.hasLoadedNamespace) || (null == (c = this.utils) ? void 0 : c.hasLoadedNamespace(o)) || (rn[`${p[0]}-${e}`] = !0, this.logger.warn(`key "${r}" for languages "${p.join(", ")}" won't get resolved as namespace "${o}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), p.forEach(r => { var o; if (this.isValidLookup(n)) return; i = r; const a = [l]; if (null == (o = this.i18nFormat) ? void 0 : o.addLookupKeys) this.i18nFormat.addLookupKeys(a, l, r, e, t); else { let e; u && (e = this.pluralResolver.getSuffix(r, t.count, t)); const n = `${this.options.pluralSeparator}zero`, s = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (u && (t.ordinal && 0 === e.indexOf(s) && a.push(l + e.replace(s, this.options.pluralSeparator)), a.push(l + e), h && a.push(l + n)), d) { const r = `${l}${this.options.contextSeparator || "_"}${t.context}`; a.push(r), u && (t.ordinal && 0 === e.indexOf(s) && a.push(r + e.replace(s, this.options.pluralSeparator)), a.push(r + e), h && a.push(r + n)) } } let c; for (; c = a.pop();)this.isValidLookup(n) || (s = c, n = this.getResource(r, e, c, t)) })) }) }), { res: n, usedKey: r, exactUsedKey: s, usedLng: i, usedNS: o } } isValidLookup(e) { return !(void 0 === e || !this.options.returnNull && null === e || !this.options.returnEmptyString && "" === e) } getResource(e, t, n, r = {}) { var s; return (null == (s = this.i18nFormat) ? void 0 : s.getResource) ? this.i18nFormat.getResource(e, t, n, r) : this.resourceStore.getResource(e, t, n, r) } getUsedParamsDetails(e = {}) { const t = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], n = e.replace && !Dt(e.replace); let r = n ? e.replace : e; if (n && void 0 !== e.count && (r.count = e.count), this.options.interpolation.defaultVariables && (r = { ...this.options.interpolation.defaultVariables, ...r }), !n) { r = { ...r }; for (const e of t) delete r[e] } return r } static hasDefaultValue(e) { for (const t in e) if (Object.prototype.hasOwnProperty.call(e, t) && "defaultValue" === t.substring(0, 12) && void 0 !== e[t]) return !0; return !1 } } class an { constructor(e) { this.options = e, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Xt.create("languageUtils") } getScriptPartFromCode(e) { if (!(e = Wt(e)) || e.indexOf("-") < 0) return null; const t = e.split("-"); return 2 === t.length ? null : (t.pop(), "x" === t[t.length - 1].toLowerCase() ? null : this.formatLanguageCode(t.join("-"))) } getLanguagePartFromCode(e) { if (!(e = Wt(e)) || e.indexOf("-") < 0) return e; const t = e.split("-"); return this.formatLanguageCode(t[0]) } formatLanguageCode(e) { if (Dt(e) && e.indexOf("-") > -1) { let t; try { t = Intl.getCanonicalLocales(e)[0] } catch (mg) { } return t && this.options.lowerCaseLng && (t = t.toLowerCase()), t || (this.options.lowerCaseLng ? e.toLowerCase() : e) } return this.options.cleanCode || this.options.lowerCaseLng ? e.toLowerCase() : e } isSupportedCode(e) { return ("languageOnly" === this.options.load || this.options.nonExplicitSupportedLngs) && (e = this.getLanguagePartFromCode(e)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(e) > -1 } getBestMatchFromCodes(e) { if (!e) return null; let t; return e.forEach(e => { if (t) return; const n = this.formatLanguageCode(e); this.options.supportedLngs && !this.isSupportedCode(n) || (t = n) }), !t && this.options.supportedLngs && e.forEach(e => { if (t) return; const n = this.getScriptPartFromCode(e); if (this.isSupportedCode(n)) return t = n; const r = this.getLanguagePartFromCode(e); if (this.isSupportedCode(r)) return t = r; t = this.options.supportedLngs.find(e => e === r ? e : e.indexOf("-") < 0 && r.indexOf("-") < 0 ? void 0 : e.indexOf("-") > 0 && r.indexOf("-") < 0 && e.substring(0, e.indexOf("-")) === r || 0 === e.indexOf(r) && r.length > 1 ? e : void 0) }), t || (t = this.getFallbackCodes(this.options.fallbackLng)[0]), t } getFallbackCodes(e, t) { if (!e) return []; if ("function" == typeof e && (e = e(t)), Dt(e) && (e = [e]), Array.isArray(e)) return e; if (!t) return e.default || []; let n = e[t]; return n || (n = e[this.getScriptPartFromCode(t)]), n || (n = e[this.formatLanguageCode(t)]), n || (n = e[this.getLanguagePartFromCode(t)]), n || (n = e.default), n || [] } toResolveHierarchy(e, t) { const n = this.getFallbackCodes((!1 === t ? [] : t) || this.options.fallbackLng || [], e), r = [], s = e => { e && (this.isSupportedCode(e) ? r.push(e) : this.logger.warn(`rejecting language code not found in supportedLngs: ${e}`)) }; return Dt(e) && (e.indexOf("-") > -1 || e.indexOf("_") > -1) ? ("languageOnly" !== this.options.load && s(this.formatLanguageCode(e)), "languageOnly" !== this.options.load && "currentOnly" !== this.options.load && s(this.getScriptPartFromCode(e)), "currentOnly" !== this.options.load && s(this.getLanguagePartFromCode(e))) : Dt(e) && s(this.formatLanguageCode(e)), n.forEach(e => { r.indexOf(e) < 0 && s(this.formatLanguageCode(e)) }), r } } const ln = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }, cn = { select: e => 1 === e ? "one" : "other", resolvedOptions: () => ({ pluralCategories: ["one", "other"] }) }; class un { constructor(e, t = {}) { this.languageUtils = e, this.options = t, this.logger = Xt.create("pluralResolver"), this.pluralRulesCache = {} } addRule(e, t) { this.rules[e] = t } clearCache() { this.pluralRulesCache = {} } getRule(e, t = {}) { const n = Wt("dev" === e ? "en" : e), r = t.ordinal ? "ordinal" : "cardinal", s = JSON.stringify({ cleanedCode: n, type: r }); if (s in this.pluralRulesCache) return this.pluralRulesCache[s]; let i; try { i = new Intl.PluralRules(n, { type: r }) } catch (o) { if (!Intl) return this.logger.error("No Intl support, please use an Intl polyfill!"), cn; if (!e.match(/-|_/)) return cn; const n = this.languageUtils.getLanguagePartFromCode(e); i = this.getRule(n, t) } return this.pluralRulesCache[s] = i, i } needsPlural(e, t = {}) { let n = this.getRule(e, t); return n || (n = this.getRule("dev", t)), (null == n ? void 0 : n.resolvedOptions().pluralCategories.length) > 1 } getPluralFormsOfKey(e, t, n = {}) { return this.getSuffixes(e, n).map(e => `${t}${e}`) } getSuffixes(e, t = {}) { let n = this.getRule(e, t); return n || (n = this.getRule("dev", t)), n ? n.resolvedOptions().pluralCategories.sort((e, t) => ln[e] - ln[t]).map(e => `${this.options.prepend}${t.ordinal ? `ordinal${this.options.prepend}` : ""}${e}`) : [] } getSuffix(e, t, n = {}) { const r = this.getRule(e, n); return r ? `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${r.select(t)}` : (this.logger.warn(`no plural rule found for: ${e}`), this.getSuffix("dev", t, n)) } } const hn = (e, t, n, r = ".", s = !0) => { let i = ((e, t, n) => { const r = Ht(e, n); return void 0 !== r ? r : Ht(t, n) })(e, t, n); return !i && s && Dt(n) && (i = $t(e, n, r), void 0 === i && (i = $t(t, n, r))), i }, dn = e => e.replace(/\$/g, "$$$$"); class pn { constructor(e = {}) { var t; this.logger = Xt.create("interpolator"), this.options = e, this.format = (null == (t = null == e ? void 0 : e.interpolation) ? void 0 : t.format) || (e => e), this.init(e) } init(e = {}) { e.interpolation || (e.interpolation = { escapeValue: !0 }); const { escape: t, escapeValue: n, useRawValueToEscape: r, prefix: s, prefixEscaped: i, suffix: o, suffixEscaped: a, formatSeparator: l, unescapeSuffix: c, unescapePrefix: u, nestingPrefix: h, nestingPrefixEscaped: d, nestingSuffix: p, nestingSuffixEscaped: f, nestingOptionsSeparator: m, maxReplaces: g, alwaysFormat: E } = e.interpolation; this.escape = void 0 !== t ? t : Yt, this.escapeValue = void 0 === n || n, this.useRawValueToEscape = void 0 !== r && r, this.prefix = s ? Gt(s) : i || "{{", this.suffix = o ? Gt(o) : a || "}}", this.formatSeparator = l || ",", this.unescapePrefix = c ? "" : u || "-", this.unescapeSuffix = this.unescapePrefix ? "" : c || "", this.nestingPrefix = h ? Gt(h) : d || Gt("$t("), this.nestingSuffix = p ? Gt(p) : f || Gt(")"), this.nestingOptionsSeparator = m || ",", this.maxReplaces = g || 1e3, this.alwaysFormat = void 0 !== E && E, this.resetRegExp() } reset() { this.options && this.init(this.options) } resetRegExp() { const e = (e, t) => (null == e ? void 0 : e.source) === t ? (e.lastIndex = 0, e) : new RegExp(t, "g"); this.regexp = e(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = e(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = e(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`) } interpolate(e, t, n, r) { var s; let i, o, a; const l = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, c = e => { if (e.indexOf(this.formatSeparator) < 0) { const s = hn(t, l, e, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(s, void 0, n, { ...r, ...t, interpolationkey: e }) : s } const s = e.split(this.formatSeparator), i = s.shift().trim(), o = s.join(this.formatSeparator).trim(); return this.format(hn(t, l, i, this.options.keySeparator, this.options.ignoreJSONStructure), o, n, { ...r, ...t, interpolationkey: i }) }; this.resetRegExp(); const u = (null == r ? void 0 : r.missingInterpolationHandler) || this.options.missingInterpolationHandler, h = void 0 !== (null == (s = null == r ? void 0 : r.interpolation) ? void 0 : s.skipOnVariables) ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: e => dn(e) }, { regex: this.regexp, safeValue: e => this.escapeValue ? dn(this.escape(e)) : dn(e) }].forEach(t => { for (a = 0; i = t.regex.exec(e);) { const n = i[1].trim(); if (o = c(n), void 0 === o) if ("function" == typeof u) { const t = u(e, i, r); o = Dt(t) ? t : "" } else if (r && Object.prototype.hasOwnProperty.call(r, n)) o = ""; else { if (h) { o = i[0]; continue } this.logger.warn(`missed to pass in variable ${n} for interpolating ${e}`), o = "" } else Dt(o) || this.useRawValueToEscape || (o = Pt(o)); const s = t.safeValue(o); if (e = e.replace(i[0], s), h ? (t.regex.lastIndex += o.length, t.regex.lastIndex -= i[0].length) : t.regex.lastIndex = 0, a++, a >= this.maxReplaces) break } }), e } nest(e, t, n = {}) { let r, s, i; const o = (e, t) => { const n = this.nestingOptionsSeparator; if (e.indexOf(n) < 0) return e; const r = e.split(new RegExp(`${n}[ ]*{`)); let s = `{${r[1]}`; e = r[0], s = this.interpolate(s, i); const o = s.match(/'/g), a = s.match(/"/g); (((null == o ? void 0 : o.length) ?? 0) % 2 == 0 && !a || a.length % 2 != 0) && (s = s.replace(/'/g, '"')); try { i = JSON.parse(s), t && (i = { ...t, ...i }) } catch (mg) { return this.logger.warn(`failed parsing options string in nesting for key ${e}`, mg), `${e}${n}${s}` } return i.defaultValue && i.defaultValue.indexOf(this.prefix) > -1 && delete i.defaultValue, e }; for (; r = this.nestingRegexp.exec(e);) { let a = []; i = { ...n }, i = i.replace && !Dt(i.replace) ? i.replace : i, i.applyPostProcessor = !1, delete i.defaultValue; const l = /{.*}/.test(r[1]) ? r[1].lastIndexOf("}") + 1 : r[1].indexOf(this.formatSeparator); if (-1 !== l && (a = r[1].slice(l).split(this.formatSeparator).map(e => e.trim()).filter(Boolean), r[1] = r[1].slice(0, l)), s = t(o.call(this, r[1].trim(), i), i), s && r[0] === e && !Dt(s)) return s; Dt(s) || (s = Pt(s)), s || (this.logger.warn(`missed to resolve ${r[1]} for nesting ${e}`), s = ""), a.length && (s = a.reduce((e, t) => this.format(e, t, n.lng, { ...n, interpolationkey: r[1].trim() }), s.trim())), e = e.replace(r[0], s), this.regexp.lastIndex = 0 } return e } } const fn = e => { const t = {}; return (n, r, s) => { let i = s; s && s.interpolationkey && s.formatParams && s.formatParams[s.interpolationkey] && s[s.interpolationkey] && (i = { ...i, [s.interpolationkey]: void 0 }); const o = r + JSON.stringify(i); let a = t[o]; return a || (a = e(Wt(r), s), t[o] = a), a(n) } }, mn = e => (t, n, r) => e(Wt(n), r)(t); class gn { constructor(e = {}) { this.logger = Xt.create("formatter"), this.options = e, this.init(e) } init(e, t = { interpolation: {} }) { this.formatSeparator = t.interpolation.formatSeparator || ","; const n = t.cacheInBuiltFormats ? fn : mn; this.formats = { number: n((e, t) => { const n = new Intl.NumberFormat(e, { ...t }); return e => n.format(e) }), currency: n((e, t) => { const n = new Intl.NumberFormat(e, { ...t, style: "currency" }); return e => n.format(e) }), datetime: n((e, t) => { const n = new Intl.DateTimeFormat(e, { ...t }); return e => n.format(e) }), relativetime: n((e, t) => { const n = new Intl.RelativeTimeFormat(e, { ...t }); return e => n.format(e, t.range || "day") }), list: n((e, t) => { const n = new Intl.ListFormat(e, { ...t }); return e => n.format(e) }) } } add(e, t) { this.formats[e.toLowerCase().trim()] = t } addCached(e, t) { this.formats[e.toLowerCase().trim()] = fn(t) } format(e, t, n, r = {}) { const s = t.split(this.formatSeparator); if (s.length > 1 && s[0].indexOf("(") > 1 && s[0].indexOf(")") < 0 && s.find(e => e.indexOf(")") > -1)) { const e = s.findIndex(e => e.indexOf(")") > -1); s[0] = [s[0], ...s.splice(1, e)].join(this.formatSeparator) } return s.reduce((e, t) => { var s; const { formatName: i, formatOptions: o } = (e => { let t = e.toLowerCase().trim(); const n = {}; if (e.indexOf("(") > -1) { const r = e.split("("); t = r[0].toLowerCase().trim(); const s = r[1].substring(0, r[1].length - 1); "currency" === t && s.indexOf(":") < 0 ? n.currency || (n.currency = s.trim()) : "relativetime" === t && s.indexOf(":") < 0 ? n.range || (n.range = s.trim()) : s.split(";").forEach(e => { if (e) { const [t, ...r] = e.split(":"), s = r.join(":").trim().replace(/^'+|'+$/g, ""), i = t.trim(); n[i] || (n[i] = s), "false" === s && (n[i] = !1), "true" === s && (n[i] = !0), isNaN(s) || (n[i] = parseInt(s, 10)) } }) } return { formatName: t, formatOptions: n } })(t); if (this.formats[i]) { let t = e; try { const a = (null == (s = null == r ? void 0 : r.formatParams) ? void 0 : s[r.interpolationkey]) || {}, l = a.locale || a.lng || r.locale || r.lng || n; t = this.formats[i](e, l, { ...o, ...r, ...a }) } catch (a) { this.logger.warn(a) } return t } return this.logger.warn(`there was no format function for ${i}`), e }, e) } } class En extends Jt { constructor(e, t, n, r = {}) { var s, i; super(), this.backend = e, this.store = t, this.services = n, this.languageUtils = n.languageUtils, this.options = r, this.logger = Xt.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = r.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = r.maxRetries >= 0 ? r.maxRetries : 5, this.retryTimeout = r.retryTimeout >= 1 ? r.retryTimeout : 350, this.state = {}, this.queue = [], null == (i = null == (s = this.backend) ? void 0 : s.init) || i.call(s, n, r.backend, r) } queueLoad(e, t, n, r) { const s = {}, i = {}, o = {}, a = {}; return e.forEach(e => { let r = !0; t.forEach(t => { const o = `${e}|${t}`; !n.reload && this.store.hasResourceBundle(e, t) ? this.state[o] = 2 : this.state[o] < 0 || (1 === this.state[o] ? void 0 === i[o] && (i[o] = !0) : (this.state[o] = 1, r = !1, void 0 === i[o] && (i[o] = !0), void 0 === s[o] && (s[o] = !0), void 0 === a[t] && (a[t] = !0))) }), r || (o[e] = !0) }), (Object.keys(s).length || Object.keys(i).length) && this.queue.push({ pending: i, pendingCount: Object.keys(i).length, loaded: {}, errors: [], callback: r }), { toLoad: Object.keys(s), pending: Object.keys(i), toLoadLanguages: Object.keys(o), toLoadNamespaces: Object.keys(a) } } loaded(e, t, n) { const r = e.split("|"), s = r[0], i = r[1]; t && this.emit("failedLoading", s, i, t), !t && n && this.store.addResourceBundle(s, i, n, void 0, void 0, { skipCopy: !0 }), this.state[e] = t ? -1 : 2, t && n && (this.state[e] = 0); const o = {}; this.queue.forEach(n => { ((e, t, n) => { const { obj: r, k: s } = Bt(e, t, Object); r[s] = r[s] || [], r[s].push(n) })(n.loaded, [s], i), ((e, t) => { void 0 !== e.pending[t] && (delete e.pending[t], e.pendingCount--) })(n, e), t && n.errors.push(t), 0 !== n.pendingCount || n.done || (Object.keys(n.loaded).forEach(e => { o[e] || (o[e] = {}); const t = n.loaded[e]; t.length && t.forEach(t => { void 0 === o[e][t] && (o[e][t] = !0) }) }), n.done = !0, n.errors.length ? n.callback(n.errors) : n.callback()) }), this.emit("loaded", o), this.queue = this.queue.filter(e => !e.done) } read(e, t, n, r = 0, s = this.retryTimeout, i) { if (!e.length) return i(null, {}); if (this.readingCalls >= this.maxParallelReads) return void this.waitingReads.push({ lng: e, ns: t, fcName: n, tried: r, wait: s, callback: i }); this.readingCalls++; const o = (o, a) => { if (this.readingCalls--, this.waitingReads.length > 0) { const e = this.waitingReads.shift(); this.read(e.lng, e.ns, e.fcName, e.tried, e.wait, e.callback) } o && a && r < this.maxRetries ? setTimeout(() => { this.read.call(this, e, t, n, r + 1, 2 * s, i) }, s) : i(o, a) }, a = this.backend[n].bind(this.backend); if (2 !== a.length) return a(e, t, o); try { const n = a(e, t); n && "function" == typeof n.then ? n.then(e => o(null, e)).catch(o) : o(null, n) } catch (l) { o(l) } } prepareLoading(e, t, n = {}, r) { if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), r && r(); Dt(e) && (e = this.languageUtils.toResolveHierarchy(e)), Dt(t) && (t = [t]); const s = this.queueLoad(e, t, n, r); if (!s.toLoad.length) return s.pending.length || r(), null; s.toLoad.forEach(e => { this.loadOne(e) }) } load(e, t, n) { this.prepareLoading(e, t, {}, n) } reload(e, t, n) { this.prepareLoading(e, t, { reload: !0 }, n) } loadOne(e, t = "") { const n = e.split("|"), r = n[0], s = n[1]; this.read(r, s, "read", void 0, void 0, (n, i) => { n && this.logger.warn(`${t}loading namespace ${s} for language ${r} failed`, n), !n && i && this.logger.log(`${t}loaded namespace ${s} for language ${r}`, i), this.loaded(e, n, i) }) } saveMissing(e, t, n, r, s, i = {}, o = () => { }) { var a, l, c, u, h; if (!(null == (l = null == (a = this.services) ? void 0 : a.utils) ? void 0 : l.hasLoadedNamespace) || (null == (u = null == (c = this.services) ? void 0 : c.utils) ? void 0 : u.hasLoadedNamespace(t))) { if (null != n && "" !== n) { if (null == (h = this.backend) ? void 0 : h.create) { const a = { ...i, isUpdate: s }, l = this.backend.create.bind(this.backend); if (l.length < 6) try { let s; s = 5 === l.length ? l(e, t, n, r, a) : l(e, t, n, r), s && "function" == typeof s.then ? s.then(e => o(null, e)).catch(o) : o(null, s) } catch (d) { o(d) } else l(e, t, n, r, o, a) } e && e[0] && this.store.addResource(e[0], t, n, r) } } else this.logger.warn(`did not save key "${n}" as the namespace "${t}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!") } } const Tn = () => ({ debug: !1, initAsync: !0, ns: ["translation"], defaultNS: ["translation"], fallbackLng: ["dev"], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: "all", preload: !1, simplifyPluralSuffix: !0, keySeparator: ".", nsSeparator: ":", pluralSeparator: "_", contextSeparator: "_", partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: "fallback", saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !1, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: e => { let t = {}; if ("object" == typeof e[1] && (t = e[1]), Dt(e[1]) && (t.defaultValue = e[1]), Dt(e[2]) && (t.tDescription = e[2]), "object" == typeof e[2] || "object" == typeof e[3]) { const n = e[3] || e[2]; Object.keys(n).forEach(e => { t[e] = n[e] }) } return t }, interpolation: { escapeValue: !0, format: e => e, prefix: "{{", suffix: "}}", formatSeparator: ",", unescapePrefix: "-", nestingPrefix: "$t(", nestingSuffix: ")", nestingOptionsSeparator: ",", maxReplaces: 1e3, skipOnVariables: !0 }, cacheInBuiltFormats: !0 }), An = e => { var t, n; return Dt(e.ns) && (e.ns = [e.ns]), Dt(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), Dt(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), (null == (n = null == (t = e.supportedLngs) ? void 0 : t.indexOf) ? void 0 : n.call(t, "cimode")) < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), "boolean" == typeof e.initImmediate && (e.initAsync = e.initImmediate), e }, _n = () => { }; class yn extends Jt { constructor(e = {}, t) { var n; if (super(), this.options = An(e), this.services = {}, this.logger = Xt, this.modules = { external: [] }, n = this, Object.getOwnPropertyNames(Object.getPrototypeOf(n)).forEach(e => { "function" == typeof n[e] && (n[e] = n[e].bind(n)) }), t && !this.isInitialized && !e.isClone) { if (!this.options.initAsync) return this.init(e, t), this; setTimeout(() => { this.init(e, t) }, 0) } } init(e = {}, t) { this.isInitializing = !0, "function" == typeof e && (t = e, e = {}), null == e.defaultNS && e.ns && (Dt(e.ns) ? e.defaultNS = e.ns : e.ns.indexOf("translation") < 0 && (e.defaultNS = e.ns[0])); const n = Tn(); this.options = { ...n, ...this.options, ...An(e) }, this.options.interpolation = { ...n.interpolation, ...this.options.interpolation }, void 0 !== e.keySeparator && (this.options.userDefinedKeySeparator = e.keySeparator), void 0 !== e.nsSeparator && (this.options.userDefinedNsSeparator = e.nsSeparator), "function" != typeof this.options.overloadTranslationOptionHandler && (this.options.overloadTranslationOptionHandler = n.overloadTranslationOptionHandler); const r = e => e ? "function" == typeof e ? new e : e : null; if (!this.options.isClone) { let e; this.modules.logger ? Xt.init(r(this.modules.logger), this.options) : Xt.init(null, this.options), e = this.modules.formatter ? this.modules.formatter : gn; const t = new an(this.options); this.store = new Zt(this.options.resources, this.options); const s = this.services; s.logger = Xt, s.resourceStore = this.store, s.languageUtils = t, s.pluralResolver = new un(t, { prepend: this.options.pluralSeparator, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), this.options.interpolation.format && this.options.interpolation.format !== n.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), !e || this.options.interpolation.format && this.options.interpolation.format !== n.interpolation.format || (s.formatter = r(e), s.formatter.init && s.formatter.init(s, this.options), this.options.interpolation.format = s.formatter.format.bind(s.formatter)), s.interpolator = new pn(this.options), s.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, s.backendConnector = new En(r(this.modules.backend), s.resourceStore, s, this.options), s.backendConnector.on("*", (e, ...t) => { this.emit(e, ...t) }), this.modules.languageDetector && (s.languageDetector = r(this.modules.languageDetector), s.languageDetector.init && s.languageDetector.init(s, this.options.detection, this.options)), this.modules.i18nFormat && (s.i18nFormat = r(this.modules.i18nFormat), s.i18nFormat.init && s.i18nFormat.init(this)), this.translator = new on(this.services, this.options), this.translator.on("*", (e, ...t) => { this.emit(e, ...t) }), this.modules.external.forEach(e => { e.init && e.init(this) }) } if (this.format = this.options.interpolation.format, t || (t = _n), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const e = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); e.length > 0 && "dev" !== e[0] && (this.options.lng = e[0]) } this.services.languageDetector || this.options.lng || this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(e => { this[e] = (...t) => this.store[e](...t) }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(e => { this[e] = (...t) => (this.store[e](...t), this) }); const s = Lt(), i = () => { const e = (e, n) => { this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), s.resolve(n), t(e, n) }; if (this.languages && !this.isInitialized) return e(null, this.t.bind(this)); this.changeLanguage(this.options.lng, e) }; return this.options.resources || !this.options.initAsync ? i() : setTimeout(i, 0), s } loadResources(e, t = _n) { var n, r; let s = t; const i = Dt(e) ? e : this.language; if ("function" == typeof e && (s = e), !this.options.resources || this.options.partialBundledLanguages) { if ("cimode" === (null == i ? void 0 : i.toLowerCase()) && (!this.options.preload || 0 === this.options.preload.length)) return s(); const e = [], t = t => { t && "cimode" !== t && this.services.languageUtils.toResolveHierarchy(t).forEach(t => { "cimode" !== t && e.indexOf(t) < 0 && e.push(t) }) }; i ? t(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(e => t(e)), null == (r = null == (n = this.options.preload) ? void 0 : n.forEach) || r.call(n, e => t(e)), this.services.backendConnector.load(e, this.options.ns, e => { e || this.resolvedLanguage || !this.language || this.setResolvedLanguage(this.language), s(e) }) } else s(null) } reloadResources(e, t, n) { const r = Lt(); return "function" == typeof e && (n = e, e = void 0), "function" == typeof t && (n = t, t = void 0), e || (e = this.languages), t || (t = this.options.ns), n || (n = _n), this.services.backendConnector.reload(e, t, e => { r.resolve(), n(e) }), r } use(e) { if (!e) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()"); if (!e.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()"); return "backend" === e.type && (this.modules.backend = e), ("logger" === e.type || e.log && e.warn && e.error) && (this.modules.logger = e), "languageDetector" === e.type && (this.modules.languageDetector = e), "i18nFormat" === e.type && (this.modules.i18nFormat = e), "postProcessor" === e.type && en.addPostProcessor(e), "formatter" === e.type && (this.modules.formatter = e), "3rdParty" === e.type && this.modules.external.push(e), this } setResolvedLanguage(e) { if (e && this.languages && !(["cimode", "dev"].indexOf(e) > -1)) { for (let e = 0; e < this.languages.length; e++) { const t = this.languages[e]; if (!(["cimode", "dev"].indexOf(t) > -1) && this.store.hasLanguageSomeTranslations(t)) { this.resolvedLanguage = t; break } } !this.resolvedLanguage && this.languages.indexOf(e) < 0 && this.store.hasLanguageSomeTranslations(e) && (this.resolvedLanguage = e, this.languages.unshift(e)) } } changeLanguage(e, t) { this.isLanguageChangingTo = e; const n = Lt(); this.emit("languageChanging", e); const r = e => { this.language = e, this.languages = this.services.languageUtils.toResolveHierarchy(e), this.resolvedLanguage = void 0, this.setResolvedLanguage(e) }, s = (s, i) => { i ? this.isLanguageChangingTo === e && (r(i), this.translator.changeLanguage(i), this.isLanguageChangingTo = void 0, this.emit("languageChanged", i), this.logger.log("languageChanged", i)) : this.isLanguageChangingTo = void 0, n.resolve((...e) => this.t(...e)), t && t(s, (...e) => this.t(...e)) }, i = t => { var n, i; e || t || !this.services.languageDetector || (t = []); const o = Dt(t) ? t : t && t[0], a = this.store.hasLanguageSomeTranslations(o) ? o : this.services.languageUtils.getBestMatchFromCodes(Dt(t) ? [t] : t); a && (this.language || r(a), this.translator.language || this.translator.changeLanguage(a), null == (i = null == (n = this.services.languageDetector) ? void 0 : n.cacheUserLanguage) || i.call(n, a)), this.loadResources(a, e => { s(e, a) }) }; return e || !this.services.languageDetector || this.services.languageDetector.async ? !e && this.services.languageDetector && this.services.languageDetector.async ? 0 === this.services.languageDetector.detect.length ? this.services.languageDetector.detect().then(i) : this.services.languageDetector.detect(i) : i(e) : i(this.services.languageDetector.detect()), n } getFixedT(e, t, n) { const r = (e, t, ...s) => { let i; i = "object" != typeof t ? this.options.overloadTranslationOptionHandler([e, t].concat(s)) : { ...t }, i.lng = i.lng || r.lng, i.lngs = i.lngs || r.lngs, i.ns = i.ns || r.ns, "" !== i.keyPrefix && (i.keyPrefix = i.keyPrefix || n || r.keyPrefix); const o = this.options.keySeparator || "."; let a; return i.keyPrefix && Array.isArray(e) ? a = e.map(e => ("function" == typeof e && (e = nn(e, { ...this.options, ...t })), `${i.keyPrefix}${o}${e}`)) : ("function" == typeof e && (e = nn(e, { ...this.options, ...t })), a = i.keyPrefix ? `${i.keyPrefix}${o}${e}` : e), this.t(a, i) }; return Dt(e) ? r.lng = e : r.lngs = e, r.ns = t, r.keyPrefix = n, r } t(...e) { var t; return null == (t = this.translator) ? void 0 : t.translate(...e) } exists(...e) { var t; return null == (t = this.translator) ? void 0 : t.exists(...e) } setDefaultNamespace(e) { this.options.defaultNS = e } hasLoadedNamespace(e, t = {}) { if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1; const n = t.lng || this.resolvedLanguage || this.languages[0], r = !!this.options && this.options.fallbackLng, s = this.languages[this.languages.length - 1]; if ("cimode" === n.toLowerCase()) return !0; const i = (e, t) => { const n = this.services.backendConnector.state[`${e}|${t}`]; return -1 === n || 0 === n || 2 === n }; if (t.precheck) { const e = t.precheck(this, i); if (void 0 !== e) return e } return !(!this.hasResourceBundle(n, e) && this.services.backendConnector.backend && (!this.options.resources || this.options.partialBundledLanguages) && (!i(n, e) || r && !i(s, e))) } loadNamespaces(e, t) { const n = Lt(); return this.options.ns ? (Dt(e) && (e = [e]), e.forEach(e => { this.options.ns.indexOf(e) < 0 && this.options.ns.push(e) }), this.loadResources(e => { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } loadLanguages(e, t) { const n = Lt(); Dt(e) && (e = [e]); const r = this.options.preload || [], s = e.filter(e => r.indexOf(e) < 0 && this.services.languageUtils.isSupportedCode(e)); return s.length ? (this.options.preload = r.concat(s), this.loadResources(e => { n.resolve(), t && t(e) }), n) : (t && t(), Promise.resolve()) } dir(e) { var t, n; if (e || (e = this.resolvedLanguage || ((null == (t = this.languages) ? void 0 : t.length) > 0 ? this.languages[0] : this.language)), !e) return "rtl"; try { const t = new Intl.Locale(e); if (t && t.getTextInfo) { const e = t.getTextInfo(); if (e && e.direction) return e.direction } } catch (mg) { } const r = (null == (n = this.services) ? void 0 : n.languageUtils) || new an(Tn()); return e.toLowerCase().indexOf("-latn") > 1 ? "ltr" : ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"].indexOf(r.getLanguagePartFromCode(e)) > -1 || e.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr" } static createInstance(e = {}, t) { const n = new yn(e, t); return n.createInstance = yn.createInstance, n } cloneInstance(e = {}, t = _n) { const n = e.forkResourceStore; n && delete e.forkResourceStore; const r = { ...this.options, ...e, isClone: !0 }, s = new yn(r); if (void 0 === e.debug && void 0 === e.prefix || (s.logger = s.logger.clone(e)), ["store", "services", "language"].forEach(e => { s[e] = this[e] }), s.services = { ...this.services }, s.services.utils = { hasLoadedNamespace: s.hasLoadedNamespace.bind(s) }, n) { const e = Object.keys(this.store.data).reduce((e, t) => (e[t] = { ...this.store.data[t] }, e[t] = Object.keys(e[t]).reduce((n, r) => (n[r] = { ...e[t][r] }, n), e[t]), e), {}); s.store = new Zt(e, r), s.services.resourceStore = s.store } return e.interpolation && (s.services.interpolator = new pn(r)), s.translator = new on(s.services, r), s.translator.on("*", (e, ...t) => { s.emit(e, ...t) }), s.init(r, t), s.translator.options = r, s.translator.backendConnector.services.utils = { hasLoadedNamespace: s.hasLoadedNamespace.bind(s) }, s } toJSON() { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } } const bn = yn.createInstance(); bn.createInstance, bn.dir, bn.init, bn.loadResources, bn.reloadResources, bn.use, bn.changeLanguage, bn.getFixedT, bn.t, bn.exists, bn.setDefaultNamespace, bn.hasLoadedNamespace, bn.loadNamespaces, bn.loadLanguages; const Sn = {}, kn = (e, t, n, r) => { On(n) && Sn[n] || (On(n) && (Sn[n] = new Date), ((e, t, n, r) => { var s, i, o, a; const l = [n, { code: t, ...r || {} }]; if (null == (i = null == (s = null == e ? void 0 : e.services) ? void 0 : s.logger) ? void 0 : i.forward) return e.services.logger.forward(l, "warn", "react-i18next::", !0); On(l[0]) && (l[0] = `react-i18next:: ${l[0]}`), (null == (a = null == (o = null == e ? void 0 : e.services) ? void 0 : o.logger) ? void 0 : a.warn) ? e.services.logger.warn(...l) : (null == console ? void 0 : console.warn) && console.warn(...l) })(e, t, n, r)) }, Cn = (e, t) => () => { if (e.isInitialized) t(); else { const n = () => { setTimeout(() => { e.off("initialized", n) }, 0), t() }; e.on("initialized", n) } }, Nn = (e, t, n) => { e.loadNamespaces(t, Cn(e, n)) }, In = (e, t, n, r) => { if (On(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(t) > -1) return Nn(e, n, r); n.forEach(t => { e.options.ns.indexOf(t) < 0 && e.options.ns.push(t) }), e.loadLanguages(t, Cn(e, r)) }, On = e => "string" == typeof e, xn = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, vn = { "&amp;": "&", "&#38;": "&", "&lt;": "<", "&#60;": "<", "&gt;": ">", "&#62;": ">", "&apos;": "'", "&#39;": "'", "&quot;": '"', "&#34;": '"', "&nbsp;": " ", "&#160;": " ", "&copy;": "", "&#169;": "", "&reg;": "", "&#174;": "", "&hellip;": "", "&#8230;": "", "&#x2F;": "/", "&#47;": "/" }, Rn = e => vn[e]; let Dn, Ln = { bindI18n: "languageChanged", bindI18nStore: "", transEmptyNodeValue: "", transSupportBasicHtmlNodes: !0, transWrapTextNodes: "", transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"], useSuspense: !0, unescape: e => e.replace(xn, Rn), transDefaultProps: void 0 }; const Pn = { type: "3rdParty", init(e) { ((e = {}) => { Ln = { ...Ln, ...e } })(e.options.react), (e => { Dn = e })(e) } }, wn = React.createContext(); class Mn { constructor() { this.usedNamespaces = {} } addUsedNamespaces(e) { e.forEach(e => { this.usedNamespaces[e] || (this.usedNamespaces[e] = !0) }) } getUsedNamespaces() { return Object.keys(this.usedNamespaces) } } var Fn = { exports: {} }, Bn = {}, Un = l, Hn = "function" == typeof Object.is ? Object.is : function (e, t) { return e === t && (0 !== e || 1 / e == 1 / t) || e != e && t != t }, jn = Un.useState, Gn = Un.useEffect, zn = Un.useLayoutEffect, Yn = Un.useDebugValue; function qn(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !Hn(e, n) } catch (r) { return !0 } } var Vn = "undefined" == typeof window || void 0 === window.document || void 0 === window.document.createElement ? function (e, t) { return t() } : function (e, t) { var n = t(), r = jn({ inst: { value: n, getSnapshot: t } }), s = r[0].inst, i = r[1]; return zn(function () { s.value = n, s.getSnapshot = t, qn(s) && i({ inst: s }) }, [e, n, t]), Gn(function () { return qn(s) && i({ inst: s }), e(function () { qn(s) && i({ inst: s }) }) }, [e]), Yn(n), n }; Bn.useSyncExternalStore = void 0 !== Un.useSyncExternalStore ? Un.useSyncExternalStore : Vn, Fn.exports = Bn; var $n = Fn.exports; const Wn = { t: (e, t) => { return On(t) ? t : "object" == typeof (n = t) && null !== n && On(t.defaultValue) ? t.defaultValue : Array.isArray(e) ? e[e.length - 1] : e; var n }, ready: !1 }, Kn = () => () => { }, Qn = (e, t = {}) => { var n, r, s; const { i18n: i } = t, { i18n: o, defaultNS: a } = React.useContext(wn) || {}, l = i || o || Dn; l && !l.reportNamespaces && (l.reportNamespaces = new Mn), l || kn(l, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next"); const c = React.useMemo(() => { var e; return { ...Ln, ...null == (e = null == l ? void 0 : l.options) ? void 0 : e.react, ...t } }, [l, t]), { useSuspense: u, keyPrefix: h } = c, d = a || (null == (n = null == l ? void 0 : l.options) ? void 0 : n.defaultNS), p = On(d) ? [d] : d || ["translation"], f = React.useMemo(() => p, p); null == (s = null == (r = null == l ? void 0 : l.reportNamespaces) ? void 0 : r.addUsedNamespaces) || s.call(r, f); const m = React.useRef(0), g = React.useCallback(e => { if (!l) return Kn; const { bindI18n: t, bindI18nStore: n } = c, r = () => { m.current += 1, e() }; return t && l.on(t, r), n && l.store.on(n, r), () => { t && t.split(" ").forEach(e => l.off(e, r)), n && n.split(" ").forEach(e => l.store.off(e, r)) } }, [l, c]), E = React.useRef(), T = React.useCallback(() => { if (!l) return Wn; const e = !(!l.isInitialized && !l.initializedStoreOnce) && f.every(e => ((e, t, n = {}) => t.languages && t.languages.length ? t.hasLoadedNamespace(e, { lng: n.lng, precheck: (t, r) => { if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && t.services.backendConnector.backend && t.isLanguageChangingTo && !r(t.isLanguageChangingTo, e)) return !1 } }) : (kn(t, "NO_LANGUAGES", "i18n.languages were undefined or empty", { languages: t.languages }), !0))(e, l, c)), n = t.lng || l.language, r = m.current, s = E.current; if (s && s.ready === e && s.lng === n && s.keyPrefix === h && s.revision === r) return s; const i = { t: l.getFixedT(n, "fallback" === c.nsMode ? f : f[0], h), ready: e, lng: n, keyPrefix: h, revision: r }; return E.current = i, i }, [l, f, h, c, t.lng]), [A, _] = React.useState(0), { t: y, ready: b } = $n.useSyncExternalStore(g, T, T); React.useEffect(() => { if (l && !b && !u) { const e = () => _(e => e + 1); t.lng ? In(l, t.lng, f, e) : Nn(l, f, e) } }, [l, t.lng, f, b, u, A]); const S = l || {}, k = React.useRef(null), C = React.useRef(), N = e => { const t = Object.getOwnPropertyDescriptors(e); t.__original && delete t.__original; const n = Object.create(Object.getPrototypeOf(e), t); if (!Object.prototype.hasOwnProperty.call(n, "__original")) try { Object.defineProperty(n, "__original", { value: e, writable: !1, enumerable: !1, configurable: !1 }) } catch (r) { } return n }, I = React.useMemo(() => { const e = S, t = null == e ? void 0 : e.language; let n = e; e && (k.current && k.current.__original === e ? C.current !== t ? (n = N(e), k.current = n, C.current = t) : n = k.current : (n = N(e), k.current = n, C.current = t)); const r = [y, n, b]; return r.t = y, r.i18n = n, r.ready = b, r }, [y, S, b, S.resolvedLanguage, S.language, S.languages]); if (l && u && !b) throw new Promise(e => { const n = () => e(); t.lng ? In(l, t.lng, f, n) : Nn(l, f, n) }); return I }; function Xn(e, t) { return function () { return e.apply(t, arguments) } } const { toString: Jn } = Object.prototype, { getPrototypeOf: Zn } = Object, { iterator: er, toStringTag: tr } = Symbol, nr = (e => t => { const n = Jn.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), rr = e => (e = e.toLowerCase(), t => nr(t) === e), sr = e => t => typeof t === e, { isArray: ir } = Array, or = sr("undefined"); function ar(e) { return null !== e && !or(e) && null !== e.constructor && !or(e.constructor) && ur(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const lr = rr("ArrayBuffer"), cr = sr("string"), ur = sr("function"), hr = sr("number"), dr = e => null !== e && "object" == typeof e, pr = e => { if ("object" !== nr(e)) return !1; const t = Zn(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || tr in e || er in e) }, fr = rr("Date"), mr = rr("File"), gr = rr("Blob"), Er = rr("FileList"), Tr = rr("URLSearchParams"), [Ar, _r, yr, br] = ["ReadableStream", "Request", "Response", "Headers"].map(rr); function Sr(e, t, { allOwnKeys: n = !1 } = {}) { if (null == e) return; let r, s; if ("object" != typeof e && (e = [e]), ir(e)) for (r = 0, s = e.length; r < s; r++)t.call(null, e[r], r, e); else { if (ar(e)) return; const s = n ? Object.getOwnPropertyNames(e) : Object.keys(e), i = s.length; let o; for (r = 0; r < i; r++)o = s[r], t.call(null, e[o], o, e) } } function kr(e, t) { if (ar(e)) return null; t = t.toLowerCase(); const n = Object.keys(e); let r, s = n.length; for (; s-- > 0;)if (r = n[s], t === r.toLowerCase()) return r; return null } const Cr = "undefined" != typeof globalThis ? globalThis : "undefined" != typeof self ? self : "undefined" != typeof window ? window : global, Nr = e => !or(e) && e !== Cr, Ir = (e => t => e && t instanceof e)("undefined" != typeof Uint8Array && Zn(Uint8Array)), Or = rr("HTMLFormElement"), xr = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), vr = rr("RegExp"), Rr = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; Sr(n, (n, s) => { let i; !1 !== (i = t(n, s, e)) && (r[s] = i || n) }), Object.defineProperties(e, r) }, Dr = rr("AsyncFunction"), Lr = (Pr = "function" == typeof setImmediate, wr = ur(Cr.postMessage), Pr ? setImmediate : wr ? (Mr = `axios@${Math.random()}`, Fr = [], Cr.addEventListener("message", ({ source: e, data: t }) => { e === Cr && t === Mr && Fr.length && Fr.shift()() }, !1), e => { Fr.push(e), Cr.postMessage(Mr, "*") }) : e => setTimeout(e)); var Pr, wr, Mr, Fr; const Br = "undefined" != typeof queueMicrotask ? queueMicrotask.bind(Cr) : "undefined" != typeof process && process.nextTick || Lr, Ur = { isArray: ir, isArrayBuffer: lr, isBuffer: ar, isFormData: e => { let t; return e && ("function" == typeof FormData && e instanceof FormData || ur(e.append) && ("formdata" === (t = nr(e)) || "object" === t && ur(e.toString) && "[object FormData]" === e.toString())) }, isArrayBufferView: function (e) { let t; return t = "undefined" != typeof ArrayBuffer && ArrayBuffer.isView ? ArrayBuffer.isView(e) : e && e.buffer && lr(e.buffer), t }, isString: cr, isNumber: hr, isBoolean: e => !0 === e || !1 === e, isObject: dr, isPlainObject: pr, isEmptyObject: e => { if (!dr(e) || ar(e)) return !1; try { return 0 === Object.keys(e).length && Object.getPrototypeOf(e) === Object.prototype } catch (mg) { return !1 } }, isReadableStream: Ar, isRequest: _r, isResponse: yr, isHeaders: br, isUndefined: or, isDate: fr, isFile: mr, isBlob: gr, isRegExp: vr, isFunction: ur, isStream: e => dr(e) && ur(e.pipe), isURLSearchParams: Tr, isTypedArray: Ir, isFileList: Er, forEach: Sr, merge: function e() { const { caseless: t, skipUndefined: n } = Nr(this) && this || {}, r = {}, s = (s, i) => { const o = t && kr(r, i) || i; pr(r[o]) && pr(s) ? r[o] = e(r[o], s) : pr(s) ? r[o] = e({}, s) : ir(s) ? r[o] = s.slice() : n && or(s) || (r[o] = s) }; for (let i = 0, o = arguments.length; i < o; i++)arguments[i] && Sr(arguments[i], s); return r }, extend: (e, t, n, { allOwnKeys: r } = {}) => (Sr(t, (t, r) => { n && ur(t) ? e[r] = Xn(t, n) : e[r] = t }, { allOwnKeys: r }), e), trim: e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""), stripBOM: e => (65279 === e.charCodeAt(0) && (e = e.slice(1)), e), inherits: (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, toFlatObject: (e, t, n, r) => { let s, i, o; const a = {}; if (t = t || {}, null == e) return t; do { for (s = Object.getOwnPropertyNames(e), i = s.length; i-- > 0;)o = s[i], r && !r(o, e, t) || a[o] || (t[o] = e[o], a[o] = !0); e = !1 !== n && Zn(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, kindOf: nr, kindOfTest: rr, endsWith: (e, t, n) => { e = String(e), (void 0 === n || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return -1 !== r && r === n }, toArray: e => { if (!e) return null; if (ir(e)) return e; let t = e.length; if (!hr(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, forEachEntry: (e, t) => { const n = (e && e[er]).call(e); let r; for (; (r = n.next()) && !r.done;) { const n = r.value; t.call(e, n[0], n[1]) } }, matchAll: (e, t) => { let n; const r = []; for (; null !== (n = e.exec(t));)r.push(n); return r }, isHTMLForm: Or, hasOwnProperty: xr, hasOwnProp: xr, reduceDescriptors: Rr, freezeMethods: e => { Rr(e, (t, n) => { if (ur(e) && -1 !== ["arguments", "caller", "callee"].indexOf(n)) return !1; const r = e[n]; ur(r) && (t.enumerable = !1, "writable" in t ? t.writable = !1 : t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") })) }) }, toObjectSet: (e, t) => { const n = {}, r = e => { e.forEach(e => { n[e] = !0 }) }; return ir(e) ? r(e) : r(String(e).split(t)), n }, toCamelCase: e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (e, t, n) { return t.toUpperCase() + n }), noop: () => { }, toFiniteNumber: (e, t) => null != e && Number.isFinite(e = +e) ? e : t, findKey: kr, global: Cr, isContextDefined: Nr, isSpecCompliantForm: function (e) { return !!(e && ur(e.append) && "FormData" === e[tr] && e[er]) }, toJSONObject: e => { const t = new Array(10), n = (e, r) => { if (dr(e)) { if (t.indexOf(e) >= 0) return; if (ar(e)) return e; if (!("toJSON" in e)) { t[r] = e; const s = ir(e) ? [] : {}; return Sr(e, (e, t) => { const i = n(e, r + 1); !or(i) && (s[t] = i) }), t[r] = void 0, s } } return e }; return n(e, 0) }, isAsyncFn: Dr, isThenable: e => e && (dr(e) || ur(e)) && ur(e.then) && ur(e.catch), setImmediate: Lr, asap: Br, isIterable: e => null != e && ur(e[er]) }; function Hr(e, t, n, r, s) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = (new Error).stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), s && (this.response = s, this.status = s.status ? s.status : null) } Ur.inherits(Hr, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: Ur.toJSONObject(this.config), code: this.code, status: this.status } } }); const jr = Hr.prototype, Gr = {}; function zr(e) { return Ur.isPlainObject(e) || Ur.isArray(e) } function Yr(e) { return Ur.endsWith(e, "[]") ? e.slice(0, -2) : e } function qr(e, t, n) { return e ? e.concat(t).map(function (e, t) { return e = Yr(e), !n && t ? "[" + e + "]" : e }).join(n ? "." : "") : t } ["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { Gr[e] = { value: e } }), Object.defineProperties(Hr, Gr), Object.defineProperty(jr, "isAxiosError", { value: !0 }), Hr.from = (e, t, n, r, s, i) => { const o = Object.create(jr); Ur.toFlatObject(e, o, function (e) { return e !== Error.prototype }, e => "isAxiosError" !== e); const a = e && e.message ? e.message : "Error", l = null == t && e ? e.code : t; return Hr.call(o, a, l, n, r, s), e && null == o.cause && Object.defineProperty(o, "cause", { value: e, configurable: !0 }), o.name = e && e.name || "Error", i && Object.assign(o, i), o }; const Vr = Ur.toFlatObject(Ur, {}, null, function (e) { return /^is[A-Z]/.test(e) }); function $r(e, t, n) { if (!Ur.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData; const r = (n = Ur.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (e, t) { return !Ur.isUndefined(t[e]) })).metaTokens, s = n.visitor || c, i = n.dots, o = n.indexes, a = (n.Blob || "undefined" != typeof Blob && Blob) && Ur.isSpecCompliantForm(t); if (!Ur.isFunction(s)) throw new TypeError("visitor must be a function"); function l(e) { if (null === e) return ""; if (Ur.isDate(e)) return e.toISOString(); if (Ur.isBoolean(e)) return e.toString(); if (!a && Ur.isBlob(e)) throw new Hr("Blob is not supported. Use a Buffer instead."); return Ur.isArrayBuffer(e) || Ur.isTypedArray(e) ? a && "function" == typeof Blob ? new Blob([e]) : Buffer.from(e) : e } function c(e, n, s) { let a = e; if (e && !s && "object" == typeof e) if (Ur.endsWith(n, "{}")) n = r ? n : n.slice(0, -2), e = JSON.stringify(e); else if (Ur.isArray(e) && function (e) { return Ur.isArray(e) && !e.some(zr) }(e) || (Ur.isFileList(e) || Ur.endsWith(n, "[]")) && (a = Ur.toArray(e))) return n = Yr(n), a.forEach(function (e, r) { !Ur.isUndefined(e) && null !== e && t.append(!0 === o ? qr([n], r, i) : null === o ? n : n + "[]", l(e)) }), !1; return !!zr(e) || (t.append(qr(s, n, i), l(e)), !1) } const u = [], h = Object.assign(Vr, { defaultVisitor: c, convertValue: l, isVisitable: zr }); if (!Ur.isObject(e)) throw new TypeError("data must be an object"); return function e(n, r) { if (!Ur.isUndefined(n)) { if (-1 !== u.indexOf(n)) throw Error("Circular reference detected in " + r.join(".")); u.push(n), Ur.forEach(n, function (n, i) { !0 === (!(Ur.isUndefined(n) || null === n) && s.call(t, n, Ur.isString(i) ? i.trim() : i, r, h)) && e(n, r ? r.concat(i) : [i]) }), u.pop() } }(e), t } function Wr(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (e) { return t[e] }) } function Kr(e, t) { this._pairs = [], e && $r(e, this, t) } const Qr = Kr.prototype; function Xr(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function Jr(e, t, n) { if (!t) return e; const r = n && n.encode || Xr; Ur.isFunction(n) && (n = { serialize: n }); const s = n && n.serialize; let i; if (i = s ? s(t, n) : Ur.isURLSearchParams(t) ? t.toString() : new Kr(t, n).toString(r), i) { const t = e.indexOf("#"); -1 !== t && (e = e.slice(0, t)), e += (-1 === e.indexOf("?") ? "?" : "&") + i } return e } Qr.append = function (e, t) { this._pairs.push([e, t]) }, Qr.toString = function (e) { const t = e ? function (t) { return e.call(this, t, Wr) } : Wr; return this._pairs.map(function (e) { return t(e[0]) + "=" + t(e[1]) }, "").join("&") }; class Zr { constructor() { this.handlers = [] } use(e, t, n) { return this.handlers.push({ fulfilled: e, rejected: t, synchronous: !!n && n.synchronous, runWhen: n ? n.runWhen : null }), this.handlers.length - 1 } eject(e) { this.handlers[e] && (this.handlers[e] = null) } clear() { this.handlers && (this.handlers = []) } forEach(e) { Ur.forEach(this.handlers, function (t) { null !== t && e(t) }) } } const es = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, ts = { isBrowser: !0, classes: { URLSearchParams: "undefined" != typeof URLSearchParams ? URLSearchParams : Kr, FormData: "undefined" != typeof FormData ? FormData : null, Blob: "undefined" != typeof Blob ? Blob : null }, protocols: ["http", "https", "file", "blob", "url", "data"] }, ns = "undefined" != typeof window && "undefined" != typeof document, rs = "object" == typeof navigator && navigator || void 0, ss = ns && (!rs || ["ReactNative", "NativeScript", "NS"].indexOf(rs.product) < 0), is = "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && "function" == typeof self.importScripts, os = ns && window.location.href || "http://localhost", as = { ...Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: ns, hasStandardBrowserEnv: ss, hasStandardBrowserWebWorkerEnv: is, navigator: rs, origin: os }, Symbol.toStringTag, { value: "Module" })), ...ts }; function ls(e) { function t(e, n, r, s) { let i = e[s++]; if ("__proto__" === i) return !0; const o = Number.isFinite(+i), a = s >= e.length; return i = !i && Ur.isArray(r) ? r.length : i, a ? (Ur.hasOwnProp(r, i) ? r[i] = [r[i], n] : r[i] = n, !o) : (r[i] && Ur.isObject(r[i]) || (r[i] = []), t(e, n, r[i], s) && Ur.isArray(r[i]) && (r[i] = function (e) { const t = {}, n = Object.keys(e); let r; const s = n.length; let i; for (r = 0; r < s; r++)i = n[r], t[i] = e[i]; return t }(r[i])), !o) } if (Ur.isFormData(e) && Ur.isFunction(e.entries)) { const n = {}; return Ur.forEachEntry(e, (e, r) => { t(function (e) { return Ur.matchAll(/\w+|\[(\w*)]/g, e).map(e => "[]" === e[0] ? "" : e[1] || e[0]) }(e), r, n, 0) }), n } return null } const cs = { transitional: es, adapter: ["xhr", "http", "fetch"], transformRequest: [function (e, t) { const n = t.getContentType() || "", r = n.indexOf("application/json") > -1, s = Ur.isObject(e); if (s && Ur.isHTMLForm(e) && (e = new FormData(e)), Ur.isFormData(e)) return r ? JSON.stringify(ls(e)) : e; if (Ur.isArrayBuffer(e) || Ur.isBuffer(e) || Ur.isStream(e) || Ur.isFile(e) || Ur.isBlob(e) || Ur.isReadableStream(e)) return e; if (Ur.isArrayBufferView(e)) return e.buffer; if (Ur.isURLSearchParams(e)) return t.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), e.toString(); let i; if (s) { if (n.indexOf("application/x-www-form-urlencoded") > -1) return function (e, t) { return $r(e, new as.classes.URLSearchParams, { visitor: function (e, t, n, r) { return as.isNode && Ur.isBuffer(e) ? (this.append(t, e.toString("base64")), !1) : r.defaultVisitor.apply(this, arguments) }, ...t }) }(e, this.formSerializer).toString(); if ((i = Ur.isFileList(e)) || n.indexOf("multipart/form-data") > -1) { const t = this.env && this.env.FormData; return $r(i ? { "files[]": e } : e, t && new t, this.formSerializer) } } return s || r ? (t.setContentType("application/json", !1), function (e) { if (Ur.isString(e)) try { return (0, JSON.parse)(e), Ur.trim(e) } catch (mg) { if ("SyntaxError" !== mg.name) throw mg } return (0, JSON.stringify)(e) }(e)) : e }], transformResponse: [function (e) { const t = this.transitional || cs.transitional, n = t && t.forcedJSONParsing, r = "json" === this.responseType; if (Ur.isResponse(e) || Ur.isReadableStream(e)) return e; if (e && Ur.isString(e) && (n && !this.responseType || r)) { const n = !(t && t.silentJSONParsing) && r; try { return JSON.parse(e, this.parseReviver) } catch (mg) { if (n) { if ("SyntaxError" === mg.name) throw Hr.from(mg, Hr.ERR_BAD_RESPONSE, this, null, this.response); throw mg } } } return e }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: as.classes.FormData, Blob: as.classes.Blob }, validateStatus: function (e) { return e >= 200 && e < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; Ur.forEach(["delete", "get", "head", "post", "put", "patch"], e => { cs.headers[e] = {} }); const us = Ur.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), hs = Symbol("internals"); function ds(e) { return e && String(e).trim().toLowerCase() } function ps(e) { return !1 === e || null == e ? e : Ur.isArray(e) ? e.map(ps) : String(e) } function fs(e, t, n, r, s) { return Ur.isFunction(r) ? r.call(this, t, n) : (s && (t = n), Ur.isString(t) ? Ur.isString(r) ? -1 !== t.indexOf(r) : Ur.isRegExp(r) ? r.test(t) : void 0 : void 0) } let ms = class { constructor(e) { e && this.set(e) } set(e, t, n) { const r = this; function s(e, t, n) { const s = ds(t); if (!s) throw new Error("header name must be a non-empty string"); const i = Ur.findKey(r, s); (!i || void 0 === r[i] || !0 === n || void 0 === n && !1 !== r[i]) && (r[i || t] = ps(e)) } const i = (e, t) => Ur.forEach(e, (e, n) => s(e, n, t)); if (Ur.isPlainObject(e) || e instanceof this.constructor) i(e, t); else if (Ur.isString(e) && (e = e.trim()) && !/^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim())) i((e => { const t = {}; let n, r, s; return e && e.split("\n").forEach(function (e) { s = e.indexOf(":"), n = e.substring(0, s).trim().toLowerCase(), r = e.substring(s + 1).trim(), !n || t[n] && us[n] || ("set-cookie" === n ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) }), t })(e), t); else if (Ur.isObject(e) && Ur.isIterable(e)) { let n, r, s = {}; for (const t of e) { if (!Ur.isArray(t)) throw TypeError("Object iterator must return a key-value pair"); s[r = t[0]] = (n = s[r]) ? Ur.isArray(n) ? [...n, t[1]] : [n, t[1]] : t[1] } i(s, t) } else null != e && s(t, e, n); return this } get(e, t) { if (e = ds(e)) { const n = Ur.findKey(this, e); if (n) { const e = this[n]; if (!t) return e; if (!0 === t) return function (e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t }(e); if (Ur.isFunction(t)) return t.call(this, e, n); if (Ur.isRegExp(t)) return t.exec(e); throw new TypeError("parser must be boolean|regexp|function") } } } has(e, t) { if (e = ds(e)) { const n = Ur.findKey(this, e); return !(!n || void 0 === this[n] || t && !fs(0, this[n], n, t)) } return !1 } delete(e, t) { const n = this; let r = !1; function s(e) { if (e = ds(e)) { const s = Ur.findKey(n, e); !s || t && !fs(0, n[s], s, t) || (delete n[s], r = !0) } } return Ur.isArray(e) ? e.forEach(s) : s(e), r } clear(e) { const t = Object.keys(this); let n = t.length, r = !1; for (; n--;) { const s = t[n]; e && !fs(0, this[s], s, e, !0) || (delete this[s], r = !0) } return r } normalize(e) { const t = this, n = {}; return Ur.forEach(this, (r, s) => { const i = Ur.findKey(n, s); if (i) return t[i] = ps(r), void delete t[s]; const o = e ? function (e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (e, t, n) => t.toUpperCase() + n) }(s) : String(s).trim(); o !== s && delete t[s], t[o] = ps(r), n[o] = !0 }), this } concat(...e) { return this.constructor.concat(this, ...e) } toJSON(e) { const t = Object.create(null); return Ur.forEach(this, (n, r) => { null != n && !1 !== n && (t[r] = e && Ur.isArray(n) ? n.join(", ") : n) }), t } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() { return Object.entries(this.toJSON()).map(([e, t]) => e + ": " + t).join("\n") } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(e) { return e instanceof this ? e : new this(e) } static concat(e, ...t) { const n = new this(e); return t.forEach(e => n.set(e)), n } static accessor(e) { const t = (this[hs] = this[hs] = { accessors: {} }).accessors, n = this.prototype; function r(e) { const r = ds(e); t[r] || (function (e, t) { const n = Ur.toCamelCase(" " + t);["get", "set", "has"].forEach(r => { Object.defineProperty(e, r + n, { value: function (e, n, s) { return this[r].call(this, t, e, n, s) }, configurable: !0 }) }) }(n, e), t[r] = !0) } return Ur.isArray(e) ? e.forEach(r) : r(e), this } }; function gs(e, t) { const n = this || cs, r = t || n, s = ms.from(r.headers); let i = r.data; return Ur.forEach(e, function (e) { i = e.call(n, i, s.normalize(), t ? t.status : void 0) }), s.normalize(), i } function Es(e) { return !(!e || !e.__CANCEL__) } function Ts(e, t, n) { Hr.call(this, null == e ? "canceled" : e, Hr.ERR_CANCELED, t, n), this.name = "CanceledError" } function As(e, t, n) { const r = n.config.validateStatus; n.status && r && !r(n.status) ? t(new Hr("Request failed with status code " + n.status, [Hr.ERR_BAD_REQUEST, Hr.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) : e(n) } ms.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]), Ur.reduceDescriptors(ms.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(e) { this[n] = e } } }), Ur.freezeMethods(ms), Ur.inherits(Ts, Hr, { __CANCEL__: !0 }); const _s = (e, t, n = 3) => { let r = 0; const s = function (e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let s, i = 0, o = 0; return t = void 0 !== t ? t : 1e3, function (a) { const l = Date.now(), c = r[o]; s || (s = l), n[i] = a, r[i] = l; let u = o, h = 0; for (; u !== i;)h += n[u++], u %= e; if (i = (i + 1) % e, i === o && (o = (o + 1) % e), l - s < t) return; const d = c && l - c; return d ? Math.round(1e3 * h / d) : void 0 } }(50, 250); return function (n, i) { let o, a, l = 0, c = 1e3 / i; const u = (n, i = Date.now()) => { l = i, o = null, a && (clearTimeout(a), a = null), (n => { const i = n.loaded, o = n.lengthComputable ? n.total : void 0, a = i - r, l = s(a); r = i, e({ loaded: i, total: o, progress: o ? i / o : void 0, bytes: a, rate: l || void 0, estimated: l && o && i <= o ? (o - i) / l : void 0, event: n, lengthComputable: null != o, [t ? "download" : "upload"]: !0 }) })(...n) }; return [(...e) => { const t = Date.now(), n = t - l; n >= c ? u(e, t) : (o = e, a || (a = setTimeout(() => { a = null, u(o) }, c - n))) }, () => o && u(o)] }(0, n) }, ys = (e, t) => { const n = null != e; return [r => t[0]({ lengthComputable: n, total: e, loaded: r }), t[1]] }, bs = e => (...t) => Ur.asap(() => e(...t)), Ss = as.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, as.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(as.origin), as.navigator && /(msie|trident)/i.test(as.navigator.userAgent)) : () => !0, ks = as.hasStandardBrowserEnv ? { write(e, t, n, r, s, i, o) { if ("undefined" == typeof document) return; const a = [`${e}=${encodeURIComponent(t)}`]; Ur.isNumber(n) && a.push(`expires=${new Date(n).toUTCString()}`), Ur.isString(r) && a.push(`path=${r}`), Ur.isString(s) && a.push(`domain=${s}`), !0 === i && a.push("secure"), Ur.isString(o) && a.push(`SameSite=${o}`), document.cookie = a.join("; ") }, read(e) { if ("undefined" == typeof document) return null; const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5, "/") } } : { write() { }, read: () => null, remove() { } }; function Cs(e, t, n) { let r = !/^([a-z][a-z\d+\-.]*:)?\/\//i.test(t); return e && (r || 0 == n) ? function (e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e }(e, t) : t } const Ns = e => e instanceof ms ? { ...e } : e; function Is(e, t) { t = t || {}; const n = {}; function r(e, t, n, r) { return Ur.isPlainObject(e) && Ur.isPlainObject(t) ? Ur.merge.call({ caseless: r }, e, t) : Ur.isPlainObject(t) ? Ur.merge({}, t) : Ur.isArray(t) ? t.slice() : t } function s(e, t, n, s) { return Ur.isUndefined(t) ? Ur.isUndefined(e) ? void 0 : r(void 0, e, 0, s) : r(e, t, 0, s) } function i(e, t) { if (!Ur.isUndefined(t)) return r(void 0, t) } function o(e, t) { return Ur.isUndefined(t) ? Ur.isUndefined(e) ? void 0 : r(void 0, e) : r(void 0, t) } function a(n, s, i) { return i in t ? r(n, s) : i in e ? r(void 0, n) : void 0 } const l = { url: i, method: i, data: i, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: a, headers: (e, t, n) => s(Ns(e), Ns(t), 0, !0) }; return Ur.forEach(Object.keys({ ...e, ...t }), function (r) { const i = l[r] || s, o = i(e[r], t[r], r); Ur.isUndefined(o) && i !== a || (n[r] = o) }), n } const Os = e => { const t = Is({}, e); let { data: n, withXSRFToken: r, xsrfHeaderName: s, xsrfCookieName: i, headers: o, auth: a } = t; if (t.headers = o = ms.from(o), t.url = Jr(Cs(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && o.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))), Ur.isFormData(n)) if (as.hasStandardBrowserEnv || as.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0); else if (Ur.isFunction(n.getHeaders)) { const e = n.getHeaders(), t = ["content-type", "content-length"]; Object.entries(e).forEach(([e, n]) => { t.includes(e.toLowerCase()) && o.set(e, n) }) } if (as.hasStandardBrowserEnv && (r && Ur.isFunction(r) && (r = r(t)), r || !1 !== r && Ss(t.url))) { const e = s && i && ks.read(i); e && o.set(s, e) } return t }, xs = "undefined" != typeof XMLHttpRequest && function (e) { return new Promise(function (t, n) { const r = Os(e); let s = r.data; const i = ms.from(r.headers).normalize(); let o, a, l, c, u, { responseType: h, onUploadProgress: d, onDownloadProgress: p } = r; function f() { c && c(), u && u(), r.cancelToken && r.cancelToken.unsubscribe(o), r.signal && r.signal.removeEventListener("abort", o) } let m = new XMLHttpRequest; function g() { if (!m) return; const r = ms.from("getAllResponseHeaders" in m && m.getAllResponseHeaders()); As(function (e) { t(e), f() }, function (e) { n(e), f() }, { data: h && "text" !== h && "json" !== h ? m.response : m.responseText, status: m.status, statusText: m.statusText, headers: r, config: e, request: m }), m = null } m.open(r.method.toUpperCase(), r.url, !0), m.timeout = r.timeout, "onloadend" in m ? m.onloadend = g : m.onreadystatechange = function () { m && 4 === m.readyState && (0 !== m.status || m.responseURL && 0 === m.responseURL.indexOf("file:")) && setTimeout(g) }, m.onabort = function () { m && (n(new Hr("Request aborted", Hr.ECONNABORTED, e, m)), m = null) }, m.onerror = function (t) { const r = new Hr(t && t.message ? t.message : "Network Error", Hr.ERR_NETWORK, e, m); r.event = t || null, n(r), m = null }, m.ontimeout = function () { let t = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"; const s = r.transitional || es; r.timeoutErrorMessage && (t = r.timeoutErrorMessage), n(new Hr(t, s.clarifyTimeoutError ? Hr.ETIMEDOUT : Hr.ECONNABORTED, e, m)), m = null }, void 0 === s && i.setContentType(null), "setRequestHeader" in m && Ur.forEach(i.toJSON(), function (e, t) { m.setRequestHeader(t, e) }), Ur.isUndefined(r.withCredentials) || (m.withCredentials = !!r.withCredentials), h && "json" !== h && (m.responseType = r.responseType), p && ([l, u] = _s(p, !0), m.addEventListener("progress", l)), d && m.upload && ([a, c] = _s(d), m.upload.addEventListener("progress", a), m.upload.addEventListener("loadend", c)), (r.cancelToken || r.signal) && (o = t => { m && (n(!t || t.type ? new Ts(null, e, m) : t), m.abort(), m = null) }, r.cancelToken && r.cancelToken.subscribe(o), r.signal && (r.signal.aborted ? o() : r.signal.addEventListener("abort", o))); const E = function (e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" }(r.url); E && -1 === as.protocols.indexOf(E) ? n(new Hr("Unsupported protocol " + E + ":", Hr.ERR_BAD_REQUEST, e)) : m.send(s || null) }) }, vs = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let n, r = new AbortController; const s = function (e) { if (!n) { n = !0, o(); const t = e instanceof Error ? e : this.reason; r.abort(t instanceof Hr ? t : new Ts(t instanceof Error ? t.message : t)) } }; let i = t && setTimeout(() => { i = null, s(new Hr(`timeout ${t} of ms exceeded`, Hr.ETIMEDOUT)) }, t); const o = () => { e && (i && clearTimeout(i), i = null, e.forEach(e => { e.unsubscribe ? e.unsubscribe(s) : e.removeEventListener("abort", s) }), e = null) }; e.forEach(e => e.addEventListener("abort", s)); const { signal: a } = r; return a.unsubscribe = () => Ur.asap(o), a } }, Rs = function* (e, t) { let n = e.byteLength; if (n < t) return void (yield e); let r, s = 0; for (; s < n;)r = s + t, yield e.slice(s, r), s = r }, Ds = (e, t, n, r) => { const s = async function* (e, t) { for await (const n of async function* (e) { if (e[Symbol.asyncIterator]) return void (yield* e); const t = e.getReader(); try { for (; ;) { const { done: e, value: n } = await t.read(); if (e) break; yield n } } finally { await t.cancel() } }(e)) yield* Rs(n, t) }(e, t); let i, o = 0, a = e => { i || (i = !0, r && r(e)) }; return new ReadableStream({ async pull(e) { try { const { done: t, value: r } = await s.next(); if (t) return a(), void e.close(); let i = r.byteLength; if (n) { let e = o += i; n(e) } e.enqueue(new Uint8Array(r)) } catch (t) { throw a(t), t } }, cancel: e => (a(e), s.return()) }, { highWaterMark: 2 }) }, { isFunction: Ls } = Ur, Ps = (({ Request: e, Response: t }) => ({ Request: e, Response: t }))(Ur.global), { ReadableStream: ws, TextEncoder: Ms } = Ur.global, Fs = (e, ...t) => { try { return !!e(...t) } catch (mg) { return !1 } }, Bs = e => { e = Ur.merge.call({ skipUndefined: !0 }, Ps, e); const { fetch: t, Request: n, Response: r } = e, s = t ? Ls(t) : "function" == typeof fetch, i = Ls(n), o = Ls(r); if (!s) return !1; const a = s && Ls(ws), l = s && ("function" == typeof Ms ? (e => t => e.encode(t))(new Ms) : async e => new Uint8Array(await new n(e).arrayBuffer())), c = i && a && Fs(() => { let e = !1; const t = new n(as.origin, { body: new ws, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t }), u = o && a && Fs(() => Ur.isReadableStream(new r("").body)), h = { stream: u && (e => e.body) }; s && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(e => { !h[e] && (h[e] = (t, n) => { let r = t && t[e]; if (r) return r.call(t); throw new Hr(`Response type '${e}' is not supported`, Hr.ERR_NOT_SUPPORT, n) }) }); return async e => { let { url: s, method: o, data: a, signal: d, cancelToken: p, timeout: f, onDownloadProgress: m, onUploadProgress: g, responseType: E, headers: T, withCredentials: A = "same-origin", fetchOptions: _ } = Os(e), y = t || fetch; E = E ? (E + "").toLowerCase() : "text"; let b = vs([d, p && p.toAbortSignal()], f), S = null; const k = b && b.unsubscribe && (() => { b.unsubscribe() }); let C; try { if (g && c && "get" !== o && "head" !== o && 0 !== (C = await (async (e, t) => { const r = Ur.toFiniteNumber(e.getContentLength()); return null == r ? (async e => { if (null == e) return 0; if (Ur.isBlob(e)) return e.size; if (Ur.isSpecCompliantForm(e)) { const t = new n(as.origin, { method: "POST", body: e }); return (await t.arrayBuffer()).byteLength } return Ur.isArrayBufferView(e) || Ur.isArrayBuffer(e) ? e.byteLength : (Ur.isURLSearchParams(e) && (e += ""), Ur.isString(e) ? (await l(e)).byteLength : void 0) })(t) : r })(T, a))) { let e, t = new n(s, { method: "POST", body: a, duplex: "half" }); if (Ur.isFormData(a) && (e = t.headers.get("content-type")) && T.setContentType(e), t.body) { const [e, n] = ys(C, _s(bs(g))); a = Ds(t.body, 65536, e, n) } } Ur.isString(A) || (A = A ? "include" : "omit"); const t = i && "credentials" in n.prototype, d = { ..._, signal: b, method: o.toUpperCase(), headers: T.normalize().toJSON(), body: a, duplex: "half", credentials: t ? A : void 0 }; S = i && new n(s, d); let p = await (i ? y(S, _) : y(s, d)); const f = u && ("stream" === E || "response" === E); if (u && (m || f && k)) { const e = {};["status", "statusText", "headers"].forEach(t => { e[t] = p[t] }); const t = Ur.toFiniteNumber(p.headers.get("content-length")), [n, s] = m && ys(t, _s(bs(m), !0)) || []; p = new r(Ds(p.body, 65536, n, () => { s && s(), k && k() }), e) } E = E || "text"; let N = await h[Ur.findKey(h, E) || "text"](p, e); return !f && k && k(), await new Promise((t, n) => { As(t, n, { data: N, headers: ms.from(p.headers), status: p.status, statusText: p.statusText, config: e, request: S }) }) } catch (N) { if (k && k(), N && "TypeError" === N.name && /Load failed|fetch/i.test(N.message)) throw Object.assign(new Hr("Network Error", Hr.ERR_NETWORK, e, S), { cause: N.cause || N }); throw Hr.from(N, N && N.code, e, S) } } }, Us = new Map, Hs = e => { let t = e && e.env || {}; const { fetch: n, Request: r, Response: s } = t, i = [r, s, n]; let o, a, l = i.length, c = Us; for (; l--;)o = i[l], a = c.get(o), void 0 === a && c.set(o, a = l ? new Map : Bs(t)), c = a; return a }; Hs(); const js = { http: null, xhr: xs, fetch: { get: Hs } }; Ur.forEach(js, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch (mg) { } Object.defineProperty(e, "adapterName", { value: t }) } }); const Gs = e => `- ${e}`, zs = e => Ur.isFunction(e) || null === e || !1 === e, Ys = function (e, t) { e = Ur.isArray(e) ? e : [e]; const { length: n } = e; let r, s; const i = {}; for (let o = 0; o < n; o++) { let n; if (r = e[o], s = r, !zs(r) && (s = js[(n = String(r)).toLowerCase()], void 0 === s)) throw new Hr(`Unknown adapter '${n}'`); if (s && (Ur.isFunction(s) || (s = s.get(t)))) break; i[n || "#" + o] = s } if (!s) { const e = Object.entries(i).map(([e, t]) => `adapter ${e} ` + (!1 === t ? "is not supported by the environment" : "is not available in the build")); throw new Hr("There is no suitable adapter to dispatch the request " + (n ? e.length > 1 ? "since :\n" + e.map(Gs).join("\n") : " " + Gs(e[0]) : "as no adapter specified"), "ERR_NOT_SUPPORT") } return s }; function qs(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Ts(null, e) } function Vs(e) { return qs(e), e.headers = ms.from(e.headers), e.data = gs.call(e, e.transformRequest), -1 !== ["post", "put", "patch"].indexOf(e.method) && e.headers.setContentType("application/x-www-form-urlencoded", !1), Ys(e.adapter || cs.adapter, e)(e).then(function (t) { return qs(e), t.data = gs.call(e, e.transformResponse, t), t.headers = ms.from(t.headers), t }, function (t) { return Es(t) || (qs(e), t && t.response && (t.response.data = gs.call(e, e.transformResponse, t.response), t.response.headers = ms.from(t.response.headers))), Promise.reject(t) }) } const $s = "1.13.2", Ws = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { Ws[e] = function (n) { return typeof n === e || "a" + (t < 1 ? "n " : " ") + e } }); const Ks = {}; Ws.transitional = function (e, t, n) { function r(e, t) { return "[Axios v" + $s + "] Transitional option '" + e + "'" + t + (n ? ". " + n : "") } return (n, s, i) => { if (!1 === e) throw new Hr(r(s, " has been removed" + (t ? " in " + t : "")), Hr.ERR_DEPRECATED); return t && !Ks[s] && (Ks[s] = !0, console.warn(r(s, " has been deprecated since v" + t + " and will be removed in the near future"))), !e || e(n, s, i) } }, Ws.spelling = function (e) { return (t, n) => (console.warn(`${n} is likely a misspelling of ${e}`), !0) }; const Qs = { assertOptions: function (e, t, n) { if ("object" != typeof e) throw new Hr("options must be an object", Hr.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let s = r.length; for (; s-- > 0;) { const i = r[s], o = t[i]; if (o) { const t = e[i], n = void 0 === t || o(t, i, e); if (!0 !== n) throw new Hr("option " + i + " must be " + n, Hr.ERR_BAD_OPTION_VALUE); continue } if (!0 !== n) throw new Hr("Unknown option " + i, Hr.ERR_BAD_OPTION) } }, validators: Ws }, Xs = Qs.validators; let Js = class { constructor(e) { this.defaults = e || {}, this.interceptors = { request: new Zr, response: new Zr } } async request(e, t) { try { return await this._request(e, t) } catch (n) { if (n instanceof Error) { let e = {}; Error.captureStackTrace ? Error.captureStackTrace(e) : e = new Error; const t = e.stack ? e.stack.replace(/^.+\n/, "") : ""; try { n.stack ? t && !String(n.stack).endsWith(t.replace(/^.+\n.+\n/, "")) && (n.stack += "\n" + t) : n.stack = t } catch (mg) { } } throw n } } _request(e, t) { "string" == typeof e ? (t = t || {}).url = e : t = e || {}, t = Is(this.defaults, t); const { transitional: n, paramsSerializer: r, headers: s } = t; void 0 !== n && Qs.assertOptions(n, { silentJSONParsing: Xs.transitional(Xs.boolean), forcedJSONParsing: Xs.transitional(Xs.boolean), clarifyTimeoutError: Xs.transitional(Xs.boolean) }, !1), null != r && (Ur.isFunction(r) ? t.paramsSerializer = { serialize: r } : Qs.assertOptions(r, { encode: Xs.function, serialize: Xs.function }, !0)), void 0 !== t.allowAbsoluteUrls || (void 0 !== this.defaults.allowAbsoluteUrls ? t.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : t.allowAbsoluteUrls = !0), Qs.assertOptions(t, { baseUrl: Xs.spelling("baseURL"), withXsrfToken: Xs.spelling("withXSRFToken") }, !0), t.method = (t.method || this.defaults.method || "get").toLowerCase(); let i = s && Ur.merge(s.common, s[t.method]); s && Ur.forEach(["delete", "get", "head", "post", "put", "patch", "common"], e => { delete s[e] }), t.headers = ms.concat(i, s); const o = []; let a = !0; this.interceptors.request.forEach(function (e) { "function" == typeof e.runWhen && !1 === e.runWhen(t) || (a = a && e.synchronous, o.unshift(e.fulfilled, e.rejected)) }); const l = []; let c; this.interceptors.response.forEach(function (e) { l.push(e.fulfilled, e.rejected) }); let u, h = 0; if (!a) { const e = [Vs.bind(this), void 0]; for (e.unshift(...o), e.push(...l), u = e.length, c = Promise.resolve(t); h < u;)c = c.then(e[h++], e[h++]); return c } u = o.length; let d = t; for (; h < u;) { const e = o[h++], t = o[h++]; try { d = e(d) } catch (p) { t.call(this, p); break } } try { c = Vs.call(this, d) } catch (p) { return Promise.reject(p) } for (h = 0, u = l.length; h < u;)c = c.then(l[h++], l[h++]); return c } getUri(e) { return Jr(Cs((e = Is(this.defaults, e)).baseURL, e.url, e.allowAbsoluteUrls), e.params, e.paramsSerializer) } }; Ur.forEach(["delete", "get", "head", "options"], function (e) { Js.prototype[e] = function (t, n) { return this.request(Is(n || {}, { method: e, url: t, data: (n || {}).data })) } }), Ur.forEach(["post", "put", "patch"], function (e) { function t(t) { return function (n, r, s) { return this.request(Is(s || {}, { method: e, headers: t ? { "Content-Type": "multipart/form-data" } : {}, url: n, data: r })) } } Js.prototype[e] = t(), Js.prototype[e + "Form"] = t(!0) }); const Zs = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(Zs).forEach(([e, t]) => { Zs[t] = e }); const ei = function e(t) { const n = new Js(t), r = Xn(Js.prototype.request, n); return Ur.extend(r, Js.prototype, n, { allOwnKeys: !0 }), Ur.extend(r, n, null, { allOwnKeys: !0 }), r.create = function (n) { return e(Is(t, n)) }, r }(cs); ei.Axios = Js, ei.CanceledError = Ts, ei.CancelToken = class e { constructor(e) { if ("function" != typeof e) throw new TypeError("executor must be a function."); let t; this.promise = new Promise(function (e) { t = e }); const n = this; this.promise.then(e => { if (!n._listeners) return; let t = n._listeners.length; for (; t-- > 0;)n._listeners[t](e); n._listeners = null }), this.promise.then = e => { let t; const r = new Promise(e => { n.subscribe(e), t = e }).then(e); return r.cancel = function () { n.unsubscribe(t) }, r }, e(function (e, r, s) { n.reason || (n.reason = new Ts(e, r, s), t(n.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(e) { this.reason ? e(this.reason) : this._listeners ? this._listeners.push(e) : this._listeners = [e] } unsubscribe(e) { if (!this._listeners) return; const t = this._listeners.indexOf(e); -1 !== t && this._listeners.splice(t, 1) } toAbortSignal() { const e = new AbortController, t = t => { e.abort(t) }; return this.subscribe(t), e.signal.unsubscribe = () => this.unsubscribe(t), e.signal } static source() { let t; return { token: new e(function (e) { t = e }), cancel: t } } }, ei.isCancel = Es, ei.VERSION = $s, ei.toFormData = $r, ei.AxiosError = Hr, ei.Cancel = ei.CanceledError, ei.all = function (e) { return Promise.all(e) }, ei.spread = function (e) { return function (t) { return e.apply(null, t) } }, ei.isAxiosError = function (e) { return Ur.isObject(e) && !0 === e.isAxiosError }, ei.mergeConfig = Is, ei.AxiosHeaders = ms, ei.formToJSON = e => ls(Ur.isHTMLForm(e) ? new FormData(e) : e), ei.getAdapter = Ys, ei.HttpStatusCode = Zs, ei.default = ei; const { Axios: ti, AxiosError: ni, CanceledError: ri, isCancel: si, CancelToken: ii, VERSION: oi, all: ai, Cancel: li, isAxiosError: ci, spread: ui, toFormData: hi, AxiosHeaders: di, HttpStatusCode: pi, formToJSON: fi, getAdapter: mi, mergeConfig: gi } = ei, Ei = ei.create({ baseURL: (() => { const e = "https://next-blog-server-nmnw6qmabq-de.a.run.app/api", t = e.endsWith("/") ? e.slice(0, -1) : e; return t.endsWith("/api") ? t : `${t}/api` })(), headers: { "Content-Type": "application/json" } }); Ei.interceptors.request.use(e => { try { const t = localStorage.getItem("auth_token"); t && (e.headers.Authorization = `Bearer ${t}`) } catch (mg) { console.warn("LocalStorage access denied in api interceptor:", mg) } return e }); const Ti = () => Ei.get("/categories"), Ai = React.createContext(void 0); function _i({ children: e }) { const { i18n: t } = Qn(), [n, r] = React.useState([]), [s, i] = React.useState(!0), o = async () => { try { i(!0); const e = await Ti(); r(e.data.categories || []) } catch (e) { console.error("Failed to load categories", e) } finally { i(!1) } }; return React.useEffect(() => { o() }, []), T.jsx(Ai.Provider, { value: { categories: n, isLoading: s, getCategoryTitle: e => { var r, s; if (!e) return ""; const i = n.find(t => t.slug === e || t.id === e || t.title.toLowerCase() === e.toLowerCase()); if (!i) return e; const o = t.language; return (null == (s = null == (r = i.translations) ? void 0 : r[o]) ? void 0 : s.title) ? i.translations[o].title : i.title }, refreshCategories: o }, children: e }) } function yi() { const e = React.useContext(Ai); if (!e) throw new Error("useCategories must be used within CategoriesProvider"); return e } const bi = React.createContext({ user: null, isAuthenticated: !1, isLoading: !1, login: async () => !1, logout: () => { } }); function Si() { return React.useContext(bi) } function ki() { const { t: e, i18n: t } = Qn(), { theme: n, toggleTheme: r, textSize: s, setTextSize: i } = function () { const e = React.useContext(vt); if (!e) throw new Error("useTheme must be used within ThemeProvider"); return e }(), { isAuthenticated: o, logout: a } = Si(), [l, c] = React.useState([]), [u, h] = React.useState(!1), d = React.useRef(null); return React.useEffect(() => { function e(e) { d.current && !d.current.contains(e.target) && h(!1) } return document.addEventListener("mousedown", e), () => document.removeEventListener("mousedown", e) }, []), React.useEffect(() => { const e = () => { Ti().then(e => { c(e.data.categories) }).catch(e => { console.error("Failed to load categories:", e) }) }; return e(), window.addEventListener("categories-updated", e), () => window.removeEventListener("categories-updated", e) }, []), T.jsx("nav", { className: "border-b border-gray-200 dark:border-gray-700", children: T.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: T.jsxs("div", { className: "flex justify-between h-16 items-center", children: [T.jsxs(Pe, { to: "/", className: "flex items-center text-2xl font-display text-text-light dark:text-text-dark hover:opacity-70 transition-opacity", children: [T.jsx("img", { src: "data:image/svg+xml,%3csvg%20width='500'%20height='500'%20viewBox='0%200%20500%20500'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20fill='%23000000'%3e%3ccircle%20cx='165'%20cy='180'%20r='40'%20/%3e%3ccircle%20cx='335'%20cy='180'%20r='40'%20/%3e%3cpath%20d='M%20150%20210%20Q%20250%20150%20350%20210%20C%20410%20240%20430%20350%20440%20420%20Q%20445%20480%20250%20480%20Q%2055%20480%2060%20420%20C%2070%20350%2090%20240%20150%20210%20Z'%20/%3e%3c/g%3e%3cpath%20d='M%20105%20305%20L%20250%20400%20L%20395%20305%20L%20410%20305%20L%20250%20450%20L%2090%20305%20Z'%20fill='%23FFFFFF'%20/%3e%3cg%3e%3ccircle%20cx='205'%20cy='245'%20r='16'%20fill='%23FFFFFF'%20/%3e%3ccircle%20cx='205'%20cy='245'%20r='7'%20fill='%23000000'%20/%3e%3ccircle%20cx='295'%20cy='245'%20r='16'%20fill='%23FFFFFF'%20/%3e%3ccircle%20cx='295'%20cy='245'%20r='7'%20fill='%23000000'%20/%3e%3c/g%3e%3cpath%20d='M%20220%20280%20Q%20250%20260%20280%20280%20Q%20295%20310%20280%20330%20Q%20250%20345%20220%20330%20Q%20205%20310%20220%20280%20Z'%20fill='%23FFFFFF'%20/%3e%3cpath%20d='M%20235%20285%20Q%20250%20280%20265%20285%20Q%20270%20295%20250%20310%20Q%20230%20295%20235%20285%20Z'%20fill='%23000000'%20/%3e%3crect%20x='248'%20y='310'%20width='4'%20height='10'%20rx='2'%20fill='%23000000'%20/%3e%3c/svg%3e", alt: "Logo", className: "mr-3 mb-2 flex-shrink-0 [filter:drop-shadow(-2px_0_0_#32cd32)_drop-shadow(2px_0_0_#ff6347)] dark:[filter:drop-shadow(-2px_0_0_rgba(50,205,50,0.5))_drop-shadow(2px_0_0_rgba(255,99,71,0.5))_drop-shadow(0_0_5px_rgba(50,205,50,0.15))]", style: { width: "40px", height: "40px" } }), e("brand")] }), T.jsxs("div", { className: "flex items-center space-x-6", children: [T.jsx(Pe, { to: "/", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: e("nav.home") }), T.jsxs("div", { className: "relative", ref: d, children: [T.jsxs("button", { onClick: () => h(!u), className: "flex items-center gap-1 text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: [e("nav.categories", "Categories"), T.jsx("svg", { className: "w-4 h-4 transition-transform " + (u ? "rotate-180" : ""), fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })] }), u && T.jsx("div", { className: "absolute left-0 mt-2 py-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-50", children: l.filter(e => o || !e.adminOnly).map(e => { var n, r; return T.jsxs(Pe, { to: `/category/${e.slug || e.id}`, className: "block px-4 py-2 text-muted-light dark:text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-text-light dark:hover:text-text-dark transition-colors " + (e.adminOnly ? "opacity-70" : ""), onClick: () => h(!1), children: [e.adminOnly ? " " : "", (null == (r = null == (n = e.translations) ? void 0 : n[t.language]) ? void 0 : r.title) || e.title] }, e.id) }) })] }), o && T.jsxs(Pe, { to: "/admin", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors font-medium", children: [" ", e("nav.admin")] })] }), T.jsxs("div", { className: "flex items-center space-x-4", children: [T.jsxs("div", { className: "hidden sm:flex items-center space-x-1 text-sm", children: [T.jsx("button", { onClick: () => { const e = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], t = e.indexOf(s); t > 0 && i(e[t - 1]) }, disabled: "small" === s, className: "w-6 h-6 flex items-center justify-center rounded " + ("small" === s ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"), title: "Decrease text size", children: "" }), T.jsx("span", { className: "w-6 h-6 flex items-center justify-center font-medium", children: "A" }), T.jsx("button", { onClick: () => { const e = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], t = e.indexOf(s); t < e.length - 1 && i(e[t + 1]) }, disabled: "xxxlarge" === s, className: "w-6 h-6 flex items-center justify-center rounded " + ("xxxlarge" === s ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"), title: "Increase text size", children: "+" })] }), T.jsxs("select", { value: t.language, onChange: e => t.changeLanguage(e.target.value), className: "relative z-10 bg-transparent text-sm text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark uppercase border-none focus:ring-0 cursor-pointer p-0 pr-6 bg-[url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E')] bg-[length:0.7em] bg-[right_0_center] bg-no-repeat", style: { WebkitAppearance: "none", opacity: 1 }, "aria-label": "Select Language", children: [T.jsx("option", { value: "en", className: "bg-white dark:bg-gray-800 py-1", children: "EN" }), T.jsx("option", { value: "poj", className: "bg-white dark:bg-gray-800 py-1", children: "POJ" }), T.jsx("option", { value: "hanlo", className: "bg-white dark:bg-gray-800 py-1", children: "" })] }), T.jsx("button", { onClick: r, className: "p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800", "aria-label": "Toggle theme", children: "light" === n ? T.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) }) : T.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) }), !1] })] }) }) }) } function Ci() { const { t: e } = Qn(), t = (new Date).getFullYear(); return T.jsx("footer", { className: "border-t border-gray-200 dark:border-gray-700 mt-20 py-10", children: T.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: T.jsx("div", { className: "text-muted-light dark:text-muted-dark text-sm", children: e("footer.copyright", { year: t }) }) }) }) } function Ni({ post: e, featured: t = !1, showDraftBadge: n = !1 }) { var r; const { t: s } = Qn(), { getCategoryTitle: i } = yi(), o = e.published || e.draft, a = null == o ? void 0 : o.meta, l = "published" !== e.status; if (!o) return null; const c = (null == (r = null == a ? void 0 : a.date) ? void 0 : r.substring(0, 7)) || `${(new Date).getFullYear()}-01`, u = (null == a ? void 0 : a.url) || e.id, h = (null == a ? void 0 : a.thumbImage) || ((e, t = 800, n = 600) => `https://picsum.photos/seed/${e}/${t}/${n}`)(e.id); return T.jsxs("article", { className: "group relative flex flex-col " + (t ? "col-span-full md:grid md:grid-cols-2 md:gap-8" : "h-full"), children: [T.jsx(Pe, { to: `/posts/${c}/${u}`, className: "absolute inset-0 z-10", "aria-label": o.title }), T.jsxs("div", { className: `overflow-hidden rounded-lg bg-gray-100 dark:bg-gray-800 ${t ? "aspect-video md:aspect-auto md:h-full" : "aspect-[16/10]"} mb-4 md:mb-0 relative shadow-sm transition-all duration-300 group-hover:shadow-md group-hover:translate-y-[-2px]`, children: [T.jsx("img", { src: h, alt: o.title, className: "w-full h-full object-cover transition-transform duration-700 ease-out group-hover:scale-105", loading: "lazy" }), n && l && T.jsx("div", { className: "absolute top-4 right-4 z-20", children: T.jsx("span", { className: "inline-block px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-orange-500/80 backdrop-blur-sm rounded-sm", children: s("post.draft") }) }), (null == a ? void 0 : a.category) && T.jsx("div", { className: "absolute top-4 left-4 z-20", children: T.jsxs("span", { className: "inline-flex items-center gap-1 px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-black/50 backdrop-blur-sm rounded-sm", children: [T.jsx("svg", { className: "w-3 h-3", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" }) }), i(a.category)] }) })] }), T.jsxs("div", { className: "flex flex-col " + (t ? "justify-center md:py-4" : "flex-1"), children: [T.jsxs("div", { className: "flex items-center gap-3 mb-3 text-xs font-medium text-muted-light dark:text-muted-dark", children: [(null == a ? void 0 : a.date) && T.jsx("time", { dateTime: a.date, children: a.date }), (null == a ? void 0 : a.featured) && T.jsx("span", { className: "text-yellow-600 dark:text-yellow-500 font-bold", children: s("post.featured") }), n && l && T.jsx("span", { className: "text-orange-500 font-bold", children: s("post.draft") })] }), T.jsx("h2", { className: `font-display font-bold text-text-light dark:text-text-dark ${t ? "text-3xl md:text-4xl" : "text-xl"} leading-tight mb-3 group-hover:text-accent transition-colors duration-200`, children: o.title }), (null == a ? void 0 : a.thumbText) && T.jsx("p", { className: `text-muted-light dark:text-muted-dark ${t ? "text-lg line-clamp-3" : "text-sm line-clamp-2"} mb-4`, children: a.thumbText }), T.jsx("div", { className: "mt-auto flex items-center text-sm font-medium text-accent opacity-0 -translate-x-2 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0", children: s("post.readArticle") })] })] }) } function Ii() { const { t: e, i18n: t } = Qn(), [n, r] = React.useState([]), [s, i] = React.useState(!0), [o, a] = React.useState(null); React.useEffect(() => { l() }, [t.language]); const l = async () => { try { i(!0); const e = await Ei.get("/posts"); r(e.data.posts) } catch (t) { a(e("home.failedToLoad")), console.error(t) } finally { i(!1) } }, c = n.filter(e => { var t, n, r; return "help" !== (null == (r = null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.category) ? void 0 : r.toLowerCase()) }), u = c.filter(e => { var t, n; return null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.featured }), h = c.filter(e => { var t, n; return !(null == (n = null == (t = e.published) ? void 0 : t.meta) ? void 0 : n.featured) }); return T.jsxs(T.Fragment, { children: [T.jsxs(Ot, { children: [T.jsxs("title", { children: [e("home.title"), " | Next Blog"] }), T.jsx("meta", { name: "description", content: "A modern blog built with React and Firestore" })] }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1", children: T.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [u.length > 0 && T.jsxs("section", { className: "mb-16", children: [T.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.featured") }), T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8", children: u.slice(0, 2).map(e => T.jsx(Ni, { post: e, featured: !0 }, e.id)) })] }), T.jsxs("section", { children: [T.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.latest") }), s ? T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((e, t) => T.jsxs("div", { className: "animate-pulse", children: [T.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-2" }), T.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, t)) }) : o ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: o }) : 0 === h.length ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: e("home.noPosts") }) : T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: h.map(e => T.jsx(Ni, { post: e }, e.id)) })] })] }) }), T.jsx(Ci, {})] })] }) } const Oi = {}, xi = function (e, t, n) { let r = Promise.resolve(); if (t && t.length > 0) { const e = document.getElementsByTagName("link"), s = document.querySelector("meta[property=csp-nonce]"), i = (null == s ? void 0 : s.nonce) || (null == s ? void 0 : s.getAttribute("nonce")); r = Promise.allSettled(t.map(t => { if (t = function (e, t) { return new URL(e, t).href }(t, n), t in Oi) return; Oi[t] = !0; const r = t.endsWith(".css"), s = r ? '[rel="stylesheet"]' : ""; if (n) for (let n = e.length - 1; n >= 0; n--) { const s = e[n]; if (s.href === t && (!r || "stylesheet" === s.rel)) return } else if (document.querySelector(`link[href="${t}"]${s}`)) return; const o = document.createElement("link"); return o.rel = r ? "stylesheet" : "modulepreload", r || (o.as = "script"), o.crossOrigin = "", o.href = t, i && o.setAttribute("nonce", i), document.head.appendChild(o), r ? new Promise((e, n) => { o.addEventListener("load", e), o.addEventListener("error", () => n(new Error(`Unable to preload CSS for ${t}`))) }) : void 0 })) } function s(e) { const t = new Event("vite:preloadError", { cancelable: !0 }); if (t.payload = e, window.dispatchEvent(t), !t.defaultPrevented) throw e } return r.then(t => { for (const e of t || []) "rejected" === e.status && s(e.reason); return e().catch(s) }) }, vi = React.lazy(() => xi(() => Promise.resolve().then(() => Ju), void 0, import.meta.url).then(e => ({ default: e.default }))), Ri = xi(() => Promise.resolve().then(() => Vd), void 0, import.meta.url).then(e => e.default), Di = xi(() => Promise.resolve().then(() => dg), void 0, import.meta.url).then(e => e.default); let Li = null, Pi = null; Promise.all([Ri, Di]).then(([e, t]) => { Li = e, Pi = t }); const wi = () => T.jsx("div", { className: "animate-pulse space-y-4", children: [...Array(5)].map((e, t) => T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, t)) }); function Mi({ children: e, className: t }) { return T.jsx(React.Suspense, { fallback: T.jsx(wi, {}), children: T.jsx(vi, { remarkPlugins: Li ? [Li] : [], rehypePlugins: Pi ? [Pi] : [], className: t, children: e }) }) } const Fi = (e, t = 1200, n = 800) => `https://picsum.photos/seed/${e}/${t}/${n}`, Bi = e => { if (!e) return []; const t = e.split(/\r?\n/), n = []; let r = [], s = !1, i = !1; const o = () => { if (r.length > 0) { const e = r.join("\n").trim(); e && n.push(e), r = [] } s = !1, i = !1 }; for (let a = 0; a < t.length; a++) { const e = t[a], n = e.trim(); if (/^#{2,3}\s+/.test(n)) o(), r.push(e); else if (n.startsWith(">")) !i && r.length > 0 && !r[0].trim().startsWith(">") && o(), i = !0, r.push(e); else if (/^[-*]\s+/.test(n) || /^\d+\.\s+/.test(n)) !s && r.length > 0 && !/^[-*]\s+/.test(r[0].trim()) && !/^\d+\.\s+/.test(r[0].trim()) && o(), s = !0, r.push(e); else if ("" !== n) (i || s) && o(), r.push(e); else if (s || i) { let n = ""; for (let e = a + 1; e < t.length; e++)if (t[e].trim()) { n = t[e].trim(); break } if (s && (/^[-*]\s+/.test(n) || /^\d+\.\s+/.test(n))) { r.push(e); continue } if (i && n.startsWith(">")) { r.push(e); continue } o() } else r.length > 0 && o() } return o(), n }; function Ui() { var e, t, n, r; const { yearMonth: s, slug: i } = pe(), { t: o } = Qn(), { getCategoryTitle: a } = yi(), [l, c] = React.useState(null), [u, h] = React.useState(!0), [d, p] = React.useState(null), [f, m] = React.useState(() => { try { const e = localStorage.getItem(xt); if ("tg" === e || "en" === e || "tg-en" === e) return e } catch (mg) { console.warn("localStorage access denied") } return "tg-en" }); React.useEffect(() => { try { localStorage.setItem(xt, f) } catch (mg) { console.warn("localStorage access denied") } }, [f]), React.useEffect(() => { s && i && g(s, i) }, [s, i]); const g = async (e, t) => { try { h(!0); const n = await ((e, t) => Ei.get(`/posts/by-slug/${e}/${t}`))(e, t); c(n.data.post) } catch (n) { p(o("post.notFound")) } finally { h(!1) } }, E = (null == l ? void 0 : l.published) || (null == l ? void 0 : l.draft), A = null == E ? void 0 : E.meta, _ = !(!(null == (e = null == E ? void 0 : E.title) ? void 0 : e.trim()) && !(null == (t = null == E ? void 0 : E.text) ? void 0 : t.trim())), y = !(!(null == (n = null == E ? void 0 : E.titleEn) ? void 0 : n.trim()) && !(null == (r = null == E ? void 0 : E.textEn) ? void 0 : r.trim())), b = _ && y, S = b, k = React.useMemo(() => { var e, t, n, r; if (!E) return ""; const s = (null == (e = E.title) ? void 0 : e.trim()) || (null == (t = E.titleEn) ? void 0 : t.trim()) || "", i = (null == (n = E.titleEn) ? void 0 : n.trim()) || (null == (r = E.title) ? void 0 : r.trim()) || ""; if (!b) return s || i; switch (f) { case "tg": case "tg-en": default: return s; case "en": return i } }, [E, f, b]), C = React.useMemo(() => { if (!E || !b) return null; const e = Bi(E.text), t = Bi(E.textEn || ""), n = Math.max(e.length, t.length), r = []; for (let s = 0; s < n; s++)r.push({ tg: e[s], en: t[s] }); return r }, [E, b]); return u ? T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1 animate-pulse", children: T.jsxs("div", { className: "max-w-3xl mx-auto px-4 py-12", children: [T.jsx("div", { className: "h-8 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-4" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-8" }), T.jsx("div", { className: "space-y-4", children: [...Array(8)].map((e, t) => T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, t)) })] }) }), T.jsx(Ci, {})] }) : !d && l && E ? T.jsxs(T.Fragment, { children: [T.jsxs(Ot, { children: [T.jsxs("title", { children: [k, " | Next Blog"] }), T.jsx("meta", { name: "description", content: (null == A ? void 0 : A.thumbText) || k }), (null == A ? void 0 : A.ogImage) && T.jsx("meta", { property: "og:image", content: A.ogImage })] }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsxs("main", { className: "flex-1 bg-background-light dark:bg-background-dark", children: [T.jsxs("div", { className: "relative w-full h-[50vh] md:h-[60vh] min-h-[400px] bg-gray-900 overflow-hidden", children: [T.jsx("img", { src: (null == A ? void 0 : A.thumbImage) || Fi(l.id), alt: k, className: "w-full h-full object-cover opacity-80" }), T.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-background-light dark:from-background-dark via-transparent to-transparent opacity-90" }), T.jsxs("div", { className: "absolute bottom-0 left-0 right-0 p-6 md:p-12 max-w-4xl mx-auto text-center", children: [T.jsxs("div", { className: "flex items-center justify-center gap-3 mb-6 animate-fade-in-up", children: [(null == A ? void 0 : A.featured) && T.jsx("span", { className: "px-2 py-1 text-xs uppercase tracking-[0.2em] font-bold text-white bg-yellow-600/90 rounded-sm shadow-sm backdrop-blur-sm", children: o("post.featured") }), (null == A ? void 0 : A.category) && T.jsxs("span", { className: "inline-flex items-center gap-1 px-2 py-1 text-xs uppercase tracking-[0.2em] font-medium text-white/90 bg-accent/80 rounded-sm shadow-sm backdrop-blur-sm", children: [T.jsx("svg", { className: "w-3 h-3", fill: "none", stroke: "currentColor", viewBox: "0 0 24 24", children: T.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M7 7h.01M7 3h5c.512 0 1.024.195 1.414.586l7 7a2 2 0 010 2.828l-7 7a2 2 0 01-2.828 0l-7-7A1.994 1.994 0 013 12V7a4 4 0 014-4z" }) }), a(A.category)] })] }), T.jsx("h1", { className: "hero-title font-display text-white mb-6 leading-tight text-shadow-lg animate-fade-in-up delay-100", children: k }), b && "tg-en" === f && E.titleEn && T.jsx("p", { className: "text-xl md:text-2xl text-white/70 mb-6 animate-fade-in-up delay-150", children: E.titleEn }), T.jsxs("div", { className: "flex items-center justify-center space-x-6 text-white/80 text-sm md:text-base font-medium animate-fade-in-up delay-200", children: [(null == A ? void 0 : A.author) && T.jsxs("div", { className: "flex items-center gap-2", children: [T.jsx("div", { className: "w-8 h-8 rounded-full bg-accent/30 flex items-center justify-center text-xs font-bold ring-1 ring-white/20", children: A.author[0] }), T.jsx("span", { children: A.author })] }), (null == A ? void 0 : A.date) && T.jsxs(T.Fragment, { children: [T.jsx("span", { children: "" }), T.jsx("time", { className: "font-mono opacity-80", children: A.date })] })] })] })] }), T.jsxs("article", { className: "max-w-3xl mx-auto px-4 sm:px-6 pt-0 pb-16", children: [S && T.jsx("div", { className: "language-switcher flex justify-center gap-2 -mt-5 mb-12 relative z-10", children: T.jsxs("div", { className: "bg-white dark:bg-gray-800 p-1 rounded-full shadow-lg flex gap-1 border border-gray-100 dark:border-gray-700", children: [T.jsx("button", { onClick: () => m("tg"), className: "px-6 py-2 text-sm font-medium rounded-full transition-all duration-200 " + ("tg" === f ? "bg-accent text-white shadow-sm" : "text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700"), children: o("bilingual.taigi") }), T.jsx("button", { onClick: () => m("tg-en"), className: "px-6 py-2 text-sm font-medium rounded-full transition-all duration-200 " + ("tg-en" === f ? "bg-accent text-white shadow-sm" : "text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700"), children: o("bilingual.parallel") }), T.jsx("button", { onClick: () => m("en"), className: "px-6 py-2 text-sm font-medium rounded-full transition-all duration-200 " + ("en" === f ? "bg-accent text-white shadow-sm" : "text-text-light dark:text-text-dark hover:bg-gray-100 dark:hover:bg-gray-700"), children: o("bilingual.english") })] }) }), !S && (_ || y) && "tg-en" === (null == A ? void 0 : A.language) && T.jsx("div", { className: "flex justify-center mb-12", children: T.jsx("span", { className: "px-4 py-2 text-sm font-medium rounded-md bg-gray-100 dark:bg-gray-800 text-gray-600 dark:text-gray-400 border border-gray-200 dark:border-gray-700", children: o(_ ? "bilingual.taigi" : "bilingual.english") }) }), (() => { var e, t, n, r; const s = (null == (e = E.text) ? void 0 : e.trim()) || (null == (t = E.textEn) ? void 0 : t.trim()) || "", i = (null == (n = E.textEn) ? void 0 : n.trim()) || (null == (r = E.text) ? void 0 : r.trim()) || ""; if (!b) return T.jsx("div", { className: "prose prose-lg md:prose-xl dark:prose-invert mx-auto drop-cap", children: T.jsx(Mi, { children: s || i }) }); switch (f) { case "tg": return T.jsx("div", { className: "prose prose-lg md:prose-xl dark:prose-invert mx-auto drop-cap", children: T.jsx(Mi, { children: s }) }); case "en": return T.jsx("div", { className: "prose prose-lg md:prose-xl dark:prose-invert mx-auto drop-cap", children: T.jsx(Mi, { children: i }) }); default: return T.jsx("div", { className: "bilingual-content mx-auto", children: null == C ? void 0 : C.map((e, t) => T.jsxs("div", { className: "bilingual-section", children: [e.tg && T.jsx("div", { className: "tg-text prose prose-lg md:prose-xl dark:prose-invert", children: T.jsx(Mi, { children: e.tg }) }), e.en && T.jsx("div", { className: "en-text prose prose-base dark:prose-invert", children: T.jsx(Mi, { children: e.en }) })] }, t)) }) } })(), (null == A ? void 0 : A.tags) && A.tags.length > 0 && T.jsx("div", { className: "mt-16 pt-10 border-t border-gray-200 dark:border-gray-800", children: T.jsx("div", { className: "flex flex-wrap gap-3", children: A.tags.map(e => T.jsxs("a", { href: `/tag/${e}`, className: "px-4 py-1.5 text-sm font-medium text-text-light dark:text-text-dark bg-surface-light dark:bg-surface-dark border border-gray-200 dark:border-gray-700 rounded-full hover:border-accent hover:text-accent dark:hover:text-accent transition-colors duration-200", children: ["#", e] }, e)) }) })] })] }), T.jsx(Ci, {})] })] }) : T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1 flex items-center justify-center", children: T.jsx("p", { className: "text-muted-light dark:text-muted-dark", children: d || o("post.notFound") }) }), T.jsx(Ci, {})] }) } function Hi() { var e, t; const { category: n, tag: r, author: s } = pe(), { t: i } = Qn(), { isAuthenticated: o } = Si(), [a, l] = React.useState([]), [c, u] = React.useState([]), [h, d] = React.useState(!0), [p, f] = React.useState(!1); React.useEffect(() => { Ti().then(e => { u(e.data.categories) }).catch(e => { console.error("Categories load ERROR:", e) }) }, []), React.useEffect(() => { if (l([]), n && c.length > 0) { const e = c.find(e => e.id === n || e.slug === n); f((null == e ? void 0 : e.adminOnly) || !1) } m() }, [n, r, s, c, o]); const m = async () => { try { let e; d(!0); const t = c.find(e => e.id === n || e.slug === n); if (o && (null == t ? void 0 : t.adminOnly)) if (e = await ((e = 1, t = 15) => Ei.get(`/posts/admin/all?page=${e}&limit=${t}`))(1, 1e3), e.data.posts) { const t = e.data.posts.filter(e => { var t, r, s; return (null == (s = null == (r = null == (t = e.draft) ? void 0 : t.meta) ? void 0 : r.category) ? void 0 : s.toLowerCase()) === (null == n ? void 0 : n.toLowerCase()) }); l(t) } else l([]); else n ? (e = await ((e, t = "en") => Ei.get(`/posts?category=${e}&language=${t}`))(n, "all"), l(e.data.posts || [])) : r ? (e = await ((e, t = "en") => Ei.get(`/posts?tag=${e}&language=${t}`))(r, "all"), l(e.data.posts || [])) : s ? (e = await ((e, t = "en") => Ei.get(`/posts?author=${e}&language=${t}`))(s, "all"), l(e.data.posts || [])) : l([]) } catch (e) { console.error("loadPosts ERROR:", e), l([]) } finally { d(!1) } }, g = c.find(e => e.id === n || e.slug === n), { i18n: E } = Qn(), A = (null == (t = null == (e = null == g ? void 0 : g.translations) ? void 0 : e[E.language]) ? void 0 : t.title) || (null == g ? void 0 : g.title) || n || r || s || "Posts"; return T.jsxs(T.Fragment, { children: [T.jsx(Ot, { children: T.jsxs("title", { children: [A, " | Next Blog"] }) }), T.jsxs("div", { className: "min-h-screen flex flex-col", children: [T.jsx(ki, {}), T.jsx("main", { className: "flex-1", children: T.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [T.jsxs("header", { className: "mb-12", children: [T.jsxs("h1", { className: "font-display text-4xl mb-2", children: [p && o ? " " : "", A] }), T.jsxs("p", { className: "text-muted-light dark:text-muted-dark", children: [i("category.postCount", { count: a.length }), p && o && ` ${i("category.includingDrafts")}`] })] }), h ? T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((e, t) => T.jsxs("div", { className: "animate-pulse", children: [T.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), T.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), T.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, t)) }) : 0 === a.length ? T.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: i("category.noPosts") }) : T.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: a.map(e => T.jsx(Ni, { post: e, showDraftBadge: p && o }, e.id)) })] }) }), T.jsx(Ci, {})] })] }) } function ji() { return T.jsx(bt, { children: T.jsx(Rt, { children: T.jsx(_i, { children: T.jsx(Re, { children: T.jsxs(Ne, { children: [T.jsx(ke, { path: "/", element: T.jsx(Ii, {}) }), T.jsx(ke, { path: "/posts/:yearMonth/:slug", element: T.jsx(Ui, {}) }), T.jsx(ke, { path: "/category/:category", element: T.jsx(Hi, {}) }), T.jsx(ke, { path: "/tag/:tag", element: T.jsx(Hi, {}) }), T.jsx(ke, { path: "/author/:author", element: T.jsx(Hi, {}) }), T.jsx(ke, { path: "*", element: T.jsx(Se, { to: "/", replace: !0 }) })] }) }) }) }) }) } const Gi = { brand: "", footer: { copyright: " {{year}} Next Blog. MIT License." }, nav: { home: "Home", tutorials: "Tutorials", admin: "Admin", categories: "Categories" }, home: { title: "Blog", featured: "Featured", latest: "Latest Posts", readMore: "Read More", noPosts: "No posts yet.", loading: "Loading...", failedToLoad: "Failed to load posts" }, post: { by: "By", published: "Published", share: "Share", readArticle: "Read article ", featured: " Featured", draft: " Unpublished", notFound: "Post not found" }, category: { postCount: "{{count}} post", postCount_plural: "{{count}} posts", includingDrafts: "(including drafts)", noPosts: "No posts found." }, bilingual: { taigi: "Taigi", english: "English", parallel: "Bilingual", taigiContent: "Taigi Content", englishContent: "English Content", taigiEnglishBilingual: "Taigi-English Bilingual", titleTaigi: "Title (Taigi):", titleEnglish: "Title (English):", language: "Language:", missingContentTitle: "Missing content:", missingContentMessage: "For bilingual posts, both Taigi and English content are recommended. Posts with only one language will not show the language switcher on the public page.", missingEnglishWarning: "Bilingual mode detected but no English content found after ---en---" } }, zi = Object.freeze(Object.defineProperty({ __proto__: null, default: Gi }, Symbol.toStringTag, { value: "Module" })), Yi = { en: { translation: Gi }, poj: { translation: {} }, hanlo: { translation: {} } }; bn.use(Pn).init({ resources: Yi, lng: "en", fallbackLng: "en", interpolation: { escapeValue: !1 } }), bn.on("languageChanged", async e => { if ("en" !== e && 0 === Object.keys(bn.getResourceBundle(e, "translation") || {}).length) { const t = await (async e => { switch (e) { case "poj": return (await xi(async () => { const { default: e } = await Promise.resolve().then(() => pg); return { default: e } }, void 0, import.meta.url)).default; case "hanlo": return (await xi(async () => { const { default: e } = await Promise.resolve().then(() => fg); return { default: e } }, void 0, import.meta.url)).default; default: return (await xi(async () => { const { default: e } = await Promise.resolve().then(() => zi); return { default: e } }, void 0, import.meta.url)).default } })(e); bn.addResourceBundle(e, "translation", t, !0, !0) } }); class qi extends React.Component { constructor(e) { super(e), this.state = { hasError: !1, error: null } } static getDerivedStateFromError(e) { return { hasError: !0, error: e } } componentDidCatch(e, t) { console.error("Uncaught error:", e, t) } render() { var e, t; return this.state.hasError ? T.jsxs("div", { style: { padding: "20px", color: "red" }, children: [T.jsx("h1", { children: "Something went wrong." }), T.jsx("pre", { children: null == (e = this.state.error) ? void 0 : e.toString() }), T.jsx("pre", { children: null == (t = this.state.error) ? void 0 : t.stack })] }) : this.props.children } } function Vi() { } function $i() { } function Wi(e) { const t = [], n = String(e || ""); let r = n.indexOf(","), s = 0, i = !1; for (; !i;) { -1 === r && (r = n.length, i = !0); const e = n.slice(s, r).trim(); !e && i || t.push(e), s = r + 1, r = n.indexOf(",", s) } return t } function Ki(e, t) { const n = {}; return ("" === e[e.length - 1] ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (!1 === n.padLeft ? "" : " ")).trim() } ReactDOM.createRoot(document.getElementById("root")).render(T.jsx(React.StrictMode, { children: T.jsx(qi, { children: T.jsx(ji, {}) }) })); const Qi = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Xi = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, Ji = {}; function Zi(e, t) { return (Ji.jsx ? Xi : Qi).test(e) } const eo = /[ \t\n\f\r]/g; function to(e) { return "" === e.replace(eo, "") } class no { constructor(e, t, n) { this.normal = t, this.property = e, n && (this.space = n) } } function ro(e, t) { const n = {}, r = {}; for (const s of e) Object.assign(n, s.property), Object.assign(r, s.normal); return new no(n, r, t) } function so(e) { return e.toLowerCase() } no.prototype.normal = {}, no.prototype.property = {}, no.prototype.space = void 0; class io { constructor(e, t) { this.attribute = t, this.property = e } } io.prototype.attribute = "", io.prototype.booleanish = !1, io.prototype.boolean = !1, io.prototype.commaOrSpaceSeparated = !1, io.prototype.commaSeparated = !1, io.prototype.defined = !1, io.prototype.mustUseProperty = !1, io.prototype.number = !1, io.prototype.overloadedBoolean = !1, io.prototype.property = "", io.prototype.spaceSeparated = !1, io.prototype.space = void 0; let oo = 0; const ao = mo(), lo = mo(), co = mo(), uo = mo(), ho = mo(), po = mo(), fo = mo(); function mo() { return 2 ** ++oo } const go = Object.freeze(Object.defineProperty({ __proto__: null, boolean: ao, booleanish: lo, commaOrSpaceSeparated: fo, commaSeparated: po, number: uo, overloadedBoolean: co, spaceSeparated: ho }, Symbol.toStringTag, { value: "Module" })), Eo = Object.keys(go); class To extends io { constructor(e, t, n, r) { let s = -1; if (super(e, t), Ao(this, "space", r), "number" == typeof n) for (; ++s < Eo.length;) { const e = Eo[s]; Ao(this, Eo[s], (n & go[e]) === go[e]) } } } function Ao(e, t, n) { n && (e[t] = n) } function _o(e) { const t = {}, n = {}; for (const [r, s] of Object.entries(e.properties)) { const i = new To(r, e.transform(e.attributes || {}, r), s, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (i.mustUseProperty = !0), t[r] = i, n[so(r)] = r, n[so(i.attribute)] = r } return new no(t, n, e.space) } To.prototype.defined = !0; const yo = _o({ properties: { ariaActiveDescendant: null, ariaAtomic: lo, ariaAutoComplete: null, ariaBusy: lo, ariaChecked: lo, ariaColCount: uo, ariaColIndex: uo, ariaColSpan: uo, ariaControls: ho, ariaCurrent: null, ariaDescribedBy: ho, ariaDetails: null, ariaDisabled: lo, ariaDropEffect: ho, ariaErrorMessage: null, ariaExpanded: lo, ariaFlowTo: ho, ariaGrabbed: lo, ariaHasPopup: null, ariaHidden: lo, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: ho, ariaLevel: uo, ariaLive: null, ariaModal: lo, ariaMultiLine: lo, ariaMultiSelectable: lo, ariaOrientation: null, ariaOwns: ho, ariaPlaceholder: null, ariaPosInSet: uo, ariaPressed: lo, ariaReadOnly: lo, ariaRelevant: null, ariaRequired: lo, ariaRoleDescription: ho, ariaRowCount: uo, ariaRowIndex: uo, ariaRowSpan: uo, ariaSelected: lo, ariaSetSize: uo, ariaSort: null, ariaValueMax: uo, ariaValueMin: uo, ariaValueNow: uo, ariaValueText: null, role: null }, transform: (e, t) => "role" === t ? t : "aria-" + t.slice(4).toLowerCase() }); function bo(e, t) { return t in e ? e[t] : t } function So(e, t) { return bo(e, t.toLowerCase()) } const ko = _o({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: po, acceptCharset: ho, accessKey: ho, action: null, allow: null, allowFullScreen: ao, allowPaymentRequest: ao, allowUserMedia: ao, alt: null, as: null, async: ao, autoCapitalize: null, autoComplete: ho, autoFocus: ao, autoPlay: ao, blocking: ho, capture: null, charSet: null, checked: ao, cite: null, className: ho, cols: uo, colSpan: null, content: null, contentEditable: lo, controls: ao, controlsList: ho, coords: uo | po, crossOrigin: null, data: null, dateTime: null, decoding: null, default: ao, defer: ao, dir: null, dirName: null, disabled: ao, download: co, draggable: lo, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: ao, formTarget: null, headers: ho, height: uo, hidden: co, high: uo, href: null, hrefLang: null, htmlFor: ho, httpEquiv: ho, id: null, imageSizes: null, imageSrcSet: null, inert: ao, inputMode: null, integrity: null, is: null, isMap: ao, itemId: null, itemProp: ho, itemRef: ho, itemScope: ao, itemType: ho, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: ao, low: uo, manifest: null, max: null, maxLength: uo, media: null, method: null, min: null, minLength: uo, multiple: ao, muted: ao, name: null, nonce: null, noModule: ao, noValidate: ao, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: ao, optimum: uo, pattern: null, ping: ho, placeholder: null, playsInline: ao, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: ao, referrerPolicy: null, rel: ho, required: ao, reversed: ao, rows: uo, rowSpan: uo, sandbox: ho, scope: null, scoped: ao, seamless: ao, selected: ao, shadowRootClonable: ao, shadowRootDelegatesFocus: ao, shadowRootMode: null, shape: null, size: uo, sizes: null, slot: null, span: uo, spellCheck: lo, src: null, srcDoc: null, srcLang: null, srcSet: null, start: uo, step: null, style: null, tabIndex: uo, target: null, title: null, translate: null, type: null, typeMustMatch: ao, useMap: null, value: lo, width: uo, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: ho, axis: null, background: null, bgColor: null, border: uo, borderColor: null, bottomMargin: uo, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: ao, declare: ao, event: null, face: null, frame: null, frameBorder: null, hSpace: uo, leftMargin: uo, link: null, longDesc: null, lowSrc: null, marginHeight: uo, marginWidth: uo, noResize: ao, noHref: ao, noShade: ao, noWrap: ao, object: null, profile: null, prompt: null, rev: null, rightMargin: uo, rules: null, scheme: null, scrolling: lo, standby: null, summary: null, text: null, topMargin: uo, valueType: null, version: null, vAlign: null, vLink: null, vSpace: uo, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: ao, disableRemotePlayback: ao, prefix: null, property: null, results: uo, security: null, unselectable: null }, space: "html", transform: So }), Co = _o({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: fo, accentHeight: uo, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: uo, amplitude: uo, arabicForm: null, ascent: uo, attributeName: null, attributeType: null, azimuth: uo, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: uo, by: null, calcMode: null, capHeight: uo, className: ho, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: uo, diffuseConstant: uo, direction: null, display: null, dur: null, divisor: uo, dominantBaseline: null, download: ao, dx: null, dy: null, edgeMode: null, editable: null, elevation: uo, enableBackground: null, end: null, event: null, exponent: uo, externalResourcesRequired: null, fill: null, fillOpacity: uo, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: po, g2: po, glyphName: po, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: uo, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: uo, horizOriginX: uo, horizOriginY: uo, id: null, ideographic: uo, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: uo, k: uo, k1: uo, k2: uo, k3: uo, k4: uo, kernelMatrix: fo, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: uo, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: uo, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: uo, overlineThickness: uo, paintOrder: null, panose1: null, path: null, pathLength: uo, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: ho, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: uo, pointsAtY: uo, pointsAtZ: uo, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: fo, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: fo, rev: fo, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: fo, requiredFeatures: fo, requiredFonts: fo, requiredFormats: fo, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: uo, specularExponent: uo, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: uo, strikethroughThickness: uo, string: null, stroke: null, strokeDashArray: fo, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: uo, strokeOpacity: uo, strokeWidth: null, style: null, surfaceScale: uo, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: fo, tabIndex: uo, tableValues: null, target: null, targetX: uo, targetY: uo, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: fo, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: uo, underlineThickness: uo, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: uo, values: null, vAlphabetic: uo, vMathematical: uo, vectorEffect: null, vHanging: uo, vIdeographic: uo, version: null, vertAdvY: uo, vertOriginX: uo, vertOriginY: uo, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: uo, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: bo }), No = _o({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform: (e, t) => "xlink:" + t.slice(5).toLowerCase() }), Io = _o({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: So }), Oo = _o({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform: (e, t) => "xml:" + t.slice(3).toLowerCase() }), xo = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, vo = /[A-Z]/g, Ro = /-[a-z]/g, Do = /^data[-\w.:]+$/i; function Lo(e, t) { const n = so(t); let r = t, s = io; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && "data" === n.slice(0, 4) && Do.test(t)) { if ("-" === t.charAt(4)) { const e = t.slice(5).replace(Ro, wo); r = "data" + e.charAt(0).toUpperCase() + e.slice(1) } else { const e = t.slice(4); if (!Ro.test(e)) { let n = e.replace(vo, Po); "-" !== n.charAt(0) && (n = "-" + n), t = "data" + n } } s = To } return new s(r, t) } function Po(e) { return "-" + e.toLowerCase() } function wo(e) { return e.charAt(1).toUpperCase() } const Mo = ro([yo, ko, No, Io, Oo], "html"), Fo = ro([yo, Co, No, Io, Oo], "svg"); function Bo(e) { const t = String(e || "").trim(); return t ? t.split(/[ \t\n\r\f]+/g) : [] } function Uo(e) { return e.join(" ").trim() } var Ho = {}, jo = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Go = /\n/g, zo = /^\s*/, Yo = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, qo = /^:\s*/, Vo = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $o = /^[;\s]*/, Wo = /^\s+|\s+$/g, Ko = ""; function Qo(e) { return e ? e.replace(Wo, Ko) : Ko } var Xo = s && s.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(Ho, "__esModule", { value: !0 }), Ho.default = function (e, t) { let n = null; if (!e || "string" != typeof e) return n; const r = (0, Jo.default)(e), s = "function" == typeof t; return r.forEach(e => { if ("declaration" !== e.type) return; const { property: r, value: i } = e; s ? t(r, i, e) : i && (n = n || {}, n[r] = i) }), n }; const Jo = Xo(function (e, t) { if ("string" != typeof e) throw new TypeError("First argument must be a string"); if (!e) return []; t = t || {}; var n = 1, r = 1; function s(e) { var t = e.match(Go); t && (n += t.length); var s = e.lastIndexOf("\n"); r = ~s ? e.length - s : r + e.length } function i() { var e = { line: n, column: r }; return function (t) { return t.position = new o(e), c(), t } } function o(e) { this.start = e, this.end = { line: n, column: r }, this.source = t.source } function a(s) { var i = new Error(t.source + ":" + n + ":" + r + ": " + s); if (i.reason = s, i.filename = t.source, i.line = n, i.column = r, i.source = e, !t.silent) throw i } function l(t) { var n = t.exec(e); if (n) { var r = n[0]; return s(r), e = e.slice(r.length), n } } function c() { l(zo) } function u(e) { var t; for (e = e || []; t = h();)!1 !== t && e.push(t); return e } function h() { var t = i(); if ("/" == e.charAt(0) && "*" == e.charAt(1)) { for (var n = 2; Ko != e.charAt(n) && ("*" != e.charAt(n) || "/" != e.charAt(n + 1));)++n; if (n += 2, Ko === e.charAt(n - 1)) return a("End of comment missing"); var o = e.slice(2, n - 2); return r += 2, s(o), e = e.slice(n), r += 2, t({ type: "comment", comment: o }) } } function d() { var e = i(), t = l(Yo); if (t) { if (h(), !l(qo)) return a("property missing ':'"); var n = l(Vo), r = e({ type: "declaration", property: Qo(t[0].replace(jo, Ko)), value: n ? Qo(n[0].replace(jo, Ko)) : Ko }); return l($o), r } } return o.prototype.content = e, c(), function () { var e, t = []; for (u(t); e = d();)!1 !== e && (t.push(e), u(t)); return t }() }); var Zo = {}; Object.defineProperty(Zo, "__esModule", { value: !0 }), Zo.camelCase = void 0; var ea = /^--[a-zA-Z0-9_-]+$/, ta = /-([a-z])/g, na = /^[^-]+$/, ra = /^-(webkit|moz|ms|o|khtml)-/, sa = /^-(ms)-/, ia = function (e, t) { return t.toUpperCase() }, oa = function (e, t) { return "".concat(t, "-") }; Zo.camelCase = function (e, t) { return void 0 === t && (t = {}), function (e) { return !e || na.test(e) || ea.test(e) }(e) ? e : (e = e.toLowerCase(), (e = t.reactCompat ? e.replace(sa, oa) : e.replace(ra, oa)).replace(ta, ia)) }; var aa = (s && s.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } })(Ho), la = Zo; function ca(e, t) { var n = {}; return e && "string" == typeof e ? ((0, aa.default)(e, function (e, r) { e && r && (n[(0, la.camelCase)(e, t)] = r) }), n) : n } ca.default = ca; const ua = i(ca), ha = pa("end"), da = pa("start"); function pa(e) { return function (t) { const n = t && t.position && t.position[e] || {}; if ("number" == typeof n.line && n.line > 0 && "number" == typeof n.column && n.column > 0) return { line: n.line, column: n.column, offset: "number" == typeof n.offset && n.offset > -1 ? n.offset : void 0 } } } function fa(e) { return e && "object" == typeof e ? "position" in e || "type" in e ? ga(e.position) : "start" in e || "end" in e ? ga(e) : "line" in e || "column" in e ? ma(e) : "" : "" } function ma(e) { return Ea(e && e.line) + ":" + Ea(e && e.column) } function ga(e) { return ma(e && e.start) + "-" + ma(e && e.end) } function Ea(e) { return e && "number" == typeof e ? e : 1 } class Ta extends Error { constructor(e, t, n) { super(), "string" == typeof t && (n = t, t = void 0); let r = "", s = {}, i = !1; if (t && (s = "line" in t && "column" in t || "start" in t && "end" in t ? { place: t } : "type" in t ? { ancestors: [t], place: t.position } : { ...t }), "string" == typeof e ? r = e : !s.cause && e && (i = !0, r = e.message, s.cause = e), !s.ruleId && !s.source && "string" == typeof n) { const e = n.indexOf(":"); -1 === e ? s.ruleId = n : (s.source = n.slice(0, e), s.ruleId = n.slice(e + 1)) } if (!s.place && s.ancestors && s.ancestors) { const e = s.ancestors[s.ancestors.length - 1]; e && (s.place = e.position) } const o = s.place && "start" in s.place ? s.place.start : s.place; this.ancestors = s.ancestors || void 0, this.cause = s.cause || void 0, this.column = o ? o.column : void 0, this.fatal = void 0, this.file = "", this.message = r, this.line = o ? o.line : void 0, this.name = fa(s.place) || "1:1", this.place = s.place || void 0, this.reason = this.message, this.ruleId = s.ruleId || void 0, this.source = s.source || void 0, this.stack = i && s.cause && "string" == typeof s.cause.stack ? s.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0 } } Ta.prototype.file = "", Ta.prototype.name = "", Ta.prototype.reason = "", Ta.prototype.message = "", Ta.prototype.stack = "", Ta.prototype.column = void 0, Ta.prototype.line = void 0, Ta.prototype.ancestors = void 0, Ta.prototype.cause = void 0, Ta.prototype.fatal = void 0, Ta.prototype.place = void 0, Ta.prototype.ruleId = void 0, Ta.prototype.source = void 0; const Aa = {}.hasOwnProperty, _a = new Map, ya = /[A-Z]/g, ba = new Set(["table", "tbody", "thead", "tfoot", "tr"]), Sa = new Set(["td", "th"]), ka = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"; function Ca(e, t, n) { return "element" === t.type ? function (e, t, n) { const r = e.schema; let s = r; "svg" === t.tagName.toLowerCase() && "html" === r.space && (s = Fo, e.schema = s), e.ancestors.push(t); const i = va(e, t.tagName, !1), o = function (e, t) { const n = {}; let r, s; for (s in t.properties) if ("children" !== s && Aa.call(t.properties, s)) { const i = xa(e, s, t.properties[s]); if (i) { const [s, o] = i; e.tableCellAlignToStyle && "align" === s && "string" == typeof o && Sa.has(t.tagName) ? r = o : n[s] = o } } return r && ((n.style || (n.style = {}))["css" === e.stylePropertyNameCase ? "text-align" : "textAlign"] = r), n }(e, t); let a = Oa(e, t); return ba.has(t.tagName) && (a = a.filter(function (e) { return "string" != typeof e || !("object" == typeof (t = e) ? "text" === t.type && to(t.value) : to(t)); var t })), Na(e, o, i, t), Ia(o, a), e.ancestors.pop(), e.schema = r, e.create(t, i, o, n) }(e, t, n) : "mdxFlowExpression" === t.type || "mdxTextExpression" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) { const n = t.data.estree.body[0]; return n.type, e.evaluater.evaluateExpression(n.expression) } Ra(e, t.position) }(e, t) : "mdxJsxFlowElement" === t.type || "mdxJsxTextElement" === t.type ? function (e, t, n) { const r = e.schema; let s = r; "svg" === t.name && "html" === r.space && (s = Fo, e.schema = s), e.ancestors.push(t); const i = null === t.name ? e.Fragment : va(e, t.name, !0), o = function (e, t) { const n = {}; for (const r of t.attributes) if ("mdxJsxExpressionAttribute" === r.type) if (r.data && r.data.estree && e.evaluater) { const t = r.data.estree.body[0]; Vi(t.type); const s = t.expression; Vi(s.type); const i = s.properties[0]; Vi(i.type), Object.assign(n, e.evaluater.evaluateExpression(i.argument)) } else Ra(e, t.position); else { const s = r.name; let i; if (r.value && "object" == typeof r.value) if (r.value.data && r.value.data.estree && e.evaluater) { const t = r.value.data.estree.body[0]; Vi(t.type), i = e.evaluater.evaluateExpression(t.expression) } else Ra(e, t.position); else i = null === r.value || r.value; n[s] = i } return n }(e, t), a = Oa(e, t); return Na(e, o, i, t), Ia(o, a), e.ancestors.pop(), e.schema = r, e.create(t, i, o, n) }(e, t, n) : "mdxjsEsm" === t.type ? function (e, t) { if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree); Ra(e, t.position) }(e, t) : "root" === t.type ? function (e, t, n) { const r = {}; return Ia(r, Oa(e, t)), e.create(t, e.Fragment, r, n) }(e, t, n) : "text" === t.type ? function (e, t) { return t.value }(0, t) : void 0 } function Na(e, t, n, r) { "string" != typeof n && n !== e.Fragment && e.passNode && (t.node = r) } function Ia(e, t) { if (t.length > 0) { const n = t.length > 1 ? t : t[0]; n && (e.children = n) } } function Oa(e, t) { const n = []; let r = -1; const s = e.passKeys ? new Map : _a; for (; ++r < t.children.length;) { const i = t.children[r]; let o; if (e.passKeys) { const e = "element" === i.type ? i.tagName : "mdxJsxFlowElement" === i.type || "mdxJsxTextElement" === i.type ? i.name : void 0; if (e) { const t = s.get(e) || 0; o = e + "-" + t, s.set(e, t + 1) } } const a = Ca(e, i, o); void 0 !== a && n.push(a) } return n } function xa(e, t, n) { const r = Lo(e.schema, t); if (!(null == n || "number" == typeof n && Number.isNaN(n))) { if (Array.isArray(n) && (n = r.commaSeparated ? Ki(n) : Uo(n)), "style" === r.property) { let t = "object" == typeof n ? n : function (e, t) { try { return ua(t, { reactCompat: !0 }) } catch (n) { if (e.ignoreInvalidStyle) return {}; const t = n, r = new Ta("Cannot parse `style` attribute", { ancestors: e.ancestors, cause: t, ruleId: "style", source: "hast-util-to-jsx-runtime" }); throw r.file = e.filePath || void 0, r.url = ka + "#cannot-parse-style-attribute", r } }(e, String(n)); return "css" === e.stylePropertyNameCase && (t = function (e) { const t = {}; let n; for (n in e) Aa.call(e, n) && (t[Da(n)] = e[n]); return t }(t)), ["style", t] } return ["react" === e.elementAttributeNameCase && r.space ? xo[r.property] || r.property : r.attribute, n] } } function va(e, t, n) { let r; if (n) if (t.includes(".")) { const e = t.split("."); let n, s = -1; for (; ++s < e.length;) { const t = Zi(e[s]) ? { type: "Identifier", name: e[s] } : { type: "Literal", value: e[s] }; n = n ? { type: "MemberExpression", object: n, property: t, computed: Boolean(s && "Literal" === t.type), optional: !1 } : t } r = n } else r = Zi(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }; else r = { type: "Literal", value: t }; if ("Literal" === r.type) { const t = r.value; return Aa.call(e.components, t) ? e.components[t] : t } if (e.evaluater) return e.evaluater.evaluateExpression(r); Ra(e) } function Ra(e, t) { const n = new Ta("Cannot handle MDX estrees without `createEvaluater`", { ancestors: e.ancestors, place: t, ruleId: "mdx-estree", source: "hast-util-to-jsx-runtime" }); throw n.file = e.filePath || void 0, n.url = ka + "#cannot-handle-mdx-estrees-without-createevaluater", n } function Da(e) { let t = e.replace(ya, La); return "ms-" === t.slice(0, 3) && (t = "-" + t), t } function La(e) { return "-" + e.toLowerCase() } const Pa = { action: ["form"], cite: ["blockquote", "del", "ins", "q"], data: ["object"], formAction: ["button", "input"], href: ["a", "area", "base", "link"], icon: ["menuitem"], itemId: null, manifest: ["html"], ping: ["a", "area"], poster: ["video"], src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"] }, wa = {}; function Ma(e, t) { return Fa(e, "boolean" != typeof wa.includeImageAlt || wa.includeImageAlt, "boolean" != typeof wa.includeHtml || wa.includeHtml) } function Fa(e, t, n) { if (function (e) { return Boolean(e && "object" == typeof e) }(e)) { if ("value" in e) return "html" !== e.type || n ? e.value : ""; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return Ba(e.children, t, n) } return Array.isArray(e) ? Ba(e, t, n) : "" } function Ba(e, t, n) { const r = []; let s = -1; for (; ++s < e.length;)r[s] = Fa(e[s], t, n); return r.join("") } const Ua = document.createElement("i"); function Ha(e) { const t = "&" + e + ";"; Ua.innerHTML = t; const n = Ua.textContent; return (59 !== n.charCodeAt(n.length - 1) || "semi" === e) && n !== t && n } function ja(e, t, n, r) { const s = e.length; let i, o = 0; if (t = t < 0 ? -t > s ? 0 : s + t : t > s ? s : t, n = n > 0 ? n : 0, r.length < 1e4) i = Array.from(r), i.unshift(t, n), e.splice(...i); else for (n && e.splice(t, n); o < r.length;)i = r.slice(o, o + 1e4), i.unshift(t, 0), e.splice(...i), o += 1e4, t += 1e4 } function Ga(e, t) { return e.length > 0 ? (ja(e, e.length, 0, t), e) : t } const za = {}.hasOwnProperty; function Ya(e) { const t = {}; let n = -1; for (; ++n < e.length;)qa(t, e[n]); return t } function qa(e, t) { let n; for (n in t) { const r = (za.call(e, n) ? e[n] : void 0) || (e[n] = {}), s = t[n]; let i; if (s) for (i in s) { za.call(r, i) || (r[i] = []); const e = s[i]; Va(r[i], Array.isArray(e) ? e : e ? [e] : []) } } } function Va(e, t) { let n = -1; const r = []; for (; ++n < t.length;)("after" === t[n].add ? e : r).push(t[n]); ja(e, 0, 0, r) } function $a(e, t) { const n = Number.parseInt(e, t); return n < 9 || 11 === n || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || !(65535 & ~n) || 65534 == (65535 & n) || n > 1114111 ? "" : String.fromCodePoint(n) } function Wa(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const Ka = al(/[A-Za-z]/), Qa = al(/[\dA-Za-z]/), Xa = al(/[#-'*+\--9=?A-Z^-~]/); function Ja(e) { return null !== e && (e < 32 || 127 === e) } const Za = al(/\d/), el = al(/[\dA-Fa-f]/), tl = al(/[!-/:-@[-`{-~]/); function nl(e) { return null !== e && e < -2 } function rl(e) { return null !== e && (e < 0 || 32 === e) } function sl(e) { return -2 === e || -1 === e || 32 === e } const il = al(new RegExp("\\p{P}|\\p{S}", "u")), ol = al(/\s/); function al(e) { return function (t) { return null !== t && t > -1 && e.test(String.fromCharCode(t)) } } function ll(e) { const t = []; let n = -1, r = 0, s = 0; for (; ++n < e.length;) { const i = e.charCodeAt(n); let o = ""; if (37 === i && Qa(e.charCodeAt(n + 1)) && Qa(e.charCodeAt(n + 2))) s = 2; else if (i < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(i)) || (o = String.fromCharCode(i)); else if (i > 55295 && i < 57344) { const t = e.charCodeAt(n + 1); i < 56320 && t > 56319 && t < 57344 ? (o = String.fromCharCode(i, t), s = 1) : o = "" } else o = String.fromCharCode(i); o && (t.push(e.slice(r, n), encodeURIComponent(o)), r = n + s + 1, o = ""), s && (n += s, s = 0) } return t.join("") + e.slice(r) } function cl(e, t, n, r) { const s = r ? r - 1 : Number.POSITIVE_INFINITY; let i = 0; return function (r) { return sl(r) ? (e.enter(n), o(r)) : t(r) }; function o(r) { return sl(r) && i++ < s ? (e.consume(r), o) : (e.exit(n), t(r)) } } const ul = { tokenize: function (e) { const t = e.attempt(this.parser.constructs.contentInitial, function (n) { if (null !== n) return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), cl(e, t, "linePrefix"); e.consume(n) }, function (t) { return e.enter("paragraph"), r(t) }); let n; return t; function r(t) { const r = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = r), n = r, s(t) } function s(t) { return null === t ? (e.exit("chunkText"), e.exit("paragraph"), void e.consume(t)) : nl(t) ? (e.consume(t), e.exit("chunkText"), r) : (e.consume(t), s) } } }, hl = { tokenize: function (e) { const t = this, n = []; let r, s, i, o = 0; return a; function a(r) { if (o < n.length) { const s = n[o]; return t.containerState = s[1], e.attempt(s[0].continuation, l, c)(r) } return c(r) } function l(e) { if (o++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, r && T(); const n = t.events.length; let s, i = n; for (; i--;)if ("exit" === t.events[i][0] && "chunkFlow" === t.events[i][1].type) { s = t.events[i][1].end; break } E(o); let a = n; for (; a < t.events.length;)t.events[a][1].end = { ...s }, a++; return ja(t.events, i + 1, 0, t.events.slice(n)), t.events.length = a, c(e) } return a(e) } function c(s) { if (o === n.length) { if (!r) return d(s); if (r.currentConstruct && r.currentConstruct.concrete) return f(s); t.interrupt = Boolean(r.currentConstruct && !r._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(dl, u, h)(s) } function u(e) { return r && T(), E(o), d(e) } function h(e) { return t.parser.lazy[t.now().line] = o !== n.length, i = t.now().offset, f(e) } function d(n) { return t.containerState = {}, e.attempt(dl, p, f)(n) } function p(e) { return o++, n.push([t.currentConstruct, t.containerState]), d(e) } function f(n) { return null === n ? (r && T(), E(0), void e.consume(n)) : (r = r || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: r, contentType: "flow", previous: s }), m(n)) } function m(n) { return null === n ? (g(e.exit("chunkFlow"), !0), E(0), void e.consume(n)) : nl(n) ? (e.consume(n), g(e.exit("chunkFlow")), o = 0, t.interrupt = void 0, a) : (e.consume(n), m) } function g(e, n) { const a = t.sliceStream(e); if (n && a.push(null), e.previous = s, s && (s.next = e), s = e, r.defineSkip(e.start), r.write(a), t.parser.lazy[e.start.line]) { let e = r.events.length; for (; e--;)if (r.events[e][1].start.offset < i && (!r.events[e][1].end || r.events[e][1].end.offset > i)) return; const n = t.events.length; let s, a, l = n; for (; l--;)if ("exit" === t.events[l][0] && "chunkFlow" === t.events[l][1].type) { if (s) { a = t.events[l][1].end; break } s = !0 } for (E(o), e = n; e < t.events.length;)t.events[e][1].end = { ...a }, e++; ja(t.events, l + 1, 0, t.events.slice(n)), t.events.length = e } } function E(r) { let s = n.length; for (; s-- > r;) { const r = n[s]; t.containerState = r[1], r[0].exit.call(t, e) } n.length = r } function T() { r.write([null]), s = void 0, r = void 0, t.containerState._closeFlow = void 0 } } }, dl = { tokenize: function (e, t, n) { return cl(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } }; function pl(e) { return null === e || rl(e) || ol(e) ? 1 : il(e) ? 2 : void 0 } function fl(e, t, n) { const r = []; let s = -1; for (; ++s < e.length;) { const i = e[s].resolveAll; i && !r.includes(i) && (t = i(t, n), r.push(i)) } return t } const ml = { name: "attention", resolveAll: function (e, t) { let n, r, s, i, o, a, l, c, u = -1; for (; ++u < e.length;)if ("enter" === e[u][0] && "attentionSequence" === e[u][1].type && e[u][1]._close) for (n = u; n--;)if ("exit" === e[n][0] && "attentionSequence" === e[n][1].type && e[n][1]._open && t.sliceSerialize(e[n][1]).charCodeAt(0) === t.sliceSerialize(e[u][1]).charCodeAt(0)) { if ((e[n][1]._close || e[u][1]._open) && (e[u][1].end.offset - e[u][1].start.offset) % 3 && !((e[n][1].end.offset - e[n][1].start.offset + e[u][1].end.offset - e[u][1].start.offset) % 3)) continue; a = e[n][1].end.offset - e[n][1].start.offset > 1 && e[u][1].end.offset - e[u][1].start.offset > 1 ? 2 : 1; const h = { ...e[n][1].end }, d = { ...e[u][1].start }; gl(h, -a), gl(d, a), i = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: h, end: { ...e[n][1].end } }, o = { type: a > 1 ? "strongSequence" : "emphasisSequence", start: { ...e[u][1].start }, end: d }, s = { type: a > 1 ? "strongText" : "emphasisText", start: { ...e[n][1].end }, end: { ...e[u][1].start } }, r = { type: a > 1 ? "strong" : "emphasis", start: { ...i.start }, end: { ...o.end } }, e[n][1].end = { ...i.start }, e[u][1].start = { ...o.end }, l = [], e[n][1].end.offset - e[n][1].start.offset && (l = Ga(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])), l = Ga(l, [["enter", r, t], ["enter", i, t], ["exit", i, t], ["enter", s, t]]), l = Ga(l, fl(t.parser.constructs.insideSpan.null, e.slice(n + 1, u), t)), l = Ga(l, [["exit", s, t], ["enter", o, t], ["exit", o, t], ["exit", r, t]]), e[u][1].end.offset - e[u][1].start.offset ? (c = 2, l = Ga(l, [["enter", e[u][1], t], ["exit", e[u][1], t]])) : c = 0, ja(e, n - 1, u - n + 3, l), u = n + l.length - c - 2; break } for (u = -1; ++u < e.length;)"attentionSequence" === e[u][1].type && (e[u][1].type = "data"); return e }, tokenize: function (e, t) { const n = this.parser.constructs.attentionMarkers.null, r = this.previous, s = pl(r); let i; return function (t) { return i = t, e.enter("attentionSequence"), o(t) }; function o(a) { if (a === i) return e.consume(a), o; const l = e.exit("attentionSequence"), c = pl(a), u = !c || 2 === c && s || n.includes(a), h = !s || 2 === s && c || n.includes(r); return l._open = Boolean(42 === i ? u : u && (s || !h)), l._close = Boolean(42 === i ? h : h && (c || !u)), t(a) } } }; function gl(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const El = { name: "autolink", tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(t), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), s }; function s(t) { return Ka(t) ? (e.consume(t), i) : 64 === t ? n(t) : l(t) } function i(e) { return 43 === e || 45 === e || 46 === e || Qa(e) ? (r = 1, o(e)) : l(e) } function o(t) { return 58 === t ? (e.consume(t), r = 0, a) : (43 === t || 45 === t || 46 === t || Qa(t)) && r++ < 32 ? (e.consume(t), o) : (r = 0, l(t)) } function a(r) { return 62 === r ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(r), e.exit("autolinkMarker"), e.exit("autolink"), t) : null === r || 32 === r || 60 === r || Ja(r) ? n(r) : (e.consume(r), a) } function l(t) { return 64 === t ? (e.consume(t), c) : Xa(t) ? (e.consume(t), l) : n(t) } function c(e) { return Qa(e) ? u(e) : n(e) } function u(n) { return 46 === n ? (e.consume(n), r = 0, c) : 62 === n ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(n), e.exit("autolinkMarker"), e.exit("autolink"), t) : h(n) } function h(t) { if ((45 === t || Qa(t)) && r++ < 63) { const n = 45 === t ? h : u; return e.consume(t), n } return n(t) } } }, Tl = { partial: !0, tokenize: function (e, t, n) { return function (t) { return sl(t) ? cl(e, r, "linePrefix")(t) : r(t) }; function r(e) { return null === e || nl(e) ? t(e) : n(e) } } }, Al = { continuation: { tokenize: function (e, t, n) { const r = this; return function (t) { return sl(t) ? cl(e, s, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : s(t) }; function s(r) { return e.attempt(Al, t, n)(r) } } }, exit: function (e) { e.exit("blockQuote") }, name: "blockQuote", tokenize: function (e, t, n) { const r = this; return function (t) { if (62 === t) { const n = r.containerState; return n.open || (e.enter("blockQuote", { _container: !0 }), n.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(t), e.exit("blockQuoteMarker"), s } return n(t) }; function s(n) { return sl(n) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(n), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(n)) } } }, _l = { name: "characterEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(t), e.exit("escapeMarker"), r }; function r(r) { return tl(r) ? (e.enter("characterEscapeValue"), e.consume(r), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(r) } } }, yl = { name: "characterReference", tokenize: function (e, t, n) { const r = this; let s, i, o = 0; return function (t) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(t), e.exit("characterReferenceMarker"), a }; function a(t) { return 35 === t ? (e.enter("characterReferenceMarkerNumeric"), e.consume(t), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), s = 31, i = Qa, c(t)) } function l(t) { return 88 === t || 120 === t ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(t), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), s = 6, i = el, c) : (e.enter("characterReferenceValue"), s = 7, i = Za, c(t)) } function c(a) { if (59 === a && o) { const s = e.exit("characterReferenceValue"); return i !== Qa || Ha(r.sliceSerialize(s)) ? (e.enter("characterReferenceMarker"), e.consume(a), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) : n(a) } return i(a) && o++ < s ? (e.consume(a), c) : n(a) } } }, bl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return null === t ? n(t) : (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) }; function s(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, Sl = { concrete: !0, name: "codeFenced", tokenize: function (e, t, n) { const r = this, s = { partial: !0, tokenize: function (e, t, n) { let s = 0; return function (t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), o }; function o(t) { return e.enter("codeFencedFence"), sl(t) ? cl(e, l, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : l(t) } function l(t) { return t === i ? (e.enter("codeFencedFenceSequence"), c(t)) : n(t) } function c(t) { return t === i ? (s++, e.consume(t), c) : s >= a ? (e.exit("codeFencedFenceSequence"), sl(t) ? cl(e, u, "whitespace")(t) : u(t)) : n(t) } function u(r) { return null === r || nl(r) ? (e.exit("codeFencedFence"), t(r)) : n(r) } } }; let i, o = 0, a = 0; return function (t) { return function (t) { const n = r.events[r.events.length - 1]; return o = n && "linePrefix" === n[1].type ? n[2].sliceSerialize(n[1], !0).length : 0, i = t, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), l(t) }(t) }; function l(t) { return t === i ? (a++, e.consume(t), l) : a < 3 ? n(t) : (e.exit("codeFencedFenceSequence"), sl(t) ? cl(e, c, "whitespace")(t) : c(t)) } function c(n) { return null === n || nl(n) ? (e.exit("codeFencedFence"), r.interrupt ? t(n) : e.check(bl, p, T)(n)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), u(n)) } function u(t) { return null === t || nl(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), c(t)) : sl(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), cl(e, h, "whitespace")(t)) : 96 === t && t === i ? n(t) : (e.consume(t), u) } function h(t) { return null === t || nl(t) ? c(t) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), d(t)) } function d(t) { return null === t || nl(t) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), c(t)) : 96 === t && t === i ? n(t) : (e.consume(t), d) } function p(t) { return e.attempt(s, T, f)(t) } function f(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), m } function m(t) { return o > 0 && sl(t) ? cl(e, g, "linePrefix", o + 1)(t) : g(t) } function g(t) { return null === t || nl(t) ? e.check(bl, p, T)(t) : (e.enter("codeFlowValue"), E(t)) } function E(t) { return null === t || nl(t) ? (e.exit("codeFlowValue"), g(t)) : (e.consume(t), E) } function T(n) { return e.exit("codeFenced"), t(n) } } }, kl = { name: "codeIndented", tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("codeIndented"), cl(e, s, "linePrefix", 5)(t) }; function s(e) { const t = r.events[r.events.length - 1]; return t && "linePrefix" === t[1].type && t[2].sliceSerialize(t[1], !0).length >= 4 ? i(e) : n(e) } function i(t) { return null === t ? a(t) : nl(t) ? e.attempt(Cl, i, a)(t) : (e.enter("codeFlowValue"), o(t)) } function o(t) { return null === t || nl(t) ? (e.exit("codeFlowValue"), i(t)) : (e.consume(t), o) } function a(n) { return e.exit("codeIndented"), t(n) } } }, Cl = { partial: !0, tokenize: function (e, t, n) { const r = this; return s; function s(t) { return r.parser.lazy[r.now().line] ? n(t) : nl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : cl(e, i, "linePrefix", 5)(t) } function i(e) { const i = r.events[r.events.length - 1]; return i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(e) : nl(e) ? s(e) : n(e) } } }, Nl = { name: "codeText", previous: function (e) { return 96 !== e || "characterEscape" === this.events[this.events.length - 1][1].type }, resolve: function (e) { let t, n, r = e.length - 4, s = 3; if (!("lineEnding" !== e[s][1].type && "space" !== e[s][1].type || "lineEnding" !== e[r][1].type && "space" !== e[r][1].type)) for (t = s; ++t < r;)if ("codeTextData" === e[t][1].type) { e[s][1].type = "codeTextPadding", e[r][1].type = "codeTextPadding", s += 2, r -= 2; break } for (t = s - 1, r++; ++t <= r;)void 0 === n ? t !== r && "lineEnding" !== e[t][1].type && (n = t) : t !== r && "lineEnding" !== e[t][1].type || (e[n][1].type = "codeTextData", t !== n + 2 && (e[n][1].end = e[t - 1][1].end, e.splice(n + 2, t - n - 2), r -= t - n - 2, t = n + 2), n = void 0); return e }, tokenize: function (e, t, n) { let r, s, i = 0; return function (t) { return e.enter("codeText"), e.enter("codeTextSequence"), o(t) }; function o(t) { return 96 === t ? (e.consume(t), i++, o) : (e.exit("codeTextSequence"), a(t)) } function a(t) { return null === t ? n(t) : 32 === t ? (e.enter("space"), e.consume(t), e.exit("space"), a) : 96 === t ? (s = e.enter("codeTextSequence"), r = 0, c(t)) : nl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), a) : (e.enter("codeTextData"), l(t)) } function l(t) { return null === t || 32 === t || 96 === t || nl(t) ? (e.exit("codeTextData"), a(t)) : (e.consume(t), l) } function c(n) { return 96 === n ? (e.consume(n), r++, c) : r === i ? (e.exit("codeTextSequence"), e.exit("codeText"), t(n)) : (s.type = "codeTextData", l(n)) } } }; class Il { constructor(e) { this.left = e ? [...e] : [], this.right = [] } get(e) { if (e < 0 || e >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + e + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return e < this.left.length ? this.left[e] : this.right[this.right.length - e + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(e, t) { const n = null == t ? Number.POSITIVE_INFINITY : t; return n < this.left.length ? this.left.slice(e, n) : e > this.left.length ? this.right.slice(this.right.length - n + this.left.length, this.right.length - e + this.left.length).reverse() : this.left.slice(e).concat(this.right.slice(this.right.length - n + this.left.length).reverse()) } splice(e, t, n) { const r = t || 0; this.setCursor(Math.trunc(e)); const s = this.right.splice(this.right.length - r, Number.POSITIVE_INFINITY); return n && Ol(this.left, n), s.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(e) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(e) } pushMany(e) { this.setCursor(Number.POSITIVE_INFINITY), Ol(this.left, e) } unshift(e) { this.setCursor(0), this.right.push(e) } unshiftMany(e) { this.setCursor(0), Ol(this.right, e.reverse()) } setCursor(e) { if (!(e === this.left.length || e > this.left.length && 0 === this.right.length || e < 0 && 0 === this.left.length)) if (e < this.left.length) { const t = this.left.splice(e, Number.POSITIVE_INFINITY); Ol(this.right, t.reverse()) } else { const t = this.right.splice(this.left.length + this.right.length - e, Number.POSITIVE_INFINITY); Ol(this.left, t.reverse()) } } } function Ol(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function xl(e) { const t = {}; let n, r, s, i, o, a, l, c = -1; const u = new Il(e); for (; ++c < u.length;) { for (; c in t;)c = t[c]; if (n = u.get(c), c && "chunkFlow" === n[1].type && "listItemPrefix" === u.get(c - 1)[1].type && (a = n[1]._tokenizer.events, s = 0, s < a.length && "lineEndingBlank" === a[s][1].type && (s += 2), s < a.length && "content" === a[s][1].type)) for (; ++s < a.length && "content" !== a[s][1].type;)"chunkText" === a[s][1].type && (a[s][1]._isInFirstContentOfListItem = !0, s++); if ("enter" === n[0]) n[1].contentType && (Object.assign(t, vl(u, c)), c = t[c], l = !0); else if (n[1]._container) { for (s = c, r = void 0; s--;)if (i = u.get(s), "lineEnding" === i[1].type || "lineEndingBlank" === i[1].type) "enter" === i[0] && (r && (u.get(r)[1].type = "lineEndingBlank"), i[1].type = "lineEnding", r = s); else if ("linePrefix" !== i[1].type && "listItemIndent" !== i[1].type) break; r && (n[1].end = { ...u.get(r)[1].start }, o = u.slice(r, c), o.unshift(n), u.splice(r, c - r + 1, o)) } } return ja(e, 0, Number.POSITIVE_INFINITY, u.slice(0)), !l } function vl(e, t) { const n = e.get(t)[1], r = e.get(t)[2]; let s = t - 1; const i = []; let o = n._tokenizer; o || (o = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (o._contentTypeTextTrailing = !0)); const a = o.events, l = [], c = {}; let u, h, d = -1, p = n, f = 0, m = 0; const g = [m]; for (; p;) { for (; e.get(++s)[1] !== p;); i.push(s), p._tokenizer || (u = r.sliceStream(p), p.next || u.push(null), h && o.defineSkip(p.start), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = !0), o.write(u), p._isInFirstContentOfListItem && (o._gfmTasklistFirstContentOfListItem = void 0)), h = p, p = p.next } for (p = n; ++d < a.length;)"exit" === a[d][0] && "enter" === a[d - 1][0] && a[d][1].type === a[d - 1][1].type && a[d][1].start.line !== a[d][1].end.line && (m = d + 1, g.push(m), p._tokenizer = void 0, p.previous = void 0, p = p.next); for (o.events = [], p ? (p._tokenizer = void 0, p.previous = void 0) : g.pop(), d = g.length; d--;) { const t = a.slice(g[d], g[d + 1]), n = i.pop(); l.push([n, n + t.length - 1]), e.splice(n, 2, t) } for (l.reverse(), d = -1; ++d < l.length;)c[f + l[d][0]] = f + l[d][1], f += l[d][1] - l[d][0] - 1; return c } const Rl = { resolve: function (e) { return xl(e), e }, tokenize: function (e, t) { let n; return function (t) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), r(t) }; function r(t) { return null === t ? s(t) : nl(t) ? e.check(Dl, i, s)(t) : (e.consume(t), r) } function s(n) { return e.exit("chunkContent"), e.exit("content"), t(n) } function i(t) { return e.consume(t), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, r } } }, Dl = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), cl(e, s, "linePrefix") }; function s(s) { if (null === s || nl(s)) return n(s); const i = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && i && "linePrefix" === i[1].type && i[2].sliceSerialize(i[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s) } } }; function Ll(e, t, n, r, s, i, o, a, l) { const c = l || Number.POSITIVE_INFINITY; let u = 0; return function (t) { return 60 === t ? (e.enter(r), e.enter(s), e.enter(i), e.consume(t), e.exit(i), h) : null === t || 32 === t || 41 === t || Ja(t) ? n(t) : (e.enter(r), e.enter(o), e.enter(a), e.enter("chunkString", { contentType: "string" }), f(t)) }; function h(n) { return 62 === n ? (e.enter(i), e.consume(n), e.exit(i), e.exit(s), e.exit(r), t) : (e.enter(a), e.enter("chunkString", { contentType: "string" }), d(n)) } function d(t) { return 62 === t ? (e.exit("chunkString"), e.exit(a), h(t)) : null === t || 60 === t || nl(t) ? n(t) : (e.consume(t), 92 === t ? p : d) } function p(t) { return 60 === t || 62 === t || 92 === t ? (e.consume(t), d) : d(t) } function f(s) { return u || null !== s && 41 !== s && !rl(s) ? u < c && 40 === s ? (e.consume(s), u++, f) : 41 === s ? (e.consume(s), u--, f) : null === s || 32 === s || 40 === s || Ja(s) ? n(s) : (e.consume(s), 92 === s ? m : f) : (e.exit("chunkString"), e.exit(a), e.exit(o), e.exit(r), t(s)) } function m(t) { return 40 === t || 41 === t || 92 === t ? (e.consume(t), f) : f(t) } } function Pl(e, t, n, r, s, i) { const o = this; let a, l = 0; return function (t) { return e.enter(r), e.enter(s), e.consume(t), e.exit(s), e.enter(i), c }; function c(h) { return l > 999 || null === h || 91 === h || 93 === h && !a || 94 === h && !l && "_hiddenFootnoteSupport" in o.parser.constructs ? n(h) : 93 === h ? (e.exit(i), e.enter(s), e.consume(h), e.exit(s), e.exit(r), t) : nl(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), c) : (e.enter("chunkString", { contentType: "string" }), u(h)) } function u(t) { return null === t || 91 === t || 93 === t || nl(t) || l++ > 999 ? (e.exit("chunkString"), c(t)) : (e.consume(t), a || (a = !sl(t)), 92 === t ? h : u) } function h(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), l++, u) : u(t) } } function wl(e, t, n, r, s, i) { let o; return function (t) { return 34 === t || 39 === t || 40 === t ? (e.enter(r), e.enter(s), e.consume(t), e.exit(s), o = 40 === t ? 41 : t, a) : n(t) }; function a(n) { return n === o ? (e.enter(s), e.consume(n), e.exit(s), e.exit(r), t) : (e.enter(i), l(n)) } function l(t) { return t === o ? (e.exit(i), a(o)) : null === t ? n(t) : nl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), cl(e, l, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), c(t)) } function c(t) { return t === o || null === t || nl(t) ? (e.exit("chunkString"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return t === o || 92 === t ? (e.consume(t), c) : c(t) } } function Ml(e, t) { let n; return function r(s) { return nl(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), n = !0, r) : sl(s) ? cl(e, r, n ? "linePrefix" : "lineSuffix")(s) : t(s) } } const Fl = { name: "definition", tokenize: function (e, t, n) { const r = this; let s; return function (t) { return e.enter("definition"), function (t) { return Pl.call(r, e, i, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(t) }(t) }; function i(t) { return s = Wa(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), o) : n(t) } function o(t) { return rl(t) ? Ml(e, a)(t) : a(t) } function a(t) { return Ll(e, l, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(t) } function l(t) { return e.attempt(Bl, c, c)(t) } function c(t) { return sl(t) ? cl(e, u, "whitespace")(t) : u(t) } function u(i) { return null === i || nl(i) ? (e.exit("definition"), r.parser.defined.push(s), t(i)) : n(i) } } }, Bl = { partial: !0, tokenize: function (e, t, n) { return function (t) { return rl(t) ? Ml(e, r)(t) : n(t) }; function r(t) { return wl(e, s, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(t) } function s(t) { return sl(t) ? cl(e, i, "whitespace")(t) : i(t) } function i(e) { return null === e || nl(e) ? t(e) : n(e) } } }, Ul = { name: "hardBreakEscape", tokenize: function (e, t, n) { return function (t) { return e.enter("hardBreakEscape"), e.consume(t), r }; function r(r) { return nl(r) ? (e.exit("hardBreakEscape"), t(r)) : n(r) } } }, Hl = { name: "headingAtx", resolve: function (e, t) { let n, r, s = e.length - 2, i = 3; return "whitespace" === e[i][1].type && (i += 2), s - 2 > i && "whitespace" === e[s][1].type && (s -= 2), "atxHeadingSequence" === e[s][1].type && (i === s - 1 || s - 4 > i && "whitespace" === e[s - 2][1].type) && (s -= i + 1 === s ? 2 : 4), s > i && (n = { type: "atxHeadingText", start: e[i][1].start, end: e[s][1].end }, r = { type: "chunkText", start: e[i][1].start, end: e[s][1].end, contentType: "text" }, ja(e, i, s - i + 1, [["enter", n, t], ["enter", r, t], ["exit", r, t], ["exit", n, t]])), e }, tokenize: function (e, t, n) { let r = 0; return function (t) { return e.enter("atxHeading"), function (t) { return e.enter("atxHeadingSequence"), s(t) }(t) }; function s(t) { return 35 === t && r++ < 6 ? (e.consume(t), s) : null === t || rl(t) ? (e.exit("atxHeadingSequence"), i(t)) : n(t) } function i(n) { return 35 === n ? (e.enter("atxHeadingSequence"), o(n)) : null === n || nl(n) ? (e.exit("atxHeading"), t(n)) : sl(n) ? cl(e, i, "whitespace")(n) : (e.enter("atxHeadingText"), a(n)) } function o(t) { return 35 === t ? (e.consume(t), o) : (e.exit("atxHeadingSequence"), i(t)) } function a(t) { return null === t || 35 === t || rl(t) ? (e.exit("atxHeadingText"), i(t)) : (e.consume(t), a) } } }, jl = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], Gl = ["pre", "script", "style", "textarea"], zl = { concrete: !0, name: "htmlFlow", resolveTo: function (e) { let t = e.length; for (; t-- && ("enter" !== e[t][0] || "htmlFlow" !== e[t][1].type);); return t > 1 && "linePrefix" === e[t - 2][1].type && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e }, tokenize: function (e, t, n) { const r = this; let s, i, o, a, l; return function (t) { return function (t) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(t), c }(t) }; function c(a) { return 33 === a ? (e.consume(a), u) : 47 === a ? (e.consume(a), i = !0, p) : 63 === a ? (e.consume(a), s = 3, r.interrupt ? t : P) : Ka(a) ? (e.consume(a), o = String.fromCharCode(a), f) : n(a) } function u(i) { return 45 === i ? (e.consume(i), s = 2, h) : 91 === i ? (e.consume(i), s = 5, a = 0, d) : Ka(i) ? (e.consume(i), s = 4, r.interrupt ? t : P) : n(i) } function h(s) { return 45 === s ? (e.consume(s), r.interrupt ? t : P) : n(s) } function d(s) { return s === "CDATA[".charCodeAt(a++) ? (e.consume(s), 6 === a ? r.interrupt ? t : N : d) : n(s) } function p(t) { return Ka(t) ? (e.consume(t), o = String.fromCharCode(t), f) : n(t) } function f(a) { if (null === a || 47 === a || 62 === a || rl(a)) { const l = 47 === a, c = o.toLowerCase(); return l || i || !Gl.includes(c) ? jl.includes(o.toLowerCase()) ? (s = 6, l ? (e.consume(a), m) : r.interrupt ? t(a) : N(a)) : (s = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(a) : i ? g(a) : E(a)) : (s = 1, r.interrupt ? t(a) : N(a)) } return 45 === a || Qa(a) ? (e.consume(a), o += String.fromCharCode(a), f) : n(a) } function m(s) { return 62 === s ? (e.consume(s), r.interrupt ? t : N) : n(s) } function g(t) { return sl(t) ? (e.consume(t), g) : k(t) } function E(t) { return 47 === t ? (e.consume(t), k) : 58 === t || 95 === t || Ka(t) ? (e.consume(t), T) : sl(t) ? (e.consume(t), E) : k(t) } function T(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Qa(t) ? (e.consume(t), T) : A(t) } function A(t) { return 61 === t ? (e.consume(t), _) : sl(t) ? (e.consume(t), A) : E(t) } function _(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), l = t, y) : sl(t) ? (e.consume(t), _) : b(t) } function y(t) { return t === l ? (e.consume(t), l = null, S) : null === t || nl(t) ? n(t) : (e.consume(t), y) } function b(t) { return null === t || 34 === t || 39 === t || 47 === t || 60 === t || 61 === t || 62 === t || 96 === t || rl(t) ? A(t) : (e.consume(t), b) } function S(e) { return 47 === e || 62 === e || sl(e) ? E(e) : n(e) } function k(t) { return 62 === t ? (e.consume(t), C) : n(t) } function C(t) { return null === t || nl(t) ? N(t) : sl(t) ? (e.consume(t), C) : n(t) } function N(t) { return 45 === t && 2 === s ? (e.consume(t), v) : 60 === t && 1 === s ? (e.consume(t), R) : 62 === t && 4 === s ? (e.consume(t), w) : 63 === t && 3 === s ? (e.consume(t), P) : 93 === t && 5 === s ? (e.consume(t), L) : !nl(t) || 6 !== s && 7 !== s ? null === t || nl(t) ? (e.exit("htmlFlowData"), I(t)) : (e.consume(t), N) : (e.exit("htmlFlowData"), e.check(Yl, M, I)(t)) } function I(t) { return e.check(ql, O, M)(t) } function O(t) { return e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), x } function x(t) { return null === t || nl(t) ? I(t) : (e.enter("htmlFlowData"), N(t)) } function v(t) { return 45 === t ? (e.consume(t), P) : N(t) } function R(t) { return 47 === t ? (e.consume(t), o = "", D) : N(t) } function D(t) { if (62 === t) { const n = o.toLowerCase(); return Gl.includes(n) ? (e.consume(t), w) : N(t) } return Ka(t) && o.length < 8 ? (e.consume(t), o += String.fromCharCode(t), D) : N(t) } function L(t) { return 93 === t ? (e.consume(t), P) : N(t) } function P(t) { return 62 === t ? (e.consume(t), w) : 45 === t && 2 === s ? (e.consume(t), P) : N(t) } function w(t) { return null === t || nl(t) ? (e.exit("htmlFlowData"), M(t)) : (e.consume(t), w) } function M(n) { return e.exit("htmlFlow"), t(n) } } }, Yl = { partial: !0, tokenize: function (e, t, n) { return function (r) { return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), e.attempt(Tl, t, n) } } }, ql = { partial: !0, tokenize: function (e, t, n) { const r = this; return function (t) { return nl(t) ? (e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), s) : n(t) }; function s(e) { return r.parser.lazy[r.now().line] ? n(e) : t(e) } } }, Vl = { name: "htmlText", tokenize: function (e, t, n) { const r = this; let s, i, o; return function (t) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(t), a }; function a(t) { return 33 === t ? (e.consume(t), l) : 47 === t ? (e.consume(t), _) : 63 === t ? (e.consume(t), T) : Ka(t) ? (e.consume(t), S) : n(t) } function l(t) { return 45 === t ? (e.consume(t), c) : 91 === t ? (e.consume(t), i = 0, p) : Ka(t) ? (e.consume(t), E) : n(t) } function c(t) { return 45 === t ? (e.consume(t), d) : n(t) } function u(t) { return null === t ? n(t) : 45 === t ? (e.consume(t), h) : nl(t) ? (o = u, D(t)) : (e.consume(t), u) } function h(t) { return 45 === t ? (e.consume(t), d) : u(t) } function d(e) { return 62 === e ? R(e) : 45 === e ? h(e) : u(e) } function p(t) { return t === "CDATA[".charCodeAt(i++) ? (e.consume(t), 6 === i ? f : p) : n(t) } function f(t) { return null === t ? n(t) : 93 === t ? (e.consume(t), m) : nl(t) ? (o = f, D(t)) : (e.consume(t), f) } function m(t) { return 93 === t ? (e.consume(t), g) : f(t) } function g(t) { return 62 === t ? R(t) : 93 === t ? (e.consume(t), g) : f(t) } function E(t) { return null === t || 62 === t ? R(t) : nl(t) ? (o = E, D(t)) : (e.consume(t), E) } function T(t) { return null === t ? n(t) : 63 === t ? (e.consume(t), A) : nl(t) ? (o = T, D(t)) : (e.consume(t), T) } function A(e) { return 62 === e ? R(e) : T(e) } function _(t) { return Ka(t) ? (e.consume(t), y) : n(t) } function y(t) { return 45 === t || Qa(t) ? (e.consume(t), y) : b(t) } function b(t) { return nl(t) ? (o = b, D(t)) : sl(t) ? (e.consume(t), b) : R(t) } function S(t) { return 45 === t || Qa(t) ? (e.consume(t), S) : 47 === t || 62 === t || rl(t) ? k(t) : n(t) } function k(t) { return 47 === t ? (e.consume(t), R) : 58 === t || 95 === t || Ka(t) ? (e.consume(t), C) : nl(t) ? (o = k, D(t)) : sl(t) ? (e.consume(t), k) : R(t) } function C(t) { return 45 === t || 46 === t || 58 === t || 95 === t || Qa(t) ? (e.consume(t), C) : N(t) } function N(t) { return 61 === t ? (e.consume(t), I) : nl(t) ? (o = N, D(t)) : sl(t) ? (e.consume(t), N) : k(t) } function I(t) { return null === t || 60 === t || 61 === t || 62 === t || 96 === t ? n(t) : 34 === t || 39 === t ? (e.consume(t), s = t, O) : nl(t) ? (o = I, D(t)) : sl(t) ? (e.consume(t), I) : (e.consume(t), x) } function O(t) { return t === s ? (e.consume(t), s = void 0, v) : null === t ? n(t) : nl(t) ? (o = O, D(t)) : (e.consume(t), O) } function x(t) { return null === t || 34 === t || 39 === t || 60 === t || 61 === t || 96 === t ? n(t) : 47 === t || 62 === t || rl(t) ? k(t) : (e.consume(t), x) } function v(e) { return 47 === e || 62 === e || rl(e) ? k(e) : n(e) } function R(r) { return 62 === r ? (e.consume(r), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(r) } function D(t) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), L } function L(t) { return sl(t) ? cl(e, P, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : P(t) } function P(t) { return e.enter("htmlTextData"), o(t) } } }, $l = { name: "labelEnd", resolveAll: function (e) { let t = -1; const n = []; for (; ++t < e.length;) { const r = e[t][1]; if (n.push(e[t]), "labelImage" === r.type || "labelLink" === r.type || "labelEnd" === r.type) { const e = "labelImage" === r.type ? 4 : 2; r.type = "data", t += e } } return e.length !== n.length && ja(e, 0, e.length, n), e }, resolveTo: function (e, t) { let n, r, s, i, o = e.length, a = 0; for (; o--;)if (n = e[o][1], r) { if ("link" === n.type || "labelLink" === n.type && n._inactive) break; "enter" === e[o][0] && "labelLink" === n.type && (n._inactive = !0) } else if (s) { if ("enter" === e[o][0] && ("labelImage" === n.type || "labelLink" === n.type) && !n._balanced && (r = o, "labelLink" !== n.type)) { a = 2; break } } else "labelEnd" === n.type && (s = o); const l = { type: "labelLink" === e[r][1].type ? "link" : "image", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }, c = { type: "label", start: { ...e[r][1].start }, end: { ...e[s][1].end } }, u = { type: "labelText", start: { ...e[r + a + 2][1].end }, end: { ...e[s - 2][1].start } }; return i = [["enter", l, t], ["enter", c, t]], i = Ga(i, e.slice(r + 1, r + a + 3)), i = Ga(i, [["enter", u, t]]), i = Ga(i, fl(t.parser.constructs.insideSpan.null, e.slice(r + a + 4, s - 3), t)), i = Ga(i, [["exit", u, t], e[s - 2], e[s - 1], ["exit", c, t]]), i = Ga(i, e.slice(s + 1)), i = Ga(i, [["exit", l, t]]), ja(e, r, e.length, i), e }, tokenize: function (e, t, n) { const r = this; let s, i, o = r.events.length; for (; o--;)if (("labelImage" === r.events[o][1].type || "labelLink" === r.events[o][1].type) && !r.events[o][1]._balanced) { s = r.events[o][1]; break } return function (t) { return s ? s._inactive ? u(t) : (i = r.parser.defined.includes(Wa(r.sliceSerialize({ start: s.end, end: r.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelEnd"), a) : n(t) }; function a(t) { return 40 === t ? e.attempt(Wl, c, i ? c : u)(t) : 91 === t ? e.attempt(Kl, c, i ? l : u)(t) : i ? c(t) : u(t) } function l(t) { return e.attempt(Ql, c, u)(t) } function c(e) { return t(e) } function u(e) { return s._balanced = !0, n(e) } } }, Wl = { tokenize: function (e, t, n) { return function (t) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(t), e.exit("resourceMarker"), r }; function r(t) { return rl(t) ? Ml(e, s)(t) : s(t) } function s(t) { return 41 === t ? c(t) : Ll(e, i, o, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(t) } function i(t) { return rl(t) ? Ml(e, a)(t) : c(t) } function o(e) { return n(e) } function a(t) { return 34 === t || 39 === t || 40 === t ? wl(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(t) : c(t) } function l(t) { return rl(t) ? Ml(e, c)(t) : c(t) } function c(r) { return 41 === r ? (e.enter("resourceMarker"), e.consume(r), e.exit("resourceMarker"), e.exit("resource"), t) : n(r) } } }, Kl = { tokenize: function (e, t, n) { const r = this; return function (t) { return Pl.call(r, e, s, i, "reference", "referenceMarker", "referenceString")(t) }; function s(e) { return r.parser.defined.includes(Wa(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(e) : n(e) } function i(e) { return n(e) } } }, Ql = { tokenize: function (e, t, n) { return function (t) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(t), e.exit("referenceMarker"), r }; function r(r) { return 93 === r ? (e.enter("referenceMarker"), e.consume(r), e.exit("referenceMarker"), e.exit("reference"), t) : n(r) } } }, Xl = { name: "labelStartImage", resolveAll: $l.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(t), e.exit("labelImageMarker"), s }; function s(t) { return 91 === t ? (e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelImage"), i) : n(t) } function i(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }, Jl = { name: "labelStartLink", resolveAll: $l.resolveAll, tokenize: function (e, t, n) { const r = this; return function (t) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(t), e.exit("labelMarker"), e.exit("labelLink"), s }; function s(e) { return 94 === e && "_hiddenFootnoteSupport" in r.parser.constructs ? n(e) : t(e) } } }, Zl = { name: "lineEnding", tokenize: function (e, t) { return function (n) { return e.enter("lineEnding"), e.consume(n), e.exit("lineEnding"), cl(e, t, "linePrefix") } } }, ec = { name: "thematicBreak", tokenize: function (e, t, n) { let r, s = 0; return function (t) { return e.enter("thematicBreak"), function (e) { return r = e, i(e) }(t) }; function i(i) { return i === r ? (e.enter("thematicBreakSequence"), o(i)) : s >= 3 && (null === i || nl(i)) ? (e.exit("thematicBreak"), t(i)) : n(i) } function o(t) { return t === r ? (e.consume(t), s++, o) : (e.exit("thematicBreakSequence"), sl(t) ? cl(e, i, "whitespace")(t) : i(t)) } } }, tc = { continuation: { tokenize: function (e, t, n) { const r = this; return r.containerState._closeFlow = void 0, e.check(Tl, function (n) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, cl(e, t, "listItemIndent", r.containerState.size + 1)(n) }, function (n) { return r.containerState.furtherBlankLines || !sl(n) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(n)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(rc, t, s)(n)) }); function s(s) { return r.containerState._closeFlow = !0, r.interrupt = void 0, cl(e, e.attempt(tc, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) } } }, exit: function (e) { e.exit(this.containerState.type) }, name: "list", tokenize: function (e, t, n) { const r = this, s = r.events[r.events.length - 1]; let i = s && "linePrefix" === s[1].type ? s[2].sliceSerialize(s[1], !0).length : 0, o = 0; return function (t) { const s = r.containerState.type || (42 === t || 43 === t || 45 === t ? "listUnordered" : "listOrdered"); if ("listUnordered" === s ? !r.containerState.marker || t === r.containerState.marker : Za(t)) { if (r.containerState.type || (r.containerState.type = s, e.enter(s, { _container: !0 })), "listUnordered" === s) return e.enter("listItemPrefix"), 42 === t || 45 === t ? e.check(ec, n, l)(t) : l(t); if (!r.interrupt || 49 === t) return e.enter("listItemPrefix"), e.enter("listItemValue"), a(t) } return n(t) }; function a(t) { return Za(t) && ++o < 10 ? (e.consume(t), a) : (!r.interrupt || o < 2) && (r.containerState.marker ? t === r.containerState.marker : 41 === t || 46 === t) ? (e.exit("listItemValue"), l(t)) : n(t) } function l(t) { return e.enter("listItemMarker"), e.consume(t), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || t, e.check(Tl, r.interrupt ? n : c, e.attempt(nc, h, u)) } function c(e) { return r.containerState.initialBlankLine = !0, i++, h(e) } function u(t) { return sl(t) ? (e.enter("listItemPrefixWhitespace"), e.consume(t), e.exit("listItemPrefixWhitespace"), h) : n(t) } function h(n) { return r.containerState.size = i + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(n) } } }, nc = { partial: !0, tokenize: function (e, t, n) { const r = this; return cl(e, function (e) { const s = r.events[r.events.length - 1]; return !sl(e) && s && "listItemPrefixWhitespace" === s[1].type ? t(e) : n(e) }, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5) } }, rc = { partial: !0, tokenize: function (e, t, n) { const r = this; return cl(e, function (e) { const s = r.events[r.events.length - 1]; return s && "listItemIndent" === s[1].type && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(e) : n(e) }, "listItemIndent", r.containerState.size + 1) } }, sc = { name: "setextUnderline", resolveTo: function (e, t) { let n, r, s, i = e.length; for (; i--;)if ("enter" === e[i][0]) { if ("content" === e[i][1].type) { n = i; break } "paragraph" === e[i][1].type && (r = i) } else "content" === e[i][1].type && e.splice(i, 1), s || "definition" !== e[i][1].type || (s = i); const o = { type: "setextHeading", start: { ...e[n][1].start }, end: { ...e[e.length - 1][1].end } }; return e[r][1].type = "setextHeadingText", s ? (e.splice(r, 0, ["enter", o, t]), e.splice(s + 1, 0, ["exit", e[n][1], t]), e[n][1].end = { ...e[s][1].end }) : e[n][1] = o, e.push(["exit", o, t]), e }, tokenize: function (e, t, n) { const r = this; let s; return function (t) { let o, a = r.events.length; for (; a--;)if ("lineEnding" !== r.events[a][1].type && "linePrefix" !== r.events[a][1].type && "content" !== r.events[a][1].type) { o = "paragraph" === r.events[a][1].type; break } return r.parser.lazy[r.now().line] || !r.interrupt && !o ? n(t) : (e.enter("setextHeadingLine"), s = t, function (t) { return e.enter("setextHeadingLineSequence"), i(t) }(t)) }; function i(t) { return t === s ? (e.consume(t), i) : (e.exit("setextHeadingLineSequence"), sl(t) ? cl(e, o, "lineSuffix")(t) : o(t)) } function o(r) { return null === r || nl(r) ? (e.exit("setextHeadingLine"), t(r)) : n(r) } } }, ic = { tokenize: function (e) { const t = this, n = e.attempt(Tl, function (r) { if (null !== r) return e.enter("lineEndingBlank"), e.consume(r), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n; e.consume(r) }, e.attempt(this.parser.constructs.flowInitial, r, cl(e, e.attempt(this.parser.constructs.flow, r, e.attempt(Rl, r)), "linePrefix"))); return n; function r(r) { if (null !== r) return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), t.currentConstruct = void 0, n; e.consume(r) } } }, oc = { resolveAll: uc() }, ac = cc("string"), lc = cc("text"); function cc(e) { return { resolveAll: uc("text" === e ? hc : void 0), tokenize: function (t) { const n = this, r = this.parser.constructs[e], s = t.attempt(r, i, o); return i; function i(e) { return l(e) ? s(e) : o(e) } function o(e) { if (null !== e) return t.enter("data"), t.consume(e), a; t.consume(e) } function a(e) { return l(e) ? (t.exit("data"), s(e)) : (t.consume(e), a) } function l(e) { if (null === e) return !0; const t = r[e]; let s = -1; if (t) for (; ++s < t.length;) { const e = t[s]; if (!e.previous || e.previous.call(n, n.previous)) return !0 } return !1 } } } } function uc(e) { return function (t, n) { let r, s = -1; for (; ++s <= t.length;)void 0 === r ? t[s] && "data" === t[s][1].type && (r = s, s++) : t[s] && "data" === t[s][1].type || (s !== r + 2 && (t[r][1].end = t[s - 1][1].end, t.splice(r + 2, s - r - 2), s = r + 2), r = void 0); return e ? e(t, n) : t } } function hc(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || "lineEnding" === e[n][1].type) && "data" === e[n - 1][1].type) { const r = e[n - 1][1], s = t.sliceStream(r); let i, o = s.length, a = -1, l = 0; for (; o--;) { const e = s[o]; if ("string" == typeof e) { for (a = e.length; 32 === e.charCodeAt(a - 1);)l++, a--; if (a) break; a = -1 } else if (-2 === e) i = !0, l++; else if (-1 !== e) { o++; break } } if (t._contentTypeTextTrailing && n === e.length && (l = 0), l) { const s = { type: n === e.length || i || l < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: o ? a : r.start._bufferIndex + a, _index: r.start._index + o, line: r.end.line, column: r.end.column - l, offset: r.end.offset - l }, end: { ...r.end } }; r.end = { ...s.start }, r.start.offset === r.end.offset ? Object.assign(r, s) : (e.splice(n, 0, ["enter", s, t], ["exit", s, t]), n += 2) } n++ } return e } const dc = { 42: tc, 43: tc, 45: tc, 48: tc, 49: tc, 50: tc, 51: tc, 52: tc, 53: tc, 54: tc, 55: tc, 56: tc, 57: tc, 62: Al }, pc = { 91: Fl }, fc = { [-2]: kl, [-1]: kl, 32: kl }, mc = { 35: Hl, 42: ec, 45: [sc, ec], 60: zl, 61: sc, 95: ec, 96: Sl, 126: Sl }, gc = { 38: yl, 92: _l }, Ec = { [-5]: Zl, [-4]: Zl, [-3]: Zl, 33: Xl, 38: yl, 42: ml, 60: [El, Vl], 91: Jl, 92: [Ul, _l], 93: $l, 95: ml, 96: Nl }, Tc = { null: [ml, oc] }, Ac = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: { null: [42, 95] }, contentInitial: pc, disable: { null: [] }, document: dc, flow: mc, flowInitial: fc, insideSpan: Tc, string: gc, text: Ec }, Symbol.toStringTag, { value: "Module" })); function _c(e, t, n) { let r = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const s = {}, i = []; let o = [], a = []; const l = { attempt: m(function (e, t) { g(e, t.from) }), check: m(f), consume: function (e) { nl(e) ? (r.line++, r.column = 1, r.offset += -3 === e ? 2 : 1, E()) : -1 !== e && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === o[r._index].length && (r._bufferIndex = -1, r._index++)), c.previous = e }, enter: function (e, t) { const n = t || {}; return n.type = e, n.start = d(), c.events.push(["enter", n, c]), a.push(n), n }, exit: function (e) { const t = a.pop(); return t.end = d(), c.events.push(["exit", t, c]), t }, interrupt: m(f, { interrupt: !0 }) }, c = { code: null, containerState: {}, defineSkip: function (e) { s[e.line] = e.column, E() }, events: [], now: d, parser: e, previous: null, sliceSerialize: function (e, t) { return function (e, t) { let n = -1; const r = []; let s; for (; ++n < e.length;) { const i = e[n]; let o; if ("string" == typeof i) o = i; else switch (i) { case -5: o = "\r"; break; case -4: o = "\n"; break; case -3: o = "\r\n"; break; case -2: o = t ? " " : "\t"; break; case -1: if (!t && s) continue; o = " "; break; default: o = String.fromCharCode(i) }s = -2 === i, r.push(o) } return r.join("") }(h(e), t) }, sliceStream: h, write: function (e) { return o = Ga(o, e), function () { let e; for (; r._index < o.length;) { const t = o[r._index]; if ("string" == typeof t) for (e = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === e && r._bufferIndex < t.length;)p(t.charCodeAt(r._bufferIndex)); else p(t) } }(), null !== o[o.length - 1] ? [] : (g(t, 0), c.events = fl(i, c.events, c), c.events) } }; let u = t.tokenize.call(c, l); return t.resolveAll && i.push(t), c; function h(e) { return function (e, t) { const n = t.start._index, r = t.start._bufferIndex, s = t.end._index, i = t.end._bufferIndex; let o; if (n === s) o = [e[n].slice(r, i)]; else { if (o = e.slice(n, s), r > -1) { const e = o[0]; "string" == typeof e ? o[0] = e.slice(r) : o.shift() } i > 0 && o.push(e[s].slice(0, i)) } return o }(o, e) } function d() { const { _bufferIndex: e, _index: t, line: n, column: s, offset: i } = r; return { _bufferIndex: e, _index: t, line: n, column: s, offset: i } } function p(e) { u = u(e) } function f(e, t) { t.restore() } function m(e, t) { return function (n, s, i) { let o, u, h, p; return Array.isArray(n) ? m(n) : "tokenize" in n ? m([n]) : (f = n, function (e) { const t = null !== e && f[e], n = null !== e && f.null; return m([...Array.isArray(t) ? t : t ? [t] : [], ...Array.isArray(n) ? n : n ? [n] : []])(e) }); var f; function m(e) { return o = e, u = 0, 0 === e.length ? i : g(e[u]) } function g(e) { return function (n) { return p = function () { const e = d(), t = c.previous, n = c.currentConstruct, s = c.events.length, i = Array.from(a); return { from: s, restore: function () { r = e, c.previous = t, c.currentConstruct = n, c.events.length = s, a = i, E() } } }(), h = e, e.partial || (c.currentConstruct = e), e.name && c.parser.constructs.disable.null.includes(e.name) ? A() : e.tokenize.call(t ? Object.assign(Object.create(c), t) : c, l, T, A)(n) } } function T(t) { return e(h, p), s } function A(e) { return p.restore(), ++u < o.length ? g(o[u]) : i } } } function g(e, t) { e.resolveAll && !i.includes(e) && i.push(e), e.resolve && ja(c.events, t, c.events.length - t, e.resolve(c.events.slice(t), c)), e.resolveTo && (c.events = e.resolveTo(c.events, c)) } function E() { r.line in s && r.column < 2 && (r.column = s[r.line], r.offset += s[r.line] - 1) } } const yc = /[\0\t\n\r]/g, bc = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function Sc(e, t, n) { if (t) return t; if (35 === n.charCodeAt(0)) { const e = n.charCodeAt(1), t = 120 === e || 88 === e; return $a(n.slice(t ? 2 : 1), t ? 16 : 10) } return Ha(n) || e } const kc = {}.hasOwnProperty; function Cc(e, t, n) { return "string" != typeof t && (n = t, t = void 0), function (e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: s(T), autolinkProtocol: u, autolinkEmail: u, atxHeading: s(m), blockQuote: s(function () { return { type: "blockquote", children: [] } }), characterEscape: u, characterReference: u, codeFenced: s(f), codeFencedFenceInfo: i, codeFencedFenceMeta: i, codeIndented: s(f, i), codeText: s(function () { return { type: "inlineCode", value: "" } }, i), codeTextData: u, data: u, codeFlowValue: u, definition: s(function () { return { type: "definition", identifier: "", label: null, title: null, url: "" } }), definitionDestinationString: i, definitionLabelString: i, definitionTitleString: i, emphasis: s(function () { return { type: "emphasis", children: [] } }), hardBreakEscape: s(g), hardBreakTrailing: s(g), htmlFlow: s(E, i), htmlFlowData: u, htmlText: s(E, i), htmlTextData: u, image: s(function () { return { type: "image", title: null, url: "", alt: null } }), label: i, link: s(T), listItem: s(function (e) { return { type: "listItem", spread: e._spread, checked: null, children: [] } }), listItemValue: function (e) { this.data.expectingFirstListItemValue && (this.stack[this.stack.length - 2].start = Number.parseInt(this.sliceSerialize(e), 10), this.data.expectingFirstListItemValue = void 0) }, listOrdered: s(A, function () { this.data.expectingFirstListItemValue = !0 }), listUnordered: s(A), paragraph: s(function () { return { type: "paragraph", children: [] } }), reference: function () { this.data.referenceType = "collapsed" }, referenceString: i, resourceDestinationString: i, resourceTitleString: i, setextHeading: s(m), strong: s(function () { return { type: "strong", children: [] } }), thematicBreak: s(function () { return { type: "thematicBreak" } }) }, exit: { atxHeading: a(), atxHeadingSequence: function (e) { const t = this.stack[this.stack.length - 1]; if (!t.depth) { const n = this.sliceSerialize(e).length; t.depth = n } }, autolink: a(), autolinkEmail: function (e) { h.call(this, e), this.stack[this.stack.length - 1].url = "mailto:" + this.sliceSerialize(e) }, autolinkProtocol: function (e) { h.call(this, e), this.stack[this.stack.length - 1].url = this.sliceSerialize(e) }, blockQuote: a(), characterEscapeValue: h, characterReferenceMarkerHexadecimal: p, characterReferenceMarkerNumeric: p, characterReferenceValue: function (e) { const t = this.sliceSerialize(e), n = this.data.characterReferenceType; let r; n ? (r = $a(t, "characterReferenceMarkerNumeric" === n ? 10 : 16), this.data.characterReferenceType = void 0) : r = Ha(t); this.stack[this.stack.length - 1].value += r }, characterReference: function (e) { this.stack.pop().position.end = Nc(e.end) }, codeFenced: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 }), codeFencedFence: function () { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) }, codeFencedFenceInfo: function () { const e = this.resume(); this.stack[this.stack.length - 1].lang = e }, codeFencedFenceMeta: function () { const e = this.resume(); this.stack[this.stack.length - 1].meta = e }, codeFlowValue: h, codeIndented: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e.replace(/(\r?\n|\r)$/g, "") }), codeText: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), codeTextData: h, data: h, definition: a(), definitionDestinationString: function () { const e = this.resume(); this.stack[this.stack.length - 1].url = e }, definitionLabelString: function (e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = Wa(this.sliceSerialize(e)).toLowerCase() }, definitionTitleString: function () { const e = this.resume(); this.stack[this.stack.length - 1].title = e }, emphasis: a(), hardBreakEscape: a(d), hardBreakTrailing: a(d), htmlFlow: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), htmlFlowData: h, htmlText: a(function () { const e = this.resume(); this.stack[this.stack.length - 1].value = e }), htmlTextData: h, image: a(function () { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 }), label: function () { const e = this.stack[this.stack.length - 1], t = this.resume(), n = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, "link" === n.type) { const t = e.children; n.children = t } else n.alt = t }, labelText: function (e) { const t = this.sliceSerialize(e), n = this.stack[this.stack.length - 2]; n.label = function (e) { return e.replace(bc, Sc) }(t), n.identifier = Wa(t).toLowerCase() }, lineEnding: function (e) { const n = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) return n.children[n.children.length - 1].position.end = Nc(e.end), void (this.data.atHardBreak = void 0); !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(n.type) && (u.call(this, e), h.call(this, e)) }, link: a(function () { const e = this.stack[this.stack.length - 1]; if (this.data.inReference) { const t = this.data.referenceType || "shortcut"; e.type += "Reference", e.referenceType = t, delete e.url, delete e.title } else delete e.identifier, delete e.label; this.data.referenceType = void 0 }), listItem: a(), listOrdered: a(), listUnordered: a(), paragraph: a(), referenceString: function (e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.label = t, n.identifier = Wa(this.sliceSerialize(e)).toLowerCase(), this.data.referenceType = "full" }, resourceDestinationString: function () { const e = this.resume(); this.stack[this.stack.length - 1].url = e }, resourceTitleString: function () { const e = this.resume(); this.stack[this.stack.length - 1].title = e }, resource: function () { this.data.inReference = void 0 }, setextHeading: a(function () { this.data.setextHeadingSlurpLineEnding = void 0 }), setextHeadingLineSequence: function (e) { this.stack[this.stack.length - 1].depth = 61 === this.sliceSerialize(e).codePointAt(0) ? 1 : 2 }, setextHeadingText: function () { this.data.setextHeadingSlurpLineEnding = !0 }, strong: a(), thematicBreak: a() } }; Ic(t, (e || {}).mdastExtensions || []); const n = {}; return function (e) { let s = { type: "root", children: [] }; const a = { stack: [s], tokenStack: [], config: t, enter: o, exit: l, buffer: i, resume: c, data: n }, u = []; let h = -1; for (; ++h < e.length;)"listOrdered" !== e[h][1].type && "listUnordered" !== e[h][1].type || ("enter" === e[h][0] ? u.push(h) : h = r(e, u.pop(), h)); for (h = -1; ++h < e.length;) { const n = t[e[h][0]]; kc.call(n, e[h][1].type) && n[e[h][1].type].call(Object.assign({ sliceSerialize: e[h][2].sliceSerialize }, a), e[h][1]) } if (a.tokenStack.length > 0) { const e = a.tokenStack[a.tokenStack.length - 1]; (e[1] || xc).call(a, void 0, e[0]) } for (s.position = { start: Nc(e.length > 0 ? e[0][1].start : { line: 1, column: 1, offset: 0 }), end: Nc(e.length > 0 ? e[e.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, h = -1; ++h < t.transforms.length;)s = t.transforms[h](s) || s; return s }; function r(e, t, n) { let r, s, i, o, a = t - 1, l = -1, c = !1; for (; ++a <= n;) { const t = e[a]; switch (t[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": "enter" === t[0] ? l++ : l--, o = void 0; break; case "lineEndingBlank": "enter" === t[0] && (!r || o || l || i || (i = a), o = void 0); break; case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: o = void 0 }if (!l && "enter" === t[0] && "listItemPrefix" === t[1].type || -1 === l && "exit" === t[0] && ("listUnordered" === t[1].type || "listOrdered" === t[1].type)) { if (r) { let o = a; for (s = void 0; o--;) { const t = e[o]; if ("lineEnding" === t[1].type || "lineEndingBlank" === t[1].type) { if ("exit" === t[0]) continue; s && (e[s][1].type = "lineEndingBlank", c = !0), t[1].type = "lineEnding", s = o } else if ("linePrefix" !== t[1].type && "blockQuotePrefix" !== t[1].type && "blockQuotePrefixWhitespace" !== t[1].type && "blockQuoteMarker" !== t[1].type && "listItemIndent" !== t[1].type) break } i && (!s || i < s) && (r._spread = !0), r.end = Object.assign({}, s ? e[s][1].start : t[1].end), e.splice(s || a, 0, ["exit", r, t[2]]), a++, n++ } if ("listItemPrefix" === t[1].type) { const s = { type: "listItem", _spread: !1, start: Object.assign({}, t[1].start), end: void 0 }; r = s, e.splice(a, 0, ["enter", s, t[2]]), a++, n++, i = void 0, o = !0 } } } return e[t][1]._spread = c, n } function s(e, t) { return function (n) { o.call(this, e(n), n), t && t.call(this, n) } } function i() { this.stack.push({ type: "fragment", children: [] }) } function o(e, t, n) { this.stack[this.stack.length - 1].children.push(e), this.stack.push(e), this.tokenStack.push([t, n || void 0]), e.position = { start: Nc(t.start), end: void 0 } } function a(e) { return function (t) { e && e.call(this, t), l.call(this, t) } } function l(e, t) { const n = this.stack.pop(), r = this.tokenStack.pop(); if (!r) throw new Error("Cannot close `" + e.type + "` (" + fa({ start: e.start, end: e.end }) + "): its not open"); r[0].type !== e.type && (t ? t.call(this, e, r[0]) : (r[1] || xc).call(this, e, r[0])), n.position.end = Nc(e.end) } function c() { return Ma(this.stack.pop()) } function u(e) { const t = this.stack[this.stack.length - 1].children; let n = t[t.length - 1]; n && "text" === n.type || (n = { type: "text", value: "" }, n.position = { start: Nc(e.start), end: void 0 }, t.push(n)), this.stack.push(n) } function h(e) { const t = this.stack.pop(); t.value += this.sliceSerialize(e), t.position.end = Nc(e.end) } function d() { this.data.atHardBreak = !0 } function p(e) { this.data.characterReferenceType = e.type } function f() { return { type: "code", lang: null, meta: null, value: "" } } function m() { return { type: "heading", depth: 0, children: [] } } function g() { return { type: "break" } } function E() { return { type: "html", value: "" } } function T() { return { type: "link", title: null, url: "", children: [] } } function A(e) { return { type: "list", ordered: "listOrdered" === e.type, start: null, spread: e._spread, children: [] } } }(n)(function (e) { for (; !xl(e);); return e }(function (e) { const t = { constructs: Ya([Ac, ...(e || {}).extensions || []]), content: n(ul), defined: [], document: n(hl), flow: n(ic), lazy: {}, string: n(ac), text: n(lc) }; return t; function n(e) { return function (n) { return _c(t, e, n) } } }(n).document().write(function () { let e, t = 1, n = "", r = !0; return function (s, i, o) { const a = []; let l, c, u, h, d; for (s = n + ("string" == typeof s ? s.toString() : new TextDecoder(i || void 0).decode(s)), u = 0, n = "", r && (65279 === s.charCodeAt(0) && u++, r = void 0); u < s.length;) { if (yc.lastIndex = u, l = yc.exec(s), h = l && void 0 !== l.index ? l.index : s.length, d = s.charCodeAt(h), !l) { n = s.slice(u); break } if (10 === d && u === h && e) a.push(-3), e = void 0; else switch (e && (a.push(-5), e = void 0), u < h && (a.push(s.slice(u, h)), t += h - u), d) { case 0: a.push(65533), t++; break; case 9: for (c = 4 * Math.ceil(t / 4), a.push(-2); t++ < c;)a.push(-1); break; case 10: a.push(-4), t = 1; break; default: e = !0, t = 1 }u = h + 1 } return o && (e && a.push(-5), n && a.push(n), a.push(null)), a } }()(e, t, !0)))) } function Nc(e) { return { line: e.line, column: e.column, offset: e.offset } } function Ic(e, t) { let n = -1; for (; ++n < t.length;) { const r = t[n]; Array.isArray(r) ? Ic(e, r) : Oc(e, r) } } function Oc(e, t) { let n; for (n in t) if (kc.call(t, n)) switch (n) { case "canContainEols": { const r = t[n]; r && e[n].push(...r); break } case "transforms": { const r = t[n]; r && e[n].push(...r); break } case "enter": case "exit": { const r = t[n]; r && Object.assign(e[n], r); break } } } function xc(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + fa({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + fa({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + fa({ start: t.start, end: t.end }) + ") is still open") } function vc(e) { const t = this; t.parser = function (n) { return Cc(n, { ...t.data("settings"), ...e, extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] }) } } function Rc(e, t) { const n = t.referenceType; let r = "]"; if ("collapsed" === n ? r += "[]" : "full" === n && (r += "[" + (t.label || t.identifier) + "]"), "imageReference" === t.type) return [{ type: "text", value: "![" + t.alt + r }]; const s = e.all(t), i = s[0]; i && "text" === i.type ? i.value = "[" + i.value : s.unshift({ type: "text", value: "[" }); const o = s[s.length - 1]; return o && "text" === o.type ? o.value += r : s.push({ type: "text", value: r }), s } function Dc(e) { const t = e.spread; return null == t ? e.children.length > 1 : t } function Lc(e) { const t = String(e), n = /\r?\n|\r/g; let r = n.exec(t), s = 0; const i = []; for (; r;)i.push(Pc(t.slice(s, r.index), s > 0, !0), r[0]), s = r.index + r[0].length, r = n.exec(t); return i.push(Pc(t.slice(s), s > 0, !1)), i.join("") } function Pc(e, t, n) { let r = 0, s = e.length; if (t) { let t = e.codePointAt(r); for (; 9 === t || 32 === t;)r++, t = e.codePointAt(r) } if (n) { let t = e.codePointAt(s - 1); for (; 9 === t || 32 === t;)s--, t = e.codePointAt(s - 1) } return s > r ? e.slice(r, s) : "" } const wc = { blockquote: function (e, t) { const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }; return e.patch(t, n), e.applyData(t, n) }, break: function (e, t) { const n = { type: "element", tagName: "br", properties: {}, children: [] }; return e.patch(t, n), [e.applyData(t, n), { type: "text", value: "\n" }] }, code: function (e, t) { const n = t.value ? t.value + "\n" : "", r = {}, s = t.lang ? t.lang.split(/\s+/) : []; s.length > 0 && (r.className = ["language-" + s[0]]); let i = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }; return t.meta && (i.data = { meta: t.meta }), e.patch(t, i), i = e.applyData(t, i), i = { type: "element", tagName: "pre", properties: {}, children: [i] }, e.patch(t, i), i }, delete: function (e, t) { const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, emphasis: function (e, t) { const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, footnoteReference: function (e, t) { const n = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), s = ll(r.toLowerCase()), i = e.footnoteOrder.indexOf(r); let o, a = e.footnoteCounts.get(r); void 0 === a ? (a = 0, e.footnoteOrder.push(r), o = e.footnoteOrder.length) : o = i + 1, a += 1, e.footnoteCounts.set(r, a); const l = { type: "element", tagName: "a", properties: { href: "#" + n + "fn-" + s, id: n + "fnref-" + s + (a > 1 ? "-" + a : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(o) }] }; e.patch(t, l); const c = { type: "element", tagName: "sup", properties: {}, children: [l] }; return e.patch(t, c), e.applyData(t, c) }, heading: function (e, t) { const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, html: function (e, t) { if (e.options.allowDangerousHtml) { const n = { type: "raw", value: t.value }; return e.patch(t, n), e.applyData(t, n) } }, imageReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Rc(e, t); const s = { src: ll(r.url || ""), alt: t.alt }; null !== r.title && void 0 !== r.title && (s.title = r.title); const i = { type: "element", tagName: "img", properties: s, children: [] }; return e.patch(t, i), e.applyData(t, i) }, image: function (e, t) { const n = { src: ll(t.url) }; null !== t.alt && void 0 !== t.alt && (n.alt = t.alt), null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "img", properties: n, children: [] }; return e.patch(t, r), e.applyData(t, r) }, inlineCode: function (e, t) { const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }; e.patch(t, n); const r = { type: "element", tagName: "code", properties: {}, children: [n] }; return e.patch(t, r), e.applyData(t, r) }, linkReference: function (e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return Rc(e, t); const s = { href: ll(r.url || "") }; null !== r.title && void 0 !== r.title && (s.title = r.title); const i = { type: "element", tagName: "a", properties: s, children: e.all(t) }; return e.patch(t, i), e.applyData(t, i) }, link: function (e, t) { const n = { href: ll(t.url) }; null !== t.title && void 0 !== t.title && (n.title = t.title); const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) }, listItem: function (e, t, n) { const r = e.all(t), s = n ? function (e) { let t = !1; if ("list" === e.type) { t = e.spread || !1; const n = e.children; let r = -1; for (; !t && ++r < n.length;)t = Dc(n[r]) } return t }(n) : Dc(t), i = {}, o = []; if ("boolean" == typeof t.checked) { const e = r[0]; let n; e && "element" === e.type && "p" === e.tagName ? n = e : (n = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(n)), n.children.length > 0 && n.children.unshift({ type: "text", value: " " }), n.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: t.checked, disabled: !0 }, children: [] }), i.className = ["task-list-item"] } let a = -1; for (; ++a < r.length;) { const e = r[a]; (s || 0 !== a || "element" !== e.type || "p" !== e.tagName) && o.push({ type: "text", value: "\n" }), "element" !== e.type || "p" !== e.tagName || s ? o.push(e) : o.push(...e.children) } const l = r[r.length - 1]; l && (s || "element" !== l.type || "p" !== l.tagName) && o.push({ type: "text", value: "\n" }); const c = { type: "element", tagName: "li", properties: i, children: o }; return e.patch(t, c), e.applyData(t, c) }, list: function (e, t) { const n = {}, r = e.all(t); let s = -1; for ("number" == typeof t.start && 1 !== t.start && (n.start = t.start); ++s < r.length;) { const e = r[s]; if ("element" === e.type && "li" === e.tagName && e.properties && Array.isArray(e.properties.className) && e.properties.className.includes("task-list-item")) { n.className = ["contains-task-list"]; break } } const i = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }; return e.patch(t, i), e.applyData(t, i) }, paragraph: function (e, t) { const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, root: function (e, t) { const n = { type: "root", children: e.wrap(e.all(t)) }; return e.patch(t, n), e.applyData(t, n) }, strong: function (e, t) { const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, table: function (e, t) { const n = e.all(t), r = n.shift(), s = []; if (r) { const n = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }; e.patch(t.children[0], n), s.push(n) } if (n.length > 0) { const r = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) }, i = da(t.children[1]), o = ha(t.children[t.children.length - 1]); i && o && (r.position = { start: i, end: o }), s.push(r) } const i = { type: "element", tagName: "table", properties: {}, children: e.wrap(s, !0) }; return e.patch(t, i), e.applyData(t, i) }, tableCell: function (e, t) { const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) }, tableRow: function (e, t, n) { const r = n ? n.children : void 0, s = 0 === (r ? r.indexOf(t) : 1) ? "th" : "td", i = n && "table" === n.type ? n.align : void 0, o = i ? i.length : t.children.length; let a = -1; const l = []; for (; ++a < o;) { const n = t.children[a], r = {}, o = i ? i[a] : void 0; o && (r.align = o); let c = { type: "element", tagName: s, properties: r, children: [] }; n && (c.children = e.all(n), e.patch(n, c), c = e.applyData(n, c)), l.push(c) } const c = { type: "element", tagName: "tr", properties: {}, children: e.wrap(l, !0) }; return e.patch(t, c), e.applyData(t, c) }, text: function (e, t) { const n = { type: "text", value: Lc(String(t.value)) }; return e.patch(t, n), e.applyData(t, n) }, thematicBreak: function (e, t) { const n = { type: "element", tagName: "hr", properties: {}, children: [] }; return e.patch(t, n), e.applyData(t, n) }, toml: Mc, yaml: Mc, definition: Mc, footnoteDefinition: Mc }; function Mc() { } const Fc = "object" == typeof self ? self : globalThis, Bc = e => ((e, t) => { const n = (t, n) => (e.set(n, t), t), r = s => { if (e.has(s)) return e.get(s); const [i, o] = t[s]; switch (i) { case 0: case -1: return n(o, s); case 1: { const e = n([], s); for (const t of o) e.push(r(t)); return e } case 2: { const e = n({}, s); for (const [t, n] of o) e[r(t)] = r(n); return e } case 3: return n(new Date(o), s); case 4: { const { source: e, flags: t } = o; return n(new RegExp(e, t), s) } case 5: { const e = n(new Map, s); for (const [t, n] of o) e.set(r(t), r(n)); return e } case 6: { const e = n(new Set, s); for (const t of o) e.add(r(t)); return e } case 7: { const { name: e, message: t } = o; return n(new Fc[e](t), s) } case 8: return n(BigInt(o), s); case "BigInt": return n(Object(BigInt(o)), s); case "ArrayBuffer": return n(new Uint8Array(o).buffer, o); case "DataView": { const { buffer: e } = new Uint8Array(o); return n(new DataView(e), o) } }return n(new Fc[i](o), s) }; return r })(new Map, e)(0), Uc = "", { toString: Hc } = {}, { keys: jc } = Object, Gc = e => { const t = typeof e; if ("object" !== t || !e) return [0, t]; const n = Hc.call(e).slice(8, -1); switch (n) { case "Array": return [1, Uc]; case "Object": return [2, Uc]; case "Date": return [3, Uc]; case "RegExp": return [4, Uc]; case "Map": return [5, Uc]; case "Set": return [6, Uc]; case "DataView": return [1, n] }return n.includes("Array") ? [1, n] : n.includes("Error") ? [7, n] : [2, n] }, zc = ([e, t]) => 0 === e && ("function" === t || "symbol" === t), Yc = (e, { json: t, lossy: n } = {}) => { const r = []; return ((e, t, n, r) => { const s = (e, t) => { const s = r.push(e) - 1; return n.set(t, s), s }, i = r => { if (n.has(r)) return n.get(r); let [o, a] = Gc(r); switch (o) { case 0: { let t = r; switch (a) { case "bigint": o = 8, t = r.toString(); break; case "function": case "symbol": if (e) throw new TypeError("unable to serialize " + a); t = null; break; case "undefined": return s([-1], r) }return s([o, t], r) } case 1: { if (a) { let e = r; return "DataView" === a ? e = new Uint8Array(r.buffer) : "ArrayBuffer" === a && (e = new Uint8Array(r)), s([a, [...e]], r) } const e = [], t = s([o, e], r); for (const n of r) e.push(i(n)); return t } case 2: { if (a) switch (a) { case "BigInt": return s([a, r.toString()], r); case "Boolean": case "Number": case "String": return s([a, r.valueOf()], r) }if (t && "toJSON" in r) return i(r.toJSON()); const n = [], l = s([o, n], r); for (const t of jc(r)) !e && zc(Gc(r[t])) || n.push([i(t), i(r[t])]); return l } case 3: return s([o, r.toISOString()], r); case 4: { const { source: e, flags: t } = r; return s([o, { source: e, flags: t }], r) } case 5: { const t = [], n = s([o, t], r); for (const [s, o] of r) (e || !zc(Gc(s)) && !zc(Gc(o))) && t.push([i(s), i(o)]); return n } case 6: { const t = [], n = s([o, t], r); for (const s of r) !e && zc(Gc(s)) || t.push(i(s)); return n } }const { message: l } = r; return s([o, { name: a, message: l }], r) }; return i })(!(t || n), !!t, new Map, r)(e), r }, qc = "function" == typeof structuredClone ? (e, t) => t && ("json" in t || "lossy" in t) ? Bc(Yc(e, t)) : structuredClone(e) : (e, t) => Bc(Yc(e, t)); function Vc(e, t) { const n = [{ type: "text", value: "" }]; return t > 1 && n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }), n } function $c(e, t) { return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "") } const Wc = function (e) { if (null == e) return Qc; if ("function" == typeof e) return Kc(e); if ("object" == typeof e) return Array.isArray(e) ? function (e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = Wc(e[n]); return Kc(function (...e) { let n = -1; for (; ++n < t.length;)if (t[n].apply(this, e)) return !0; return !1 }) }(e) : function (e) { const t = e; return Kc(function (n) { const r = n; let s; for (s in e) if (r[s] !== t[s]) return !1; return !0 }) }(e); if ("string" == typeof e) return t = e, Kc(function (e) { return e && e.type === t }); var t; throw new Error("Expected function, string, or object as test") }; function Kc(e) { return function (t, n, r) { return Boolean(function (e) { return null !== e && "object" == typeof e && "type" in e }(t) && e.call(this, t, "number" == typeof n ? n : void 0, r || void 0)) } } function Qc() { return !0 } const Xc = [], Jc = !1; function Zc(e, t, n, r) { let s; "function" == typeof t && "function" != typeof n ? (r = n, n = t) : s = t; const i = Wc(s), o = r ? -1 : 1; !function e(s, a, l) { const c = s && "object" == typeof s ? s : {}; if ("string" == typeof c.type) { const e = "string" == typeof c.tagName ? c.tagName : "string" == typeof c.name ? c.name : void 0; Object.defineProperty(u, "name", { value: "node (" + s.type + (e ? "<" + e + ">" : "") + ")" }) } return u; function u() { let c, u, h, d = Xc; if ((!t || i(s, a, l[l.length - 1] || void 0)) && (d = function (e) { return Array.isArray(e) ? e : "number" == typeof e ? [true, e] : null == e ? Xc : [e] }(n(s, l)), d[0] === Jc)) return d; if ("children" in s && s.children) { const t = s; if (t.children && "skip" !== d[0]) for (u = (r ? t.children.length : -1) + o, h = l.concat(t); u > -1 && u < t.children.length;) { const n = t.children[u]; if (c = e(n, u, h)(), c[0] === Jc) return c; u = "number" == typeof c[1] ? c[1] : u + o } } return d } }(e, void 0, [])() } function eu(e, t, n, r) { let s, i, o; "function" == typeof t && "function" != typeof n ? (i = void 0, o = t, s = n) : (i = t, o = n, s = r), Zc(e, i, function (e, t) { const n = t[t.length - 1], r = n ? n.children.indexOf(e) : void 0; return o(e, r, n) }, s) } const tu = {}.hasOwnProperty, nu = {}; function ru(e, t) { e.position && (t.position = function (e) { const t = da(e), n = ha(e); if (t && n) return { start: t, end: n } }(e)) } function su(e, t) { let n = t; if (e && e.data) { const t = e.data.hName, r = e.data.hChildren, s = e.data.hProperties; "string" == typeof t && ("element" === n.type ? n.tagName = t : n = { type: "element", tagName: t, properties: {}, children: "children" in n ? n.children : [n] }), "element" === n.type && s && Object.assign(n.properties, qc(s)), "children" in n && n.children && null != r && (n.children = r) } return n } function iu(e, t) { const n = t.data || {}, r = !("value" in t) || tu.call(n, "hProperties") || tu.call(n, "hChildren") ? { type: "element", tagName: "div", properties: {}, children: e.all(t) } : { type: "text", value: t.value }; return e.patch(t, r), e.applyData(t, r) } function ou(e, t) { const n = []; let r = -1; for (t && n.push({ type: "text", value: "\n" }); ++r < e.length;)r && n.push({ type: "text", value: "\n" }), n.push(e[r]); return t && e.length > 0 && n.push({ type: "text", value: "\n" }), n } function au(e) { let t = 0, n = e.charCodeAt(t); for (; 9 === n || 32 === n;)t++, n = e.charCodeAt(t); return e.slice(t) } function lu(e, t) { const n = function (e, t) { const n = t || nu, r = new Map, s = new Map, i = new Map, o = { ...wc, ...n.handlers }, a = { all: function (e) { const t = []; if ("children" in e) { const n = e.children; let r = -1; for (; ++r < n.length;) { const s = a.one(n[r], e); if (s) { if (r && "break" === n[r - 1].type && (Array.isArray(s) || "text" !== s.type || (s.value = au(s.value)), !Array.isArray(s) && "element" === s.type)) { const e = s.children[0]; e && "text" === e.type && (e.value = au(e.value)) } Array.isArray(s) ? t.push(...s) : t.push(s) } } } return t }, applyData: su, definitionById: r, footnoteById: s, footnoteCounts: i, footnoteOrder: [], handlers: o, one: function (e, t) { const n = e.type, r = a.handlers[n]; if (tu.call(a.handlers, n) && r) return r(a, e, t); if (a.options.passThrough && a.options.passThrough.includes(n)) { if ("children" in e) { const { children: t, ...n } = e, r = qc(n); return r.children = a.all(e), r } return qc(e) } return (a.options.unknownHandler || iu)(a, e, t) }, options: n, patch: ru, wrap: ou }; return eu(e, function (e) { if ("definition" === e.type || "footnoteDefinition" === e.type) { const t = "definition" === e.type ? r : s, n = String(e.identifier).toUpperCase(); t.has(n) || t.set(n, e) } }), a }(e, t), r = n.one(e, void 0), s = function (e) { const t = "string" == typeof e.options.clobberPrefix ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || Vc, r = e.options.footnoteBackLabel || $c, s = e.options.footnoteLabel || "Footnotes", i = e.options.footnoteLabelTagName || "h2", o = e.options.footnoteLabelProperties || { className: ["sr-only"] }, a = []; let l = -1; for (; ++l < e.footnoteOrder.length;) { const s = e.footnoteById.get(e.footnoteOrder[l]); if (!s) continue; const i = e.all(s), o = String(s.identifier).toUpperCase(), c = ll(o.toLowerCase()); let u = 0; const h = [], d = e.footnoteCounts.get(o); for (; void 0 !== d && ++u <= d;) { h.length > 0 && h.push({ type: "text", value: " " }); let e = "string" == typeof n ? n : n(l, u); "string" == typeof e && (e = { type: "text", value: e }), h.push({ type: "element", tagName: "a", properties: { href: "#" + t + "fnref-" + c + (u > 1 ? "-" + u : ""), dataFootnoteBackref: "", ariaLabel: "string" == typeof r ? r : r(l, u), className: ["data-footnote-backref"] }, children: Array.isArray(e) ? e : [e] }) } const p = i[i.length - 1]; if (p && "element" === p.type && "p" === p.tagName) { const e = p.children[p.children.length - 1]; e && "text" === e.type ? e.value += " " : p.children.push({ type: "text", value: " " }), p.children.push(...h) } else i.push(...h); const f = { type: "element", tagName: "li", properties: { id: t + "fn-" + c }, children: e.wrap(i, !0) }; e.patch(s, f), a.push(f) } if (0 !== a.length) return { type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: i, properties: { ...qc(o), id: "footnote-label" }, children: [{ type: "text", value: s }] }, { type: "text", value: "\n" }, { type: "element", tagName: "ol", properties: {}, children: e.wrap(a, !0) }, { type: "text", value: "\n" }] } }(n), i = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }; return s && i.children.push({ type: "text", value: "\n" }, s), i } function cu(e, t) { return e && "run" in e ? async function (n, r) { const s = lu(n, { file: r, ...t }); await e.run(s, r) } : function (n, r) { return lu(n, { file: r, ...e || t }) } } function uu(e) { if (e) throw e } var hu = Object.prototype.hasOwnProperty, du = Object.prototype.toString, pu = Object.defineProperty, fu = Object.getOwnPropertyDescriptor, mu = function (e) { return "function" == typeof Array.isArray ? Array.isArray(e) : "[object Array]" === du.call(e) }, gu = function (e) { if (!e || "[object Object]" !== du.call(e)) return !1; var t, n = hu.call(e, "constructor"), r = e.constructor && e.constructor.prototype && hu.call(e.constructor.prototype, "isPrototypeOf"); if (e.constructor && !n && !r) return !1; for (t in e); return void 0 === t || hu.call(e, t) }, Eu = function (e, t) { pu && "__proto__" === t.name ? pu(e, t.name, { enumerable: !0, configurable: !0, value: t.newValue, writable: !0 }) : e[t.name] = t.newValue }, Tu = function (e, t) { if ("__proto__" === t) { if (!hu.call(e, t)) return; if (fu) return fu(e, t).value } return e[t] }; const Au = i(function e() { var t, n, r, s, i, o, a = arguments[0], l = 1, c = arguments.length, u = !1; for ("boolean" == typeof a && (u = a, a = arguments[1] || {}, l = 2), (null == a || "object" != typeof a && "function" != typeof a) && (a = {}); l < c; ++l)if (null != (t = arguments[l])) for (n in t) r = Tu(a, n), a !== (s = Tu(t, n)) && (u && s && (gu(s) || (i = mu(s))) ? (i ? (i = !1, o = r && mu(r) ? r : []) : o = r && gu(r) ? r : {}, Eu(a, { name: n, newValue: e(u, o, s) })) : void 0 !== s && Eu(a, { name: n, newValue: s })); return a }); function _u(e) { if ("object" != typeof e || null === e) return !1; const t = Object.getPrototypeOf(e); return !(null !== t && t !== Object.prototype && null !== Object.getPrototypeOf(t) || Symbol.toStringTag in e || Symbol.iterator in e) } const yu = function (e, t) { if (void 0 !== t && "string" != typeof t) throw new TypeError('"ext" argument must be a string'); Nu(e); let n, r = 0, s = -1, i = e.length; if (void 0 === t || 0 === t.length || t.length > e.length) { for (; i--;)if (47 === e.codePointAt(i)) { if (n) { r = i + 1; break } } else s < 0 && (n = !0, s = i + 1); return s < 0 ? "" : e.slice(r, s) } if (t === e) return ""; let o = -1, a = t.length - 1; for (; i--;)if (47 === e.codePointAt(i)) { if (n) { r = i + 1; break } } else o < 0 && (n = !0, o = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (s = i) : (a = -1, s = o)); return r === s ? s = o : s < 0 && (s = e.length), e.slice(r, s) }, bu = function (e) { if (Nu(e), 0 === e.length) return "."; let t, n = -1, r = e.length; for (; --r;)if (47 === e.codePointAt(r)) { if (t) { n = r; break } } else t || (t = !0); return n < 0 ? 47 === e.codePointAt(0) ? "/" : "." : 1 === n && 47 === e.codePointAt(0) ? "//" : e.slice(0, n) }, Su = function (e) { Nu(e); let t, n = e.length, r = -1, s = 0, i = -1, o = 0; for (; n--;) { const a = e.codePointAt(n); if (47 !== a) r < 0 && (t = !0, r = n + 1), 46 === a ? i < 0 ? i = n : 1 !== o && (o = 1) : i > -1 && (o = -1); else if (t) { s = n + 1; break } } return i < 0 || r < 0 || 0 === o || 1 === o && i === r - 1 && i === s + 1 ? "" : e.slice(i, r) }, ku = function (...e) { let t, n = -1; for (; ++n < e.length;)Nu(e[n]), e[n] && (t = void 0 === t ? e[n] : t + "/" + e[n]); return void 0 === t ? "." : function (e) { Nu(e); const t = 47 === e.codePointAt(0); let n = function (e, t) { let n, r, s = "", i = 0, o = -1, a = 0, l = -1; for (; ++l <= e.length;) { if (l < e.length) n = e.codePointAt(l); else { if (47 === n) break; n = 47 } if (47 === n) { if (o === l - 1 || 1 === a); else if (o !== l - 1 && 2 === a) { if (s.length < 2 || 2 !== i || 46 !== s.codePointAt(s.length - 1) || 46 !== s.codePointAt(s.length - 2)) if (s.length > 2) { if (r = s.lastIndexOf("/"), r !== s.length - 1) { r < 0 ? (s = "", i = 0) : (s = s.slice(0, r), i = s.length - 1 - s.lastIndexOf("/")), o = l, a = 0; continue } } else if (s.length > 0) { s = "", i = 0, o = l, a = 0; continue } t && (s = s.length > 0 ? s + "/.." : "..", i = 2) } else s.length > 0 ? s += "/" + e.slice(o + 1, l) : s = e.slice(o + 1, l), i = l - o - 1; o = l, a = 0 } else 46 === n && a > -1 ? a++ : a = -1 } return s }(e, !t); return 0 !== n.length || t || (n = "."), n.length > 0 && 47 === e.codePointAt(e.length - 1) && (n += "/"), t ? "/" + n : n }(t) }, Cu = "/"; function Nu(e) { if ("string" != typeof e) throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const Iu = function () { return "/" }; function Ou(e) { return Boolean(null !== e && "object" == typeof e && "href" in e && e.href && "protocol" in e && e.protocol && void 0 === e.auth) } const xu = ["history", "path", "basename", "stem", "extname", "dirname"]; class vu { constructor(e) { let t; t = e ? Ou(e) ? { path: e } : "string" == typeof e || function (e) { return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e) }(e) ? { value: e } : e : {}, this.cwd = "cwd" in t ? "" : Iu(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let n, r = -1; for (; ++r < xu.length;) { const e = xu[r]; e in t && void 0 !== t[e] && null !== t[e] && (this[e] = "history" === e ? [...t[e]] : t[e]) } for (n in t) xu.includes(n) || (this[n] = t[n]) } get basename() { return "string" == typeof this.path ? yu(this.path) : void 0 } set basename(e) { Du(e, "basename"), Ru(e, "basename"), this.path = ku(this.dirname || "", e) } get dirname() { return "string" == typeof this.path ? bu(this.path) : void 0 } set dirname(e) { Lu(this.basename, "dirname"), this.path = ku(e || "", this.basename) } get extname() { return "string" == typeof this.path ? Su(this.path) : void 0 } set extname(e) { if (Ru(e, "extname"), Lu(this.dirname, "extname"), e) { if (46 !== e.codePointAt(0)) throw new Error("`extname` must start with `.`"); if (e.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = ku(this.dirname, this.stem + (e || "")) } get path() { return this.history[this.history.length - 1] } set path(e) { Ou(e) && (e = function (e) { if ("string" == typeof e) e = new URL(e); else if (!Ou(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if ("file:" !== e.protocol) { const e = new TypeError("The URL must be of scheme file"); throw e.code = "ERR_INVALID_URL_SCHEME", e } return function (e) { if ("" !== e.hostname) { const e = new TypeError('File URL host must be "localhost" or empty on darwin'); throw e.code = "ERR_INVALID_FILE_URL_HOST", e } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (37 === t.codePointAt(n) && 50 === t.codePointAt(n + 1)) { const e = t.codePointAt(n + 2); if (70 === e || 102 === e) { const e = new TypeError("File URL path must not include encoded / characters"); throw e.code = "ERR_INVALID_FILE_URL_PATH", e } } return decodeURIComponent(t) }(e) }(e)), Du(e, "path"), this.path !== e && this.history.push(e) } get stem() { return "string" == typeof this.path ? yu(this.path, this.extname) : void 0 } set stem(e) { Du(e, "stem"), Ru(e, "stem"), this.path = ku(this.dirname || "", e + (this.extname || "")) } fail(e, t, n) { const r = this.message(e, t, n); throw r.fatal = !0, r } info(e, t, n) { const r = this.message(e, t, n); return r.fatal = void 0, r } message(e, t, n) { const r = new Ta(e, t, n); return this.path && (r.name = this.path + ":" + r.name, r.file = this.path), r.fatal = !1, this.messages.push(r), r } toString(e) { return void 0 === this.value ? "" : "string" == typeof this.value ? this.value : new TextDecoder(e || void 0).decode(this.value) } } function Ru(e, t) { if (e && e.includes(Cu)) throw new Error("`" + t + "` cannot be a path: did not expect `" + Cu + "`") } function Du(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function Lu(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } const Pu = function (e) { const t = this.constructor.prototype, n = t[e], r = function () { return n.apply(r, arguments) }; return Object.setPrototypeOf(r, t), r }, wu = {}.hasOwnProperty; class Mu extends Pu { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = function () { const e = [], t = { run: function (...t) { let n = -1; const r = t.pop(); if ("function" != typeof r) throw new TypeError("Expected function as last argument, not " + r); !function s(i, ...o) { const a = e[++n]; let l = -1; if (i) r(i); else { for (; ++l < t.length;)null !== o[l] && void 0 !== o[l] || (o[l] = t[l]); t = o, a ? function (e, t) { let n; return function (...t) { const o = e.length > t.length; let a; o && t.push(r); try { a = e.apply(this, t) } catch (i) { if (o && n) throw i; return r(i) } o || (a && a.then && "function" == typeof a.then ? a.then(s, r) : a instanceof Error ? r(a) : s(a)) }; function r(e, ...r) { n || (n = !0, t(e, ...r)) } function s(e) { r(null, e) } }(a, s)(...o) : r(null, ...o) } }(null, ...t) }, use: function (n) { if ("function" != typeof n) throw new TypeError("Expected `middelware` to be a function, not " + n); return e.push(n), t } }; return t }() } copy() { const e = new Mu; let t = -1; for (; ++t < this.attachers.length;) { const n = this.attachers[t]; e.use(...n) } return e.data(Au(!0, {}, this.namespace)), e } data(e, t) { return "string" == typeof e ? 2 === arguments.length ? (Hu("data", this.frozen), this.namespace[e] = t, this) : wu.call(this.namespace, e) && this.namespace[e] || void 0 : e ? (Hu("data", this.frozen), this.namespace = e, this) : this.namespace } freeze() { if (this.frozen) return this; const e = this; for (; ++this.freezeIndex < this.attachers.length;) { const [t, ...n] = this.attachers[this.freezeIndex]; if (!1 === n[0]) continue; !0 === n[0] && (n[0] = void 0); const r = t.call(e, ...n); "function" == typeof r && this.transformers.use(r) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(e) { this.freeze(); const t = zu(e), n = this.parser || this.Parser; return Bu("parse", n), n(String(t), t) } process(e, t) { const n = this; return this.freeze(), Bu("process", this.parser || this.Parser), Uu("process", this.compiler || this.Compiler), t ? r(void 0, t) : new Promise(r); function r(r, s) { const i = zu(e), o = n.parse(i); function a(e, n) { e || !n ? s(e) : r ? r(n) : t(void 0, n) } n.run(o, i, function (e, t, r) { if (e || !t || !r) return a(e); const s = t, i = n.stringify(s, r); var o; "string" == typeof (o = i) || function (e) { return Boolean(e && "object" == typeof e && "byteLength" in e && "byteOffset" in e) }(o) ? r.value = i : r.result = i, a(e, r) }) } } processSync(e) { let t, n = !1; return this.freeze(), Bu("processSync", this.parser || this.Parser), Uu("processSync", this.compiler || this.Compiler), this.process(e, function (e, r) { n = !0, uu(e), t = r }), Gu("processSync", "process", n), t } run(e, t, n) { ju(e), this.freeze(); const r = this.transformers; return n || "function" != typeof t || (n = t, t = void 0), n ? s(void 0, n) : new Promise(s); function s(s, i) { const o = zu(t); r.run(e, o, function (t, r, o) { const a = r || e; t ? i(t) : s ? s(a) : n(void 0, a, o) }) } } runSync(e, t) { let n, r = !1; return this.run(e, t, function (e, t) { uu(e), n = t, r = !0 }), Gu("runSync", "run", r), n } stringify(e, t) { this.freeze(); const n = zu(t), r = this.compiler || this.Compiler; return Uu("stringify", r), ju(e), r(e, n) } use(e, ...t) { const n = this.attachers, r = this.namespace; if (Hu("use", this.frozen), null == e); else if ("function" == typeof e) a(e, t); else { if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); Array.isArray(e) ? o(e) : i(e) } return this; function s(e) { if ("function" == typeof e) a(e, []); else { if ("object" != typeof e) throw new TypeError("Expected usable value, not `" + e + "`"); if (Array.isArray(e)) { const [t, ...n] = e; a(t, n) } else i(e) } } function i(e) { if (!("plugins" in e) && !("settings" in e)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); o(e.plugins), e.settings && (r.settings = Au(!0, r.settings, e.settings)) } function o(e) { let t = -1; if (null == e); else { if (!Array.isArray(e)) throw new TypeError("Expected a list of plugins, not `" + e + "`"); for (; ++t < e.length;)s(e[t]) } } function a(e, t) { let r = -1, s = -1; for (; ++r < n.length;)if (n[r][0] === e) { s = r; break } if (-1 === s) n.push([e, ...t]); else if (t.length > 0) { let [r, ...i] = t; const o = n[s][1]; _u(o) && _u(r) && (r = Au(!0, o, r)), n[s] = [e, r, ...i] } } } } const Fu = (new Mu).freeze(); function Bu(e, t) { if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `parser`") } function Uu(e, t) { if ("function" != typeof t) throw new TypeError("Cannot `" + e + "` without `compiler`") } function Hu(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function ju(e) { if (!_u(e) || "string" != typeof e.type) throw new TypeError("Expected node, got `" + e + "`") } function Gu(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function zu(e) { return function (e) { return Boolean(e && "object" == typeof e && "message" in e && "messages" in e) }(e) ? e : new vu(e) } const Yu = [], qu = { allowDangerousHtml: !0 }, Vu = /^(https?|ircs?|mailto|xmpp)$/i, $u = [{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" }, { from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" }, { from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" }, { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "includeElementIndex", id: "#remove-includeelementindex" }, { from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" }, { from: "linkTarget", id: "remove-linktarget" }, { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" }, { from: "rawSourcePos", id: "#remove-rawsourcepos" }, { from: "renderers", id: "change-renderers-to-components", to: "components" }, { from: "source", id: "change-source-to-children", to: "children" }, { from: "sourcePos", id: "#remove-sourcepos" }, { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" }, { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }]; function Wu(e) { const t = e.rehypePlugins || Yu, n = e.remarkPlugins || Yu, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...qu } : qu; return Fu().use(vc).use(n).use(cu, r).use(t) } function Ku(e) { const t = e.children || "", n = new vu; return "string" == typeof t && (n.value = t), n } function Qu(e, t) { const n = t.allowedElements, r = t.allowElement, s = t.components, i = t.disallowedElements, o = t.skipHtml, a = t.unwrapDisallowed, l = t.urlTransform || Xu; for (const c of $u) Object.hasOwn(t, c.from) && $i((c.from, c.to && c.to, c.id)); return t.className && (e = { type: "element", tagName: "div", properties: { className: t.className }, children: "root" === e.type ? e.children : [e] }), eu(e, function (e, t, s) { if ("raw" === e.type && s && "number" == typeof t) return o ? s.children.splice(t, 1) : s.children[t] = { type: "text", value: e.value }, t; if ("element" === e.type) { let t; for (t in Pa) if (Object.hasOwn(Pa, t) && Object.hasOwn(e.properties, t)) { const n = e.properties[t], r = Pa[t]; (null === r || r.includes(e.tagName)) && (e.properties[t] = l(String(n || ""), t, e)) } } if ("element" === e.type) { let o = n ? !n.includes(e.tagName) : !!i && i.includes(e.tagName); if (!o && r && "number" == typeof t && (o = !r(e, t, s)), o && s && "number" == typeof t) return a && e.children ? s.children.splice(t, 1, ...e.children) : s.children.splice(t, 1), t } }), function (e, t) { if (!t || void 0 === t.Fragment) throw new TypeError("Expected `Fragment` in options"); const n = t.filePath || void 0; let r; if (t.development) { if ("function" != typeof t.jsxDEV) throw new TypeError("Expected `jsxDEV` in options when `development: true`"); r = function (e, t) { return function (n, r, s, i) { const o = Array.isArray(s.children), a = da(n); return t(r, s, i, o, { columnNumber: a ? a.column - 1 : void 0, fileName: e, lineNumber: a ? a.line : void 0 }, void 0) } }(n, t.jsxDEV) } else { if ("function" != typeof t.jsx) throw new TypeError("Expected `jsx` in production options"); if ("function" != typeof t.jsxs) throw new TypeError("Expected `jsxs` in production options"); s = t.jsx, i = t.jsxs, r = function (e, t, n, r) { const o = Array.isArray(n.children) ? i : s; return r ? o(t, n, r) : o(t, n) } } var s, i; const o = { Fragment: t.Fragment, ancestors: [], components: t.components || {}, create: r, elementAttributeNameCase: t.elementAttributeNameCase || "react", evaluater: t.createEvaluater ? t.createEvaluater() : void 0, filePath: n, ignoreInvalidStyle: t.ignoreInvalidStyle || !1, passKeys: !1 !== t.passKeys, passNode: t.passNode || !1, schema: "svg" === t.space ? Fo : Mo, stylePropertyNameCase: t.stylePropertyNameCase || "dom", tableCellAlignToStyle: !1 !== t.tableCellAlignToStyle }, a = Ca(o, e, void 0); return a && "string" != typeof a ? a : o.create(e, o.Fragment, { children: a || void 0 }, void 0) }(e, { Fragment: T.Fragment, components: s, ignoreInvalidStyle: !0, jsx: T.jsx, jsxs: T.jsxs, passKeys: !0, passNode: !0 }) } function Xu(e) { const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), s = e.indexOf("/"); return -1 === t || -1 !== s && t > s || -1 !== n && t > n || -1 !== r && t > r || Vu.test(e.slice(0, t)) ? e : "" } const Ju = Object.freeze(Object.defineProperty({ __proto__: null, MarkdownAsync: async function (e) { const t = Wu(e), n = Ku(e); return Qu(await t.run(t.parse(n), n), e) }, MarkdownHooks: function (e) { const t = Wu(e), [n, r] = React.useState(void 0), [s, i] = React.useState(void 0); if (React.useEffect(function () { const n = Ku(e); t.run(t.parse(n), n, function (e, t) { r(e), i(t) }) }, [e.children, e.rehypePlugins, e.remarkPlugins, e.remarkRehypeOptions]), n) throw n; return s ? Qu(s, e) : React.createElement(T.Fragment) }, default: function (e) { const t = Wu(e), n = Ku(e); return Qu(t.runSync(t.parse(n), n), e) }, defaultUrlTransform: Xu }, Symbol.toStringTag, { value: "Module" })); function Zu(e, t) { const n = String(e); if ("string" != typeof t) throw new TypeError("Expected character"); let r = 0, s = n.indexOf(t); for (; -1 !== s;)r++, s = n.indexOf(t, s + t.length); return r } function eh(e) { return "string" == typeof e ? new RegExp(function (e) { if ("string" != typeof e) throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") }(e), "g") : e } function th(e) { return "function" == typeof e ? e : function () { return e } } const nh = "phrasing", rh = ["autolink", "link", "image", "label"]; function sh(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function ih(e) { this.config.enter.autolinkProtocol.call(this, e) } function oh(e) { this.config.exit.autolinkProtocol.call(this, e) } function ah(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function lh(e) { this.config.exit.autolinkEmail.call(this, e) } function ch(e) { this.exit(e) } function uh(e) { !function (e, t, n) { const r = Wc((n || {}).ignore || []), s = function (e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let r = -1; for (; ++r < n.length;) { const e = n[r]; t.push([eh(e[0]), th(e[1])]) } return t }(t); let i = -1; for (; ++i < s.length;)Zc(e, "text", o); function o(e, t) { let n, o = -1; for (; ++o < t.length;) { const e = t[o], s = n ? n.children : void 0; if (r(e, s ? s.indexOf(e) : void 0, n)) return; n = e } if (n) return function (e, t) { const n = t[t.length - 1], r = s[i][0], o = s[i][1]; let a = 0; const l = n.children.indexOf(e); let c = !1, u = []; r.lastIndex = 0; let h = r.exec(e.value); for (; h;) { const n = h.index, s = { index: h.index, input: h.input, stack: [...t, e] }; let i = o(...h, s); if ("string" == typeof i && (i = i.length > 0 ? { type: "text", value: i } : void 0), !1 === i ? r.lastIndex = n + 1 : (a !== n && u.push({ type: "text", value: e.value.slice(a, n) }), Array.isArray(i) ? u.push(...i) : i && u.push(i), a = n + h[0].length, c = !0), !r.global) break; h = r.exec(e.value) } return c ? (a < e.value.length && u.push({ type: "text", value: e.value.slice(a) }), n.children.splice(l, 1, ...u)) : u = [e], l + u.length }(e, t) } }(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, hh], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), dh]], { ignore: ["link", "linkReference"] }) } function hh(e, t, n, r, s) { let i = ""; if (!ph(s)) return !1; if (/^w/i.test(t) && (n = t + n, t = "", i = "http://"), !function (e) { const t = e.split("."); return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) }(n)) return !1; const o = function (e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], r = n.indexOf(")"); const s = Zu(e, "("); let i = Zu(e, ")"); for (; -1 !== r && s > i;)e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), i++; return [e, n] }(n + r); if (!o[0]) return !1; const a = { type: "link", title: null, url: i + t + o[0], children: [{ type: "text", value: t + o[0] }] }; return o[1] ? [a, { type: "text", value: o[1] }] : a } function dh(e, t, n, r) { return !(!ph(r, !0) || /[-\d_]$/.test(n)) && { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function ph(e, t) { const n = e.input.charCodeAt(e.index - 1); return (0 === e.index || ol(n) || il(n)) && (!t || 47 !== n) } function fh() { this.buffer() } function mh(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function gh() { this.buffer() } function Eh(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function Th(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = Wa(this.sliceSerialize(e)).toLowerCase(), n.label = t } function Ah(e) { this.exit(e) } function _h(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = Wa(this.sliceSerialize(e)).toLowerCase(), n.label = t } function yh(e) { this.exit(e) } function bh(e, t, n, r) { const s = n.createTracker(r); let i = s.move("[^"); const o = n.enter("footnoteReference"), a = n.enter("reference"); return i += s.move(n.safe(n.associationId(e), { after: "]", before: i })), a(), o(), i += s.move("]"), i } function Sh(e) { let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: function (e, n, r, s) { const i = r.createTracker(s); let o = i.move("[^"); const a = r.enter("footnoteDefinition"), l = r.enter("label"); return o += i.move(r.safe(r.associationId(e), { before: o, after: "]" })), l(), o += i.move("]:"), e.children && e.children.length > 0 && (i.shift(4), o += i.move((t ? "\n" : " ") + r.indentLines(r.containerFlow(e, i.current()), t ? Ch : kh))), a(), o }, footnoteReference: bh }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] } } function kh(e, t, n) { return 0 === t ? e : Ch(e, 0, n) } function Ch(e, t, n) { return (n ? "" : "    ") + e } bh.peek = function () { return "[" }; const Nh = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; function Ih(e) { this.enter({ type: "delete", children: [] }, e) } function Oh(e) { this.exit(e) } function xh(e, t, n, r) { const s = n.createTracker(r), i = n.enter("strikethrough"); let o = s.move("~~"); return o += n.containerPhrasing(e, { ...s.current(), before: o, after: "~" }), o += s.move("~~"), i(), o } function vh(e) { return e.length } function Rh(e) { return null == e ? "" : String(e) } function Dh(e) { const t = "string" == typeof e ? e.codePointAt(0) : 0; return 67 === t || 99 === t ? 99 : 76 === t || 108 === t ? 108 : 82 === t || 114 === t ? 114 : 0 } xh.peek = function () { return "~" }; const Lh = {}.hasOwnProperty; function Ph(e, t) { const n = t || {}; function r(t, ...n) { let s = r.invalid; const i = r.handlers; if (t && Lh.call(t, e)) { const n = String(t[e]); s = Lh.call(i, n) ? i[n] : r.unknown } if (s) return s.call(this, t, ...n) } return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r } function wh(e, t, n) { return ">" + (n ? "" : " ") + e } function Mh(e, t) { return Fh(e, t.inConstruct, !0) && !Fh(e, t.notInConstruct, !1) } function Fh(e, t, n) { if ("string" == typeof t && (t = [t]), !t || 0 === t.length) return n; let r = -1; for (; ++r < t.length;)if (e.includes(t[r])) return !0; return !1 } function Bh(e, t, n, r) { let s = -1; for (; ++s < n.unsafe.length;)if ("\n" === n.unsafe[s].character && Mh(n.stack, n.unsafe[s])) return /[ \t]/.test(r.before) ? "" : " "; return "\\\n" } function Uh(e, t, n) { return (n ? "" : "    ") + e } function Hh(e) { const t = e.options.quote || '"'; if ('"' !== t && "'" !== t) throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function jh(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function Gh(e, t, n) { const r = pl(e), s = pl(t); return void 0 === r ? void 0 === s ? "_" === n ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : 1 === r ? void 0 === s ? { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : void 0 === s ? { inside: !1, outside: !1 } : 1 === s ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } function zh(e, t, n, r) { const s = function (e) { const t = e.options.emphasis || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t }(n), i = n.enter("emphasis"), o = n.createTracker(r), a = o.move(s); let l = o.move(n.containerPhrasing(e, { after: s, before: a, ...o.current() })); const c = l.charCodeAt(0), u = Gh(r.before.charCodeAt(r.before.length - 1), c, s); u.inside && (l = jh(c) + l.slice(1)); const h = l.charCodeAt(l.length - 1), d = Gh(r.after.charCodeAt(0), h, s); d.inside && (l = l.slice(0, -1) + jh(h)); const p = o.move(s); return i(), n.attentionEncodeSurroundingInfo = { after: d.outside, before: u.outside }, a + l + p } function Yh(e) { return e.value || "" } function qh(e, t, n, r) { const s = Hh(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.enter("image"); let a = n.enter("label"); const l = n.createTracker(r); let c = l.move("!["); return c += l.move(n.safe(e.alt, { before: c, after: "]", ...l.current() })), c += l.move("]("), a(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...l.current() }))), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(n.safe(e.title, { before: c, after: s, ...l.current() })), c += l.move(s), a()), c += l.move(")"), o(), c } function Vh(e, t, n, r) { const s = e.referenceType, i = n.enter("imageReference"); let o = n.enter("label"); const a = n.createTracker(r); let l = a.move("!["); const c = n.safe(e.alt, { before: l, after: "]", ...a.current() }); l += a.move(c + "]["), o(); const u = n.stack; n.stack = [], o = n.enter("reference"); const h = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() }); return o(), n.stack = u, i(), "full" !== s && c && c === h ? "shortcut" === s ? l = l.slice(0, -1) : l += a.move("]") : l += a.move(h + "]"), l } function $h(e, t, n) { let r = e.value || "", s = "`", i = -1; for (; new RegExp("(^|[^`])" + s + "([^`]|$)").test(r);)s += "`"; for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++i < n.unsafe.length;) { const e = n.unsafe[i], t = n.compilePattern(e); let s; if (e.atBreak) for (; s = t.exec(r);) { let e = s.index; 10 === r.charCodeAt(e) && 13 === r.charCodeAt(e - 1) && e--, r = r.slice(0, e) + " " + r.slice(s.index + 1) } } return s + r + s } function Wh(e, t) { const n = Ma(e); return Boolean(!t.options.resourceLink && e.url && !e.title && e.children && 1 === e.children.length && "text" === e.children[0].type && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } function Kh(e, t, n, r) { const s = Hh(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.createTracker(r); let a, l; if (Wh(e, n)) { const t = n.stack; n.stack = [], a = n.enter("autolink"); let r = o.move("<"); return r += o.move(n.containerPhrasing(e, { before: r, after: ">", ...o.current() })), r += o.move(">"), a(), n.stack = t, r } a = n.enter("link"), l = n.enter("label"); let c = o.move("["); return c += o.move(n.containerPhrasing(e, { before: c, after: "](", ...o.current() })), c += o.move("]("), l(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (l = n.enter("destinationLiteral"), c += o.move("<"), c += o.move(n.safe(e.url, { before: c, after: ">", ...o.current() })), c += o.move(">")) : (l = n.enter("destinationRaw"), c += o.move(n.safe(e.url, { before: c, after: e.title ? " " : ")", ...o.current() }))), l(), e.title && (l = n.enter(`title${i}`), c += o.move(" " + s), c += o.move(n.safe(e.title, { before: c, after: s, ...o.current() })), c += o.move(s), l()), c += o.move(")"), a(), c } function Qh(e, t, n, r) { const s = e.referenceType, i = n.enter("linkReference"); let o = n.enter("label"); const a = n.createTracker(r); let l = a.move("["); const c = n.containerPhrasing(e, { before: l, after: "]", ...a.current() }); l += a.move(c + "]["), o(); const u = n.stack; n.stack = [], o = n.enter("reference"); const h = n.safe(n.associationId(e), { before: l, after: "]", ...a.current() }); return o(), n.stack = u, i(), "full" !== s && c && c === h ? "shortcut" === s ? l = l.slice(0, -1) : l += a.move("]") : l += a.move(h + "]"), l } function Xh(e) { const t = e.options.bullet || "*"; if ("*" !== t && "+" !== t && "-" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function Jh(e) { const t = e.options.rule || "*"; if ("*" !== t && "-" !== t && "_" !== t) throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } zh.peek = function (e, t, n) { return n.options.emphasis || "*" }, Yh.peek = function () { return "<" }, qh.peek = function () { return "!" }, Vh.peek = function () { return "!" }, $h.peek = function () { return "`" }, Kh.peek = function (e, t, n) { return Wh(e, n) ? "<" : "[" }, Qh.peek = function () { return "[" }; const Zh = Wc(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function ed(e, t, n, r) { const s = function (e) { const t = e.options.strong || "*"; if ("*" !== t && "_" !== t) throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t }(n), i = n.enter("strong"), o = n.createTracker(r), a = o.move(s + s); let l = o.move(n.containerPhrasing(e, { after: s, before: a, ...o.current() })); const c = l.charCodeAt(0), u = Gh(r.before.charCodeAt(r.before.length - 1), c, s); u.inside && (l = jh(c) + l.slice(1)); const h = l.charCodeAt(l.length - 1), d = Gh(r.after.charCodeAt(0), h, s); d.inside && (l = l.slice(0, -1) + jh(h)); const p = o.move(s + s); return i(), n.attentionEncodeSurroundingInfo = { after: d.outside, before: u.outside }, a + l + p } ed.peek = function (e, t, n) { return n.options.strong || "*" }; const td = { blockquote: function (e, t, n, r) { const s = n.enter("blockquote"), i = n.createTracker(r); i.move("> "), i.shift(2); const o = n.indentLines(n.containerFlow(e, i.current()), wh); return s(), o }, break: Bh, code: function (e, t, n, r) { const s = function (e) { const t = e.options.fence || "`"; if ("`" !== t && "~" !== t) throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t }(n), i = e.value || "", o = "`" === s ? "GraveAccent" : "Tilde"; if (function (e, t) { return Boolean(!1 === t.options.fences && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) }(e, n)) { const e = n.enter("codeIndented"), t = n.indentLines(i, Uh); return e(), t } const a = n.createTracker(r), l = s.repeat(Math.max(function (e, t) { const n = String(e); let r = n.indexOf(t), s = r, i = 0, o = 0; if ("string" != typeof t) throw new TypeError("Expected substring"); for (; -1 !== r;)r === s ? ++i > o && (o = i) : i = 1, s = r + t.length, r = n.indexOf(t, s); return o }(i, s) + 1, 3)), c = n.enter("codeFenced"); let u = a.move(l); if (e.lang) { const t = n.enter(`codeFencedLang${o}`); u += a.move(n.safe(e.lang, { before: u, after: " ", encode: ["`"], ...a.current() })), t() } if (e.lang && e.meta) { const t = n.enter(`codeFencedMeta${o}`); u += a.move(" "), u += a.move(n.safe(e.meta, { before: u, after: "\n", encode: ["`"], ...a.current() })), t() } return u += a.move("\n"), i && (u += a.move(i + "\n")), u += a.move(l), c(), u }, definition: function (e, t, n, r) { const s = Hh(n), i = '"' === s ? "Quote" : "Apostrophe", o = n.enter("definition"); let a = n.enter("label"); const l = n.createTracker(r); let c = l.move("["); return c += l.move(n.safe(n.associationId(e), { before: c, after: "]", ...l.current() })), c += l.move("]: "), a(), !e.url || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), c += l.move("<"), c += l.move(n.safe(e.url, { before: c, after: ">", ...l.current() })), c += l.move(">")) : (a = n.enter("destinationRaw"), c += l.move(n.safe(e.url, { before: c, after: e.title ? " " : "\n", ...l.current() }))), a(), e.title && (a = n.enter(`title${i}`), c += l.move(" " + s), c += l.move(n.safe(e.title, { before: c, after: s, ...l.current() })), c += l.move(s), a()), o(), c }, emphasis: zh, hardBreak: Bh, heading: function (e, t, n, r) { const s = Math.max(Math.min(6, e.depth || 1), 1), i = n.createTracker(r); if (function (e, t) { let n = !1; return eu(e, function (e) { if ("value" in e && /\r?\n|\r/.test(e.value) || "break" === e.type) return n = !0, Jc }), Boolean((!e.depth || e.depth < 3) && Ma(e) && (t.options.setext || n)) }(e, n)) { const t = n.enter("headingSetext"), r = n.enter("phrasing"), o = n.containerPhrasing(e, { ...i.current(), before: "\n", after: "\n" }); return r(), t(), o + "\n" + (1 === s ? "=" : "-").repeat(o.length - (Math.max(o.lastIndexOf("\r"), o.lastIndexOf("\n")) + 1)) } const o = "#".repeat(s), a = n.enter("headingAtx"), l = n.enter("phrasing"); i.move(o + " "); let c = n.containerPhrasing(e, { before: "# ", after: "\n", ...i.current() }); return /^[\t ]/.test(c) && (c = jh(c.charCodeAt(0)) + c.slice(1)), c = c ? o + " " + c : o, n.options.closeAtx && (c += " " + o), l(), a(), c }, html: Yh, image: qh, imageReference: Vh, inlineCode: $h, link: Kh, linkReference: Qh, list: function (e, t, n, r) { const s = n.enter("list"), i = n.bulletCurrent; let o = e.ordered ? function (e) { const t = e.options.bulletOrdered || "."; if ("." !== t && ")" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t }(n) : Xh(n); const a = e.ordered ? "." === o ? ")" : "." : function (e) { const t = Xh(e), n = e.options.bulletOther; if (!n) return "*" === t ? "-" : "*"; if ("*" !== n && "+" !== n && "-" !== n) throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n }(n); let l = !(!t || !n.bulletLastUsed) && o === n.bulletLastUsed; if (!e.ordered) { const t = e.children ? e.children[0] : void 0; if ("*" !== o && "-" !== o || !t || t.children && t.children[0] || "list" !== n.stack[n.stack.length - 1] || "listItem" !== n.stack[n.stack.length - 2] || "list" !== n.stack[n.stack.length - 3] || "listItem" !== n.stack[n.stack.length - 4] || 0 !== n.indexStack[n.indexStack.length - 1] || 0 !== n.indexStack[n.indexStack.length - 2] || 0 !== n.indexStack[n.indexStack.length - 3] || (l = !0), Jh(n) === o && t) { let t = -1; for (; ++t < e.children.length;) { const n = e.children[t]; if (n && "listItem" === n.type && n.children && n.children[0] && "thematicBreak" === n.children[0].type) { l = !0; break } } } } l && (o = a), n.bulletCurrent = o; const c = n.containerFlow(e, r); return n.bulletLastUsed = o, n.bulletCurrent = i, s(), c }, listItem: function (e, t, n, r) { const s = function (e) { const t = e.options.listItemIndent || "one"; if ("tab" !== t && "one" !== t && "mixed" !== t) throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t }(n); let i = n.bulletCurrent || Xh(n); t && "list" === t.type && t.ordered && (i = ("number" == typeof t.start && t.start > -1 ? t.start : 1) + (!1 === n.options.incrementListMarker ? 0 : t.children.indexOf(e)) + i); let o = i.length + 1; ("tab" === s || "mixed" === s && (t && "list" === t.type && t.spread || e.spread)) && (o = 4 * Math.ceil(o / 4)); const a = n.createTracker(r); a.move(i + " ".repeat(o - i.length)), a.shift(o); const l = n.enter("listItem"), c = n.indentLines(n.containerFlow(e, a.current()), function (e, t, n) { return t ? (n ? "" : " ".repeat(o)) + e : (n ? i : i + " ".repeat(o - i.length)) + e }); return l(), c }, paragraph: function (e, t, n, r) { const s = n.enter("paragraph"), i = n.enter("phrasing"), o = n.containerPhrasing(e, r); return i(), s(), o }, root: function (e, t, n, r) { return (e.children.some(function (e) { return Zh(e) }) ? n.containerPhrasing : n.containerFlow).call(n, e, r) }, strong: ed, text: function (e, t, n, r) { return n.safe(e.value, r) }, thematicBreak: function (e, t, n) { const r = (Jh(n) + (n.options.ruleSpaces ? " " : "")).repeat(function (e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t }(n)); return n.options.ruleSpaces ? r.slice(0, -1) : r } }; function nd(e) { const t = e._align; this.enter({ type: "table", align: t.map(function (e) { return "none" === e ? null : e }), children: [] }, e), this.data.inTable = !0 } function rd(e) { this.exit(e), this.data.inTable = void 0 } function sd(e) { this.enter({ type: "tableRow", children: [] }, e) } function id(e) { this.exit(e) } function od(e) { this.enter({ type: "tableCell", children: [] }, e) } function ad(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, ld)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function ld(e, t) { return "|" === t ? t : e } function cd(e) { const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, s = t.stringLength, i = n ? " " : "|"; return { unsafe: [{ character: "\r", inConstruct: "tableCell" }, { character: "\n", inConstruct: "tableCell" }, { atBreak: !0, character: "|", after: "[\t :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: function (e, t, n) { let r = td.inlineCode(e, t, n); return n.stack.includes("tableCell") && (r = r.replace(/\|/g, "\\$&")), r }, table: function (e, t, n, r) { return a(function (e, t, n) { const r = e.children; let s = -1; const i = [], o = t.enter("table"); for (; ++s < r.length;)i[s] = l(r[s], t, n); return o(), i }(e, n, r), e.align) }, tableCell: o, tableRow: function (e, t, n, r) { const s = a([l(e, n, r)]); return s.slice(0, s.indexOf("\n")) } } }; function o(e, t, n, r) { const s = n.enter("tableCell"), o = n.enter("phrasing"), a = n.containerPhrasing(e, { ...r, before: i, after: i }); return o(), s(), a } function a(e, t) { return function (e, t) { const n = t || {}, r = (n.align || []).concat(), s = n.stringLength || vh, i = [], o = [], a = [], l = []; let c = 0, u = -1; for (; ++u < e.length;) { const t = [], r = []; let i = -1; for (e[u].length > c && (c = e[u].length); ++i < e[u].length;) { const o = Rh(e[u][i]); if (!1 !== n.alignDelimiters) { const e = s(o); r[i] = e, (void 0 === l[i] || e > l[i]) && (l[i] = e) } t.push(o) } o[u] = t, a[u] = r } let h = -1; if ("object" == typeof r && "length" in r) for (; ++h < c;)i[h] = Dh(r[h]); else { const e = Dh(r); for (; ++h < c;)i[h] = e } h = -1; const d = [], p = []; for (; ++h < c;) { const e = i[h]; let t = "", r = ""; 99 === e ? (t = ":", r = ":") : 108 === e ? t = ":" : 114 === e && (r = ":"); let s = !1 === n.alignDelimiters ? 1 : Math.max(1, l[h] - t.length - r.length); const o = t + "-".repeat(s) + r; !1 !== n.alignDelimiters && (s = t.length + s + r.length, s > l[h] && (l[h] = s), p[h] = s), d[h] = o } o.splice(1, 0, d), a.splice(1, 0, p), u = -1; const f = []; for (; ++u < o.length;) { const e = o[u], t = a[u]; h = -1; const r = []; for (; ++h < c;) { const s = e[h] || ""; let o = "", a = ""; if (!1 !== n.alignDelimiters) { const e = l[h] - (t[h] || 0), n = i[h]; 114 === n ? o = " ".repeat(e) : 99 === n ? e % 2 ? (o = " ".repeat(e / 2 + .5), a = " ".repeat(e / 2 - .5)) : (o = " ".repeat(e / 2), a = o) : a = " ".repeat(e) } !1 === n.delimiterStart || h || r.push("|"), !1 === n.padding || !1 === n.alignDelimiters && "" === s || !1 === n.delimiterStart && !h || r.push(" "), !1 !== n.alignDelimiters && r.push(o), r.push(s), !1 !== n.alignDelimiters && r.push(a), !1 !== n.padding && r.push(" "), !1 === n.delimiterEnd && h === c - 1 || r.push("|") } f.push(!1 === n.delimiterEnd ? r.join("").replace(/ +$/, "") : r.join("")) } return f.join("\n") }(e, { align: t, alignDelimiters: r, padding: n, stringLength: s }) } function l(e, t, n) { const r = e.children; let s = -1; const i = [], a = t.enter("tableRow"); for (; ++s < r.length;)i[s] = o(r[s], 0, t, n); return a(), i } } function ud(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = "taskListCheckValueChecked" === e.type } function hd(e) { const t = this.stack[this.stack.length - 2]; if (t && "listItem" === t.type && "boolean" == typeof t.checked) { const e = this.stack[this.stack.length - 1]; e.type; const n = e.children[0]; if (n && "text" === n.type) { const r = t.children; let s, i = -1; for (; ++i < r.length;) { const e = r[i]; if ("paragraph" === e.type) { s = e; break } } s === e && (n.value = n.value.slice(1), 0 === n.value.length ? e.children.shift() : e.position && n.position && "number" == typeof n.position.start.offset && (n.position.start.column++, n.position.start.offset++, e.position.start = Object.assign({}, n.position.start))) } } this.exit(e) } function dd(e, t, n, r) { const s = e.children[0], i = "boolean" == typeof e.checked && s && "paragraph" === s.type, o = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r); i && a.move(o); let l = td.listItem(e, t, n, { ...r, ...a.current() }); return i && (l = l.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, function (e) { return e + o })), l } const pd = { tokenize: function (e, t, n) { let r = 0; return function t(i) { return (87 === i || 119 === i) && r < 3 ? (r++, e.consume(i), t) : 46 === i && 3 === r ? (e.consume(i), s) : n(i) }; function s(e) { return null === e ? n(e) : t(e) } }, partial: !0 }, fd = { tokenize: function (e, t, n) { let r, s, i; return o; function o(t) { return 46 === t || 95 === t ? e.check(gd, l, a)(t) : null === t || rl(t) || ol(t) || 45 !== t && il(t) ? l(t) : (i = !0, e.consume(t), o) } function a(t) { return 95 === t ? r = !0 : (s = r, r = void 0), e.consume(t), o } function l(e) { return s || r || !i ? n(e) : t(e) } }, partial: !0 }, md = { tokenize: function (e, t) { let n = 0, r = 0; return s; function s(o) { return 40 === o ? (n++, e.consume(o), s) : 41 === o && r < n ? i(o) : 33 === o || 34 === o || 38 === o || 39 === o || 41 === o || 42 === o || 44 === o || 46 === o || 58 === o || 59 === o || 60 === o || 63 === o || 93 === o || 95 === o || 126 === o ? e.check(gd, t, i)(o) : null === o || rl(o) || ol(o) ? t(o) : (e.consume(o), s) } function i(t) { return 41 === t && r++, e.consume(t), s } }, partial: !0 }, gd = { tokenize: function (e, t, n) { return r; function r(o) { return 33 === o || 34 === o || 39 === o || 41 === o || 42 === o || 44 === o || 46 === o || 58 === o || 59 === o || 63 === o || 95 === o || 126 === o ? (e.consume(o), r) : 38 === o ? (e.consume(o), i) : 93 === o ? (e.consume(o), s) : 60 === o || null === o || rl(o) || ol(o) ? t(o) : n(o) } function s(e) { return null === e || 40 === e || 91 === e || rl(e) || ol(e) ? t(e) : r(e) } function i(e) { return Ka(e) ? o(e) : n(e) } function o(t) { return 59 === t ? (e.consume(t), r) : Ka(t) ? (e.consume(t), o) : n(t) } }, partial: !0 }, Ed = { tokenize: function (e, t, n) { return function (t) { return e.consume(t), r }; function r(e) { return Qa(e) ? n(e) : t(e) } }, partial: !0 }, Td = { name: "wwwAutolink", tokenize: function (e, t, n) { const r = this; return function (t) { return 87 !== t && 119 !== t || !Sd.call(r, r.previous) || Id(r.events) ? n(t) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(pd, e.attempt(fd, e.attempt(md, s), n), n)(t)) }; function s(n) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(n) } }, previous: Sd }, Ad = { name: "protocolAutolink", tokenize: function (e, t, n) { const r = this; let s = "", i = !1; return function (t) { return 72 !== t && 104 !== t || !kd.call(r, r.previous) || Id(r.events) ? n(t) : (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), s += String.fromCodePoint(t), e.consume(t), o) }; function o(t) { if (Ka(t) && s.length < 5) return s += String.fromCodePoint(t), e.consume(t), o; if (58 === t) { const n = s.toLowerCase(); if ("http" === n || "https" === n) return e.consume(t), a } return n(t) } function a(t) { return 47 === t ? (e.consume(t), i ? l : (i = !0, a)) : n(t) } function l(t) { return null === t || Ja(t) || rl(t) || ol(t) || il(t) ? n(t) : e.attempt(fd, e.attempt(md, c), n)(t) } function c(n) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(n) } }, previous: kd }, _d = { name: "emailAutolink", tokenize: function (e, t, n) { const r = this; let s, i; return function (t) { return Nd(t) && Cd.call(r, r.previous) && !Id(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), o(t)) : n(t) }; function o(t) { return Nd(t) ? (e.consume(t), o) : 64 === t ? (e.consume(t), a) : n(t) } function a(t) { return 46 === t ? e.check(Ed, c, l)(t) : 45 === t || 95 === t || Qa(t) ? (i = !0, e.consume(t), a) : c(t) } function l(t) { return e.consume(t), s = !0, a } function c(o) { return i && s && Ka(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(o)) : n(o) } }, previous: Cd }, yd = {}; let bd = 48; for (; bd < 123;)yd[bd] = _d, bd++, 58 === bd ? bd = 65 : 91 === bd && (bd = 97); function Sd(e) { return null === e || 40 === e || 42 === e || 95 === e || 91 === e || 93 === e || 126 === e || rl(e) } function kd(e) { return !Ka(e) } function Cd(e) { return !(47 === e || Nd(e)) } function Nd(e) { return 43 === e || 45 === e || 46 === e || 95 === e || Qa(e) } function Id(e) { let t = e.length, n = !1; for (; t--;) { const r = e[t][1]; if (("labelLink" === r.type || "labelImage" === r.type) && !r._balanced) { n = !0; break } if (r._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } yd[43] = _d, yd[45] = _d, yd[46] = _d, yd[95] = _d, yd[72] = [_d, Ad], yd[104] = [_d, Ad], yd[87] = [_d, Td], yd[119] = [_d, Td]; const Od = { tokenize: function (e, t, n) { const r = this; return cl(e, function (e) { const s = r.events[r.events.length - 1]; return s && "gfmFootnoteDefinitionIndent" === s[1].type && 4 === s[2].sliceSerialize(s[1], !0).length ? t(e) : n(e) }, "gfmFootnoteDefinitionIndent", 5) }, partial: !0 }; function xd(e, t, n) { const r = this; let s = r.events.length; const i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let o; for (; s--;) { const e = r.events[s][1]; if ("labelImage" === e.type) { o = e; break } if ("gfmFootnoteCall" === e.type || "labelLink" === e.type || "label" === e.type || "image" === e.type || "link" === e.type) break } return function (s) { if (!o || !o._balanced) return n(s); const a = Wa(r.sliceSerialize({ start: o.end, end: r.now() })); return 94 === a.codePointAt(0) && i.includes(a.slice(1)) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(s), e.exit("gfmFootnoteCallLabelMarker"), t(s)) : n(s) } } function vd(e, t) { let n = e.length; for (; n--;)if ("labelImage" === e[n][1].type && "enter" === e[n][0]) { e[n][1]; break } e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker"; const r = { type: "gfmFootnoteCall", start: Object.assign({}, e[n + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, s = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[n + 3][1].end), end: Object.assign({}, e[n + 3][1].end) }; s.end.column++, s.end.offset++, s.end._bufferIndex++; const i = { type: "gfmFootnoteCallString", start: Object.assign({}, s.end), end: Object.assign({}, e[e.length - 1][1].start) }, o = { type: "chunkString", contentType: "string", start: Object.assign({}, i.start), end: Object.assign({}, i.end) }, a = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", s, t], ["exit", s, t], ["enter", i, t], ["enter", o, t], ["exit", o, t], ["exit", i, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]]; return e.splice(n, e.length - n + 1, ...a), e } function Rd(e, t, n) { const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let i, o = 0; return function (t) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(t), e.exit("gfmFootnoteCallLabelMarker"), a }; function a(t) { return 94 !== t ? n(t) : (e.enter("gfmFootnoteCallMarker"), e.consume(t), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l) } function l(a) { if (o > 999 || 93 === a && !i || null === a || 91 === a || rl(a)) return n(a); if (93 === a) { e.exit("chunkString"); const i = e.exit("gfmFootnoteCallString"); return s.includes(Wa(r.sliceSerialize(i))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(a), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(a) } return rl(a) || (i = !0), o++, e.consume(a), 92 === a ? c : l } function c(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), o++, l) : l(t) } } function Dd(e, t, n) { const r = this, s = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let i, o, a = 0; return function (t) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), l }; function l(t) { return 94 === t ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", c) : n(t) } function c(t) { if (a > 999 || 93 === t && !o || null === t || 91 === t || rl(t)) return n(t); if (93 === t) { e.exit("chunkString"); const n = e.exit("gfmFootnoteDefinitionLabelString"); return i = Wa(r.sliceSerialize(n)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(t), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), h } return rl(t) || (o = !0), a++, e.consume(t), 92 === t ? u : c } function u(t) { return 91 === t || 92 === t || 93 === t ? (e.consume(t), a++, c) : c(t) } function h(t) { return 58 === t ? (e.enter("definitionMarker"), e.consume(t), e.exit("definitionMarker"), s.includes(i) || s.push(i), cl(e, d, "gfmFootnoteDefinitionWhitespace")) : n(t) } function d(e) { return t(e) } } function Ld(e, t, n) { return e.check(Tl, t, e.attempt(Od, t, n)) } function Pd(e) { e.exit("gfmFootnoteDefinition") } function wd(e) { let t = (e || {}).singleTilde; const n = { name: "strikethrough", tokenize: function (e, n, r) { const s = this.previous, i = this.events; let o = 0; return function (t) { return 126 === s && "characterEscape" !== i[i.length - 1][1].type ? r(t) : (e.enter("strikethroughSequenceTemporary"), a(t)) }; function a(i) { const l = pl(s); if (126 === i) return o > 1 ? r(i) : (e.consume(i), o++, a); if (o < 2 && !t) return r(i); const c = e.exit("strikethroughSequenceTemporary"), u = pl(i); return c._open = !u || 2 === u && Boolean(l), c._close = !l || 2 === l && Boolean(u), n(i) } }, resolveAll: function (e, t) { let n = -1; for (; ++n < e.length;)if ("enter" === e[n][0] && "strikethroughSequenceTemporary" === e[n][1].type && e[n][1]._close) { let r = n; for (; r--;)if ("exit" === e[r][0] && "strikethroughSequenceTemporary" === e[r][1].type && e[r][1]._open && e[n][1].end.offset - e[n][1].start.offset === e[r][1].end.offset - e[r][1].start.offset) { e[n][1].type = "strikethroughSequence", e[r][1].type = "strikethroughSequence"; const s = { type: "strikethrough", start: Object.assign({}, e[r][1].start), end: Object.assign({}, e[n][1].end) }, i = { type: "strikethroughText", start: Object.assign({}, e[r][1].end), end: Object.assign({}, e[n][1].start) }, o = [["enter", s, t], ["enter", e[r][1], t], ["exit", e[r][1], t], ["enter", i, t]], a = t.parser.constructs.insideSpan.null; a && ja(o, o.length, 0, fl(a, e.slice(r + 1, n), t)), ja(o, o.length, 0, [["exit", i, t], ["enter", e[n][1], t], ["exit", e[n][1], t], ["exit", s, t]]), ja(e, r - 1, n - r + 3, o), n = r + o.length - 2; break } } for (n = -1; ++n < e.length;)"strikethroughSequenceTemporary" === e[n][1].type && (e[n][1].type = "data"); return e } }; return null == t && (t = !0), { text: { 126: n }, insideSpan: { null: [n] }, attentionMarkers: { null: [126] } } } class Md { constructor() { this.map = [] } add(e, t, n) { !function (e, t, n, r) { let s = 0; if (0 !== n || 0 !== r.length) { for (; s < e.map.length;) { if (e.map[s][0] === t) return e.map[s][1] += n, void e.map[s][2].push(...r); s += 1 } e.map.push([t, n, r]) } }(this, e, t, n) } consume(e) { if (this.map.sort(function (e, t) { return e[0] - t[0] }), 0 === this.map.length) return; let t = this.map.length; const n = []; for (; t > 0;)t -= 1, n.push(e.slice(this.map[t][0] + this.map[t][1]), this.map[t][2]), e.length = this.map[t][0]; n.push(e.slice()), e.length = 0; let r = n.pop(); for (; r;) { for (const t of r) e.push(t); r = n.pop() } this.map.length = 0 } } function Fd(e, t) { let n = !1; const r = []; for (; t < e.length;) { const s = e[t]; if (n) { if ("enter" === s[0]) "tableContent" === s[1].type && r.push("tableDelimiterMarker" === e[t + 1][1].type ? "left" : "none"); else if ("tableContent" === s[1].type) { if ("tableDelimiterMarker" === e[t - 1][1].type) { const e = r.length - 1; r[e] = "left" === r[e] ? "center" : "right" } } else if ("tableDelimiterRow" === s[1].type) break } else "enter" === s[0] && "tableDelimiterRow" === s[1].type && (n = !0); t += 1 } return r } function Bd(e, t, n) { const r = this; let s, i = 0, o = 0; return function (e) { let t = r.events.length - 1; for (; t > -1;) { const e = r.events[t][1].type; if ("lineEnding" !== e && "linePrefix" !== e) break; t-- } const s = t > -1 ? r.events[t][1].type : null, i = "tableHead" === s || "tableRow" === s ? _ : a; return i === _ && r.parser.lazy[r.now().line] ? n(e) : i(e) }; function a(t) { return e.enter("tableHead"), e.enter("tableRow"), function (e) { return 124 === e || (s = !0, o += 1), l(e) }(t) } function l(t) { return null === t ? n(t) : nl(t) ? o > 1 ? (o = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(t), e.exit("lineEnding"), h) : n(t) : sl(t) ? cl(e, l, "whitespace")(t) : (o += 1, s && (s = !1, i += 1), 124 === t ? (e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), s = !0, l) : (e.enter("data"), c(t))) } function c(t) { return null === t || 124 === t || rl(t) ? (e.exit("data"), l(t)) : (e.consume(t), 92 === t ? u : c) } function u(t) { return 92 === t || 124 === t ? (e.consume(t), c) : c(t) } function h(t) { return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(t) : (e.enter("tableDelimiterRow"), s = !1, sl(t) ? cl(e, d, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(t) : d(t)) } function d(t) { return 45 === t || 58 === t ? f(t) : 124 === t ? (s = !0, e.enter("tableCellDivider"), e.consume(t), e.exit("tableCellDivider"), p) : A(t) } function p(t) { return sl(t) ? cl(e, f, "whitespace")(t) : f(t) } function f(t) { return 58 === t ? (o += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), m) : 45 === t ? (o += 1, m(t)) : null === t || nl(t) ? T(t) : A(t) } function m(t) { return 45 === t ? (e.enter("tableDelimiterFiller"), g(t)) : A(t) } function g(t) { return 45 === t ? (e.consume(t), g) : 58 === t ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(t), e.exit("tableDelimiterMarker"), E) : (e.exit("tableDelimiterFiller"), E(t)) } function E(t) { return sl(t) ? cl(e, T, "whitespace")(t) : T(t) } function T(n) { return 124 === n ? d(n) : (null === n || nl(n)) && s && i === o ? (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(n)) : A(n) } function A(e) { return n(e) } function _(t) { return e.enter("tableRow"), y(t) } function y(n) { return 124 === n ? (e.enter("tableCellDivider"), e.consume(n), e.exit("tableCellDivider"), y) : null === n || nl(n) ? (e.exit("tableRow"), t(n)) : sl(n) ? cl(e, y, "whitespace")(n) : (e.enter("data"), b(n)) } function b(t) { return null === t || 124 === t || rl(t) ? (e.exit("data"), y(t)) : (e.consume(t), 92 === t ? S : b) } function S(t) { return 92 === t || 124 === t ? (e.consume(t), b) : b(t) } } function Ud(e, t) { let n, r, s, i = -1, o = !0, a = 0, l = [0, 0, 0, 0], c = [0, 0, 0, 0], u = !1, h = 0; const d = new Md; for (; ++i < e.length;) { const p = e[i], f = p[1]; "enter" === p[0] ? "tableHead" === f.type ? (u = !1, 0 !== h && (jd(d, t, h, n, r), r = void 0, h = 0), n = { type: "table", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }, d.add(i, 0, [["enter", n, t]])) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (o = !0, s = void 0, l = [0, 0, 0, 0], c = [0, i + 1, 0, 0], u && (u = !1, r = { type: "tableBody", start: Object.assign({}, f.start), end: Object.assign({}, f.end) }, d.add(i, 0, [["enter", r, t]])), a = "tableDelimiterRow" === f.type ? 2 : r ? 3 : 1) : !a || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type ? "tableCellDivider" === f.type && (o ? o = !1 : (0 !== l[1] && (c[0] = c[1], s = Hd(d, t, l, a, void 0, s)), l = c, c = [l[1], i, 0, 0])) : (o = !1, 0 === c[2] && (0 !== l[1] && (c[0] = c[1], s = Hd(d, t, l, a, void 0, s), l = [0, 0, 0, 0]), c[2] = i)) : "tableHead" === f.type ? (u = !0, h = i) : "tableRow" === f.type || "tableDelimiterRow" === f.type ? (h = i, 0 !== l[1] ? (c[0] = c[1], s = Hd(d, t, l, a, i, s)) : 0 !== c[1] && (s = Hd(d, t, c, a, i, s)), a = 0) : !a || "data" !== f.type && "tableDelimiterMarker" !== f.type && "tableDelimiterFiller" !== f.type || (c[3] = i) } for (0 !== h && jd(d, t, h, n, r), d.consume(t.events), i = -1; ++i < t.events.length;) { const e = t.events[i]; "enter" === e[0] && "table" === e[1].type && (e[1]._align = Fd(t.events, i)) } return e } function Hd(e, t, n, r, s, i) { const o = 1 === r ? "tableHeader" : 2 === r ? "tableDelimiter" : "tableData"; 0 !== n[0] && (i.end = Object.assign({}, Gd(t.events, n[0])), e.add(n[0], 0, [["exit", i, t]])); const a = Gd(t.events, n[1]); if (i = { type: o, start: Object.assign({}, a), end: Object.assign({}, a) }, e.add(n[1], 0, [["enter", i, t]]), 0 !== n[2]) { const s = Gd(t.events, n[2]), i = Gd(t.events, n[3]), o = { type: "tableContent", start: Object.assign({}, s), end: Object.assign({}, i) }; if (e.add(n[2], 0, [["enter", o, t]]), 2 !== r) { const r = t.events[n[2]], s = t.events[n[3]]; if (r[1].end = Object.assign({}, s[1].end), r[1].type = "chunkText", r[1].contentType = "text", n[3] > n[2] + 1) { const t = n[2] + 1, r = n[3] - n[2] - 1; e.add(t, r, []) } } e.add(n[3] + 1, 0, [["exit", o, t]]) } return void 0 !== s && (i.end = Object.assign({}, Gd(t.events, s)), e.add(s, 0, [["exit", i, t]]), i = void 0), i } function jd(e, t, n, r, s) { const i = [], o = Gd(t.events, n); s && (s.end = Object.assign({}, o), i.push(["exit", s, t])), r.end = Object.assign({}, o), i.push(["exit", r, t]), e.add(n + 1, 0, i) } function Gd(e, t) { const n = e[t], r = "enter" === n[0] ? "start" : "end"; return n[1][r] } const zd = { name: "tasklistCheck", tokenize: function (e, t, n) { const r = this; return function (t) { return null === r.previous && r._gfmTasklistFirstContentOfListItem ? (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), s) : n(t) }; function s(t) { return rl(t) ? (e.enter("taskListCheckValueUnchecked"), e.consume(t), e.exit("taskListCheckValueUnchecked"), i) : 88 === t || 120 === t ? (e.enter("taskListCheckValueChecked"), e.consume(t), e.exit("taskListCheckValueChecked"), i) : n(t) } function i(t) { return 93 === t ? (e.enter("taskListCheckMarker"), e.consume(t), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), o) : n(t) } function o(r) { return nl(r) ? t(r) : sl(r) ? e.check({ tokenize: Yd }, t, n)(r) : n(r) } } }; function Yd(e, t, n) { return cl(e, function (e) { return null === e ? n(e) : t(e) }, "whitespace") } const qd = {}, Vd = Object.freeze(Object.defineProperty({ __proto__: null, default: function (e) { const t = e || qd, n = this.data(), r = n.micromarkExtensions || (n.micromarkExtensions = []), s = n.fromMarkdownExtensions || (n.fromMarkdownExtensions = []), i = n.toMarkdownExtensions || (n.toMarkdownExtensions = []); r.push(function (e) { return Ya([{ text: yd }, { document: { 91: { name: "gfmFootnoteDefinition", tokenize: Dd, continuation: { tokenize: Ld }, exit: Pd } }, text: { 91: { name: "gfmFootnoteCall", tokenize: Rd }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: xd, resolveTo: vd } } }, wd(e), { flow: { null: { name: "table", tokenize: Bd, resolveAll: Ud } } }, { text: { 91: zd } }]) }(t)), s.push([{ transforms: [uh], enter: { literalAutolink: sh, literalAutolinkEmail: ih, literalAutolinkHttp: ih, literalAutolinkWww: ih }, exit: { literalAutolink: ch, literalAutolinkEmail: lh, literalAutolinkHttp: oh, literalAutolinkWww: ah } }, { enter: { gfmFootnoteCallString: fh, gfmFootnoteCall: mh, gfmFootnoteDefinitionLabelString: gh, gfmFootnoteDefinition: Eh }, exit: { gfmFootnoteCallString: Th, gfmFootnoteCall: Ah, gfmFootnoteDefinitionLabelString: _h, gfmFootnoteDefinition: yh } }, { canContainEols: ["delete"], enter: { strikethrough: Ih }, exit: { strikethrough: Oh } }, { enter: { table: nd, tableData: od, tableHeader: od, tableRow: sd }, exit: { codeText: ad, table: rd, tableData: id, tableHeader: id, tableRow: id } }, { exit: { taskListCheckValueChecked: ud, taskListCheckValueUnchecked: ud, paragraph: hd } }]), i.push(function (e) { return { extensions: [{ unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: nh, notInConstruct: rh }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: nh, notInConstruct: rh }, { character: ":", before: "[ps]", after: "\\/", inConstruct: nh, notInConstruct: rh }] }, Sh(e), { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: Nh }], handlers: { delete: xh } }, cd(e), { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: dd } }] } }(t)) } }, Symbol.toStringTag, { value: "Module" })), $d = /[#.]/g; function Wd(e, t, n) { const r = n ? function (e) { const t = new Map; for (const n of e) t.set(n.toLowerCase(), n); return t }(n) : void 0; return function (n, s, ...i) { let o; if (null == n) { o = { type: "root", children: [] }; const e = s; i.unshift(e) } else { o = function (e, t) { const n = e || "", r = {}; let s, i, o = 0; for (; o < n.length;) { $d.lastIndex = o; const e = $d.exec(n), t = n.slice(o, e ? e.index : n.length); t && (s ? "#" === s ? r.id = t : Array.isArray(r.className) ? r.className.push(t) : r.className = [t] : i = t, o += t.length), e && (s = e[0], o++) } return { type: "element", tagName: i || t || "div", properties: r, children: [] } }(n, t); const a = o.tagName.toLowerCase(), l = r ? r.get(a) : void 0; if (o.tagName = l || a, function (e) { if (null === e || "object" != typeof e || Array.isArray(e)) return !0; if ("string" != typeof e.type) return !1; const t = e, n = Object.keys(e); for (const r of n) { const e = t[r]; if (e && "object" == typeof e) { if (!Array.isArray(e)) return !0; const t = e; for (const e of t) if ("number" != typeof e && "string" != typeof e) return !0 } } return !(!("children" in e) || !Array.isArray(e.children)) }(s)) i.unshift(s); else for (const [t, n] of Object.entries(s)) Kd(e, o.properties, t, n) } for (const e of i) Qd(o.children, e); return "element" === o.type && "template" === o.tagName && (o.content = { type: "root", children: o.children }, o.children = []), o } } function Kd(e, t, n, r) { const s = Lo(e, n); let i; if (null != r) { if ("number" == typeof r) { if (Number.isNaN(r)) return; i = r } else i = "boolean" == typeof r ? r : "string" == typeof r ? s.spaceSeparated ? Bo(r) : s.commaSeparated ? Wi(r) : s.commaOrSpaceSeparated ? Bo(Wi(r).join(" ")) : Xd(s, s.property, r) : Array.isArray(r) ? [...r] : "style" === s.property ? function (e) { const t = []; for (const [n, r] of Object.entries(e)) t.push([n, r].join(": ")); return t.join("; ") }(r) : String(r); if (Array.isArray(i)) { const e = []; for (const t of i) e.push(Xd(s, s.property, t)); i = e } "className" === s.property && Array.isArray(t.className) && (i = t.className.concat(i)), t[s.property] = i } } function Qd(e, t) { if (null == t); else if ("number" == typeof t || "string" == typeof t) e.push({ type: "text", value: String(t) }); else if (Array.isArray(t)) for (const n of t) Qd(e, n); else { if ("object" != typeof t || !("type" in t)) throw new Error("Expected node, nodes, or string, got `" + t + "`"); "root" === t.type ? Qd(e, t.children) : e.push(t) } } function Xd(e, t, n) { if ("string" == typeof n) { if (e.number && n && !Number.isNaN(Number(n))) return Number(n); if ((e.boolean || e.overloadedBoolean) && ("" === n || so(n) === so(t))) return !0 } return n } const Jd = Wd(Mo, "div"), Zd = Wd(Fo, "g", ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"]); function ep(e, t) { const n = e.indexOf("\r", t), r = e.indexOf("\n", t); return -1 === r ? n : -1 === n || n + 1 === r ? r : n < r ? n : r } const tp = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, np = {}.hasOwnProperty, rp = Object.prototype; function sp(e, t) { let n; switch (t.nodeName) { case "#comment": { const r = t; return n = { type: "comment", value: r.data }, op(e, r, n), n } case "#document": case "#document-fragment": { const r = t, s = "mode" in r && ("quirks" === r.mode || "limited-quirks" === r.mode); if (n = { type: "root", children: ip(e, t.childNodes), data: { quirksMode: s } }, e.file && e.location) { const t = String(e.file), r = function (e) { const t = String(e), n = []; return { toOffset: function (e) { if (e && "number" == typeof e.line && "number" == typeof e.column && !Number.isNaN(e.line) && !Number.isNaN(e.column)) { for (; n.length < e.line;) { const e = n[n.length - 1], r = ep(t, e), s = -1 === r ? t.length + 1 : r + 1; if (e === s) break; n.push(s) } const r = (e.line > 1 ? n[e.line - 2] : 0) + e.column - 1; if (r < n[e.line - 1]) return r } }, toPoint: function (e) { if ("number" == typeof e && e > -1 && e <= t.length) { let r = 0; for (; ;) { let s = n[r]; if (void 0 === s) { const e = ep(t, n[r - 1]); s = -1 === e ? t.length + 1 : e + 1, n[r] = s } if (s > e) return { line: r + 1, column: e - (r > 0 ? n[r - 1] : 0) + 1, offset: e }; r++ } } } } }(t), s = r.toPoint(0), i = r.toPoint(t.length); n.position = { start: s, end: i } } return n } case "#documentType": return n = { type: "doctype" }, op(e, t, n), n; case "#text": { const r = t; return n = { type: "text", value: r.value }, op(e, r, n), n } default: return n = function (e, t) { const n = e.schema; e.schema = t.namespaceURI === tp.svg ? Fo : Mo; let r = -1; const s = {}; for (; ++r < t.attrs.length;) { const e = t.attrs[r], n = (e.prefix ? e.prefix + ":" : "") + e.name; np.call(rp, n) || (s[n] = e.value) } const i = ("svg" === e.schema.space ? Zd : Jd)(t.tagName, s, ip(e, t.childNodes)); if (op(e, t, i), "template" === i.tagName) { const n = t, r = n.sourceCodeLocation, s = r && r.startTag && ap(r.startTag), o = r && r.endTag && ap(r.endTag), a = sp(e, n.content); s && o && e.file && (a.position = { start: s.end, end: o.start }), i.content = a } return e.schema = n, i }(e, t), n } } function ip(e, t) { let n = -1; const r = []; for (; ++n < t.length;) { const s = sp(e, t[n]); r.push(s) } return r } function op(e, t, n) { if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) { const r = function (e, t, n) { const r = ap(n); if ("element" === t.type) { const s = t.children[t.children.length - 1]; if (r && !n.endTag && s && s.position && s.position.end && (r.end = Object.assign({}, s.position.end)), e.verbose) { const r = {}; let s; if (n.attrs) for (s in n.attrs) np.call(n.attrs, s) && (r[Lo(e.schema, s).property] = ap(n.attrs[s])); n.startTag; const i = ap(n.startTag), o = n.endTag ? ap(n.endTag) : void 0, a = { opening: i }; o && (a.closing = o), a.properties = r, t.data = { position: a } } } return r }(e, n, t.sourceCodeLocation); r && (e.location = !0, n.position = r) } } function ap(e) { const t = lp({ line: e.startLine, column: e.startCol, offset: e.startOffset }), n = lp({ line: e.endLine, column: e.endCol, offset: e.endOffset }); return t || n ? { start: t, end: n } : void 0 } function lp(e) { return e.line && e.column ? e : void 0 } const cp = {}, up = {}.hasOwnProperty, hp = Ph("type", { handlers: { root: function (e, t) { const n = { nodeName: "#document", mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks", childNodes: [] }; return n.childNodes = pp(e.children, n, t), fp(e, n), n }, element: function (e, t) { const n = t; let r = n; "element" === e.type && "svg" === e.tagName.toLowerCase() && "html" === n.space && (r = Fo); const s = []; let i; if (e.properties) for (i in e.properties) if ("children" !== i && up.call(e.properties, i)) { const t = dp(r, i, e.properties[i]); t && s.push(t) } const o = r.space, a = { nodeName: e.tagName, tagName: e.tagName, attrs: s, namespaceURI: tp[o], childNodes: [], parentNode: null }; return a.childNodes = pp(e.children, a, r), fp(e, a), "template" === e.tagName && e.content && (a.content = function (e, t) { const n = { nodeName: "#document-fragment", childNodes: [] }; return n.childNodes = pp(e.children, n, t), fp(e, n), n }(e.content, r)), a }, text: function (e) { const t = { nodeName: "#text", value: e.value, parentNode: null }; return fp(e, t), t }, comment: function (e) { const t = { nodeName: "#comment", data: e.value, parentNode: null }; return fp(e, t), t }, doctype: function (e) { const t = { nodeName: "#documentType", name: "html", publicId: "", systemId: "", parentNode: null }; return fp(e, t), t } } }); function dp(e, t, n) { const r = Lo(e, t); if (!1 === n || null == n || "number" == typeof n && Number.isNaN(n) || !n && r.boolean) return; Array.isArray(n) && (n = r.commaSeparated ? Ki(n) : Uo(n)); const s = { name: r.attribute, value: !0 === n ? "" : String(n) }; if (r.space && "html" !== r.space && "svg" !== r.space) { const e = s.name.indexOf(":"); e < 0 ? s.prefix = "" : (s.name = s.name.slice(e + 1), s.prefix = r.attribute.slice(0, e)), s.namespace = tp[r.space] } return s } function pp(e, t, n) { let r = -1; const s = []; if (e) for (; ++r < e.length;) { const i = hp(e[r], n); i.parentNode = t, s.push(i) } return s } function fp(e, t) { const n = e.position; n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = { startLine: n.start.line, startCol: n.start.column, startOffset: n.start.offset, endLine: n.end.line, endCol: n.end.column, endOffset: n.end.offset }) } const mp = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], gp = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]), Ep = ""; var Tp, Ap; (Ap = Tp || (Tp = {}))[Ap.EOF = -1] = "EOF", Ap[Ap.NULL = 0] = "NULL", Ap[Ap.TABULATION = 9] = "TABULATION", Ap[Ap.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", Ap[Ap.LINE_FEED = 10] = "LINE_FEED", Ap[Ap.FORM_FEED = 12] = "FORM_FEED", Ap[Ap.SPACE = 32] = "SPACE", Ap[Ap.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", Ap[Ap.QUOTATION_MARK = 34] = "QUOTATION_MARK", Ap[Ap.AMPERSAND = 38] = "AMPERSAND", Ap[Ap.APOSTROPHE = 39] = "APOSTROPHE", Ap[Ap.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", Ap[Ap.SOLIDUS = 47] = "SOLIDUS", Ap[Ap.DIGIT_0 = 48] = "DIGIT_0", Ap[Ap.DIGIT_9 = 57] = "DIGIT_9", Ap[Ap.SEMICOLON = 59] = "SEMICOLON", Ap[Ap.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", Ap[Ap.EQUALS_SIGN = 61] = "EQUALS_SIGN", Ap[Ap.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", Ap[Ap.QUESTION_MARK = 63] = "QUESTION_MARK", Ap[Ap.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", Ap[Ap.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", Ap[Ap.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", Ap[Ap.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", Ap[Ap.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", Ap[Ap.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z"; const _p = "[CDATA[", yp = "doctype", bp = "script"; function Sp(e) { return e >= 55296 && e <= 57343 } function kp(e) { return 32 !== e && 10 !== e && 13 !== e && 9 !== e && 12 !== e && e >= 1 && e <= 31 || e >= 127 && e <= 159 } function Cp(e) { return e >= 64976 && e <= 65007 || gp.has(e) } var Np, Ip, Op, xp; (Ip = Np || (Np = {})).controlCharacterInInputStream = "control-character-in-input-stream", Ip.noncharacterInInputStream = "noncharacter-in-input-stream", Ip.surrogateInInputStream = "surrogate-in-input-stream", Ip.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", Ip.endTagWithAttributes = "end-tag-with-attributes", Ip.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", Ip.unexpectedSolidusInTag = "unexpected-solidus-in-tag", Ip.unexpectedNullCharacter = "unexpected-null-character", Ip.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", Ip.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", Ip.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", Ip.missingEndTagName = "missing-end-tag-name", Ip.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", Ip.unknownNamedCharacterReference = "unknown-named-character-reference", Ip.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", Ip.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", Ip.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", Ip.eofBeforeTagName = "eof-before-tag-name", Ip.eofInTag = "eof-in-tag", Ip.missingAttributeValue = "missing-attribute-value", Ip.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", Ip.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", Ip.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", Ip.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", Ip.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", Ip.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", Ip.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", Ip.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", Ip.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", Ip.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", Ip.cdataInHtmlContent = "cdata-in-html-content", Ip.incorrectlyOpenedComment = "incorrectly-opened-comment", Ip.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", Ip.eofInDoctype = "eof-in-doctype", Ip.nestedComment = "nested-comment", Ip.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", Ip.eofInComment = "eof-in-comment", Ip.incorrectlyClosedComment = "incorrectly-closed-comment", Ip.eofInCdata = "eof-in-cdata", Ip.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", Ip.nullCharacterReference = "null-character-reference", Ip.surrogateCharacterReference = "surrogate-character-reference", Ip.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", Ip.controlCharacterReference = "control-character-reference", Ip.noncharacterCharacterReference = "noncharacter-character-reference", Ip.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", Ip.missingDoctypeName = "missing-doctype-name", Ip.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", Ip.duplicateAttribute = "duplicate-attribute", Ip.nonConformingDoctype = "non-conforming-doctype", Ip.missingDoctype = "missing-doctype", Ip.misplacedDoctype = "misplaced-doctype", Ip.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", Ip.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", Ip.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", Ip.openElementsLeftAfterEof = "open-elements-left-after-eof", Ip.abandonedHeadElementChild = "abandoned-head-element-child", Ip.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", Ip.nestedNoscriptInHead = "nested-noscript-in-head", Ip.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text"; class vp { constructor(e) { this.handler = e, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = 65536, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1 } get col() { return this.pos - this.lineStartPos + Number(this.lastGapPos !== this.pos) } get offset() { return this.droppedBufferSize + this.pos } getError(e, t) { const { line: n, col: r, offset: s } = this, i = r + t, o = s + t; return { code: e, startLine: n, endLine: n, startCol: i, endCol: i, startOffset: o, endOffset: o } } _err(e) { this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(e, 0))) } _addGap() { this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos } _processSurrogate(e) { if (this.pos !== this.html.length - 1) { const t = this.html.charCodeAt(this.pos + 1); if (function (e) { return e >= 56320 && e <= 57343 }(t)) return this.pos++, this._addGap(), 1024 * (e - 55296) + 9216 + t } else if (!this.lastChunkWritten) return this.endOfChunkHit = !0, Tp.EOF; return this._err(Np.surrogateInInputStream), e } willDropParsedChunk() { return this.pos > this.bufferWaterline } dropParsedChunk() { this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0) } write(e, t) { this.html.length > 0 ? this.html += e : this.html = e, this.endOfChunkHit = !1, this.lastChunkWritten = t } insertHtmlAtCurrentPos(e) { this.html = this.html.substring(0, this.pos + 1) + e + this.html.substring(this.pos + 1), this.endOfChunkHit = !1 } startsWith(e, t) { if (this.pos + e.length > this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, !1; if (t) return this.html.startsWith(e, this.pos); for (let n = 0; n < e.length; n++)if ((32 | this.html.charCodeAt(this.pos + n)) !== e.charCodeAt(n)) return !1; return !0 } peek(e) { const t = this.pos + e; if (t >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, Tp.EOF; const n = this.html.charCodeAt(t); return n === Tp.CARRIAGE_RETURN ? Tp.LINE_FEED : n } advance() { if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, Tp.EOF; let e = this.html.charCodeAt(this.pos); return e === Tp.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, Tp.LINE_FEED) : e === Tp.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, Sp(e) && (e = this._processSurrogate(e)), null === this.handler.onParseError || e > 31 && e < 127 || e === Tp.LINE_FEED || e === Tp.CARRIAGE_RETURN || e > 159 && e < 64976 || this._checkForProblematicCharacters(e), e) } _checkForProblematicCharacters(e) { kp(e) ? this._err(Np.controlCharacterInInputStream) : Cp(e) && this._err(Np.noncharacterInInputStream) } retreat(e) { for (this.pos -= e; this.pos < this.lastGapPos;)this.lastGapPos = this.gapStack.pop(), this.pos--; this.isEol = !1 } } function Rp(e, t) { for (let n = e.attrs.length - 1; n >= 0; n--)if (e.attrs[n].name === t) return e.attrs[n].value; return null } (xp = Op || (Op = {}))[xp.CHARACTER = 0] = "CHARACTER", xp[xp.NULL_CHARACTER = 1] = "NULL_CHARACTER", xp[xp.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", xp[xp.START_TAG = 3] = "START_TAG", xp[xp.END_TAG = 4] = "END_TAG", xp[xp.COMMENT = 5] = "COMMENT", xp[xp.DOCTYPE = 6] = "DOCTYPE", xp[xp.EOF = 7] = "EOF", xp[xp.HIBERNATION = 8] = "HIBERNATION"; const Dp = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(e => e.charCodeAt(0))), Lp = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]); var Pp, wp, Mp, Fp, Bp, Up, Hp, jp, Gp, zp, Yp, qp, Vp, $p, Wp, Kp, Qp, Xp; function Jp(e) { return e >= Pp.ZERO && e <= Pp.NINE } function Zp(e) { return e >= Pp.UPPER_A && e <= Pp.UPPER_F || e >= Pp.LOWER_A && e <= Pp.LOWER_F } function ef(e) { return e === Pp.EQUALS || function (e) { return e >= Pp.UPPER_A && e <= Pp.UPPER_Z || e >= Pp.LOWER_A && e <= Pp.LOWER_Z || Jp(e) }(e) } (wp = Pp || (Pp = {}))[wp.NUM = 35] = "NUM", wp[wp.SEMI = 59] = "SEMI", wp[wp.EQUALS = 61] = "EQUALS", wp[wp.ZERO = 48] = "ZERO", wp[wp.NINE = 57] = "NINE", wp[wp.LOWER_A = 97] = "LOWER_A", wp[wp.LOWER_F = 102] = "LOWER_F", wp[wp.LOWER_X = 120] = "LOWER_X", wp[wp.LOWER_Z = 122] = "LOWER_Z", wp[wp.UPPER_A = 65] = "UPPER_A", wp[wp.UPPER_F = 70] = "UPPER_F", wp[wp.UPPER_Z = 90] = "UPPER_Z", (Fp = Mp || (Mp = {}))[Fp.VALUE_LENGTH = 49152] = "VALUE_LENGTH", Fp[Fp.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", Fp[Fp.JUMP_TABLE = 127] = "JUMP_TABLE", (Up = Bp || (Bp = {}))[Up.EntityStart = 0] = "EntityStart", Up[Up.NumericStart = 1] = "NumericStart", Up[Up.NumericDecimal = 2] = "NumericDecimal", Up[Up.NumericHex = 3] = "NumericHex", Up[Up.NamedEntity = 4] = "NamedEntity", (jp = Hp || (Hp = {}))[jp.Legacy = 0] = "Legacy", jp[jp.Strict = 1] = "Strict", jp[jp.Attribute = 2] = "Attribute"; class tf { constructor(e, t, n) { this.decodeTree = e, this.emitCodePoint = t, this.errors = n, this.state = Bp.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = Hp.Strict } startEntity(e) { this.decodeMode = e, this.state = Bp.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1 } write(e, t) { switch (this.state) { case Bp.EntityStart: return e.charCodeAt(t) === Pp.NUM ? (this.state = Bp.NumericStart, this.consumed += 1, this.stateNumericStart(e, t + 1)) : (this.state = Bp.NamedEntity, this.stateNamedEntity(e, t)); case Bp.NumericStart: return this.stateNumericStart(e, t); case Bp.NumericDecimal: return this.stateNumericDecimal(e, t); case Bp.NumericHex: return this.stateNumericHex(e, t); case Bp.NamedEntity: return this.stateNamedEntity(e, t) } } stateNumericStart(e, t) { return t >= e.length ? -1 : (32 | e.charCodeAt(t)) === Pp.LOWER_X ? (this.state = Bp.NumericHex, this.consumed += 1, this.stateNumericHex(e, t + 1)) : (this.state = Bp.NumericDecimal, this.stateNumericDecimal(e, t)) } addToNumericResult(e, t, n, r) { if (t !== n) { const s = n - t; this.result = this.result * Math.pow(r, s) + Number.parseInt(e.substr(t, s), r), this.consumed += s } } stateNumericHex(e, t) { const n = t; for (; t < e.length;) { const r = e.charCodeAt(t); if (!Jp(r) && !Zp(r)) return this.addToNumericResult(e, n, t, 16), this.emitNumericEntity(r, 3); t += 1 } return this.addToNumericResult(e, n, t, 16), -1 } stateNumericDecimal(e, t) { const n = t; for (; t < e.length;) { const r = e.charCodeAt(t); if (!Jp(r)) return this.addToNumericResult(e, n, t, 10), this.emitNumericEntity(r, 2); t += 1 } return this.addToNumericResult(e, n, t, 10), -1 } emitNumericEntity(e, t) { var n; if (this.consumed <= t) return null === (n = this.errors) || void 0 === n || n.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; if (e === Pp.SEMI) this.consumed += 1; else if (this.decodeMode === Hp.Strict) return 0; return this.emitCodePoint(function (e) { var t; return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : null !== (t = Lp.get(e)) && void 0 !== t ? t : e }(this.result), this.consumed), this.errors && (e !== Pp.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed } stateNamedEntity(e, t) { const { decodeTree: n } = this; let r = n[this.treeIndex], s = (r & Mp.VALUE_LENGTH) >> 14; for (; t < e.length; t++, this.excess++) { const i = e.charCodeAt(t); if (this.treeIndex = nf(n, r, this.treeIndex + Math.max(1, s), i), this.treeIndex < 0) return 0 === this.result || this.decodeMode === Hp.Attribute && (0 === s || ef(i)) ? 0 : this.emitNotTerminatedNamedEntity(); if (r = n[this.treeIndex], s = (r & Mp.VALUE_LENGTH) >> 14, 0 !== s) { if (i === Pp.SEMI) return this.emitNamedEntityData(this.treeIndex, s, this.consumed + this.excess); this.decodeMode !== Hp.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0) } } return -1 } emitNotTerminatedNamedEntity() { var e; const { result: t, decodeTree: n } = this, r = (n[t] & Mp.VALUE_LENGTH) >> 14; return this.emitNamedEntityData(t, r, this.consumed), null === (e = this.errors) || void 0 === e || e.missingSemicolonAfterCharacterReference(), this.consumed } emitNamedEntityData(e, t, n) { const { decodeTree: r } = this; return this.emitCodePoint(1 === t ? r[e] & ~Mp.VALUE_LENGTH : r[e + 1], n), 3 === t && this.emitCodePoint(r[e + 2], n), n } end() { var e; switch (this.state) { case Bp.NamedEntity: return 0 === this.result || this.decodeMode === Hp.Attribute && this.result !== this.treeIndex ? 0 : this.emitNotTerminatedNamedEntity(); case Bp.NumericDecimal: return this.emitNumericEntity(0, 2); case Bp.NumericHex: return this.emitNumericEntity(0, 3); case Bp.NumericStart: return null === (e = this.errors) || void 0 === e || e.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; case Bp.EntityStart: return 0 } } } function nf(e, t, n, r) { const s = (t & Mp.BRANCH_LENGTH) >> 7, i = t & Mp.JUMP_TABLE; if (0 === s) return 0 !== i && r === i ? n : -1; if (i) { const t = r - i; return t < 0 || t >= s ? -1 : e[n + t] - 1 } let o = n, a = o + s - 1; for (; o <= a;) { const t = o + a >>> 1, n = e[t]; if (n < r) o = t + 1; else { if (!(n > r)) return e[t + s]; a = t - 1 } } return -1 } (zp = Gp || (Gp = {})).HTML = "http://www.w3.org/1999/xhtml", zp.MATHML = "http://www.w3.org/1998/Math/MathML", zp.SVG = "http://www.w3.org/2000/svg", zp.XLINK = "http://www.w3.org/1999/xlink", zp.XML = "http://www.w3.org/XML/1998/namespace", zp.XMLNS = "http://www.w3.org/2000/xmlns/", (qp = Yp || (Yp = {})).TYPE = "type", qp.ACTION = "action", qp.ENCODING = "encoding", qp.PROMPT = "prompt", qp.NAME = "name", qp.COLOR = "color", qp.FACE = "face", qp.SIZE = "size", ($p = Vp || (Vp = {})).NO_QUIRKS = "no-quirks", $p.QUIRKS = "quirks", $p.LIMITED_QUIRKS = "limited-quirks", (Kp = Wp || (Wp = {})).A = "a", Kp.ADDRESS = "address", Kp.ANNOTATION_XML = "annotation-xml", Kp.APPLET = "applet", Kp.AREA = "area", Kp.ARTICLE = "article", Kp.ASIDE = "aside", Kp.B = "b", Kp.BASE = "base", Kp.BASEFONT = "basefont", Kp.BGSOUND = "bgsound", Kp.BIG = "big", Kp.BLOCKQUOTE = "blockquote", Kp.BODY = "body", Kp.BR = "br", Kp.BUTTON = "button", Kp.CAPTION = "caption", Kp.CENTER = "center", Kp.CODE = "code", Kp.COL = "col", Kp.COLGROUP = "colgroup", Kp.DD = "dd", Kp.DESC = "desc", Kp.DETAILS = "details", Kp.DIALOG = "dialog", Kp.DIR = "dir", Kp.DIV = "div", Kp.DL = "dl", Kp.DT = "dt", Kp.EM = "em", Kp.EMBED = "embed", Kp.FIELDSET = "fieldset", Kp.FIGCAPTION = "figcaption", Kp.FIGURE = "figure", Kp.FONT = "font", Kp.FOOTER = "footer", Kp.FOREIGN_OBJECT = "foreignObject", Kp.FORM = "form", Kp.FRAME = "frame", Kp.FRAMESET = "frameset", Kp.H1 = "h1", Kp.H2 = "h2", Kp.H3 = "h3", Kp.H4 = "h4", Kp.H5 = "h5", Kp.H6 = "h6", Kp.HEAD = "head", Kp.HEADER = "header", Kp.HGROUP = "hgroup", Kp.HR = "hr", Kp.HTML = "html", Kp.I = "i", Kp.IMG = "img", Kp.IMAGE = "image", Kp.INPUT = "input", Kp.IFRAME = "iframe", Kp.KEYGEN = "keygen", Kp.LABEL = "label", Kp.LI = "li", Kp.LINK = "link", Kp.LISTING = "listing", Kp.MAIN = "main", Kp.MALIGNMARK = "malignmark", Kp.MARQUEE = "marquee", Kp.MATH = "math", Kp.MENU = "menu", Kp.META = "meta", Kp.MGLYPH = "mglyph", Kp.MI = "mi", Kp.MO = "mo", Kp.MN = "mn", Kp.MS = "ms", Kp.MTEXT = "mtext", Kp.NAV = "nav", Kp.NOBR = "nobr", Kp.NOFRAMES = "noframes", Kp.NOEMBED = "noembed", Kp.NOSCRIPT = "noscript", Kp.OBJECT = "object", Kp.OL = "ol", Kp.OPTGROUP = "optgroup", Kp.OPTION = "option", Kp.P = "p", Kp.PARAM = "param", Kp.PLAINTEXT = "plaintext", Kp.PRE = "pre", Kp.RB = "rb", Kp.RP = "rp", Kp.RT = "rt", Kp.RTC = "rtc", Kp.RUBY = "ruby", Kp.S = "s", Kp.SCRIPT = "script", Kp.SEARCH = "search", Kp.SECTION = "section", Kp.SELECT = "select", Kp.SOURCE = "source", Kp.SMALL = "small", Kp.SPAN = "span", Kp.STRIKE = "strike", Kp.STRONG = "strong", Kp.STYLE = "style", Kp.SUB = "sub", Kp.SUMMARY = "summary", Kp.SUP = "sup", Kp.TABLE = "table", Kp.TBODY = "tbody", Kp.TEMPLATE = "template", Kp.TEXTAREA = "textarea", Kp.TFOOT = "tfoot", Kp.TD = "td", Kp.TH = "th", Kp.THEAD = "thead", Kp.TITLE = "title", Kp.TR = "tr", Kp.TRACK = "track", Kp.TT = "tt", Kp.U = "u", Kp.UL = "ul", Kp.SVG = "svg", Kp.VAR = "var", Kp.WBR = "wbr", Kp.XMP = "xmp", (Xp = Qp || (Qp = {}))[Xp.UNKNOWN = 0] = "UNKNOWN", Xp[Xp.A = 1] = "A", Xp[Xp.ADDRESS = 2] = "ADDRESS", Xp[Xp.ANNOTATION_XML = 3] = "ANNOTATION_XML", Xp[Xp.APPLET = 4] = "APPLET", Xp[Xp.AREA = 5] = "AREA", Xp[Xp.ARTICLE = 6] = "ARTICLE", Xp[Xp.ASIDE = 7] = "ASIDE", Xp[Xp.B = 8] = "B", Xp[Xp.BASE = 9] = "BASE", Xp[Xp.BASEFONT = 10] = "BASEFONT", Xp[Xp.BGSOUND = 11] = "BGSOUND", Xp[Xp.BIG = 12] = "BIG", Xp[Xp.BLOCKQUOTE = 13] = "BLOCKQUOTE", Xp[Xp.BODY = 14] = "BODY", Xp[Xp.BR = 15] = "BR", Xp[Xp.BUTTON = 16] = "BUTTON", Xp[Xp.CAPTION = 17] = "CAPTION", Xp[Xp.CENTER = 18] = "CENTER", Xp[Xp.CODE = 19] = "CODE", Xp[Xp.COL = 20] = "COL", Xp[Xp.COLGROUP = 21] = "COLGROUP", Xp[Xp.DD = 22] = "DD", Xp[Xp.DESC = 23] = "DESC", Xp[Xp.DETAILS = 24] = "DETAILS", Xp[Xp.DIALOG = 25] = "DIALOG", Xp[Xp.DIR = 26] = "DIR", Xp[Xp.DIV = 27] = "DIV", Xp[Xp.DL = 28] = "DL", Xp[Xp.DT = 29] = "DT", Xp[Xp.EM = 30] = "EM", Xp[Xp.EMBED = 31] = "EMBED", Xp[Xp.FIELDSET = 32] = "FIELDSET", Xp[Xp.FIGCAPTION = 33] = "FIGCAPTION", Xp[Xp.FIGURE = 34] = "FIGURE", Xp[Xp.FONT = 35] = "FONT", Xp[Xp.FOOTER = 36] = "FOOTER", Xp[Xp.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", Xp[Xp.FORM = 38] = "FORM", Xp[Xp.FRAME = 39] = "FRAME", Xp[Xp.FRAMESET = 40] = "FRAMESET", Xp[Xp.H1 = 41] = "H1", Xp[Xp.H2 = 42] = "H2", Xp[Xp.H3 = 43] = "H3", Xp[Xp.H4 = 44] = "H4", Xp[Xp.H5 = 45] = "H5", Xp[Xp.H6 = 46] = "H6", Xp[Xp.HEAD = 47] = "HEAD", Xp[Xp.HEADER = 48] = "HEADER", Xp[Xp.HGROUP = 49] = "HGROUP", Xp[Xp.HR = 50] = "HR", Xp[Xp.HTML = 51] = "HTML", Xp[Xp.I = 52] = "I", Xp[Xp.IMG = 53] = "IMG", Xp[Xp.IMAGE = 54] = "IMAGE", Xp[Xp.INPUT = 55] = "INPUT", Xp[Xp.IFRAME = 56] = "IFRAME", Xp[Xp.KEYGEN = 57] = "KEYGEN", Xp[Xp.LABEL = 58] = "LABEL", Xp[Xp.LI = 59] = "LI", Xp[Xp.LINK = 60] = "LINK", Xp[Xp.LISTING = 61] = "LISTING", Xp[Xp.MAIN = 62] = "MAIN", Xp[Xp.MALIGNMARK = 63] = "MALIGNMARK", Xp[Xp.MARQUEE = 64] = "MARQUEE", Xp[Xp.MATH = 65] = "MATH", Xp[Xp.MENU = 66] = "MENU", Xp[Xp.META = 67] = "META", Xp[Xp.MGLYPH = 68] = "MGLYPH", Xp[Xp.MI = 69] = "MI", Xp[Xp.MO = 70] = "MO", Xp[Xp.MN = 71] = "MN", Xp[Xp.MS = 72] = "MS", Xp[Xp.MTEXT = 73] = "MTEXT", Xp[Xp.NAV = 74] = "NAV", Xp[Xp.NOBR = 75] = "NOBR", Xp[Xp.NOFRAMES = 76] = "NOFRAMES", Xp[Xp.NOEMBED = 77] = "NOEMBED", Xp[Xp.NOSCRIPT = 78] = "NOSCRIPT", Xp[Xp.OBJECT = 79] = "OBJECT", Xp[Xp.OL = 80] = "OL", Xp[Xp.OPTGROUP = 81] = "OPTGROUP", Xp[Xp.OPTION = 82] = "OPTION", Xp[Xp.P = 83] = "P", Xp[Xp.PARAM = 84] = "PARAM", Xp[Xp.PLAINTEXT = 85] = "PLAINTEXT", Xp[Xp.PRE = 86] = "PRE", Xp[Xp.RB = 87] = "RB", Xp[Xp.RP = 88] = "RP", Xp[Xp.RT = 89] = "RT", Xp[Xp.RTC = 90] = "RTC", Xp[Xp.RUBY = 91] = "RUBY", Xp[Xp.S = 92] = "S", Xp[Xp.SCRIPT = 93] = "SCRIPT", Xp[Xp.SEARCH = 94] = "SEARCH", Xp[Xp.SECTION = 95] = "SECTION", Xp[Xp.SELECT = 96] = "SELECT", Xp[Xp.SOURCE = 97] = "SOURCE", Xp[Xp.SMALL = 98] = "SMALL", Xp[Xp.SPAN = 99] = "SPAN", Xp[Xp.STRIKE = 100] = "STRIKE", Xp[Xp.STRONG = 101] = "STRONG", Xp[Xp.STYLE = 102] = "STYLE", Xp[Xp.SUB = 103] = "SUB", Xp[Xp.SUMMARY = 104] = "SUMMARY", Xp[Xp.SUP = 105] = "SUP", Xp[Xp.TABLE = 106] = "TABLE", Xp[Xp.TBODY = 107] = "TBODY", Xp[Xp.TEMPLATE = 108] = "TEMPLATE", Xp[Xp.TEXTAREA = 109] = "TEXTAREA", Xp[Xp.TFOOT = 110] = "TFOOT", Xp[Xp.TD = 111] = "TD", Xp[Xp.TH = 112] = "TH", Xp[Xp.THEAD = 113] = "THEAD", Xp[Xp.TITLE = 114] = "TITLE", Xp[Xp.TR = 115] = "TR", Xp[Xp.TRACK = 116] = "TRACK", Xp[Xp.TT = 117] = "TT", Xp[Xp.U = 118] = "U", Xp[Xp.UL = 119] = "UL", Xp[Xp.SVG = 120] = "SVG", Xp[Xp.VAR = 121] = "VAR", Xp[Xp.WBR = 122] = "WBR", Xp[Xp.XMP = 123] = "XMP"; const rf = new Map([[Wp.A, Qp.A], [Wp.ADDRESS, Qp.ADDRESS], [Wp.ANNOTATION_XML, Qp.ANNOTATION_XML], [Wp.APPLET, Qp.APPLET], [Wp.AREA, Qp.AREA], [Wp.ARTICLE, Qp.ARTICLE], [Wp.ASIDE, Qp.ASIDE], [Wp.B, Qp.B], [Wp.BASE, Qp.BASE], [Wp.BASEFONT, Qp.BASEFONT], [Wp.BGSOUND, Qp.BGSOUND], [Wp.BIG, Qp.BIG], [Wp.BLOCKQUOTE, Qp.BLOCKQUOTE], [Wp.BODY, Qp.BODY], [Wp.BR, Qp.BR], [Wp.BUTTON, Qp.BUTTON], [Wp.CAPTION, Qp.CAPTION], [Wp.CENTER, Qp.CENTER], [Wp.CODE, Qp.CODE], [Wp.COL, Qp.COL], [Wp.COLGROUP, Qp.COLGROUP], [Wp.DD, Qp.DD], [Wp.DESC, Qp.DESC], [Wp.DETAILS, Qp.DETAILS], [Wp.DIALOG, Qp.DIALOG], [Wp.DIR, Qp.DIR], [Wp.DIV, Qp.DIV], [Wp.DL, Qp.DL], [Wp.DT, Qp.DT], [Wp.EM, Qp.EM], [Wp.EMBED, Qp.EMBED], [Wp.FIELDSET, Qp.FIELDSET], [Wp.FIGCAPTION, Qp.FIGCAPTION], [Wp.FIGURE, Qp.FIGURE], [Wp.FONT, Qp.FONT], [Wp.FOOTER, Qp.FOOTER], [Wp.FOREIGN_OBJECT, Qp.FOREIGN_OBJECT], [Wp.FORM, Qp.FORM], [Wp.FRAME, Qp.FRAME], [Wp.FRAMESET, Qp.FRAMESET], [Wp.H1, Qp.H1], [Wp.H2, Qp.H2], [Wp.H3, Qp.H3], [Wp.H4, Qp.H4], [Wp.H5, Qp.H5], [Wp.H6, Qp.H6], [Wp.HEAD, Qp.HEAD], [Wp.HEADER, Qp.HEADER], [Wp.HGROUP, Qp.HGROUP], [Wp.HR, Qp.HR], [Wp.HTML, Qp.HTML], [Wp.I, Qp.I], [Wp.IMG, Qp.IMG], [Wp.IMAGE, Qp.IMAGE], [Wp.INPUT, Qp.INPUT], [Wp.IFRAME, Qp.IFRAME], [Wp.KEYGEN, Qp.KEYGEN], [Wp.LABEL, Qp.LABEL], [Wp.LI, Qp.LI], [Wp.LINK, Qp.LINK], [Wp.LISTING, Qp.LISTING], [Wp.MAIN, Qp.MAIN], [Wp.MALIGNMARK, Qp.MALIGNMARK], [Wp.MARQUEE, Qp.MARQUEE], [Wp.MATH, Qp.MATH], [Wp.MENU, Qp.MENU], [Wp.META, Qp.META], [Wp.MGLYPH, Qp.MGLYPH], [Wp.MI, Qp.MI], [Wp.MO, Qp.MO], [Wp.MN, Qp.MN], [Wp.MS, Qp.MS], [Wp.MTEXT, Qp.MTEXT], [Wp.NAV, Qp.NAV], [Wp.NOBR, Qp.NOBR], [Wp.NOFRAMES, Qp.NOFRAMES], [Wp.NOEMBED, Qp.NOEMBED], [Wp.NOSCRIPT, Qp.NOSCRIPT], [Wp.OBJECT, Qp.OBJECT], [Wp.OL, Qp.OL], [Wp.OPTGROUP, Qp.OPTGROUP], [Wp.OPTION, Qp.OPTION], [Wp.P, Qp.P], [Wp.PARAM, Qp.PARAM], [Wp.PLAINTEXT, Qp.PLAINTEXT], [Wp.PRE, Qp.PRE], [Wp.RB, Qp.RB], [Wp.RP, Qp.RP], [Wp.RT, Qp.RT], [Wp.RTC, Qp.RTC], [Wp.RUBY, Qp.RUBY], [Wp.S, Qp.S], [Wp.SCRIPT, Qp.SCRIPT], [Wp.SEARCH, Qp.SEARCH], [Wp.SECTION, Qp.SECTION], [Wp.SELECT, Qp.SELECT], [Wp.SOURCE, Qp.SOURCE], [Wp.SMALL, Qp.SMALL], [Wp.SPAN, Qp.SPAN], [Wp.STRIKE, Qp.STRIKE], [Wp.STRONG, Qp.STRONG], [Wp.STYLE, Qp.STYLE], [Wp.SUB, Qp.SUB], [Wp.SUMMARY, Qp.SUMMARY], [Wp.SUP, Qp.SUP], [Wp.TABLE, Qp.TABLE], [Wp.TBODY, Qp.TBODY], [Wp.TEMPLATE, Qp.TEMPLATE], [Wp.TEXTAREA, Qp.TEXTAREA], [Wp.TFOOT, Qp.TFOOT], [Wp.TD, Qp.TD], [Wp.TH, Qp.TH], [Wp.THEAD, Qp.THEAD], [Wp.TITLE, Qp.TITLE], [Wp.TR, Qp.TR], [Wp.TRACK, Qp.TRACK], [Wp.TT, Qp.TT], [Wp.U, Qp.U], [Wp.UL, Qp.UL], [Wp.SVG, Qp.SVG], [Wp.VAR, Qp.VAR], [Wp.WBR, Qp.WBR], [Wp.XMP, Qp.XMP]]); function sf(e) { var t; return null !== (t = rf.get(e)) && void 0 !== t ? t : Qp.UNKNOWN } const of = Qp, af = { [Gp.HTML]: new Set([of.ADDRESS, of.APPLET, of.AREA, of.ARTICLE, of.ASIDE, of.BASE, of.BASEFONT, of.BGSOUND, of.BLOCKQUOTE, of.BODY, of.BR, of.BUTTON, of.CAPTION, of.CENTER, of.COL, of.COLGROUP, of.DD, of.DETAILS, of.DIR, of.DIV, of.DL, of.DT, of.EMBED, of.FIELDSET, of.FIGCAPTION, of.FIGURE, of.FOOTER, of.FORM, of.FRAME, of.FRAMESET, of.H1, of.H2, of.H3, of.H4, of.H5, of.H6, of.HEAD, of.HEADER, of.HGROUP, of.HR, of.HTML, of.IFRAME, of.IMG, of.INPUT, of.LI, of.LINK, of.LISTING, of.MAIN, of.MARQUEE, of.MENU, of.META, of.NAV, of.NOEMBED, of.NOFRAMES, of.NOSCRIPT, of.OBJECT, of.OL, of.P, of.PARAM, of.PLAINTEXT, of.PRE, of.SCRIPT, of.SECTION, of.SELECT, of.SOURCE, of.STYLE, of.SUMMARY, of.TABLE, of.TBODY, of.TD, of.TEMPLATE, of.TEXTAREA, of.TFOOT, of.TH, of.THEAD, of.TITLE, of.TR, of.TRACK, of.UL, of.WBR, of.XMP]), [Gp.MATHML]: new Set([of.MI, of.MO, of.MN, of.MS, of.MTEXT, of.ANNOTATION_XML]), [Gp.SVG]: new Set([of.TITLE, of.FOREIGN_OBJECT, of.DESC]), [Gp.XLINK]: new Set, [Gp.XML]: new Set, [Gp.XMLNS]: new Set }, lf = new Set([of.H1, of.H2, of.H3, of.H4, of.H5, of.H6]); var cf, uf; Wp.STYLE, Wp.SCRIPT, Wp.XMP, Wp.IFRAME, Wp.NOEMBED, Wp.NOFRAMES, Wp.PLAINTEXT, (uf = cf || (cf = {}))[uf.DATA = 0] = "DATA", uf[uf.RCDATA = 1] = "RCDATA", uf[uf.RAWTEXT = 2] = "RAWTEXT", uf[uf.SCRIPT_DATA = 3] = "SCRIPT_DATA", uf[uf.PLAINTEXT = 4] = "PLAINTEXT", uf[uf.TAG_OPEN = 5] = "TAG_OPEN", uf[uf.END_TAG_OPEN = 6] = "END_TAG_OPEN", uf[uf.TAG_NAME = 7] = "TAG_NAME", uf[uf.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", uf[uf.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", uf[uf.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", uf[uf.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", uf[uf.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", uf[uf.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", uf[uf.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", uf[uf.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", uf[uf.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", uf[uf.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", uf[uf.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", uf[uf.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", uf[uf.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", uf[uf.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", uf[uf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", uf[uf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", uf[uf.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", uf[uf.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", uf[uf.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", uf[uf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", uf[uf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", uf[uf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", uf[uf.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", uf[uf.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", uf[uf.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", uf[uf.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", uf[uf.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", uf[uf.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", uf[uf.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", uf[uf.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", uf[uf.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", uf[uf.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", uf[uf.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", uf[uf.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", uf[uf.COMMENT_START = 42] = "COMMENT_START", uf[uf.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", uf[uf.COMMENT = 44] = "COMMENT", uf[uf.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", uf[uf.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", uf[uf.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", uf[uf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", uf[uf.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", uf[uf.COMMENT_END = 50] = "COMMENT_END", uf[uf.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", uf[uf.DOCTYPE = 52] = "DOCTYPE", uf[uf.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", uf[uf.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", uf[uf.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", uf[uf.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", uf[uf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", uf[uf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", uf[uf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", uf[uf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", uf[uf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", uf[uf.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", uf[uf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", uf[uf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", uf[uf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", uf[uf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", uf[uf.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", uf[uf.CDATA_SECTION = 68] = "CDATA_SECTION", uf[uf.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", uf[uf.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", uf[uf.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", uf[uf.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND"; const hf = { DATA: cf.DATA, RCDATA: cf.RCDATA, RAWTEXT: cf.RAWTEXT, SCRIPT_DATA: cf.SCRIPT_DATA, PLAINTEXT: cf.PLAINTEXT, CDATA_SECTION: cf.CDATA_SECTION }; function df(e) { return e >= Tp.LATIN_CAPITAL_A && e <= Tp.LATIN_CAPITAL_Z } function pf(e) { return function (e) { return e >= Tp.LATIN_SMALL_A && e <= Tp.LATIN_SMALL_Z }(e) || df(e) } function ff(e) { return pf(e) || function (e) { return e >= Tp.DIGIT_0 && e <= Tp.DIGIT_9 }(e) } function mf(e) { return e + 32 } function gf(e) { return e === Tp.SPACE || e === Tp.LINE_FEED || e === Tp.TABULATION || e === Tp.FORM_FEED } function Ef(e) { return gf(e) || e === Tp.SOLIDUS || e === Tp.GREATER_THAN_SIGN } class Tf { constructor(e, t) { this.options = e, this.handler = t, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = cf.DATA, this.returnState = cf.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new vp(t), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new tf(Dp, (e, t) => { this.preprocessor.pos = this.entityStartPos + t - 1, this._flushCodePointConsumedAsCharacterReference(e) }, t.onParseError ? { missingSemicolonAfterCharacterReference: () => { this._err(Np.missingSemicolonAfterCharacterReference, 1) }, absenceOfDigitsInNumericCharacterReference: e => { this._err(Np.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + e) }, validateNumericCharacterReference: e => { const t = function (e) { return e === Tp.NULL ? Np.nullCharacterReference : e > 1114111 ? Np.characterReferenceOutsideUnicodeRange : Sp(e) ? Np.surrogateCharacterReference : Cp(e) ? Np.noncharacterCharacterReference : kp(e) || e === Tp.CARRIAGE_RETURN ? Np.controlCharacterReference : null }(e); t && this._err(t, 1) } } : void 0) } _err(e, t = 0) { var n, r; null === (r = (n = this.handler).onParseError) || void 0 === r || r.call(n, this.preprocessor.getError(e, t)) } getCurrentLocation(e) { return this.options.sourceCodeLocationInfo ? { startLine: this.preprocessor.line, startCol: this.preprocessor.col - e, startOffset: this.preprocessor.offset - e, endLine: -1, endCol: -1, endOffset: -1 } : null } _runParsingLoop() { if (!this.inLoop) { for (this.inLoop = !0; this.active && !this.paused;) { this.consumedAfterSnapshot = 0; const e = this._consume(); this._ensureHibernation() || this._callState(e) } this.inLoop = !1 } } pause() { this.paused = !0 } resume(e) { if (!this.paused) throw new Error("Parser was already resumed"); this.paused = !1, this.inLoop || (this._runParsingLoop(), this.paused || null == e || e()) } write(e, t, n) { this.active = !0, this.preprocessor.write(e, t), this._runParsingLoop(), this.paused || null == n || n() } insertHtmlAtCurrentPos(e) { this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(e), this._runParsingLoop() } _ensureHibernation() { return !!this.preprocessor.endOfChunkHit && (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) } _consume() { return this.consumedAfterSnapshot++, this.preprocessor.advance() } _advanceBy(e) { this.consumedAfterSnapshot += e; for (let t = 0; t < e; t++)this.preprocessor.advance() } _consumeSequenceIfMatch(e, t) { return !!this.preprocessor.startsWith(e, t) && (this._advanceBy(e.length - 1), !0) } _createStartTagToken() { this.currentToken = { type: Op.START_TAG, tagName: "", tagID: Qp.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(1) } } _createEndTagToken() { this.currentToken = { type: Op.END_TAG, tagName: "", tagID: Qp.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(2) } } _createCommentToken(e) { this.currentToken = { type: Op.COMMENT, data: "", location: this.getCurrentLocation(e) } } _createDoctypeToken(e) { this.currentToken = { type: Op.DOCTYPE, name: e, forceQuirks: !1, publicId: null, systemId: null, location: this.currentLocation } } _createCharacterToken(e, t) { this.currentCharacterToken = { type: e, chars: t, location: this.currentLocation } } _createAttr(e) { this.currentAttr = { name: e, value: "" }, this.currentLocation = this.getCurrentLocation(0) } _leaveAttrName() { var e, t; const n = this.currentToken; null === Rp(n, this.currentAttr.name) ? (n.attrs.push(this.currentAttr), n.location && this.currentLocation && ((null !== (e = (t = n.location).attrs) && void 0 !== e ? e : t.attrs = Object.create(null))[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue())) : this._err(Np.duplicateAttribute) } _leaveAttrValue() { this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset) } prepareToken(e) { this._emitCurrentCharacterToken(e.location), this.currentToken = null, e.location && (e.location.endLine = this.preprocessor.line, e.location.endCol = this.preprocessor.col + 1, e.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1) } emitCurrentTagToken() { const e = this.currentToken; this.prepareToken(e), e.tagID = sf(e.tagName), e.type === Op.START_TAG ? (this.lastStartTagName = e.tagName, this.handler.onStartTag(e)) : (e.attrs.length > 0 && this._err(Np.endTagWithAttributes), e.selfClosing && this._err(Np.endTagWithTrailingSolidus), this.handler.onEndTag(e)), this.preprocessor.dropParsedChunk() } emitCurrentComment(e) { this.prepareToken(e), this.handler.onComment(e), this.preprocessor.dropParsedChunk() } emitCurrentDoctype(e) { this.prepareToken(e), this.handler.onDoctype(e), this.preprocessor.dropParsedChunk() } _emitCurrentCharacterToken(e) { if (this.currentCharacterToken) { switch (e && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = e.startLine, this.currentCharacterToken.location.endCol = e.startCol, this.currentCharacterToken.location.endOffset = e.startOffset), this.currentCharacterToken.type) { case Op.CHARACTER: this.handler.onCharacter(this.currentCharacterToken); break; case Op.NULL_CHARACTER: this.handler.onNullCharacter(this.currentCharacterToken); break; case Op.WHITESPACE_CHARACTER: this.handler.onWhitespaceCharacter(this.currentCharacterToken) }this.currentCharacterToken = null } } _emitEOFToken() { const e = this.getCurrentLocation(0); e && (e.endLine = e.startLine, e.endCol = e.startCol, e.endOffset = e.startOffset), this._emitCurrentCharacterToken(e), this.handler.onEof({ type: Op.EOF, location: e }), this.active = !1 } _appendCharToCurrentCharacterToken(e, t) { if (this.currentCharacterToken) { if (this.currentCharacterToken.type === e) return void (this.currentCharacterToken.chars += t); this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk() } this._createCharacterToken(e, t) } _emitCodePoint(e) { const t = gf(e) ? Op.WHITESPACE_CHARACTER : e === Tp.NULL ? Op.NULL_CHARACTER : Op.CHARACTER; this._appendCharToCurrentCharacterToken(t, String.fromCodePoint(e)) } _emitChars(e) { this._appendCharToCurrentCharacterToken(Op.CHARACTER, e) } _startCharacterReference() { this.returnState = this.state, this.state = cf.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? Hp.Attribute : Hp.Legacy) } _isCharacterReferenceInAttribute() { return this.returnState === cf.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === cf.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === cf.ATTRIBUTE_VALUE_UNQUOTED } _flushCodePointConsumedAsCharacterReference(e) { this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(e) : this._emitCodePoint(e) } _callState(e) { switch (this.state) { case cf.DATA: this._stateData(e); break; case cf.RCDATA: this._stateRcdata(e); break; case cf.RAWTEXT: this._stateRawtext(e); break; case cf.SCRIPT_DATA: this._stateScriptData(e); break; case cf.PLAINTEXT: this._statePlaintext(e); break; case cf.TAG_OPEN: this._stateTagOpen(e); break; case cf.END_TAG_OPEN: this._stateEndTagOpen(e); break; case cf.TAG_NAME: this._stateTagName(e); break; case cf.RCDATA_LESS_THAN_SIGN: this._stateRcdataLessThanSign(e); break; case cf.RCDATA_END_TAG_OPEN: this._stateRcdataEndTagOpen(e); break; case cf.RCDATA_END_TAG_NAME: this._stateRcdataEndTagName(e); break; case cf.RAWTEXT_LESS_THAN_SIGN: this._stateRawtextLessThanSign(e); break; case cf.RAWTEXT_END_TAG_OPEN: this._stateRawtextEndTagOpen(e); break; case cf.RAWTEXT_END_TAG_NAME: this._stateRawtextEndTagName(e); break; case cf.SCRIPT_DATA_LESS_THAN_SIGN: this._stateScriptDataLessThanSign(e); break; case cf.SCRIPT_DATA_END_TAG_OPEN: this._stateScriptDataEndTagOpen(e); break; case cf.SCRIPT_DATA_END_TAG_NAME: this._stateScriptDataEndTagName(e); break; case cf.SCRIPT_DATA_ESCAPE_START: this._stateScriptDataEscapeStart(e); break; case cf.SCRIPT_DATA_ESCAPE_START_DASH: this._stateScriptDataEscapeStartDash(e); break; case cf.SCRIPT_DATA_ESCAPED: this._stateScriptDataEscaped(e); break; case cf.SCRIPT_DATA_ESCAPED_DASH: this._stateScriptDataEscapedDash(e); break; case cf.SCRIPT_DATA_ESCAPED_DASH_DASH: this._stateScriptDataEscapedDashDash(e); break; case cf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: this._stateScriptDataEscapedLessThanSign(e); break; case cf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: this._stateScriptDataEscapedEndTagOpen(e); break; case cf.SCRIPT_DATA_ESCAPED_END_TAG_NAME: this._stateScriptDataEscapedEndTagName(e); break; case cf.SCRIPT_DATA_DOUBLE_ESCAPE_START: this._stateScriptDataDoubleEscapeStart(e); break; case cf.SCRIPT_DATA_DOUBLE_ESCAPED: this._stateScriptDataDoubleEscaped(e); break; case cf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: this._stateScriptDataDoubleEscapedDash(e); break; case cf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: this._stateScriptDataDoubleEscapedDashDash(e); break; case cf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: this._stateScriptDataDoubleEscapedLessThanSign(e); break; case cf.SCRIPT_DATA_DOUBLE_ESCAPE_END: this._stateScriptDataDoubleEscapeEnd(e); break; case cf.BEFORE_ATTRIBUTE_NAME: this._stateBeforeAttributeName(e); break; case cf.ATTRIBUTE_NAME: this._stateAttributeName(e); break; case cf.AFTER_ATTRIBUTE_NAME: this._stateAfterAttributeName(e); break; case cf.BEFORE_ATTRIBUTE_VALUE: this._stateBeforeAttributeValue(e); break; case cf.ATTRIBUTE_VALUE_DOUBLE_QUOTED: this._stateAttributeValueDoubleQuoted(e); break; case cf.ATTRIBUTE_VALUE_SINGLE_QUOTED: this._stateAttributeValueSingleQuoted(e); break; case cf.ATTRIBUTE_VALUE_UNQUOTED: this._stateAttributeValueUnquoted(e); break; case cf.AFTER_ATTRIBUTE_VALUE_QUOTED: this._stateAfterAttributeValueQuoted(e); break; case cf.SELF_CLOSING_START_TAG: this._stateSelfClosingStartTag(e); break; case cf.BOGUS_COMMENT: this._stateBogusComment(e); break; case cf.MARKUP_DECLARATION_OPEN: this._stateMarkupDeclarationOpen(e); break; case cf.COMMENT_START: this._stateCommentStart(e); break; case cf.COMMENT_START_DASH: this._stateCommentStartDash(e); break; case cf.COMMENT: this._stateComment(e); break; case cf.COMMENT_LESS_THAN_SIGN: this._stateCommentLessThanSign(e); break; case cf.COMMENT_LESS_THAN_SIGN_BANG: this._stateCommentLessThanSignBang(e); break; case cf.COMMENT_LESS_THAN_SIGN_BANG_DASH: this._stateCommentLessThanSignBangDash(e); break; case cf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: this._stateCommentLessThanSignBangDashDash(e); break; case cf.COMMENT_END_DASH: this._stateCommentEndDash(e); break; case cf.COMMENT_END: this._stateCommentEnd(e); break; case cf.COMMENT_END_BANG: this._stateCommentEndBang(e); break; case cf.DOCTYPE: this._stateDoctype(e); break; case cf.BEFORE_DOCTYPE_NAME: this._stateBeforeDoctypeName(e); break; case cf.DOCTYPE_NAME: this._stateDoctypeName(e); break; case cf.AFTER_DOCTYPE_NAME: this._stateAfterDoctypeName(e); break; case cf.AFTER_DOCTYPE_PUBLIC_KEYWORD: this._stateAfterDoctypePublicKeyword(e); break; case cf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: this._stateBeforeDoctypePublicIdentifier(e); break; case cf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: this._stateDoctypePublicIdentifierDoubleQuoted(e); break; case cf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: this._stateDoctypePublicIdentifierSingleQuoted(e); break; case cf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: this._stateAfterDoctypePublicIdentifier(e); break; case cf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: this._stateBetweenDoctypePublicAndSystemIdentifiers(e); break; case cf.AFTER_DOCTYPE_SYSTEM_KEYWORD: this._stateAfterDoctypeSystemKeyword(e); break; case cf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: this._stateBeforeDoctypeSystemIdentifier(e); break; case cf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: this._stateDoctypeSystemIdentifierDoubleQuoted(e); break; case cf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: this._stateDoctypeSystemIdentifierSingleQuoted(e); break; case cf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: this._stateAfterDoctypeSystemIdentifier(e); break; case cf.BOGUS_DOCTYPE: this._stateBogusDoctype(e); break; case cf.CDATA_SECTION: this._stateCdataSection(e); break; case cf.CDATA_SECTION_BRACKET: this._stateCdataSectionBracket(e); break; case cf.CDATA_SECTION_END: this._stateCdataSectionEnd(e); break; case cf.CHARACTER_REFERENCE: this._stateCharacterReference(); break; case cf.AMBIGUOUS_AMPERSAND: this._stateAmbiguousAmpersand(e); break; default: throw new Error("Unknown state") } } _stateData(e) { switch (e) { case Tp.LESS_THAN_SIGN: this.state = cf.TAG_OPEN; break; case Tp.AMPERSAND: this._startCharacterReference(); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitCodePoint(e); break; case Tp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateRcdata(e) { switch (e) { case Tp.AMPERSAND: this._startCharacterReference(); break; case Tp.LESS_THAN_SIGN: this.state = cf.RCDATA_LESS_THAN_SIGN; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitChars(Ep); break; case Tp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateRawtext(e) { switch (e) { case Tp.LESS_THAN_SIGN: this.state = cf.RAWTEXT_LESS_THAN_SIGN; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitChars(Ep); break; case Tp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptData(e) { switch (e) { case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_LESS_THAN_SIGN; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitChars(Ep); break; case Tp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _statePlaintext(e) { switch (e) { case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitChars(Ep); break; case Tp.EOF: this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateTagOpen(e) { if (pf(e)) this._createStartTagToken(), this.state = cf.TAG_NAME, this._stateTagName(e); else switch (e) { case Tp.EXCLAMATION_MARK: this.state = cf.MARKUP_DECLARATION_OPEN; break; case Tp.SOLIDUS: this.state = cf.END_TAG_OPEN; break; case Tp.QUESTION_MARK: this._err(Np.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = cf.BOGUS_COMMENT, this._stateBogusComment(e); break; case Tp.EOF: this._err(Np.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken(); break; default: this._err(Np.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = cf.DATA, this._stateData(e) } } _stateEndTagOpen(e) { if (pf(e)) this._createEndTagToken(), this.state = cf.TAG_NAME, this._stateTagName(e); else switch (e) { case Tp.GREATER_THAN_SIGN: this._err(Np.missingEndTagName), this.state = cf.DATA; break; case Tp.EOF: this._err(Np.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken(); break; default: this._err(Np.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = cf.BOGUS_COMMENT, this._stateBogusComment(e) } } _stateTagName(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this.state = cf.BEFORE_ATTRIBUTE_NAME; break; case Tp.SOLIDUS: this.state = cf.SELF_CLOSING_START_TAG; break; case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentTagToken(); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.tagName += Ep; break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: t.tagName += String.fromCodePoint(df(e) ? mf(e) : e) } } _stateRcdataLessThanSign(e) { e === Tp.SOLIDUS ? this.state = cf.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = cf.RCDATA, this._stateRcdata(e)) } _stateRcdataEndTagOpen(e) { pf(e) ? (this.state = cf.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(e)) : (this._emitChars("</"), this.state = cf.RCDATA, this._stateRcdata(e)) } handleSpecialEndTag(e) { if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation(); switch (this._createEndTagToken(), this.currentToken.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: return this._advanceBy(this.lastStartTagName.length), this.state = cf.BEFORE_ATTRIBUTE_NAME, !1; case Tp.SOLIDUS: return this._advanceBy(this.lastStartTagName.length), this.state = cf.SELF_CLOSING_START_TAG, !1; case Tp.GREATER_THAN_SIGN: return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = cf.DATA, !1; default: return !this._ensureHibernation() } } _stateRcdataEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = cf.RCDATA, this._stateRcdata(e)) } _stateRawtextLessThanSign(e) { e === Tp.SOLIDUS ? this.state = cf.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = cf.RAWTEXT, this._stateRawtext(e)) } _stateRawtextEndTagOpen(e) { pf(e) ? (this.state = cf.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(e)) : (this._emitChars("</"), this.state = cf.RAWTEXT, this._stateRawtext(e)) } _stateRawtextEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = cf.RAWTEXT, this._stateRawtext(e)) } _stateScriptDataLessThanSign(e) { switch (e) { case Tp.SOLIDUS: this.state = cf.SCRIPT_DATA_END_TAG_OPEN; break; case Tp.EXCLAMATION_MARK: this.state = cf.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!"); break; default: this._emitChars("<"), this.state = cf.SCRIPT_DATA, this._stateScriptData(e) } } _stateScriptDataEndTagOpen(e) { pf(e) ? (this.state = cf.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(e)) : (this._emitChars("</"), this.state = cf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = cf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscapeStart(e) { e === Tp.HYPHEN_MINUS ? (this.state = cf.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = cf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscapeStartDash(e) { e === Tp.HYPHEN_MINUS ? (this.state = cf.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = cf.SCRIPT_DATA, this._stateScriptData(e)) } _stateScriptDataEscaped(e) { switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-"); break; case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitChars(Ep); break; case Tp.EOF: this._err(Np.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptDataEscapedDash(e) { switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-"); break; case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.state = cf.SCRIPT_DATA_ESCAPED, this._emitChars(Ep); break; case Tp.EOF: this._err(Np.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = cf.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataEscapedDashDash(e) { switch (e) { case Tp.HYPHEN_MINUS: this._emitChars("-"); break; case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break; case Tp.GREATER_THAN_SIGN: this.state = cf.SCRIPT_DATA, this._emitChars(">"); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.state = cf.SCRIPT_DATA_ESCAPED, this._emitChars(Ep); break; case Tp.EOF: this._err(Np.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = cf.SCRIPT_DATA_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataEscapedLessThanSign(e) { e === Tp.SOLIDUS ? this.state = cf.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : pf(e) ? (this._emitChars("<"), this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(e)) : (this._emitChars("<"), this.state = cf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataEscapedEndTagOpen(e) { pf(e) ? (this.state = cf.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(e)) : (this._emitChars("</"), this.state = cf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataEscapedEndTagName(e) { this.handleSpecialEndTag(e) && (this._emitChars("</"), this.state = cf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataDoubleEscapeStart(e) { if (this.preprocessor.startsWith(bp, !1) && Ef(this.preprocessor.peek(6))) { this._emitCodePoint(e); for (let e = 0; e < 6; e++)this._emitCodePoint(this._consume()); this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED } else this._ensureHibernation() || (this.state = cf.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(e)) } _stateScriptDataDoubleEscaped(e) { switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-"); break; case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._emitChars(Ep); break; case Tp.EOF: this._err(Np.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedDash(e) { switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-"); break; case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Ep); break; case Tp.EOF: this._err(Np.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedDashDash(e) { switch (e) { case Tp.HYPHEN_MINUS: this._emitChars("-"); break; case Tp.LESS_THAN_SIGN: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break; case Tp.GREATER_THAN_SIGN: this.state = cf.SCRIPT_DATA, this._emitChars(">"); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Ep); break; case Tp.EOF: this._err(Np.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break; default: this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(e) } } _stateScriptDataDoubleEscapedLessThanSign(e) { e === Tp.SOLIDUS ? (this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e)) } _stateScriptDataDoubleEscapeEnd(e) { if (this.preprocessor.startsWith(bp, !1) && Ef(this.preprocessor.peek(6))) { this._emitCodePoint(e); for (let e = 0; e < 6; e++)this._emitCodePoint(this._consume()); this.state = cf.SCRIPT_DATA_ESCAPED } else this._ensureHibernation() || (this.state = cf.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(e)) } _stateBeforeAttributeName(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.SOLIDUS: case Tp.GREATER_THAN_SIGN: case Tp.EOF: this.state = cf.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e); break; case Tp.EQUALS_SIGN: this._err(Np.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = cf.ATTRIBUTE_NAME; break; default: this._createAttr(""), this.state = cf.ATTRIBUTE_NAME, this._stateAttributeName(e) } } _stateAttributeName(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: case Tp.SOLIDUS: case Tp.GREATER_THAN_SIGN: case Tp.EOF: this._leaveAttrName(), this.state = cf.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(e); break; case Tp.EQUALS_SIGN: this._leaveAttrName(), this.state = cf.BEFORE_ATTRIBUTE_VALUE; break; case Tp.QUOTATION_MARK: case Tp.APOSTROPHE: case Tp.LESS_THAN_SIGN: this._err(Np.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(e); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.currentAttr.name += Ep; break; default: this.currentAttr.name += String.fromCodePoint(df(e) ? mf(e) : e) } } _stateAfterAttributeName(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.SOLIDUS: this.state = cf.SELF_CLOSING_START_TAG; break; case Tp.EQUALS_SIGN: this.state = cf.BEFORE_ATTRIBUTE_VALUE; break; case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentTagToken(); break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: this._createAttr(""), this.state = cf.ATTRIBUTE_NAME, this._stateAttributeName(e) } } _stateBeforeAttributeValue(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.QUOTATION_MARK: this.state = cf.ATTRIBUTE_VALUE_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: this.state = cf.ATTRIBUTE_VALUE_SINGLE_QUOTED; break; case Tp.GREATER_THAN_SIGN: this._err(Np.missingAttributeValue), this.state = cf.DATA, this.emitCurrentTagToken(); break; default: this.state = cf.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(e) } } _stateAttributeValueDoubleQuoted(e) { switch (e) { case Tp.QUOTATION_MARK: this.state = cf.AFTER_ATTRIBUTE_VALUE_QUOTED; break; case Tp.AMPERSAND: this._startCharacterReference(); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.currentAttr.value += Ep; break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAttributeValueSingleQuoted(e) { switch (e) { case Tp.APOSTROPHE: this.state = cf.AFTER_ATTRIBUTE_VALUE_QUOTED; break; case Tp.AMPERSAND: this._startCharacterReference(); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.currentAttr.value += Ep; break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAttributeValueUnquoted(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this._leaveAttrValue(), this.state = cf.BEFORE_ATTRIBUTE_NAME; break; case Tp.AMPERSAND: this._startCharacterReference(); break; case Tp.GREATER_THAN_SIGN: this._leaveAttrValue(), this.state = cf.DATA, this.emitCurrentTagToken(); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this.currentAttr.value += Ep; break; case Tp.QUOTATION_MARK: case Tp.APOSTROPHE: case Tp.LESS_THAN_SIGN: case Tp.EQUALS_SIGN: case Tp.GRAVE_ACCENT: this._err(Np.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(e); break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: this.currentAttr.value += String.fromCodePoint(e) } } _stateAfterAttributeValueQuoted(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this._leaveAttrValue(), this.state = cf.BEFORE_ATTRIBUTE_NAME; break; case Tp.SOLIDUS: this._leaveAttrValue(), this.state = cf.SELF_CLOSING_START_TAG; break; case Tp.GREATER_THAN_SIGN: this._leaveAttrValue(), this.state = cf.DATA, this.emitCurrentTagToken(); break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: this._err(Np.missingWhitespaceBetweenAttributes), this.state = cf.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e) } } _stateSelfClosingStartTag(e) { switch (e) { case Tp.GREATER_THAN_SIGN: this.currentToken.selfClosing = !0, this.state = cf.DATA, this.emitCurrentTagToken(); break; case Tp.EOF: this._err(Np.eofInTag), this._emitEOFToken(); break; default: this._err(Np.unexpectedSolidusInTag), this.state = cf.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(e) } } _stateBogusComment(e) { const t = this.currentToken; switch (e) { case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentComment(t); break; case Tp.EOF: this.emitCurrentComment(t), this._emitEOFToken(); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.data += Ep; break; default: t.data += String.fromCodePoint(e) } } _stateMarkupDeclarationOpen(e) { this._consumeSequenceIfMatch("--", !0) ? (this._createCommentToken(3), this.state = cf.COMMENT_START) : this._consumeSequenceIfMatch(yp, !1) ? (this.currentLocation = this.getCurrentLocation(8), this.state = cf.DOCTYPE) : this._consumeSequenceIfMatch(_p, !0) ? this.inForeignNode ? this.state = cf.CDATA_SECTION : (this._err(Np.cdataInHtmlContent), this._createCommentToken(8), this.currentToken.data = "[CDATA[", this.state = cf.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(Np.incorrectlyOpenedComment), this._createCommentToken(2), this.state = cf.BOGUS_COMMENT, this._stateBogusComment(e)) } _stateCommentStart(e) { switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.COMMENT_START_DASH; break; case Tp.GREATER_THAN_SIGN: { this._err(Np.abruptClosingOfEmptyComment), this.state = cf.DATA; const e = this.currentToken; this.emitCurrentComment(e); break } default: this.state = cf.COMMENT, this._stateComment(e) } } _stateCommentStartDash(e) { const t = this.currentToken; switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.COMMENT_END; break; case Tp.GREATER_THAN_SIGN: this._err(Np.abruptClosingOfEmptyComment), this.state = cf.DATA, this.emitCurrentComment(t); break; case Tp.EOF: this._err(Np.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "-", this.state = cf.COMMENT, this._stateComment(e) } } _stateComment(e) { const t = this.currentToken; switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.COMMENT_END_DASH; break; case Tp.LESS_THAN_SIGN: t.data += "<", this.state = cf.COMMENT_LESS_THAN_SIGN; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.data += Ep; break; case Tp.EOF: this._err(Np.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += String.fromCodePoint(e) } } _stateCommentLessThanSign(e) { const t = this.currentToken; switch (e) { case Tp.EXCLAMATION_MARK: t.data += "!", this.state = cf.COMMENT_LESS_THAN_SIGN_BANG; break; case Tp.LESS_THAN_SIGN: t.data += "<"; break; default: this.state = cf.COMMENT, this._stateComment(e) } } _stateCommentLessThanSignBang(e) { e === Tp.HYPHEN_MINUS ? this.state = cf.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = cf.COMMENT, this._stateComment(e)) } _stateCommentLessThanSignBangDash(e) { e === Tp.HYPHEN_MINUS ? this.state = cf.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = cf.COMMENT_END_DASH, this._stateCommentEndDash(e)) } _stateCommentLessThanSignBangDashDash(e) { e !== Tp.GREATER_THAN_SIGN && e !== Tp.EOF && this._err(Np.nestedComment), this.state = cf.COMMENT_END, this._stateCommentEnd(e) } _stateCommentEndDash(e) { const t = this.currentToken; switch (e) { case Tp.HYPHEN_MINUS: this.state = cf.COMMENT_END; break; case Tp.EOF: this._err(Np.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "-", this.state = cf.COMMENT, this._stateComment(e) } } _stateCommentEnd(e) { const t = this.currentToken; switch (e) { case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentComment(t); break; case Tp.EXCLAMATION_MARK: this.state = cf.COMMENT_END_BANG; break; case Tp.HYPHEN_MINUS: t.data += "-"; break; case Tp.EOF: this._err(Np.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "--", this.state = cf.COMMENT, this._stateComment(e) } } _stateCommentEndBang(e) { const t = this.currentToken; switch (e) { case Tp.HYPHEN_MINUS: t.data += "--!", this.state = cf.COMMENT_END_DASH; break; case Tp.GREATER_THAN_SIGN: this._err(Np.incorrectlyClosedComment), this.state = cf.DATA, this.emitCurrentComment(t); break; case Tp.EOF: this._err(Np.eofInComment), this.emitCurrentComment(t), this._emitEOFToken(); break; default: t.data += "--!", this.state = cf.COMMENT, this._stateComment(e) } } _stateDoctype(e) { switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this.state = cf.BEFORE_DOCTYPE_NAME; break; case Tp.GREATER_THAN_SIGN: this.state = cf.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e); break; case Tp.EOF: { this._err(Np.eofInDoctype), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this._emitEOFToken(); break } default: this._err(Np.missingWhitespaceBeforeDoctypeName), this.state = cf.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(e) } } _stateBeforeDoctypeName(e) { if (df(e)) this._createDoctypeToken(String.fromCharCode(mf(e))), this.state = cf.DOCTYPE_NAME; else switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), this._createDoctypeToken(Ep), this.state = cf.DOCTYPE_NAME; break; case Tp.GREATER_THAN_SIGN: { this._err(Np.missingDoctypeName), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this.state = cf.DATA; break } case Tp.EOF: { this._err(Np.eofInDoctype), this._createDoctypeToken(null); const e = this.currentToken; e.forceQuirks = !0, this.emitCurrentDoctype(e), this._emitEOFToken(); break } default: this._createDoctypeToken(String.fromCodePoint(e)), this.state = cf.DOCTYPE_NAME } } _stateDoctypeName(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this.state = cf.AFTER_DOCTYPE_NAME; break; case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.name += Ep; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.name += String.fromCodePoint(df(e) ? mf(e) : e) } } _stateAfterDoctypeName(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._consumeSequenceIfMatch("public", !1) ? this.state = cf.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch("system", !1) ? this.state = cf.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(Np.invalidCharacterSequenceAfterDoctypeName), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e)) } } _stateAfterDoctypePublicKeyword(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this.state = cf.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER; break; case Tp.QUOTATION_MARK: this._err(Np.missingWhitespaceAfterDoctypePublicKeyword), t.publicId = "", this.state = cf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: this._err(Np.missingWhitespaceAfterDoctypePublicKeyword), t.publicId = "", this.state = cf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break; case Tp.GREATER_THAN_SIGN: this._err(Np.missingDoctypePublicIdentifier), t.forceQuirks = !0, this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.missingQuoteBeforeDoctypePublicIdentifier), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBeforeDoctypePublicIdentifier(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.QUOTATION_MARK: t.publicId = "", this.state = cf.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: t.publicId = "", this.state = cf.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break; case Tp.GREATER_THAN_SIGN: this._err(Np.missingDoctypePublicIdentifier), t.forceQuirks = !0, this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.missingQuoteBeforeDoctypePublicIdentifier), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateDoctypePublicIdentifierDoubleQuoted(e) { const t = this.currentToken; switch (e) { case Tp.QUOTATION_MARK: this.state = cf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.publicId += Ep; break; case Tp.GREATER_THAN_SIGN: this._err(Np.abruptDoctypePublicIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.publicId += String.fromCodePoint(e) } } _stateDoctypePublicIdentifierSingleQuoted(e) { const t = this.currentToken; switch (e) { case Tp.APOSTROPHE: this.state = cf.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.publicId += Ep; break; case Tp.GREATER_THAN_SIGN: this._err(Np.abruptDoctypePublicIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.publicId += String.fromCodePoint(e) } } _stateAfterDoctypePublicIdentifier(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this.state = cf.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS; break; case Tp.GREATER_THAN_SIGN: this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.QUOTATION_MARK: this._err(Np.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: this._err(Np.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBetweenDoctypePublicAndSystemIdentifiers(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.QUOTATION_MARK: t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateAfterDoctypeSystemKeyword(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: this.state = cf.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER; break; case Tp.QUOTATION_MARK: this._err(Np.missingWhitespaceAfterDoctypeSystemKeyword), t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: this._err(Np.missingWhitespaceAfterDoctypeSystemKeyword), t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Tp.GREATER_THAN_SIGN: this._err(Np.missingDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBeforeDoctypeSystemIdentifier(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.QUOTATION_MARK: t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break; case Tp.APOSTROPHE: t.systemId = "", this.state = cf.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break; case Tp.GREATER_THAN_SIGN: this._err(Np.missingDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = cf.DATA, this.emitCurrentDoctype(t); break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.missingQuoteBeforeDoctypeSystemIdentifier), t.forceQuirks = !0, this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateDoctypeSystemIdentifierDoubleQuoted(e) { const t = this.currentToken; switch (e) { case Tp.QUOTATION_MARK: this.state = cf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.systemId += Ep; break; case Tp.GREATER_THAN_SIGN: this._err(Np.abruptDoctypeSystemIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.systemId += String.fromCodePoint(e) } } _stateDoctypeSystemIdentifierSingleQuoted(e) { const t = this.currentToken; switch (e) { case Tp.APOSTROPHE: this.state = cf.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter), t.systemId += Ep; break; case Tp.GREATER_THAN_SIGN: this._err(Np.abruptDoctypeSystemIdentifier), t.forceQuirks = !0, this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: t.systemId += String.fromCodePoint(e) } } _stateAfterDoctypeSystemIdentifier(e) { const t = this.currentToken; switch (e) { case Tp.SPACE: case Tp.LINE_FEED: case Tp.TABULATION: case Tp.FORM_FEED: break; case Tp.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.EOF: this._err(Np.eofInDoctype), t.forceQuirks = !0, this.emitCurrentDoctype(t), this._emitEOFToken(); break; default: this._err(Np.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = cf.BOGUS_DOCTYPE, this._stateBogusDoctype(e) } } _stateBogusDoctype(e) { const t = this.currentToken; switch (e) { case Tp.GREATER_THAN_SIGN: this.emitCurrentDoctype(t), this.state = cf.DATA; break; case Tp.NULL: this._err(Np.unexpectedNullCharacter); break; case Tp.EOF: this.emitCurrentDoctype(t), this._emitEOFToken() } } _stateCdataSection(e) { switch (e) { case Tp.RIGHT_SQUARE_BRACKET: this.state = cf.CDATA_SECTION_BRACKET; break; case Tp.EOF: this._err(Np.eofInCdata), this._emitEOFToken(); break; default: this._emitCodePoint(e) } } _stateCdataSectionBracket(e) { e === Tp.RIGHT_SQUARE_BRACKET ? this.state = cf.CDATA_SECTION_END : (this._emitChars("]"), this.state = cf.CDATA_SECTION, this._stateCdataSection(e)) } _stateCdataSectionEnd(e) { switch (e) { case Tp.GREATER_THAN_SIGN: this.state = cf.DATA; break; case Tp.RIGHT_SQUARE_BRACKET: this._emitChars("]"); break; default: this._emitChars("]]"), this.state = cf.CDATA_SECTION, this._stateCdataSection(e) } } _stateCharacterReference() { let e = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos); if (e < 0) { if (!this.preprocessor.lastChunkWritten) return this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, void (this.preprocessor.endOfChunkHit = !0); e = this.entityDecoder.end() } 0 === e ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(Tp.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && ff(this.preprocessor.peek(1)) ? cf.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState } _stateAmbiguousAmpersand(e) { ff(e) ? this._flushCodePointConsumedAsCharacterReference(e) : (e === Tp.SEMICOLON && this._err(Np.unknownNamedCharacterReference), this.state = this.returnState, this._callState(e)) } } const Af = new Set([Qp.DD, Qp.DT, Qp.LI, Qp.OPTGROUP, Qp.OPTION, Qp.P, Qp.RB, Qp.RP, Qp.RT, Qp.RTC]), _f = new Set([...Af, Qp.CAPTION, Qp.COLGROUP, Qp.TBODY, Qp.TD, Qp.TFOOT, Qp.TH, Qp.THEAD, Qp.TR]), yf = new Set([Qp.APPLET, Qp.CAPTION, Qp.HTML, Qp.MARQUEE, Qp.OBJECT, Qp.TABLE, Qp.TD, Qp.TEMPLATE, Qp.TH]), bf = new Set([...yf, Qp.OL, Qp.UL]), Sf = new Set([...yf, Qp.BUTTON]), kf = new Set([Qp.ANNOTATION_XML, Qp.MI, Qp.MN, Qp.MO, Qp.MS, Qp.MTEXT]), Cf = new Set([Qp.DESC, Qp.FOREIGN_OBJECT, Qp.TITLE]), Nf = new Set([Qp.TR, Qp.TEMPLATE, Qp.HTML]), If = new Set([Qp.TBODY, Qp.TFOOT, Qp.THEAD, Qp.TEMPLATE, Qp.HTML]), Of = new Set([Qp.TABLE, Qp.TEMPLATE, Qp.HTML]), xf = new Set([Qp.TD, Qp.TH]); class vf { get currentTmplContentOrNode() { return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current } constructor(e, t, n) { this.treeAdapter = t, this.handler = n, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = Qp.UNKNOWN, this.current = e } _indexOf(e) { return this.items.lastIndexOf(e, this.stackTop) } _isInTemplate() { return this.currentTagId === Qp.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === Gp.HTML } _updateCurrentElement() { this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop] } push(e, t) { this.stackTop++, this.items[this.stackTop] = e, this.current = e, this.tagIDs[this.stackTop] = t, this.currentTagId = t, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(e, t, !0) } pop() { const e = this.current; this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !0) } replace(e, t) { const n = this._indexOf(e); this.items[n] = t, n === this.stackTop && (this.current = t) } insertAfter(e, t, n) { const r = this._indexOf(e) + 1; this.items.splice(r, 0, t), this.tagIDs.splice(r, 0, n), this.stackTop++, r === this.stackTop && this._updateCurrentElement(), this.current && void 0 !== this.currentTagId && this.handler.onItemPush(this.current, this.currentTagId, r === this.stackTop) } popUntilTagNamePopped(e) { let t = this.stackTop + 1; do { t = this.tagIDs.lastIndexOf(e, t - 1) } while (t > 0 && this.treeAdapter.getNamespaceURI(this.items[t]) !== Gp.HTML); this.shortenToLength(Math.max(t, 0)) } shortenToLength(e) { for (; this.stackTop >= e;) { const t = this.current; this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, this.stackTop < e) } } popUntilElementPopped(e) { const t = this._indexOf(e); this.shortenToLength(Math.max(t, 0)) } popUntilPopped(e, t) { const n = this._indexOfTagNames(e, t); this.shortenToLength(Math.max(n, 0)) } popUntilNumberedHeaderPopped() { this.popUntilPopped(lf, Gp.HTML) } popUntilTableCellPopped() { this.popUntilPopped(xf, Gp.HTML) } popAllUpToHtmlElement() { this.tmplCount = 0, this.shortenToLength(1) } _indexOfTagNames(e, t) { for (let n = this.stackTop; n >= 0; n--)if (e.has(this.tagIDs[n]) && this.treeAdapter.getNamespaceURI(this.items[n]) === t) return n; return -1 } clearBackTo(e, t) { const n = this._indexOfTagNames(e, t); this.shortenToLength(n + 1) } clearBackToTableContext() { this.clearBackTo(Of, Gp.HTML) } clearBackToTableBodyContext() { this.clearBackTo(If, Gp.HTML) } clearBackToTableRowContext() { this.clearBackTo(Nf, Gp.HTML) } remove(e) { const t = this._indexOf(e); t >= 0 && (t === this.stackTop ? this.pop() : (this.items.splice(t, 1), this.tagIDs.splice(t, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(e, !1))) } tryPeekProperlyNestedBodyElement() { return this.stackTop >= 1 && this.tagIDs[1] === Qp.BODY ? this.items[1] : null } contains(e) { return this._indexOf(e) > -1 } getCommonAncestor(e) { const t = this._indexOf(e) - 1; return t >= 0 ? this.items[t] : null } isRootHtmlElementCurrent() { return 0 === this.stackTop && this.tagIDs[0] === Qp.HTML } hasInDynamicScope(e, t) { for (let n = this.stackTop; n >= 0; n--) { const r = this.tagIDs[n]; switch (this.treeAdapter.getNamespaceURI(this.items[n])) { case Gp.HTML: if (r === e) return !0; if (t.has(r)) return !1; break; case Gp.SVG: if (Cf.has(r)) return !1; break; case Gp.MATHML: if (kf.has(r)) return !1 } } return !0 } hasInScope(e) { return this.hasInDynamicScope(e, yf) } hasInListItemScope(e) { return this.hasInDynamicScope(e, bf) } hasInButtonScope(e) { return this.hasInDynamicScope(e, Sf) } hasNumberedHeaderInScope() { for (let e = this.stackTop; e >= 0; e--) { const t = this.tagIDs[e]; switch (this.treeAdapter.getNamespaceURI(this.items[e])) { case Gp.HTML: if (lf.has(t)) return !0; if (yf.has(t)) return !1; break; case Gp.SVG: if (Cf.has(t)) return !1; break; case Gp.MATHML: if (kf.has(t)) return !1 } } return !0 } hasInTableScope(e) { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === Gp.HTML) switch (this.tagIDs[t]) { case e: return !0; case Qp.TABLE: case Qp.HTML: return !1 }return !0 } hasTableBodyContextInTableScope() { for (let e = this.stackTop; e >= 0; e--)if (this.treeAdapter.getNamespaceURI(this.items[e]) === Gp.HTML) switch (this.tagIDs[e]) { case Qp.TBODY: case Qp.THEAD: case Qp.TFOOT: return !0; case Qp.TABLE: case Qp.HTML: return !1 }return !0 } hasInSelectScope(e) { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === Gp.HTML) switch (this.tagIDs[t]) { case e: return !0; case Qp.OPTION: case Qp.OPTGROUP: break; default: return !1 }return !0 } generateImpliedEndTags() { for (; void 0 !== this.currentTagId && Af.has(this.currentTagId);)this.pop() } generateImpliedEndTagsThoroughly() { for (; void 0 !== this.currentTagId && _f.has(this.currentTagId);)this.pop() } generateImpliedEndTagsWithExclusion(e) { for (; void 0 !== this.currentTagId && this.currentTagId !== e && _f.has(this.currentTagId);)this.pop() } } var Rf, Df; (Df = Rf || (Rf = {}))[Df.Marker = 0] = "Marker", Df[Df.Element = 1] = "Element"; const Lf = { type: Rf.Marker }; class Pf { constructor(e) { this.treeAdapter = e, this.entries = [], this.bookmark = null } _getNoahArkConditionCandidates(e, t) { const n = [], r = t.length, s = this.treeAdapter.getTagName(e), i = this.treeAdapter.getNamespaceURI(e); for (let o = 0; o < this.entries.length; o++) { const e = this.entries[o]; if (e.type === Rf.Marker) break; const { element: t } = e; if (this.treeAdapter.getTagName(t) === s && this.treeAdapter.getNamespaceURI(t) === i) { const e = this.treeAdapter.getAttrList(t); e.length === r && n.push({ idx: o, attrs: e }) } } return n } _ensureNoahArkCondition(e) { if (this.entries.length < 3) return; const t = this.treeAdapter.getAttrList(e), n = this._getNoahArkConditionCandidates(e, t); if (n.length < 3) return; const r = new Map(t.map(e => [e.name, e.value])); let s = 0; for (let i = 0; i < n.length; i++) { const e = n[i]; e.attrs.every(e => r.get(e.name) === e.value) && (s += 1, s >= 3 && this.entries.splice(e.idx, 1)) } } insertMarker() { this.entries.unshift(Lf) } pushElement(e, t) { this._ensureNoahArkCondition(e), this.entries.unshift({ type: Rf.Element, element: e, token: t }) } insertElementAfterBookmark(e, t) { const n = this.entries.indexOf(this.bookmark); this.entries.splice(n, 0, { type: Rf.Element, element: e, token: t }) } removeEntry(e) { const t = this.entries.indexOf(e); -1 !== t && this.entries.splice(t, 1) } clearToLastMarker() { const e = this.entries.indexOf(Lf); -1 === e ? this.entries.length = 0 : this.entries.splice(0, e + 1) } getElementEntryInScopeWithTagName(e) { const t = this.entries.find(t => t.type === Rf.Marker || this.treeAdapter.getTagName(t.element) === e); return t && t.type === Rf.Element ? t : null } getElementEntry(e) { return this.entries.find(t => t.type === Rf.Element && t.element === e) } } const wf = { createDocument: () => ({ nodeName: "#document", mode: Vp.NO_QUIRKS, childNodes: [] }), createDocumentFragment: () => ({ nodeName: "#document-fragment", childNodes: [] }), createElement: (e, t, n) => ({ nodeName: e, tagName: e, attrs: n, namespaceURI: t, childNodes: [], parentNode: null }), createCommentNode: e => ({ nodeName: "#comment", data: e, parentNode: null }), createTextNode: e => ({ nodeName: "#text", value: e, parentNode: null }), appendChild(e, t) { e.childNodes.push(t), t.parentNode = e }, insertBefore(e, t, n) { const r = e.childNodes.indexOf(n); e.childNodes.splice(r, 0, t), t.parentNode = e }, setTemplateContent(e, t) { e.content = t }, getTemplateContent: e => e.content, setDocumentType(e, t, n, r) { const s = e.childNodes.find(e => "#documentType" === e.nodeName); if (s) s.name = t, s.publicId = n, s.systemId = r; else { const s = { nodeName: "#documentType", name: t, publicId: n, systemId: r, parentNode: null }; wf.appendChild(e, s) } }, setDocumentMode(e, t) { e.mode = t }, getDocumentMode: e => e.mode, detachNode(e) { if (e.parentNode) { const t = e.parentNode.childNodes.indexOf(e); e.parentNode.childNodes.splice(t, 1), e.parentNode = null } }, insertText(e, t) { if (e.childNodes.length > 0) { const n = e.childNodes[e.childNodes.length - 1]; if (wf.isTextNode(n)) return void (n.value += t) } wf.appendChild(e, wf.createTextNode(t)) }, insertTextBefore(e, t, n) { const r = e.childNodes[e.childNodes.indexOf(n) - 1]; r && wf.isTextNode(r) ? r.value += t : wf.insertBefore(e, wf.createTextNode(t), n) }, adoptAttributes(e, t) { const n = new Set(e.attrs.map(e => e.name)); for (let r = 0; r < t.length; r++)n.has(t[r].name) || e.attrs.push(t[r]) }, getFirstChild: e => e.childNodes[0], getChildNodes: e => e.childNodes, getParentNode: e => e.parentNode, getAttrList: e => e.attrs, getTagName: e => e.tagName, getNamespaceURI: e => e.namespaceURI, getTextNodeContent: e => e.value, getCommentNodeContent: e => e.data, getDocumentTypeNodeName: e => e.name, getDocumentTypeNodePublicId: e => e.publicId, getDocumentTypeNodeSystemId: e => e.systemId, isTextNode: e => "#text" === e.nodeName, isCommentNode: e => "#comment" === e.nodeName, isDocumentTypeNode: e => "#documentType" === e.nodeName, isElementNode: e => Object.prototype.hasOwnProperty.call(e, "tagName"), setNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = t }, getNodeSourceCodeLocation: e => e.sourceCodeLocation, updateNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t } } }, Mf = "html", Ff = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"], Bf = [...Ff, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"], Uf = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]), Hf = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], jf = [...Hf, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]; function Gf(e, t) { return t.some(t => e.startsWith(t)) } const zf = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(e => [e.toLowerCase(), e])), Yf = new Map([["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: Gp.XLINK }], ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: Gp.XLINK }], ["xlink:href", { prefix: "xlink", name: "href", namespace: Gp.XLINK }], ["xlink:role", { prefix: "xlink", name: "role", namespace: Gp.XLINK }], ["xlink:show", { prefix: "xlink", name: "show", namespace: Gp.XLINK }], ["xlink:title", { prefix: "xlink", name: "title", namespace: Gp.XLINK }], ["xlink:type", { prefix: "xlink", name: "type", namespace: Gp.XLINK }], ["xml:lang", { prefix: "xml", name: "lang", namespace: Gp.XML }], ["xml:space", { prefix: "xml", name: "space", namespace: Gp.XML }], ["xmlns", { prefix: "", name: "xmlns", namespace: Gp.XMLNS }], ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: Gp.XMLNS }]]), qf = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(e => [e.toLowerCase(), e])), Vf = new Set([Qp.B, Qp.BIG, Qp.BLOCKQUOTE, Qp.BODY, Qp.BR, Qp.CENTER, Qp.CODE, Qp.DD, Qp.DIV, Qp.DL, Qp.DT, Qp.EM, Qp.EMBED, Qp.H1, Qp.H2, Qp.H3, Qp.H4, Qp.H5, Qp.H6, Qp.HEAD, Qp.HR, Qp.I, Qp.IMG, Qp.LI, Qp.LISTING, Qp.MENU, Qp.META, Qp.NOBR, Qp.OL, Qp.P, Qp.PRE, Qp.RUBY, Qp.S, Qp.SMALL, Qp.SPAN, Qp.STRONG, Qp.STRIKE, Qp.SUB, Qp.SUP, Qp.TABLE, Qp.TT, Qp.U, Qp.UL, Qp.VAR]); function $f(e) { for (let t = 0; t < e.attrs.length; t++)if ("definitionurl" === e.attrs[t].name) { e.attrs[t].name = "definitionURL"; break } } function Wf(e) { for (let t = 0; t < e.attrs.length; t++) { const n = zf.get(e.attrs[t].name); null != n && (e.attrs[t].name = n) } } function Kf(e) { for (let t = 0; t < e.attrs.length; t++) { const n = Yf.get(e.attrs[t].name); n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace) } } var Qf, Xf; (Xf = Qf || (Qf = {}))[Xf.INITIAL = 0] = "INITIAL", Xf[Xf.BEFORE_HTML = 1] = "BEFORE_HTML", Xf[Xf.BEFORE_HEAD = 2] = "BEFORE_HEAD", Xf[Xf.IN_HEAD = 3] = "IN_HEAD", Xf[Xf.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", Xf[Xf.AFTER_HEAD = 5] = "AFTER_HEAD", Xf[Xf.IN_BODY = 6] = "IN_BODY", Xf[Xf.TEXT = 7] = "TEXT", Xf[Xf.IN_TABLE = 8] = "IN_TABLE", Xf[Xf.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", Xf[Xf.IN_CAPTION = 10] = "IN_CAPTION", Xf[Xf.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", Xf[Xf.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", Xf[Xf.IN_ROW = 13] = "IN_ROW", Xf[Xf.IN_CELL = 14] = "IN_CELL", Xf[Xf.IN_SELECT = 15] = "IN_SELECT", Xf[Xf.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", Xf[Xf.IN_TEMPLATE = 17] = "IN_TEMPLATE", Xf[Xf.AFTER_BODY = 18] = "AFTER_BODY", Xf[Xf.IN_FRAMESET = 19] = "IN_FRAMESET", Xf[Xf.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", Xf[Xf.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", Xf[Xf.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET"; const Jf = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 }, Zf = new Set([Qp.TABLE, Qp.TBODY, Qp.TFOOT, Qp.THEAD, Qp.TR]), em = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: wf, onParseError: null }; class tm { constructor(e, t, n = null, r = null) { this.fragmentContext = n, this.scriptHandler = r, this.currentToken = null, this.stopped = !1, this.insertionMode = Qf.INITIAL, this.originalInsertionMode = Qf.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = { ...em, ...e }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = null != t ? t : this.treeAdapter.createDocument(), this.tokenizer = new Tf(this.options, this), this.activeFormattingElements = new Pf(this.treeAdapter), this.fragmentContextID = n ? sf(this.treeAdapter.getTagName(n)) : Qp.UNKNOWN, this._setContextModes(null != n ? n : this.document, this.fragmentContextID), this.openElements = new vf(this.document, this.treeAdapter, this) } static parse(e, t) { const n = new this(t); return n.tokenizer.write(e, !0), n.document } static getFragmentParser(e, t) { const n = { ...em, ...t }; null != e || (e = n.treeAdapter.createElement(Wp.TEMPLATE, Gp.HTML, [])); const r = n.treeAdapter.createElement("documentmock", Gp.HTML, []), s = new this(n, r, e); return s.fragmentContextID === Qp.TEMPLATE && s.tmplInsertionModeStack.unshift(Qf.IN_TEMPLATE), s._initTokenizerForFragmentParsing(), s._insertFakeRootElement(), s._resetInsertionMode(), s._findFormInFragmentContext(), s } getFragment() { const e = this.treeAdapter.getFirstChild(this.document), t = this.treeAdapter.createDocumentFragment(); return this._adoptNodes(e, t), t } _err(e, t, n) { var r; if (!this.onParseError) return; const s = null !== (r = e.location) && void 0 !== r ? r : Jf, i = { code: t, startLine: s.startLine, startCol: s.startCol, startOffset: s.startOffset, endLine: n ? s.startLine : s.endLine, endCol: n ? s.startCol : s.endCol, endOffset: n ? s.startOffset : s.endOffset }; this.onParseError(i) } onItemPush(e, t, n) { var r, s; null === (s = (r = this.treeAdapter).onItemPush) || void 0 === s || s.call(r, e), n && this.openElements.stackTop > 0 && this._setContextModes(e, t) } onItemPop(e, t) { var n, r; if (this.options.sourceCodeLocationInfo && this._setEndLocation(e, this.currentToken), null === (r = (n = this.treeAdapter).onItemPop) || void 0 === r || r.call(n, e, this.openElements.current), t) { let e, t; 0 === this.openElements.stackTop && this.fragmentContext ? (e = this.fragmentContext, t = this.fragmentContextID) : ({ current: e, currentTagId: t } = this.openElements), this._setContextModes(e, t) } } _setContextModes(e, t) { const n = e === this.document || e && this.treeAdapter.getNamespaceURI(e) === Gp.HTML; this.currentNotInHTML = !n, this.tokenizer.inForeignNode = !n && void 0 !== e && void 0 !== t && !this._isIntegrationPoint(t, e) } _switchToTextParsing(e, t) { this._insertElement(e, Gp.HTML), this.tokenizer.state = t, this.originalInsertionMode = this.insertionMode, this.insertionMode = Qf.TEXT } switchToPlaintextParsing() { this.insertionMode = Qf.TEXT, this.originalInsertionMode = Qf.IN_BODY, this.tokenizer.state = hf.PLAINTEXT } _getAdjustedCurrentElement() { return 0 === this.openElements.stackTop && this.fragmentContext ? this.fragmentContext : this.openElements.current } _findFormInFragmentContext() { let e = this.fragmentContext; for (; e;) { if (this.treeAdapter.getTagName(e) === Wp.FORM) { this.formElement = e; break } e = this.treeAdapter.getParentNode(e) } } _initTokenizerForFragmentParsing() { if (this.fragmentContext && this.treeAdapter.getNamespaceURI(this.fragmentContext) === Gp.HTML) switch (this.fragmentContextID) { case Qp.TITLE: case Qp.TEXTAREA: this.tokenizer.state = hf.RCDATA; break; case Qp.STYLE: case Qp.XMP: case Qp.IFRAME: case Qp.NOEMBED: case Qp.NOFRAMES: case Qp.NOSCRIPT: this.tokenizer.state = hf.RAWTEXT; break; case Qp.SCRIPT: this.tokenizer.state = hf.SCRIPT_DATA; break; case Qp.PLAINTEXT: this.tokenizer.state = hf.PLAINTEXT } } _setDocumentType(e) { const t = e.name || "", n = e.publicId || "", r = e.systemId || ""; if (this.treeAdapter.setDocumentType(this.document, t, n, r), e.location) { const t = this.treeAdapter.getChildNodes(this.document).find(e => this.treeAdapter.isDocumentTypeNode(e)); t && this.treeAdapter.setNodeSourceCodeLocation(t, e.location) } } _attachElementToTree(e, t) { if (this.options.sourceCodeLocationInfo) { const n = t && { ...t, startTag: t }; this.treeAdapter.setNodeSourceCodeLocation(e, n) } if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(e); else { const t = this.openElements.currentTmplContentOrNode; this.treeAdapter.appendChild(null != t ? t : this.document, e) } } _appendElement(e, t) { const n = this.treeAdapter.createElement(e.tagName, t, e.attrs); this._attachElementToTree(n, e.location) } _insertElement(e, t) { const n = this.treeAdapter.createElement(e.tagName, t, e.attrs); this._attachElementToTree(n, e.location), this.openElements.push(n, e.tagID) } _insertFakeElement(e, t) { const n = this.treeAdapter.createElement(e, Gp.HTML, []); this._attachElementToTree(n, null), this.openElements.push(n, t) } _insertTemplate(e) { const t = this.treeAdapter.createElement(e.tagName, Gp.HTML, e.attrs), n = this.treeAdapter.createDocumentFragment(); this.treeAdapter.setTemplateContent(t, n), this._attachElementToTree(t, e.location), this.openElements.push(t, e.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, null) } _insertFakeRootElement() { const e = this.treeAdapter.createElement(Wp.HTML, Gp.HTML, []); this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(e, null), this.treeAdapter.appendChild(this.openElements.current, e), this.openElements.push(e, Qp.HTML) } _appendCommentNode(e, t) { const n = this.treeAdapter.createCommentNode(e.data); this.treeAdapter.appendChild(t, n), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(n, e.location) } _insertCharacters(e) { let t, n; if (this._shouldFosterParentOnInsertion() ? (({ parent: t, beforeElement: n } = this._findFosterParentingLocation()), n ? this.treeAdapter.insertTextBefore(t, e.chars, n) : this.treeAdapter.insertText(t, e.chars)) : (t = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(t, e.chars)), !e.location) return; const r = this.treeAdapter.getChildNodes(t), s = n ? r.lastIndexOf(n) : r.length, i = r[s - 1]; if (this.treeAdapter.getNodeSourceCodeLocation(i)) { const { endLine: t, endCol: n, endOffset: r } = e.location; this.treeAdapter.updateNodeSourceCodeLocation(i, { endLine: t, endCol: n, endOffset: r }) } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(i, e.location) } _adoptNodes(e, t) { for (let n = this.treeAdapter.getFirstChild(e); n; n = this.treeAdapter.getFirstChild(e))this.treeAdapter.detachNode(n), this.treeAdapter.appendChild(t, n) } _setEndLocation(e, t) { if (this.treeAdapter.getNodeSourceCodeLocation(e) && t.location) { const n = t.location, r = this.treeAdapter.getTagName(e), s = t.type === Op.END_TAG && r === t.tagName ? { endTag: { ...n }, endLine: n.endLine, endCol: n.endCol, endOffset: n.endOffset } : { endLine: n.startLine, endCol: n.startCol, endOffset: n.startOffset }; this.treeAdapter.updateNodeSourceCodeLocation(e, s) } } shouldProcessStartTagTokenInForeignContent(e) { if (!this.currentNotInHTML) return !1; let t, n; return 0 === this.openElements.stackTop && this.fragmentContext ? (t = this.fragmentContext, n = this.fragmentContextID) : ({ current: t, currentTagId: n } = this.openElements), (e.tagID !== Qp.SVG || this.treeAdapter.getTagName(t) !== Wp.ANNOTATION_XML || this.treeAdapter.getNamespaceURI(t) !== Gp.MATHML) && (this.tokenizer.inForeignNode || (e.tagID === Qp.MGLYPH || e.tagID === Qp.MALIGNMARK) && void 0 !== n && !this._isIntegrationPoint(n, t, Gp.HTML)) } _processToken(e) { switch (e.type) { case Op.CHARACTER: this.onCharacter(e); break; case Op.NULL_CHARACTER: this.onNullCharacter(e); break; case Op.COMMENT: this.onComment(e); break; case Op.DOCTYPE: this.onDoctype(e); break; case Op.START_TAG: this._processStartTag(e); break; case Op.END_TAG: this.onEndTag(e); break; case Op.EOF: this.onEof(e); break; case Op.WHITESPACE_CHARACTER: this.onWhitespaceCharacter(e) } } _isIntegrationPoint(e, t, n) { return function (e, t, n, r) { return (!r || r === Gp.HTML) && function (e, t, n) { if (t === Gp.MATHML && e === Qp.ANNOTATION_XML) for (let r = 0; r < n.length; r++)if (n[r].name === Yp.ENCODING) { const e = n[r].value.toLowerCase(); return "text/html" === e || "application/xhtml+xml" === e } return t === Gp.SVG && (e === Qp.FOREIGN_OBJECT || e === Qp.DESC || e === Qp.TITLE) }(e, t, n) || (!r || r === Gp.MATHML) && function (e, t) { return t === Gp.MATHML && (e === Qp.MI || e === Qp.MO || e === Qp.MN || e === Qp.MS || e === Qp.MTEXT) }(e, t) }(e, this.treeAdapter.getNamespaceURI(t), this.treeAdapter.getAttrList(t), n) } _reconstructActiveFormattingElements() { const e = this.activeFormattingElements.entries.length; if (e) { const t = this.activeFormattingElements.entries.findIndex(e => e.type === Rf.Marker || this.openElements.contains(e.element)); for (let n = -1 === t ? e - 1 : t - 1; n >= 0; n--) { const e = this.activeFormattingElements.entries[n]; this._insertElement(e.token, this.treeAdapter.getNamespaceURI(e.element)), e.element = this.openElements.current } } } _closeTableCell() { this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = Qf.IN_ROW } _closePElement() { this.openElements.generateImpliedEndTagsWithExclusion(Qp.P), this.openElements.popUntilTagNamePopped(Qp.P) } _resetInsertionMode() { for (let e = this.openElements.stackTop; e >= 0; e--)switch (0 === e && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[e]) { case Qp.TR: return void (this.insertionMode = Qf.IN_ROW); case Qp.TBODY: case Qp.THEAD: case Qp.TFOOT: return void (this.insertionMode = Qf.IN_TABLE_BODY); case Qp.CAPTION: return void (this.insertionMode = Qf.IN_CAPTION); case Qp.COLGROUP: return void (this.insertionMode = Qf.IN_COLUMN_GROUP); case Qp.TABLE: return void (this.insertionMode = Qf.IN_TABLE); case Qp.BODY: return void (this.insertionMode = Qf.IN_BODY); case Qp.FRAMESET: return void (this.insertionMode = Qf.IN_FRAMESET); case Qp.SELECT: return void this._resetInsertionModeForSelect(e); case Qp.TEMPLATE: return void (this.insertionMode = this.tmplInsertionModeStack[0]); case Qp.HTML: return void (this.insertionMode = this.headElement ? Qf.AFTER_HEAD : Qf.BEFORE_HEAD); case Qp.TD: case Qp.TH: if (e > 0) return void (this.insertionMode = Qf.IN_CELL); break; case Qp.HEAD: if (e > 0) return void (this.insertionMode = Qf.IN_HEAD) }this.insertionMode = Qf.IN_BODY } _resetInsertionModeForSelect(e) { if (e > 0) for (let t = e - 1; t > 0; t--) { const e = this.openElements.tagIDs[t]; if (e === Qp.TEMPLATE) break; if (e === Qp.TABLE) return void (this.insertionMode = Qf.IN_SELECT_IN_TABLE) } this.insertionMode = Qf.IN_SELECT } _isElementCausesFosterParenting(e) { return Zf.has(e) } _shouldFosterParentOnInsertion() { return this.fosterParentingEnabled && void 0 !== this.openElements.currentTagId && this._isElementCausesFosterParenting(this.openElements.currentTagId) } _findFosterParentingLocation() { for (let e = this.openElements.stackTop; e >= 0; e--) { const t = this.openElements.items[e]; switch (this.openElements.tagIDs[e]) { case Qp.TEMPLATE: if (this.treeAdapter.getNamespaceURI(t) === Gp.HTML) return { parent: this.treeAdapter.getTemplateContent(t), beforeElement: null }; break; case Qp.TABLE: { const n = this.treeAdapter.getParentNode(t); return n ? { parent: n, beforeElement: t } : { parent: this.openElements.items[e - 1], beforeElement: null } } } } return { parent: this.openElements.items[0], beforeElement: null } } _fosterParentElement(e) { const t = this._findFosterParentingLocation(); t.beforeElement ? this.treeAdapter.insertBefore(t.parent, e, t.beforeElement) : this.treeAdapter.appendChild(t.parent, e) } _isSpecialElement(e, t) { const n = this.treeAdapter.getNamespaceURI(e); return af[n].has(t) } onCharacter(e) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) !function (e, t) { e._insertCharacters(t), e.framesetOk = !1 }(this, e); else switch (this.insertionMode) { case Qf.INITIAL: hm(this, e); break; case Qf.BEFORE_HTML: dm(this, e); break; case Qf.BEFORE_HEAD: pm(this, e); break; case Qf.IN_HEAD: gm(this, e); break; case Qf.IN_HEAD_NO_SCRIPT: Em(this, e); break; case Qf.AFTER_HEAD: Tm(this, e); break; case Qf.IN_BODY: case Qf.IN_CAPTION: case Qf.IN_CELL: case Qf.IN_TEMPLATE: ym(this, e); break; case Qf.TEXT: case Qf.IN_SELECT: case Qf.IN_SELECT_IN_TABLE: this._insertCharacters(e); break; case Qf.IN_TABLE: case Qf.IN_TABLE_BODY: case Qf.IN_ROW: vm(this, e); break; case Qf.IN_TABLE_TEXT: wm(this, e); break; case Qf.IN_COLUMN_GROUP: Um(this, e); break; case Qf.AFTER_BODY: Wm(this, e); break; case Qf.AFTER_AFTER_BODY: Km(this, e) } } onNullCharacter(e) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) !function (e, t) { t.chars = Ep, e._insertCharacters(t) }(this, e); else switch (this.insertionMode) { case Qf.INITIAL: hm(this, e); break; case Qf.BEFORE_HTML: dm(this, e); break; case Qf.BEFORE_HEAD: pm(this, e); break; case Qf.IN_HEAD: gm(this, e); break; case Qf.IN_HEAD_NO_SCRIPT: Em(this, e); break; case Qf.AFTER_HEAD: Tm(this, e); break; case Qf.TEXT: this._insertCharacters(e); break; case Qf.IN_TABLE: case Qf.IN_TABLE_BODY: case Qf.IN_ROW: vm(this, e); break; case Qf.IN_COLUMN_GROUP: Um(this, e); break; case Qf.AFTER_BODY: Wm(this, e); break; case Qf.AFTER_AFTER_BODY: Km(this, e) } } onComment(e) { if (this.skipNextNewLine = !1, this.currentNotInHTML) cm(this, e); else switch (this.insertionMode) { case Qf.INITIAL: case Qf.BEFORE_HTML: case Qf.BEFORE_HEAD: case Qf.IN_HEAD: case Qf.IN_HEAD_NO_SCRIPT: case Qf.AFTER_HEAD: case Qf.IN_BODY: case Qf.IN_TABLE: case Qf.IN_CAPTION: case Qf.IN_COLUMN_GROUP: case Qf.IN_TABLE_BODY: case Qf.IN_ROW: case Qf.IN_CELL: case Qf.IN_SELECT: case Qf.IN_SELECT_IN_TABLE: case Qf.IN_TEMPLATE: case Qf.IN_FRAMESET: case Qf.AFTER_FRAMESET: cm(this, e); break; case Qf.IN_TABLE_TEXT: Mm(this, e); break; case Qf.AFTER_BODY: !function (e, t) { e._appendCommentNode(t, e.openElements.items[0]) }(this, e); break; case Qf.AFTER_AFTER_BODY: case Qf.AFTER_AFTER_FRAMESET: !function (e, t) { e._appendCommentNode(t, e.document) }(this, e) } } onDoctype(e) { switch (this.skipNextNewLine = !1, this.insertionMode) { case Qf.INITIAL: !function (e, t) { e._setDocumentType(t); const n = t.forceQuirks ? Vp.QUIRKS : function (e) { if (e.name !== Mf) return Vp.QUIRKS; const { systemId: t } = e; if (t && "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd" === t.toLowerCase()) return Vp.QUIRKS; let { publicId: n } = e; if (null !== n) { if (n = n.toLowerCase(), Uf.has(n)) return Vp.QUIRKS; let e = null === t ? Bf : Ff; if (Gf(n, e)) return Vp.QUIRKS; if (e = null === t ? Hf : jf, Gf(n, e)) return Vp.LIMITED_QUIRKS } return Vp.NO_QUIRKS }(t); (function (e) { return e.name === Mf && null === e.publicId && (null === e.systemId || "about:legacy-compat" === e.systemId) })(t) || e._err(t, Np.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = Qf.BEFORE_HTML }(this, e); break; case Qf.BEFORE_HEAD: case Qf.IN_HEAD: case Qf.IN_HEAD_NO_SCRIPT: case Qf.AFTER_HEAD: this._err(e, Np.misplacedDoctype); break; case Qf.IN_TABLE_TEXT: Mm(this, e) } } onStartTag(e) { this.skipNextNewLine = !1, this.currentToken = e, this._processStartTag(e), e.selfClosing && !e.ackSelfClosing && this._err(e, Np.nonVoidHtmlElementStartTagWithTrailingSolidus) } _processStartTag(e) { this.shouldProcessStartTagTokenInForeignContent(e) ? function (e, t) { if (function (e) { const t = e.tagID; return t === Qp.FONT && e.attrs.some(({ name: e }) => e === Yp.COLOR || e === Yp.SIZE || e === Yp.FACE) || Vf.has(t) }(t)) Qm(e), e._startTagOutsideForeignContent(t); else { const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n); r === Gp.MATHML ? $f(t) : r === Gp.SVG && (function (e) { const t = qf.get(e.tagName); null != t && (e.tagName = t, e.tagID = sf(e.tagName)) }(t), Wf(t)), Kf(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0 } }(this, e) : this._startTagOutsideForeignContent(e) } _startTagOutsideForeignContent(e) { switch (this.insertionMode) { case Qf.INITIAL: hm(this, e); break; case Qf.BEFORE_HTML: !function (e, t) { t.tagID === Qp.HTML ? (e._insertElement(t, Gp.HTML), e.insertionMode = Qf.BEFORE_HEAD) : dm(e, t) }(this, e); break; case Qf.BEFORE_HEAD: !function (e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.HEAD: e._insertElement(t, Gp.HTML), e.headElement = e.openElements.current, e.insertionMode = Qf.IN_HEAD; break; default: pm(e, t) } }(this, e); break; case Qf.IN_HEAD: fm(this, e); break; case Qf.IN_HEAD_NO_SCRIPT: !function (e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.BASEFONT: case Qp.BGSOUND: case Qp.HEAD: case Qp.LINK: case Qp.META: case Qp.NOFRAMES: case Qp.STYLE: fm(e, t); break; case Qp.NOSCRIPT: e._err(t, Np.nestedNoscriptInHead); break; default: Em(e, t) } }(this, e); break; case Qf.AFTER_HEAD: !function (e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.BODY: e._insertElement(t, Gp.HTML), e.framesetOk = !1, e.insertionMode = Qf.IN_BODY; break; case Qp.FRAMESET: e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_FRAMESET; break; case Qp.BASE: case Qp.BASEFONT: case Qp.BGSOUND: case Qp.LINK: case Qp.META: case Qp.NOFRAMES: case Qp.SCRIPT: case Qp.STYLE: case Qp.TEMPLATE: case Qp.TITLE: e._err(t, Np.abandonedHeadElementChild), e.openElements.push(e.headElement, Qp.HEAD), fm(e, t), e.openElements.remove(e.headElement); break; case Qp.HEAD: e._err(t, Np.misplacedStartTagForHeadElement); break; default: Tm(e, t) } }(this, e); break; case Qf.IN_BODY: Nm(this, e); break; case Qf.IN_TABLE: Rm(this, e); break; case Qf.IN_TABLE_TEXT: Mm(this, e); break; case Qf.IN_CAPTION: !function (e, t) { const n = t.tagID; Fm.has(n) ? e.openElements.hasInTableScope(Qp.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Qp.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Qf.IN_TABLE, Rm(e, t)) : Nm(e, t) }(this, e); break; case Qf.IN_COLUMN_GROUP: Bm(this, e); break; case Qf.IN_TABLE_BODY: Hm(this, e); break; case Qf.IN_ROW: Gm(this, e); break; case Qf.IN_CELL: !function (e, t) { const n = t.tagID; Fm.has(n) ? (e.openElements.hasInTableScope(Qp.TD) || e.openElements.hasInTableScope(Qp.TH)) && (e._closeTableCell(), Gm(e, t)) : Nm(e, t) }(this, e); break; case Qf.IN_SELECT: Ym(this, e); break; case Qf.IN_SELECT_IN_TABLE: !function (e, t) { const n = t.tagID; n === Qp.CAPTION || n === Qp.TABLE || n === Qp.TBODY || n === Qp.TFOOT || n === Qp.THEAD || n === Qp.TR || n === Qp.TD || n === Qp.TH ? (e.openElements.popUntilTagNamePopped(Qp.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : Ym(e, t) }(this, e); break; case Qf.IN_TEMPLATE: !function (e, t) { switch (t.tagID) { case Qp.BASE: case Qp.BASEFONT: case Qp.BGSOUND: case Qp.LINK: case Qp.META: case Qp.NOFRAMES: case Qp.SCRIPT: case Qp.STYLE: case Qp.TEMPLATE: case Qp.TITLE: fm(e, t); break; case Qp.CAPTION: case Qp.COLGROUP: case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: e.tmplInsertionModeStack[0] = Qf.IN_TABLE, e.insertionMode = Qf.IN_TABLE, Rm(e, t); break; case Qp.COL: e.tmplInsertionModeStack[0] = Qf.IN_COLUMN_GROUP, e.insertionMode = Qf.IN_COLUMN_GROUP, Bm(e, t); break; case Qp.TR: e.tmplInsertionModeStack[0] = Qf.IN_TABLE_BODY, e.insertionMode = Qf.IN_TABLE_BODY, Hm(e, t); break; case Qp.TD: case Qp.TH: e.tmplInsertionModeStack[0] = Qf.IN_ROW, e.insertionMode = Qf.IN_ROW, Gm(e, t); break; default: e.tmplInsertionModeStack[0] = Qf.IN_BODY, e.insertionMode = Qf.IN_BODY, Nm(e, t) } }(this, e); break; case Qf.AFTER_BODY: !function (e, t) { t.tagID === Qp.HTML ? Nm(e, t) : Wm(e, t) }(this, e); break; case Qf.IN_FRAMESET: !function (e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.FRAMESET: e._insertElement(t, Gp.HTML); break; case Qp.FRAME: e._appendElement(t, Gp.HTML), t.ackSelfClosing = !0; break; case Qp.NOFRAMES: fm(e, t) } }(this, e); break; case Qf.AFTER_FRAMESET: !function (e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.NOFRAMES: fm(e, t) } }(this, e); break; case Qf.AFTER_AFTER_BODY: !function (e, t) { t.tagID === Qp.HTML ? Nm(e, t) : Km(e, t) }(this, e); break; case Qf.AFTER_AFTER_FRAMESET: !function (e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.NOFRAMES: fm(e, t) } }(this, e) } } onEndTag(e) { this.skipNextNewLine = !1, this.currentToken = e, this.currentNotInHTML ? function (e, t) { if (t.tagID === Qp.P || t.tagID === Qp.BR) return Qm(e), void e._endTagOutsideForeignContent(t); for (let n = e.openElements.stackTop; n > 0; n--) { const r = e.openElements.items[n]; if (e.treeAdapter.getNamespaceURI(r) === Gp.HTML) { e._endTagOutsideForeignContent(t); break } const s = e.treeAdapter.getTagName(r); if (s.toLowerCase() === t.tagName) { t.tagName = s, e.openElements.shortenToLength(n); break } } }(this, e) : this._endTagOutsideForeignContent(e) } _endTagOutsideForeignContent(e) { switch (this.insertionMode) { case Qf.INITIAL: hm(this, e); break; case Qf.BEFORE_HTML: !function (e, t) { const n = t.tagID; n !== Qp.HTML && n !== Qp.HEAD && n !== Qp.BODY && n !== Qp.BR || dm(e, t) }(this, e); break; case Qf.BEFORE_HEAD: !function (e, t) { const n = t.tagID; n === Qp.HEAD || n === Qp.BODY || n === Qp.HTML || n === Qp.BR ? pm(e, t) : e._err(t, Np.endTagWithoutMatchingOpenElement) }(this, e); break; case Qf.IN_HEAD: !function (e, t) { switch (t.tagID) { case Qp.HEAD: e.openElements.pop(), e.insertionMode = Qf.AFTER_HEAD; break; case Qp.BODY: case Qp.BR: case Qp.HTML: gm(e, t); break; case Qp.TEMPLATE: mm(e, t); break; default: e._err(t, Np.endTagWithoutMatchingOpenElement) } }(this, e); break; case Qf.IN_HEAD_NO_SCRIPT: !function (e, t) { switch (t.tagID) { case Qp.NOSCRIPT: e.openElements.pop(), e.insertionMode = Qf.IN_HEAD; break; case Qp.BR: Em(e, t); break; default: e._err(t, Np.endTagWithoutMatchingOpenElement) } }(this, e); break; case Qf.AFTER_HEAD: !function (e, t) { switch (t.tagID) { case Qp.BODY: case Qp.HTML: case Qp.BR: Tm(e, t); break; case Qp.TEMPLATE: mm(e, t); break; default: e._err(t, Np.endTagWithoutMatchingOpenElement) } }(this, e); break; case Qf.IN_BODY: Om(this, e); break; case Qf.TEXT: !function (e, t) { var n; t.tagID === Qp.SCRIPT && (null === (n = e.scriptHandler) || void 0 === n || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode }(this, e); break; case Qf.IN_TABLE: Dm(this, e); break; case Qf.IN_TABLE_TEXT: Mm(this, e); break; case Qf.IN_CAPTION: !function (e, t) { const n = t.tagID; switch (n) { case Qp.CAPTION: case Qp.TABLE: e.openElements.hasInTableScope(Qp.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Qp.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Qf.IN_TABLE, n === Qp.TABLE && Dm(e, t)); break; case Qp.BODY: case Qp.COL: case Qp.COLGROUP: case Qp.HTML: case Qp.TBODY: case Qp.TD: case Qp.TFOOT: case Qp.TH: case Qp.THEAD: case Qp.TR: break; default: Om(e, t) } }(this, e); break; case Qf.IN_COLUMN_GROUP: !function (e, t) { switch (t.tagID) { case Qp.COLGROUP: e.openElements.currentTagId === Qp.COLGROUP && (e.openElements.pop(), e.insertionMode = Qf.IN_TABLE); break; case Qp.TEMPLATE: mm(e, t); break; case Qp.COL: break; default: Um(e, t) } }(this, e); break; case Qf.IN_TABLE_BODY: jm(this, e); break; case Qf.IN_ROW: zm(this, e); break; case Qf.IN_CELL: !function (e, t) { const n = t.tagID; switch (n) { case Qp.TD: case Qp.TH: e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = Qf.IN_ROW); break; case Qp.TABLE: case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: case Qp.TR: e.openElements.hasInTableScope(n) && (e._closeTableCell(), zm(e, t)); break; case Qp.BODY: case Qp.CAPTION: case Qp.COL: case Qp.COLGROUP: case Qp.HTML: break; default: Om(e, t) } }(this, e); break; case Qf.IN_SELECT: qm(this, e); break; case Qf.IN_SELECT_IN_TABLE: !function (e, t) { const n = t.tagID; n === Qp.CAPTION || n === Qp.TABLE || n === Qp.TBODY || n === Qp.TFOOT || n === Qp.THEAD || n === Qp.TR || n === Qp.TD || n === Qp.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(Qp.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : qm(e, t) }(this, e); break; case Qf.IN_TEMPLATE: !function (e, t) { t.tagID === Qp.TEMPLATE && mm(e, t) }(this, e); break; case Qf.AFTER_BODY: $m(this, e); break; case Qf.IN_FRAMESET: !function (e, t) { t.tagID !== Qp.FRAMESET || e.openElements.isRootHtmlElementCurrent() || (e.openElements.pop(), e.fragmentContext || e.openElements.currentTagId === Qp.FRAMESET || (e.insertionMode = Qf.AFTER_FRAMESET)) }(this, e); break; case Qf.AFTER_FRAMESET: !function (e, t) { t.tagID === Qp.HTML && (e.insertionMode = Qf.AFTER_AFTER_FRAMESET) }(this, e); break; case Qf.AFTER_AFTER_BODY: Km(this, e) } } onEof(e) { switch (this.insertionMode) { case Qf.INITIAL: hm(this, e); break; case Qf.BEFORE_HTML: dm(this, e); break; case Qf.BEFORE_HEAD: pm(this, e); break; case Qf.IN_HEAD: gm(this, e); break; case Qf.IN_HEAD_NO_SCRIPT: Em(this, e); break; case Qf.AFTER_HEAD: Tm(this, e); break; case Qf.IN_BODY: case Qf.IN_TABLE: case Qf.IN_CAPTION: case Qf.IN_COLUMN_GROUP: case Qf.IN_TABLE_BODY: case Qf.IN_ROW: case Qf.IN_CELL: case Qf.IN_SELECT: case Qf.IN_SELECT_IN_TABLE: xm(this, e); break; case Qf.TEXT: !function (e, t) { e._err(t, Np.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t) }(this, e); break; case Qf.IN_TABLE_TEXT: Mm(this, e); break; case Qf.IN_TEMPLATE: Vm(this, e); break; case Qf.AFTER_BODY: case Qf.IN_FRAMESET: case Qf.AFTER_FRAMESET: case Qf.AFTER_AFTER_BODY: case Qf.AFTER_AFTER_FRAMESET: um(this, e) } } onWhitespaceCharacter(e) { if (this.skipNextNewLine && (this.skipNextNewLine = !1, e.chars.charCodeAt(0) === Tp.LINE_FEED)) { if (1 === e.chars.length) return; e.chars = e.chars.substr(1) } if (this.tokenizer.inForeignNode) this._insertCharacters(e); else switch (this.insertionMode) { case Qf.IN_HEAD: case Qf.IN_HEAD_NO_SCRIPT: case Qf.AFTER_HEAD: case Qf.TEXT: case Qf.IN_COLUMN_GROUP: case Qf.IN_SELECT: case Qf.IN_SELECT_IN_TABLE: case Qf.IN_FRAMESET: case Qf.AFTER_FRAMESET: this._insertCharacters(e); break; case Qf.IN_BODY: case Qf.IN_CAPTION: case Qf.IN_CELL: case Qf.IN_TEMPLATE: case Qf.AFTER_BODY: case Qf.AFTER_AFTER_BODY: case Qf.AFTER_AFTER_FRAMESET: _m(this, e); break; case Qf.IN_TABLE: case Qf.IN_TABLE_BODY: case Qf.IN_ROW: vm(this, e); break; case Qf.IN_TABLE_TEXT: Pm(this, e) } } } function nm(e, t) { let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName); return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : Im(e, t), n } function rm(e, t) { let n = null, r = e.openElements.stackTop; for (; r >= 0; r--) { const s = e.openElements.items[r]; if (s === t.element) break; e._isSpecialElement(s, e.openElements.tagIDs[r]) && (n = s) } return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n } function sm(e, t, n) { let r = t, s = e.openElements.getCommonAncestor(t); for (let i = 0, o = s; o !== n; i++, o = s) { s = e.openElements.getCommonAncestor(o); const n = e.activeFormattingElements.getElementEntry(o), a = n && i >= 3; !n || a ? (a && e.activeFormattingElements.removeEntry(n), e.openElements.remove(o)) : (o = im(e, n), r === t && (e.activeFormattingElements.bookmark = n), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(o, r), r = o) } return r } function im(e, t) { const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs); return e.openElements.replace(t.element, r), t.element = r, r } function om(e, t, n) { const r = sf(e.treeAdapter.getTagName(t)); if (e._isElementCausesFosterParenting(r)) e._fosterParentElement(n); else { const s = e.treeAdapter.getNamespaceURI(t); r === Qp.TEMPLATE && s === Gp.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n) } } function am(e, t, n) { const r = e.treeAdapter.getNamespaceURI(n.element), { token: s } = n, i = e.treeAdapter.createElement(s.tagName, r, s.attrs); e._adoptNodes(t, i), e.treeAdapter.appendChild(t, i), e.activeFormattingElements.insertElementAfterBookmark(i, s), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, i, s.tagID) } function lm(e, t) { for (let n = 0; n < 8; n++) { const n = nm(e, t); if (!n) break; const r = rm(e, n); if (!r) break; e.activeFormattingElements.bookmark = n; const s = sm(e, r, n.element), i = e.openElements.getCommonAncestor(n.element); e.treeAdapter.detachNode(s), i && om(e, i, s), am(e, r, n) } } function cm(e, t) { e._appendCommentNode(t, e.openElements.currentTmplContentOrNode) } function um(e, t) { if (e.stopped = !0, t.location) { const n = e.fragmentContext ? 0 : 2; for (let r = e.openElements.stackTop; r >= n; r--)e._setEndLocation(e.openElements.items[r], t); if (!e.fragmentContext && e.openElements.stackTop >= 0) { const n = e.openElements.items[0], r = e.treeAdapter.getNodeSourceCodeLocation(n); if (r && !r.endTag && (e._setEndLocation(n, t), e.openElements.stackTop >= 1)) { const n = e.openElements.items[1], r = e.treeAdapter.getNodeSourceCodeLocation(n); r && !r.endTag && e._setEndLocation(n, t) } } } } function hm(e, t) { e._err(t, Np.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, Vp.QUIRKS), e.insertionMode = Qf.BEFORE_HTML, e._processToken(t) } function dm(e, t) { e._insertFakeRootElement(), e.insertionMode = Qf.BEFORE_HEAD, e._processToken(t) } function pm(e, t) { e._insertFakeElement(Wp.HEAD, Qp.HEAD), e.headElement = e.openElements.current, e.insertionMode = Qf.IN_HEAD, e._processToken(t) } function fm(e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.BASE: case Qp.BASEFONT: case Qp.BGSOUND: case Qp.LINK: case Qp.META: e._appendElement(t, Gp.HTML), t.ackSelfClosing = !0; break; case Qp.TITLE: e._switchToTextParsing(t, hf.RCDATA); break; case Qp.NOSCRIPT: e.options.scriptingEnabled ? e._switchToTextParsing(t, hf.RAWTEXT) : (e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_HEAD_NO_SCRIPT); break; case Qp.NOFRAMES: case Qp.STYLE: e._switchToTextParsing(t, hf.RAWTEXT); break; case Qp.SCRIPT: e._switchToTextParsing(t, hf.SCRIPT_DATA); break; case Qp.TEMPLATE: e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = Qf.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(Qf.IN_TEMPLATE); break; case Qp.HEAD: e._err(t, Np.misplacedStartTagForHeadElement); break; default: gm(e, t) } } function mm(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== Qp.TEMPLATE && e._err(t, Np.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(Qp.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, Np.endTagWithoutMatchingOpenElement) } function gm(e, t) { e.openElements.pop(), e.insertionMode = Qf.AFTER_HEAD, e._processToken(t) } function Em(e, t) { const n = t.type === Op.EOF ? Np.openElementsLeftAfterEof : Np.disallowedContentInNoscriptInHead; e._err(t, n), e.openElements.pop(), e.insertionMode = Qf.IN_HEAD, e._processToken(t) } function Tm(e, t) { e._insertFakeElement(Wp.BODY, Qp.BODY), e.insertionMode = Qf.IN_BODY, Am(e, t) } function Am(e, t) { switch (t.type) { case Op.CHARACTER: ym(e, t); break; case Op.WHITESPACE_CHARACTER: _m(e, t); break; case Op.COMMENT: cm(e, t); break; case Op.START_TAG: Nm(e, t); break; case Op.END_TAG: Om(e, t); break; case Op.EOF: xm(e, t) } } function _m(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t) } function ym(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1 } function bm(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, Gp.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function Sm(e) { const t = Rp(e, Yp.TYPE); return null != t && "hidden" === t.toLowerCase() } function km(e, t) { e._switchToTextParsing(t, hf.RAWTEXT) } function Cm(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML) } function Nm(e, t) { switch (t.tagID) { case Qp.I: case Qp.S: case Qp.B: case Qp.U: case Qp.EM: case Qp.TT: case Qp.BIG: case Qp.CODE: case Qp.FONT: case Qp.SMALL: case Qp.STRIKE: case Qp.STRONG: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Qp.A: !function (e, t) { const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(Wp.A); n && (lm(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Qp.H1: case Qp.H2: case Qp.H3: case Qp.H4: case Qp.H5: case Qp.H6: !function (e, t) { e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), void 0 !== e.openElements.currentTagId && lf.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, Gp.HTML) }(e, t); break; case Qp.P: case Qp.DL: case Qp.OL: case Qp.UL: case Qp.DIV: case Qp.DIR: case Qp.NAV: case Qp.MAIN: case Qp.MENU: case Qp.ASIDE: case Qp.CENTER: case Qp.FIGURE: case Qp.FOOTER: case Qp.HEADER: case Qp.HGROUP: case Qp.DIALOG: case Qp.DETAILS: case Qp.ADDRESS: case Qp.ARTICLE: case Qp.SEARCH: case Qp.SECTION: case Qp.SUMMARY: case Qp.FIELDSET: case Qp.BLOCKQUOTE: case Qp.FIGCAPTION: !function (e, t) { e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._insertElement(t, Gp.HTML) }(e, t); break; case Qp.LI: case Qp.DD: case Qp.DT: !function (e, t) { e.framesetOk = !1; const n = t.tagID; for (let r = e.openElements.stackTop; r >= 0; r--) { const t = e.openElements.tagIDs[r]; if (n === Qp.LI && t === Qp.LI || (n === Qp.DD || n === Qp.DT) && (t === Qp.DD || t === Qp.DT)) { e.openElements.generateImpliedEndTagsWithExclusion(t), e.openElements.popUntilTagNamePopped(t); break } if (t !== Qp.ADDRESS && t !== Qp.DIV && t !== Qp.P && e._isSpecialElement(e.openElements.items[r], t)) break } e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._insertElement(t, Gp.HTML) }(e, t); break; case Qp.BR: case Qp.IMG: case Qp.WBR: case Qp.AREA: case Qp.EMBED: case Qp.KEYGEN: bm(e, t); break; case Qp.HR: !function (e, t) { e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._appendElement(t, Gp.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 }(e, t); break; case Qp.RB: case Qp.RTC: !function (e, t) { e.openElements.hasInScope(Qp.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, Gp.HTML) }(e, t); break; case Qp.RT: case Qp.RP: !function (e, t) { e.openElements.hasInScope(Qp.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(Qp.RTC), e._insertElement(t, Gp.HTML) }(e, t); break; case Qp.PRE: case Qp.LISTING: !function (e, t) { e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._insertElement(t, Gp.HTML), e.skipNextNewLine = !0, e.framesetOk = !1 }(e, t); break; case Qp.XMP: !function (e, t) { e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, hf.RAWTEXT) }(e, t); break; case Qp.SVG: !function (e, t) { e._reconstructActiveFormattingElements(), Wf(t), Kf(t), t.selfClosing ? e._appendElement(t, Gp.SVG) : e._insertElement(t, Gp.SVG), t.ackSelfClosing = !0 }(e, t); break; case Qp.HTML: !function (e, t) { 0 === e.openElements.tmplCount && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs) }(e, t); break; case Qp.BASE: case Qp.LINK: case Qp.META: case Qp.STYLE: case Qp.TITLE: case Qp.SCRIPT: case Qp.BGSOUND: case Qp.BASEFONT: case Qp.TEMPLATE: fm(e, t); break; case Qp.BODY: !function (e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && 0 === e.openElements.tmplCount && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs)) }(e, t); break; case Qp.FORM: !function (e, t) { const n = e.openElements.tmplCount > 0; e.formElement && !n || (e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._insertElement(t, Gp.HTML), n || (e.formElement = e.openElements.current)) }(e, t); break; case Qp.NOBR: !function (e, t) { e._reconstructActiveFormattingElements(), e.openElements.hasInScope(Qp.NOBR) && (lm(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, Gp.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) }(e, t); break; case Qp.MATH: !function (e, t) { e._reconstructActiveFormattingElements(), $f(t), Kf(t), t.selfClosing ? e._appendElement(t, Gp.MATHML) : e._insertElement(t, Gp.MATHML), t.ackSelfClosing = !0 }(e, t); break; case Qp.TABLE: !function (e, t) { e.treeAdapter.getDocumentMode(e.document) !== Vp.QUIRKS && e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._insertElement(t, Gp.HTML), e.framesetOk = !1, e.insertionMode = Qf.IN_TABLE }(e, t); break; case Qp.INPUT: !function (e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, Gp.HTML), Sm(t) || (e.framesetOk = !1), t.ackSelfClosing = !0 }(e, t); break; case Qp.PARAM: case Qp.TRACK: case Qp.SOURCE: !function (e, t) { e._appendElement(t, Gp.HTML), t.ackSelfClosing = !0 }(e, t); break; case Qp.IMAGE: !function (e, t) { t.tagName = Wp.IMG, t.tagID = Qp.IMG, bm(e, t) }(e, t); break; case Qp.BUTTON: !function (e, t) { e.openElements.hasInScope(Qp.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(Qp.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML), e.framesetOk = !1 }(e, t); break; case Qp.APPLET: case Qp.OBJECT: case Qp.MARQUEE: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1 }(e, t); break; case Qp.IFRAME: !function (e, t) { e.framesetOk = !1, e._switchToTextParsing(t, hf.RAWTEXT) }(e, t); break; case Qp.SELECT: !function (e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === Qf.IN_TABLE || e.insertionMode === Qf.IN_CAPTION || e.insertionMode === Qf.IN_TABLE_BODY || e.insertionMode === Qf.IN_ROW || e.insertionMode === Qf.IN_CELL ? Qf.IN_SELECT_IN_TABLE : Qf.IN_SELECT }(e, t); break; case Qp.OPTION: case Qp.OPTGROUP: !function (e, t) { e.openElements.currentTagId === Qp.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, Gp.HTML) }(e, t); break; case Qp.NOEMBED: case Qp.NOFRAMES: km(e, t); break; case Qp.FRAMESET: !function (e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_FRAMESET) }(e, t); break; case Qp.TEXTAREA: !function (e, t) { e._insertElement(t, Gp.HTML), e.skipNextNewLine = !0, e.tokenizer.state = hf.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = Qf.TEXT }(e, t); break; case Qp.NOSCRIPT: e.options.scriptingEnabled ? km(e, t) : Cm(e, t); break; case Qp.PLAINTEXT: !function (e, t) { e.openElements.hasInButtonScope(Qp.P) && e._closePElement(), e._insertElement(t, Gp.HTML), e.tokenizer.state = hf.PLAINTEXT }(e, t); break; case Qp.COL: case Qp.TH: case Qp.TD: case Qp.TR: case Qp.HEAD: case Qp.FRAME: case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: case Qp.CAPTION: case Qp.COLGROUP: break; default: Cm(e, t) } } function Im(e, t) { const n = t.tagName, r = t.tagID; for (let s = e.openElements.stackTop; s > 0; s--) { const t = e.openElements.items[s], i = e.openElements.tagIDs[s]; if (r === i && (r !== Qp.UNKNOWN || e.treeAdapter.getTagName(t) === n)) { e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= s && e.openElements.shortenToLength(s); break } if (e._isSpecialElement(t, i)) break } } function Om(e, t) { switch (t.tagID) { case Qp.A: case Qp.B: case Qp.I: case Qp.S: case Qp.U: case Qp.EM: case Qp.TT: case Qp.BIG: case Qp.CODE: case Qp.FONT: case Qp.NOBR: case Qp.SMALL: case Qp.STRIKE: case Qp.STRONG: lm(e, t); break; case Qp.P: !function (e) { e.openElements.hasInButtonScope(Qp.P) || e._insertFakeElement(Wp.P, Qp.P), e._closePElement() }(e); break; case Qp.DL: case Qp.UL: case Qp.OL: case Qp.DIR: case Qp.DIV: case Qp.NAV: case Qp.PRE: case Qp.MAIN: case Qp.MENU: case Qp.ASIDE: case Qp.BUTTON: case Qp.CENTER: case Qp.FIGURE: case Qp.FOOTER: case Qp.HEADER: case Qp.HGROUP: case Qp.DIALOG: case Qp.ADDRESS: case Qp.ARTICLE: case Qp.DETAILS: case Qp.SEARCH: case Qp.SECTION: case Qp.SUMMARY: case Qp.LISTING: case Qp.FIELDSET: case Qp.BLOCKQUOTE: case Qp.FIGCAPTION: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n)) }(e, t); break; case Qp.LI: !function (e) { e.openElements.hasInListItemScope(Qp.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(Qp.LI), e.openElements.popUntilTagNamePopped(Qp.LI)) }(e); break; case Qp.DD: case Qp.DT: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n)) }(e, t); break; case Qp.H1: case Qp.H2: case Qp.H3: case Qp.H4: case Qp.H5: case Qp.H6: !function (e) { e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped()) }(e); break; case Qp.BR: !function (e) { e._reconstructActiveFormattingElements(), e._insertFakeElement(Wp.BR, Qp.BR), e.openElements.pop(), e.framesetOk = !1 }(e); break; case Qp.BODY: !function (e, t) { if (e.openElements.hasInScope(Qp.BODY) && (e.insertionMode = Qf.AFTER_BODY, e.options.sourceCodeLocationInfo)) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e._setEndLocation(n, t) } }(e, t); break; case Qp.HTML: !function (e, t) { e.openElements.hasInScope(Qp.BODY) && (e.insertionMode = Qf.AFTER_BODY, $m(e, t)) }(e, t); break; case Qp.FORM: !function (e) { const t = e.openElements.tmplCount > 0, { formElement: n } = e; t || (e.formElement = null), (n || t) && e.openElements.hasInScope(Qp.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(Qp.FORM) : n && e.openElements.remove(n)) }(e); break; case Qp.APPLET: case Qp.OBJECT: case Qp.MARQUEE: !function (e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker()) }(e, t); break; case Qp.TEMPLATE: mm(e, t); break; default: Im(e, t) } } function xm(e, t) { e.tmplInsertionModeStack.length > 0 ? Vm(e, t) : um(e, t) } function vm(e, t) { if (void 0 !== e.openElements.currentTagId && Zf.has(e.openElements.currentTagId)) switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = Qf.IN_TABLE_TEXT, t.type) { case Op.CHARACTER: wm(e, t); break; case Op.WHITESPACE_CHARACTER: Pm(e, t) } else Lm(e, t) } function Rm(e, t) { switch (t.tagID) { case Qp.TD: case Qp.TH: case Qp.TR: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(Wp.TBODY, Qp.TBODY), e.insertionMode = Qf.IN_TABLE_BODY, Hm(e, t) }(e, t); break; case Qp.STYLE: case Qp.SCRIPT: case Qp.TEMPLATE: fm(e, t); break; case Qp.COL: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(Wp.COLGROUP, Qp.COLGROUP), e.insertionMode = Qf.IN_COLUMN_GROUP, Bm(e, t) }(e, t); break; case Qp.FORM: !function (e, t) { e.formElement || 0 !== e.openElements.tmplCount || (e._insertElement(t, Gp.HTML), e.formElement = e.openElements.current, e.openElements.pop()) }(e, t); break; case Qp.TABLE: !function (e, t) { e.openElements.hasInTableScope(Qp.TABLE) && (e.openElements.popUntilTagNamePopped(Qp.TABLE), e._resetInsertionMode(), e._processStartTag(t)) }(e, t); break; case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_TABLE_BODY }(e, t); break; case Qp.INPUT: !function (e, t) { Sm(t) ? e._appendElement(t, Gp.HTML) : Lm(e, t), t.ackSelfClosing = !0 }(e, t); break; case Qp.CAPTION: !function (e, t) { e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_CAPTION }(e, t); break; case Qp.COLGROUP: !function (e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_COLUMN_GROUP }(e, t); break; default: Lm(e, t) } } function Dm(e, t) { switch (t.tagID) { case Qp.TABLE: e.openElements.hasInTableScope(Qp.TABLE) && (e.openElements.popUntilTagNamePopped(Qp.TABLE), e._resetInsertionMode()); break; case Qp.TEMPLATE: mm(e, t); break; case Qp.BODY: case Qp.CAPTION: case Qp.COL: case Qp.COLGROUP: case Qp.HTML: case Qp.TBODY: case Qp.TD: case Qp.TFOOT: case Qp.TH: case Qp.THEAD: case Qp.TR: break; default: Lm(e, t) } } function Lm(e, t) { const n = e.fosterParentingEnabled; e.fosterParentingEnabled = !0, Am(e, t), e.fosterParentingEnabled = n } function Pm(e, t) { e.pendingCharacterTokens.push(t) } function wm(e, t) { e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0 } function Mm(e, t) { let n = 0; if (e.hasNonWhitespacePendingCharacterToken) for (; n < e.pendingCharacterTokens.length; n++)Lm(e, e.pendingCharacterTokens[n]); else for (; n < e.pendingCharacterTokens.length; n++)e._insertCharacters(e.pendingCharacterTokens[n]); e.insertionMode = e.originalInsertionMode, e._processToken(t) } const Fm = new Set([Qp.CAPTION, Qp.COL, Qp.COLGROUP, Qp.TBODY, Qp.TD, Qp.TFOOT, Qp.TH, Qp.THEAD, Qp.TR]); function Bm(e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.COL: e._appendElement(t, Gp.HTML), t.ackSelfClosing = !0; break; case Qp.TEMPLATE: fm(e, t); break; default: Um(e, t) } } function Um(e, t) { e.openElements.currentTagId === Qp.COLGROUP && (e.openElements.pop(), e.insertionMode = Qf.IN_TABLE, e._processToken(t)) } function Hm(e, t) { switch (t.tagID) { case Qp.TR: e.openElements.clearBackToTableBodyContext(), e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_ROW; break; case Qp.TH: case Qp.TD: e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(Wp.TR, Qp.TR), e.insertionMode = Qf.IN_ROW, Gm(e, t); break; case Qp.CAPTION: case Qp.COL: case Qp.COLGROUP: case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE, Rm(e, t)); break; default: Rm(e, t) } } function jm(e, t) { const n = t.tagID; switch (t.tagID) { case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE); break; case Qp.TABLE: e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE, Dm(e, t)); break; case Qp.BODY: case Qp.CAPTION: case Qp.COL: case Qp.COLGROUP: case Qp.HTML: case Qp.TD: case Qp.TH: case Qp.TR: break; default: Dm(e, t) } } function Gm(e, t) { switch (t.tagID) { case Qp.TH: case Qp.TD: e.openElements.clearBackToTableRowContext(), e._insertElement(t, Gp.HTML), e.insertionMode = Qf.IN_CELL, e.activeFormattingElements.insertMarker(); break; case Qp.CAPTION: case Qp.COL: case Qp.COLGROUP: case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: case Qp.TR: e.openElements.hasInTableScope(Qp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE_BODY, Hm(e, t)); break; default: Rm(e, t) } } function zm(e, t) { switch (t.tagID) { case Qp.TR: e.openElements.hasInTableScope(Qp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE_BODY); break; case Qp.TABLE: e.openElements.hasInTableScope(Qp.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE_BODY, jm(e, t)); break; case Qp.TBODY: case Qp.TFOOT: case Qp.THEAD: (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(Qp.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = Qf.IN_TABLE_BODY, jm(e, t)); break; case Qp.BODY: case Qp.CAPTION: case Qp.COL: case Qp.COLGROUP: case Qp.HTML: case Qp.TD: case Qp.TH: break; default: Dm(e, t) } } function Ym(e, t) { switch (t.tagID) { case Qp.HTML: Nm(e, t); break; case Qp.OPTION: e.openElements.currentTagId === Qp.OPTION && e.openElements.pop(), e._insertElement(t, Gp.HTML); break; case Qp.OPTGROUP: e.openElements.currentTagId === Qp.OPTION && e.openElements.pop(), e.openElements.currentTagId === Qp.OPTGROUP && e.openElements.pop(), e._insertElement(t, Gp.HTML); break; case Qp.HR: e.openElements.currentTagId === Qp.OPTION && e.openElements.pop(), e.openElements.currentTagId === Qp.OPTGROUP && e.openElements.pop(), e._appendElement(t, Gp.HTML), t.ackSelfClosing = !0; break; case Qp.INPUT: case Qp.KEYGEN: case Qp.TEXTAREA: case Qp.SELECT: e.openElements.hasInSelectScope(Qp.SELECT) && (e.openElements.popUntilTagNamePopped(Qp.SELECT), e._resetInsertionMode(), t.tagID !== Qp.SELECT && e._processStartTag(t)); break; case Qp.SCRIPT: case Qp.TEMPLATE: fm(e, t) } } function qm(e, t) { switch (t.tagID) { case Qp.OPTGROUP: e.openElements.stackTop > 0 && e.openElements.currentTagId === Qp.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === Qp.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === Qp.OPTGROUP && e.openElements.pop(); break; case Qp.OPTION: e.openElements.currentTagId === Qp.OPTION && e.openElements.pop(); break; case Qp.SELECT: e.openElements.hasInSelectScope(Qp.SELECT) && (e.openElements.popUntilTagNamePopped(Qp.SELECT), e._resetInsertionMode()); break; case Qp.TEMPLATE: mm(e, t) } } function Vm(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(Qp.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : um(e, t) } function $m(e, t) { var n; if (t.tagID === Qp.HTML) { if (e.fragmentContext || (e.insertionMode = Qf.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === Qp.HTML) { e._setEndLocation(e.openElements.items[0], t); const r = e.openElements.items[1]; r && !(null === (n = e.treeAdapter.getNodeSourceCodeLocation(r)) || void 0 === n ? void 0 : n.endTag) && e._setEndLocation(r, t) } } else Wm(e, t) } function Wm(e, t) { e.insertionMode = Qf.IN_BODY, Am(e, t) } function Km(e, t) { e.insertionMode = Qf.IN_BODY, Am(e, t) } function Qm(e) { for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== Gp.HTML && void 0 !== e.openElements.currentTagId && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);)e.openElements.pop() } Wp.AREA, Wp.BASE, Wp.BASEFONT, Wp.BGSOUND, Wp.BR, Wp.COL, Wp.EMBED, Wp.FRAME, Wp.HR, Wp.IMG, Wp.INPUT, Wp.KEYGEN, Wp.LINK, Wp.META, Wp.PARAM, Wp.SOURCE, Wp.TRACK, Wp.WBR; const Xm = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, Jm = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]), Zm = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }; function eg(e, t) { const n = function (e) { const t = "root" === e.type ? e.children[0] : e; return Boolean(t && ("doctype" === t.type || "element" === t.type && "html" === t.tagName.toLowerCase())) }(e), r = Ph("type", { handlers: { root: ng, element: rg, text: sg, comment: og, doctype: ig, raw: ag }, unknown: lg }), s = { parser: n ? new tm(Zm) : tm.getFragmentParser(void 0, Zm), handle(e) { r(e, s) }, stitches: !1, options: t || {} }; r(e, s), cg(s, da()); const i = function (e, t) { const n = t || {}; return sp({ file: n.file || void 0, location: !1, schema: "svg" === n.space ? Fo : Mo, verbose: n.verbose || !1 }, e) }(n ? s.parser.document : s.parser.getFragment(), { file: s.options.file }); return s.stitches && eu(i, "comment", function (e, t, n) { const r = e; if (r.value.stitch && n && void 0 !== t) return n.children[t] = r.value.stitch, t }), "root" === i.type && 1 === i.children.length && i.children[0].type === e.type ? i.children[0] : i } function tg(e, t) { let n = -1; if (e) for (; ++n < e.length;)t.handle(e[n]) } function ng(e, t) { tg(e.children, t) } function rg(e, t) { !function (e, t) { const n = e.tagName.toLowerCase(); if (t.parser.tokenizer.state === hf.PLAINTEXT) return; cg(t, da(e)); const r = t.parser.openElements.current; let s = "namespaceURI" in r ? r.namespaceURI : tp.html; s === tp.html && "svg" === n && (s = tp.svg); const i = (a = { ...e, children: [] }, hp(a, "svg" === ({ space: s === tp.svg ? "svg" : "html" } || cp).space ? Fo : Mo)), o = { type: Op.START_TAG, tagName: n, tagID: sf(n), selfClosing: !1, ackSelfClosing: !1, attrs: "attrs" in i ? i.attrs : [], location: hg(e) }; var a; t.parser.currentToken = o, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n }(e, t), tg(e.children, t), function (e, t) { const n = e.tagName.toLowerCase(); if (!t.parser.tokenizer.inForeignNode && mp.includes(n)) return; if (t.parser.tokenizer.state === hf.PLAINTEXT) return; cg(t, ha(e)); const r = { type: Op.END_TAG, tagName: n, tagID: sf(n), selfClosing: !1, ackSelfClosing: !1, attrs: [], location: hg(e) }; t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), n !== t.parser.tokenizer.lastStartTagName || t.parser.tokenizer.state !== hf.RCDATA && t.parser.tokenizer.state !== hf.RAWTEXT && t.parser.tokenizer.state !== hf.SCRIPT_DATA || (t.parser.tokenizer.state = hf.DATA) }(e, t) } function sg(e, t) { t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0); const n = { type: Op.CHARACTER, chars: e.value, location: hg(e) }; cg(t, da(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function ig(e, t) { const n = { type: Op.DOCTYPE, name: "html", forceQuirks: !1, publicId: "", systemId: "", location: hg(e) }; cg(t, da(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function og(e, t) { const n = e.value, r = { type: Op.COMMENT, data: n, location: hg(e) }; cg(t, da(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken) } function ag(e, t) { if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, ug(t, da(e)), t.parser.tokenizer.write(t.options.tagfilter ? e.value.replace(Xm, "&lt;$1$2") : e.value, !1), t.parser.tokenizer._runParsingLoop(), 72 === t.parser.tokenizer.state || 78 === t.parser.tokenizer.state) { t.parser.tokenizer.preprocessor.lastChunkWritten = !0; const e = t.parser.tokenizer._consume(); t.parser.tokenizer._callState(e) } } function lg(e, t) { const n = e; if (!t.options.passThrough || !t.options.passThrough.includes(n.type)) { let e = ""; throw Jm.has(n.type) && (e = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + e) } !function (e, t) { t.stitches = !0; const n = function (e) { return qc("children" in e ? { ...e, children: [] } : e) }(e); if ("children" in e && "children" in n) { const r = eg({ type: "root", children: e.children }, t.options); n.children = r.children } og({ type: "comment", value: { stitch: n } }, t) }(n, t) } function cg(e, t) { ug(e, t); const n = e.parser.tokenizer.currentCharacterToken; n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = hf.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" } } function ug(e, t) { if (t && void 0 !== t.offset) { const n = { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: -1, endCol: -1, endOffset: -1 }; e.parser.tokenizer.preprocessor.lineStartPos = 1 - t.column, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n } } function hg(e) { const t = da(e) || { line: void 0, column: void 0, offset: void 0 }, n = ha(e) || { line: void 0, column: void 0, offset: void 0 }; return { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: n.line, endCol: n.column, endOffset: n.offset } } const dg = Object.freeze(Object.defineProperty({ __proto__: null, default: function (e) { return function (t, n) { return eg(t, { ...e, file: n }) } } }, Symbol.toStringTag, { value: "Module" })), pg = Object.freeze(Object.defineProperty({ __proto__: null, default: { brand: "", footer: { copyright: " {{year}} Cyber O-hm blog. MIT License." }, nav: { home: "Ch-iah", tutorials: "Ku-hak", admin: "Kon-l", categories: "Li-piat" }, home: { title: "Cyber O-hm blog", featured: "Cheng-son", latest: "Sing-sin Bn-chiu", readMore: "Kho Sing-s", noPosts: "Iu-be  bn-chiu", loading: "Tng teh liah...", failedToLoad: "Bn-chiu liah-b--tioh" }, post: { by: "Chok-chi:", published: "Hoat-piu", share: "Hun-hing", readArticle: "Kho bn-chiu ", featured: " Cheng-son", notFound: "Chhe-b bn-chiu" }, category: { postCount: "{{count}} phi", postCount_plural: "{{count}} phi", includingDrafts: "(lin chh-k)", noPosts: "Chhe-b bn-chiu." }, bilingual: { taigi: "Ti-g", english: "Eng-g", parallel: "Siang-g", taigiContent: "Ti-g Le-ing", englishContent: "Eng-g Le-ing", taigiEnglishBilingual: "Ti-Eng Siang-g", titleTaigi: "Ch-t (Ti-g):", titleEnglish: "Ch-t (Eng-g):", language: "G-gin:", missingContentTitle: "Khim le-ing:", missingContentMessage: "Ti-Eng siang-g bn-chiu i Ti-g kap Eng-g lng  le-ing. Kan-ta chit-khon g-gin  bn-chiu b hin-s g-gin son-tek.", missingEnglishWarning: "Ti-Eng piau-thu , m-koh ---en--- u-piah b Eng-g le-ing" } } }, Symbol.toStringTag, { value: "Module" })), fg = Object.freeze(Object.defineProperty({ __proto__: null, default: { brand: "", footer: { copyright: " {{year}} Cyber  blog. MIT License." }, nav: { home: "", tutorials: "", admin: "", categories: "" }, home: { title: "Cyber  blog", featured: "", latest: "", readMore: "", noPosts: "", loading: "Tng teh ...", failedToLoad: "--tioh" }, post: { by: "", published: "", share: "", readArticle: " ", featured: " ", notFound: "" }, category: { postCount: "{{count}} ", postCount_plural: "{{count}} ", includingDrafts: "()", noPosts: "" }, bilingual: { taigi: "", english: "", parallel: "", taigiContent: "", englishContent: "", taigiEnglishBilingual: "-", titleTaigi: " ():", titleEnglish: " ():", language: ":", missingContentTitle: ":", missingContentMessage: "- i  kap  lng kan-ta    b  ", missingEnglishWarning: "-m-koh ---en---  " } } }, Symbol.toStringTag, { value: "Module" }));</script>
    {% endraw %}
    <style rel="stylesheet" crossorigin>
        @font-face {
            font-family: ChiayiCity;
            src: url(https://raw.githubusercontent.com/CyberOoHim/CyberOoHim.github.io/main/assets/fonts/ChiayiCity.ttf) format("truetype");
            font-weight: 400;
            font-style: normal;
            font-display: block
        }

        *,
        :before,
        :after {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / .5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style:
        }

        ::backdrop {
            --tw-border-spacing-x: 0;
            --tw-border-spacing-y: 0;
            --tw-translate-x: 0;
            --tw-translate-y: 0;
            --tw-rotate: 0;
            --tw-skew-x: 0;
            --tw-skew-y: 0;
            --tw-scale-x: 1;
            --tw-scale-y: 1;
            --tw-pan-x: ;
            --tw-pan-y: ;
            --tw-pinch-zoom: ;
            --tw-scroll-snap-strictness: proximity;
            --tw-gradient-from-position: ;
            --tw-gradient-via-position: ;
            --tw-gradient-to-position: ;
            --tw-ordinal: ;
            --tw-slashed-zero: ;
            --tw-numeric-figure: ;
            --tw-numeric-spacing: ;
            --tw-numeric-fraction: ;
            --tw-ring-inset: ;
            --tw-ring-offset-width: 0px;
            --tw-ring-offset-color: #fff;
            --tw-ring-color: rgb(59 130 246 / .5);
            --tw-ring-offset-shadow: 0 0 #0000;
            --tw-ring-shadow: 0 0 #0000;
            --tw-shadow: 0 0 #0000;
            --tw-shadow-colored: 0 0 #0000;
            --tw-blur: ;
            --tw-brightness: ;
            --tw-contrast: ;
            --tw-grayscale: ;
            --tw-hue-rotate: ;
            --tw-invert: ;
            --tw-saturate: ;
            --tw-sepia: ;
            --tw-drop-shadow: ;
            --tw-backdrop-blur: ;
            --tw-backdrop-brightness: ;
            --tw-backdrop-contrast: ;
            --tw-backdrop-grayscale: ;
            --tw-backdrop-hue-rotate: ;
            --tw-backdrop-invert: ;
            --tw-backdrop-opacity: ;
            --tw-backdrop-saturate: ;
            --tw-backdrop-sepia: ;
            --tw-contain-size: ;
            --tw-contain-layout: ;
            --tw-contain-paint: ;
            --tw-contain-style:
        }

        *,
        :before,
        :after {
            box-sizing: border-box;
            border-width: 0;
            border-style: solid;
            border-color: #e5e7eb
        }

        :before,
        :after {
            --tw-content: ""
        }

        html,
        :host {
            line-height: 1.5;
            -webkit-text-size-adjust: 100%;
            -moz-tab-size: 4;
            -o-tab-size: 4;
            tab-size: 4;
            font-family: Huninn, Times New Roman, serif;
            font-feature-settings: normal;
            font-variation-settings: normal;
            -webkit-tap-highlight-color: transparent
        }

        body {
            margin: 0;
            line-height: inherit
        }

        hr {
            height: 0;
            color: inherit;
            border-top-width: 1px
        }

        abbr:where([title]) {
            -webkit-text-decoration: underline dotted;
            text-decoration: underline dotted
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            font-size: inherit;
            font-weight: inherit
        }

        a {
            color: inherit;
            text-decoration: inherit
        }

        b,
        strong {
            font-weight: bolder
        }

        code,
        kbd,
        samp,
        pre {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
            font-feature-settings: normal;
            font-variation-settings: normal;
            font-size: 1em
        }

        small {
            font-size: 80%
        }

        sub,
        sup {
            font-size: 75%;
            line-height: 0;
            position: relative;
            vertical-align: baseline
        }

        sub {
            bottom: -.25em
        }

        sup {
            top: -.5em
        }

        table {
            text-indent: 0;
            border-color: inherit;
            border-collapse: collapse
        }

        button,
        input,
        optgroup,
        select,
        textarea {
            font-family: inherit;
            font-feature-settings: inherit;
            font-variation-settings: inherit;
            font-size: 100%;
            font-weight: inherit;
            line-height: inherit;
            letter-spacing: inherit;
            color: inherit;
            margin: 0;
            padding: 0
        }

        button,
        select {
            text-transform: none
        }

        button,
        input:where([type=button]),
        input:where([type=reset]),
        input:where([type=submit]) {
            -webkit-appearance: button;
            background-color: transparent;
            background-image: none
        }

        :-moz-focusring {
            outline: auto
        }

        :-moz-ui-invalid {
            box-shadow: none
        }

        progress {
            vertical-align: baseline
        }

        ::-webkit-inner-spin-button,
        ::-webkit-outer-spin-button {
            height: auto
        }

        [type=search] {
            -webkit-appearance: textfield;
            outline-offset: -2px
        }

        ::-webkit-search-decoration {
            -webkit-appearance: none
        }

        ::-webkit-file-upload-button {
            -webkit-appearance: button;
            font: inherit
        }

        summary {
            display: list-item
        }

        blockquote,
        dl,
        dd,
        h1,
        h2,
        h3,
        h4,
        h5,
        h6,
        hr,
        figure,
        p,
        pre {
            margin: 0
        }

        fieldset {
            margin: 0;
            padding: 0
        }

        legend {
            padding: 0
        }

        ol,
        ul,
        menu {
            list-style: none;
            margin: 0;
            padding: 0
        }

        dialog {
            padding: 0
        }

        textarea {
            resize: vertical
        }

        input::-moz-placeholder,
        textarea::-moz-placeholder {
            opacity: 1;
            color: #9ca3af
        }

        input::placeholder,
        textarea::placeholder {
            opacity: 1;
            color: #9ca3af
        }

        button,
        [role=button] {
            cursor: pointer
        }

        :disabled {
            cursor: default
        }

        img,
        svg,
        video,
        canvas,
        audio,
        iframe,
        embed,
        object {
            display: block;
            vertical-align: middle
        }

        img,
        video {
            max-width: 100%;
            height: auto
        }

        [hidden]:where(:not([hidden=until-found])) {
            display: none
        }

        :root {
            --text-base: 1rem;
            --text-scale: 1
        }

        [data-text-size=small] {
            --text-scale: .875
        }

        [data-text-size=medium] {
            --text-scale: 1
        }

        [data-text-size=large] {
            --text-scale: 1.125
        }

        [data-text-size=xlarge] {
            --text-scale: 1.25
        }

        [data-text-size=xxlarge] {
            --text-scale: 1.4
        }

        [data-text-size=xxxlarge] {
            --text-scale: 1.6
        }

        html {
            scroll-behavior: smooth
        }

        body {
            --tw-bg-opacity: 1;
            background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1));
            font-family: Huninn, Times New Roman, serif;
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1));
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .3s
        }

        body *::-moz-selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body *::selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body::-moz-selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body::selection {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        body:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1));
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        body {
            font-size: calc(1rem * var(--text-scale))
        }

        p,
        span,
        a,
        li,
        td,
        th,
        label,
        button {
            font-size: inherit
        }

        h1 {
            font-size: calc(3rem * var(--text-scale))
        }

        h2 {
            font-size: calc(2.25rem * var(--text-scale))
        }

        h3 {
            font-size: calc(1.75rem * var(--text-scale))
        }

        h4 {
            font-size: calc(1.5rem * var(--text-scale))
        }

        h5 {
            font-size: calc(1.25rem * var(--text-scale))
        }

        h6 {
            font-size: calc(1rem * var(--text-scale))
        }

        small,
        .text-xs {
            font-size: calc(.75rem * var(--text-scale))
        }

        .text-sm {
            font-size: calc(.875rem * var(--text-scale))
        }

        ruby {
            ruby-position: over;
            ruby-align: center
        }

        rt {
            font-size: .6em;
            font-weight: 400;
            opacity: .9
        }

        .prose {
            color: var(--tw-prose-body);
            max-width: 65ch
        }

        .prose :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-lead);
            font-size: 1.25em;
            line-height: 1.6;
            margin-top: 1.2em;
            margin-bottom: 1.2em
        }

        .prose :where(a):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-links);
            text-decoration: underline;
            font-weight: 500
        }

        .prose :where(strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-bold);
            font-weight: 600
        }

        .prose :where(a strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(blockquote strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(thead th strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: decimal;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose :where(ol[type=A]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-alpha
        }

        .prose :where(ol[type=a]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-alpha
        }

        .prose :where(ol[type=A s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-alpha
        }

        .prose :where(ol[type=a s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-alpha
        }

        .prose :where(ol[type=I]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-roman
        }

        .prose :where(ol[type=i]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-roman
        }

        .prose :where(ol[type=I s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: upper-roman
        }

        .prose :where(ol[type=i s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: lower-roman
        }

        .prose :where(ol[type="1"]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: decimal
        }

        .prose :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            list-style-type: disc;
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
            font-weight: 400;
            color: var(--tw-prose-counters)
        }

        .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
            color: var(--tw-prose-bullets)
        }

        .prose :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            margin-top: 1.25em
        }

        .prose :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-color: var(--tw-prose-hr);
            border-top-width: 1px;
            margin-top: 3em;
            margin-bottom: 3em
        }

        .prose :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 500;
            font-style: italic;
            color: var(--tw-prose-quotes);
            border-inline-start-width: .25rem;
            border-inline-start-color: var(--tw-prose-quote-borders);
            quotes: "" "" "" "";
            margin-top: 1.6em;
            margin-bottom: 1.6em;
            padding-inline-start: 1em
        }

        .prose :where(blockquote p:first-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: open-quote
        }

        .prose :where(blockquote p:last-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: close-quote
        }

        .prose :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 800;
            font-size: 2.25em;
            margin-top: 0;
            margin-bottom: .8888889em;
            line-height: 1.1111111
        }

        .prose :where(h1 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 900;
            color: inherit
        }

        .prose :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 700;
            font-size: 1.5em;
            margin-top: 2em;
            margin-bottom: 1em;
            line-height: 1.3333333
        }

        .prose :where(h2 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 800;
            color: inherit
        }

        .prose :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            font-size: 1.25em;
            margin-top: 1.6em;
            margin-bottom: .6em;
            line-height: 1.6
        }

        .prose :where(h3 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 700;
            color: inherit
        }

        .prose :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            margin-top: 1.5em;
            margin-bottom: .5em;
            line-height: 1.5
        }

        .prose :where(h4 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 700;
            color: inherit
        }

        .prose :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            display: block;
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-weight: 500;
            font-family: inherit;
            color: var(--tw-prose-kbd);
            box-shadow: 0 0 0 1px var(--tw-prose-kbd-shadows), 0 3px 0 var(--tw-prose-kbd-shadows);
            font-size: .875em;
            border-radius: .3125rem;
            padding-top: .1875em;
            padding-inline-end: .375em;
            padding-bottom: .1875em;
            padding-inline-start: .375em
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-code);
            font-weight: 600;
            font-size: .875em
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: "`"
        }

        .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: "`"
        }

        .prose :where(a code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(h1 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit;
            font-size: .875em
        }

        .prose :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit;
            font-size: .9em
        }

        .prose :where(h4 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(blockquote code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(thead th code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: inherit
        }

        .prose :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-pre-code);
            background-color: var(--tw-prose-pre-bg);
            overflow-x: auto;
            font-weight: 400;
            font-size: .875em;
            line-height: 1.7142857;
            margin-top: 1.7142857em;
            margin-bottom: 1.7142857em;
            border-radius: .375rem;
            padding-top: .8571429em;
            padding-inline-end: 1.1428571em;
            padding-bottom: .8571429em;
            padding-inline-start: 1.1428571em
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            background-color: transparent;
            border-width: 0;
            border-radius: 0;
            padding: 0;
            font-weight: inherit;
            color: inherit;
            font-size: inherit;
            font-family: inherit;
            line-height: inherit
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
            content: none
        }

        .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
            content: none
        }

        .prose :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            width: 100%;
            table-layout: auto;
            margin-top: 2em;
            margin-bottom: 2em;
            font-size: .875em;
            line-height: 1.7142857
        }

        .prose :where(thead):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 1px;
            border-bottom-color: var(--tw-prose-th-borders)
        }

        .prose :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-headings);
            font-weight: 600;
            vertical-align: bottom;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose :where(tbody tr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 1px;
            border-bottom-color: var(--tw-prose-td-borders)
        }

        .prose :where(tbody tr:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-bottom-width: 0
        }

        .prose :where(tbody td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            vertical-align: baseline
        }

        .prose :where(tfoot):not(:where([class~=not-prose], [class~=not-prose] *)) {
            border-top-width: 1px;
            border-top-color: var(--tw-prose-th-borders)
        }

        .prose :where(tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            vertical-align: top
        }

        .prose :where(th, td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            text-align: start
        }

        .prose :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            color: var(--tw-prose-captions);
            font-size: .875em;
            line-height: 1.4285714;
            margin-top: .8571429em
        }

        .prose {
            --tw-prose-body: #374151;
            --tw-prose-headings: #111827;
            --tw-prose-lead: #4b5563;
            --tw-prose-links: #111827;
            --tw-prose-bold: #111827;
            --tw-prose-counters: #6b7280;
            --tw-prose-bullets: #d1d5db;
            --tw-prose-hr: #e5e7eb;
            --tw-prose-quotes: #111827;
            --tw-prose-quote-borders: #e5e7eb;
            --tw-prose-captions: #6b7280;
            --tw-prose-kbd: #111827;
            --tw-prose-kbd-shadows: rgb(17 24 39 / 10%);
            --tw-prose-code: #111827;
            --tw-prose-pre-code: #e5e7eb;
            --tw-prose-pre-bg: #1f2937;
            --tw-prose-th-borders: #d1d5db;
            --tw-prose-td-borders: #e5e7eb;
            --tw-prose-invert-body: #d1d5db;
            --tw-prose-invert-headings: #fff;
            --tw-prose-invert-lead: #9ca3af;
            --tw-prose-invert-links: #fff;
            --tw-prose-invert-bold: #fff;
            --tw-prose-invert-counters: #9ca3af;
            --tw-prose-invert-bullets: #4b5563;
            --tw-prose-invert-hr: #374151;
            --tw-prose-invert-quotes: #f3f4f6;
            --tw-prose-invert-quote-borders: #374151;
            --tw-prose-invert-captions: #9ca3af;
            --tw-prose-invert-kbd: #fff;
            --tw-prose-invert-kbd-shadows: rgb(255 255 255 / 10%);
            --tw-prose-invert-code: #fff;
            --tw-prose-invert-pre-code: #d1d5db;
            --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
            --tw-prose-invert-th-borders: #4b5563;
            --tw-prose-invert-td-borders: #374151;
            font-size: 1rem;
            line-height: 1.75
        }

        .prose :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            margin-bottom: .5em
        }

        .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose :where(.prose>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            padding-inline-start: 1.625em
        }

        .prose :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .5714286em;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose :where(.prose>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose :where(.prose>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .prose-base {
            font-size: 1rem;
            line-height: 1.75
        }

        .prose-base :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose-base :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.25em;
            line-height: 1.6;
            margin-top: 1.2em;
            margin-bottom: 1.2em
        }

        .prose-base :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.6em;
            margin-bottom: 1.6em;
            padding-inline-start: 1em
        }

        .prose-base :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 2.25em;
            margin-top: 0;
            margin-bottom: .8888889em;
            line-height: 1.1111111
        }

        .prose-base :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.5em;
            margin-top: 2em;
            margin-bottom: 1em;
            line-height: 1.3333333
        }

        .prose-base :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.25em;
            margin-top: 1.6em;
            margin-bottom: .6em;
            line-height: 1.6
        }

        .prose-base :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.5em;
            margin-bottom: .5em;
            line-height: 1.5
        }

        .prose-base :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose-base :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose-base :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-base :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose-base :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em;
            border-radius: .3125rem;
            padding-top: .1875em;
            padding-inline-end: .375em;
            padding-bottom: .1875em;
            padding-inline-start: .375em
        }

        .prose-base :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em
        }

        .prose-base :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em
        }

        .prose-base :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .9em
        }

        .prose-base :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em;
            line-height: 1.7142857;
            margin-top: 1.7142857em;
            margin-bottom: 1.7142857em;
            border-radius: .375rem;
            padding-top: .8571429em;
            padding-inline-end: 1.1428571em;
            padding-bottom: .8571429em;
            padding-inline-start: 1.1428571em
        }

        .prose-base :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose-base :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em;
            padding-inline-start: 1.625em
        }

        .prose-base :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            margin-bottom: .5em
        }

        .prose-base :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose-base :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .375em
        }

        .prose-base :where(.prose-base>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose-base :where(.prose-base>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose-base :where(.prose-base>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose-base :where(.prose-base>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose-base :where(.prose-base>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.25em
        }

        .prose-base :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .75em;
            margin-bottom: .75em
        }

        .prose-base :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em;
            margin-bottom: 1.25em
        }

        .prose-base :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.25em
        }

        .prose-base :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .5em;
            padding-inline-start: 1.625em
        }

        .prose-base :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 3em;
            margin-bottom: 3em
        }

        .prose-base :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-base :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-base :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-base :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-base :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em;
            line-height: 1.7142857
        }

        .prose-base :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose-base :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-base :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-base :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .5714286em;
            padding-inline-end: .5714286em;
            padding-bottom: .5714286em;
            padding-inline-start: .5714286em
        }

        .prose-base :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-base :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-base :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 2em;
            margin-bottom: 2em
        }

        .prose-base :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-base :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em;
            line-height: 1.4285714;
            margin-top: .8571429em
        }

        .prose-base :where(.prose-base>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-base :where(.prose-base>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .prose-lg {
            font-size: 1.125rem;
            line-height: 1.7777778
        }

        .prose-lg :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em
        }

        .prose-lg :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.2222222em;
            line-height: 1.4545455;
            margin-top: 1.0909091em;
            margin-bottom: 1.0909091em
        }

        .prose-lg :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.6666667em;
            margin-bottom: 1.6666667em;
            padding-inline-start: 1em
        }

        .prose-lg :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 2.6666667em;
            margin-top: 0;
            margin-bottom: .8333333em;
            line-height: 1
        }

        .prose-lg :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.6666667em;
            margin-top: 1.8666667em;
            margin-bottom: 1.0666667em;
            line-height: 1.3333333
        }

        .prose-lg :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: 1.3333333em;
            margin-top: 1.6666667em;
            margin-bottom: .6666667em;
            line-height: 1.5
        }

        .prose-lg :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: .4444444em;
            line-height: 1.5555556
        }

        .prose-lg :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-lg :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            border-radius: .3125rem;
            padding-top: .2222222em;
            padding-inline-end: .4444444em;
            padding-bottom: .2222222em;
            padding-inline-start: .4444444em
        }

        .prose-lg :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em
        }

        .prose-lg :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8666667em
        }

        .prose-lg :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .875em
        }

        .prose-lg :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.75;
            margin-top: 2em;
            margin-bottom: 2em;
            border-radius: .375rem;
            padding-top: 1em;
            padding-inline-end: 1.5em;
            padding-bottom: 1em;
            padding-inline-start: 1.5em
        }

        .prose-lg :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .6666667em;
            margin-bottom: .6666667em
        }

        .prose-lg :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .4444444em
        }

        .prose-lg :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: .4444444em
        }

        .prose-lg :where(.prose-lg>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .8888889em;
            margin-bottom: .8888889em
        }

        .prose-lg :where(.prose-lg>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(.prose-lg>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .8888889em;
            margin-bottom: .8888889em
        }

        .prose-lg :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em;
            margin-bottom: 1.3333333em
        }

        .prose-lg :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.3333333em
        }

        .prose-lg :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: .6666667em;
            padding-inline-start: 1.5555556em
        }

        .prose-lg :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 3.1111111em;
            margin-bottom: 3.1111111em
        }

        .prose-lg :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.5
        }

        .prose-lg :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: .75em;
            padding-bottom: .75em;
            padding-inline-start: .75em
        }

        .prose-lg :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-lg :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-lg :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-top: .75em;
            padding-inline-end: .75em;
            padding-bottom: .75em;
            padding-inline-start: .75em
        }

        .prose-lg :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-start: 0
        }

        .prose-lg :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            padding-inline-end: 0
        }

        .prose-lg :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 1.7777778em;
            margin-bottom: 1.7777778em
        }

        .prose-lg :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0;
            margin-bottom: 0
        }

        .prose-lg :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
            font-size: .8888889em;
            line-height: 1.5;
            margin-top: 1em
        }

        .prose-lg :where(.prose-lg>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-top: 0
        }

        .prose-lg :where(.prose-lg>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
            margin-bottom: 0
        }

        .pointer-events-none {
            pointer-events: none
        }

        .visible {
            visibility: visible
        }

        .collapse {
            visibility: collapse
        }

        .static {
            position: static
        }

        .fixed {
            position: fixed
        }

        .absolute {
            position: absolute
        }

        .relative {
            position: relative
        }

        .inset-0 {
            top: 0;
            right: 0;
            bottom: 0;
            left: 0
        }

        .-right-1 {
            right: -.25rem
        }

        .-top-1 {
            top: -.25rem
        }

        .bottom-0 {
            bottom: 0
        }

        .left-0 {
            left: 0
        }

        .left-4 {
            left: 1rem
        }

        .right-0 {
            right: 0
        }

        .right-4 {
            right: 1rem
        }

        .top-16 {
            top: 4rem
        }

        .top-4 {
            top: 1rem
        }

        .z-10 {
            z-index: 10
        }

        .z-20 {
            z-index: 20
        }

        .z-40 {
            z-index: 40
        }

        .z-50 {
            z-index: 50
        }

        .z-\[60\] {
            z-index: 60
        }

        .col-span-full {
            grid-column: 1 / -1
        }

        .mx-1 {
            margin-left: .25rem;
            margin-right: .25rem
        }

        .mx-4 {
            margin-left: 1rem;
            margin-right: 1rem
        }

        .mx-auto {
            margin-left: auto;
            margin-right: auto
        }

        .-mt-5 {
            margin-top: -1.25rem
        }

        .mb-1 {
            margin-bottom: .25rem
        }

        .mb-12 {
            margin-bottom: 3rem
        }

        .mb-16 {
            margin-bottom: 4rem
        }

        .mb-2 {
            margin-bottom: .5rem
        }

        .mb-3 {
            margin-bottom: .75rem
        }

        .mb-4 {
            margin-bottom: 1rem
        }

        .mb-6 {
            margin-bottom: 1.5rem
        }

        .mb-8 {
            margin-bottom: 2rem
        }

        .mb-\[1px\] {
            margin-bottom: 1px
        }

        .ml-1 {
            margin-left: .25rem
        }

        .ml-2 {
            margin-left: .5rem
        }

        .ml-auto {
            margin-left: auto
        }

        .mr-2 {
            margin-right: .5rem
        }

        .mr-3 {
            margin-right: .75rem
        }

        .mt-1 {
            margin-top: .25rem
        }

        .mt-16 {
            margin-top: 4rem
        }

        .mt-2 {
            margin-top: .5rem
        }

        .mt-20 {
            margin-top: 5rem
        }

        .mt-3 {
            margin-top: .75rem
        }

        .mt-4 {
            margin-top: 1rem
        }

        .mt-8 {
            margin-top: 2rem
        }

        .mt-auto {
            margin-top: auto
        }

        .line-clamp-2 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 2
        }

        .line-clamp-3 {
            overflow: hidden;
            display: -webkit-box;
            -webkit-box-orient: vertical;
            -webkit-line-clamp: 3
        }

        .block {
            display: block
        }

        .inline-block {
            display: inline-block
        }

        .inline {
            display: inline
        }

        .flex {
            display: flex
        }

        .inline-flex {
            display: inline-flex
        }

        .grid {
            display: grid
        }

        .contents {
            display: contents
        }

        .hidden {
            display: none
        }

        .aspect-\[16\/10\] {
            aspect-ratio: 16/10
        }

        .aspect-\[4\/3\] {
            aspect-ratio: 4/3
        }

        .aspect-video {
            aspect-ratio: 16 / 9
        }

        .h-10 {
            height: 2.5rem
        }

        .h-12 {
            height: 3rem
        }

        .h-16 {
            height: 4rem
        }

        .h-3 {
            height: .75rem
        }

        .h-4 {
            height: 1rem
        }

        .h-5 {
            height: 1.25rem
        }

        .h-6 {
            height: 1.5rem
        }

        .h-8 {
            height: 2rem
        }

        .h-\[50vh\] {
            height: 50vh
        }

        .h-\[calc\(100vh-350px\)\] {
            height: calc(100vh - 350px)
        }

        .h-\[calc\(100vh-64px\)\] {
            height: calc(100vh - 64px)
        }

        .h-full {
            height: 100%
        }

        .max-h-\[80vh\] {
            max-height: 80vh
        }

        .max-h-\[90vh\] {
            max-height: 90vh
        }

        .min-h-32 {
            min-height: 8rem
        }

        .min-h-\[400px\] {
            min-height: 400px
        }

        .min-h-\[60px\] {
            min-height: 60px
        }

        .min-h-screen {
            min-height: 100vh
        }

        .w-1\/2 {
            width: 50%
        }

        .w-1\/4 {
            width: 25%
        }

        .w-10 {
            width: 2.5rem
        }

        .w-12 {
            width: 3rem
        }

        .w-16 {
            width: 4rem
        }

        .w-3 {
            width: .75rem
        }

        .w-3\/4 {
            width: 75%
        }

        .w-4 {
            width: 1rem
        }

        .w-48 {
            width: 12rem
        }

        .w-5 {
            width: 1.25rem
        }

        .w-6 {
            width: 1.5rem
        }

        .w-64 {
            width: 16rem
        }

        .w-8 {
            width: 2rem
        }

        .w-fit {
            width: -moz-fit-content;
            width: fit-content
        }

        .w-full {
            width: 100%
        }

        .w-px {
            width: 1px
        }

        .min-w-0 {
            min-width: 0px
        }

        .min-w-\[150px\] {
            min-width: 150px
        }

        .min-w-\[60px\] {
            min-width: 60px
        }

        .max-w-2xl {
            max-width: 42rem
        }

        .max-w-3xl {
            max-width: 48rem
        }

        .max-w-4xl {
            max-width: 56rem
        }

        .max-w-6xl {
            max-width: 72rem
        }

        .max-w-lg {
            max-width: 32rem
        }

        .max-w-sm {
            max-width: 24rem
        }

        .max-w-xs {
            max-width: 20rem
        }

        .flex-1 {
            flex: 1 1 0%
        }

        .flex-shrink-0 {
            flex-shrink: 0
        }

        .-translate-x-2 {
            --tw-translate-x: -.5rem;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .rotate-180 {
            --tw-rotate: 180deg;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        @keyframes pulse {
            50% {
                opacity: .5
            }
        }

        .animate-pulse {
            animation: pulse 2s cubic-bezier(.4, 0, .6, 1) infinite
        }

        @keyframes spin {
            to {
                transform: rotate(360deg)
            }
        }

        .animate-spin {
            animation: spin 1s linear infinite
        }

        .cursor-not-allowed {
            cursor: not-allowed
        }

        .cursor-pointer {
            cursor: pointer
        }

        .resize-none {
            resize: none
        }

        .list-inside {
            list-style-position: inside
        }

        .list-disc {
            list-style-type: disc
        }

        .grid-cols-1 {
            grid-template-columns: repeat(1, minmax(0, 1fr))
        }

        .flex-col {
            flex-direction: column
        }

        .flex-wrap {
            flex-wrap: wrap
        }

        .items-end {
            align-items: flex-end
        }

        .items-center {
            align-items: center
        }

        .justify-end {
            justify-content: flex-end
        }

        .justify-center {
            justify-content: center
        }

        .justify-between {
            justify-content: space-between
        }

        .gap-1 {
            gap: .25rem
        }

        .gap-2 {
            gap: .5rem
        }

        .gap-3 {
            gap: .75rem
        }

        .gap-4 {
            gap: 1rem
        }

        .gap-8 {
            gap: 2rem
        }

        .space-x-1>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(.25rem * var(--tw-space-x-reverse));
            margin-left: calc(.25rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-2>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(.5rem * var(--tw-space-x-reverse));
            margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-4>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(1rem * var(--tw-space-x-reverse));
            margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-x-6>:not([hidden])~:not([hidden]) {
            --tw-space-x-reverse: 0;
            margin-right: calc(1.5rem * var(--tw-space-x-reverse));
            margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))
        }

        .space-y-1>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.25rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.25rem * var(--tw-space-y-reverse))
        }

        .space-y-2>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.5rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.5rem * var(--tw-space-y-reverse))
        }

        .space-y-3>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(.75rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(.75rem * var(--tw-space-y-reverse))
        }

        .space-y-4>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(1rem * var(--tw-space-y-reverse))
        }

        .space-y-6>:not([hidden])~:not([hidden]) {
            --tw-space-y-reverse: 0;
            margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
            margin-bottom: calc(1.5rem * var(--tw-space-y-reverse))
        }

        .overflow-auto {
            overflow: auto
        }

        .overflow-hidden {
            overflow: hidden
        }

        .overflow-y-auto {
            overflow-y: auto
        }

        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap
        }

        .whitespace-pre-wrap {
            white-space: pre-wrap
        }

        .break-words {
            overflow-wrap: break-word
        }

        .rounded {
            border-radius: 0
        }

        .rounded-full {
            border-radius: 9999px
        }

        .rounded-lg {
            border-radius: 8px
        }

        .rounded-md {
            border-radius: 4px
        }

        .rounded-sm {
            border-radius: 2px
        }

        .rounded-l {
            border-top-left-radius: 0;
            border-bottom-left-radius: 0
        }

        .rounded-r {
            border-top-right-radius: 0;
            border-bottom-right-radius: 0
        }

        .rounded-t {
            border-top-left-radius: 0;
            border-top-right-radius: 0
        }

        .border {
            border-width: 1px
        }

        .border-2 {
            border-width: 2px
        }

        .border-4 {
            border-width: 4px
        }

        .border-y {
            border-top-width: 1px;
            border-bottom-width: 1px
        }

        .border-b {
            border-bottom-width: 1px
        }

        .border-b-2 {
            border-bottom-width: 2px
        }

        .border-r {
            border-right-width: 1px
        }

        .border-t {
            border-top-width: 1px
        }

        .border-dashed {
            border-style: dashed
        }

        .border-none {
            border-style: none
        }

        .border-accent {
            --tw-border-opacity: 1;
            border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
        }

        .border-blue-400 {
            --tw-border-opacity: 1;
            border-color: rgb(96 165 250 / var(--tw-border-opacity, 1))
        }

        .border-blue-500 {
            --tw-border-opacity: 1;
            border-color: rgb(59 130 246 / var(--tw-border-opacity, 1))
        }

        .border-gray-100 {
            --tw-border-opacity: 1;
            border-color: rgb(243 244 246 / var(--tw-border-opacity, 1))
        }

        .border-gray-200 {
            --tw-border-opacity: 1;
            border-color: rgb(229 231 235 / var(--tw-border-opacity, 1))
        }

        .border-gray-300 {
            --tw-border-opacity: 1;
            border-color: rgb(209 213 219 / var(--tw-border-opacity, 1))
        }

        .border-gray-900 {
            --tw-border-opacity: 1;
            border-color: rgb(17 24 39 / var(--tw-border-opacity, 1))
        }

        .border-orange-300 {
            --tw-border-opacity: 1;
            border-color: rgb(253 186 116 / var(--tw-border-opacity, 1))
        }

        .border-primary {
            --tw-border-opacity: 1;
            border-color: rgb(17 24 39 / var(--tw-border-opacity, 1))
        }

        .border-red-300 {
            --tw-border-opacity: 1;
            border-color: rgb(252 165 165 / var(--tw-border-opacity, 1))
        }

        .border-yellow-300 {
            --tw-border-opacity: 1;
            border-color: rgb(253 224 71 / var(--tw-border-opacity, 1))
        }

        .border-t-transparent {
            border-top-color: transparent
        }

        .bg-accent {
            --tw-bg-opacity: 1;
            background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1))
        }

        .bg-accent\/30 {
            background-color: #0f766e4d
        }

        .bg-accent\/80 {
            background-color: #0f766ecc
        }

        .bg-background-light {
            --tw-bg-opacity: 1;
            background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1))
        }

        .bg-black {
            --tw-bg-opacity: 1;
            background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1))
        }

        .bg-black\/50 {
            background-color: #00000080
        }

        .bg-black\/70 {
            background-color: #000000b3
        }

        .bg-blue-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
        }

        .bg-blue-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
        }

        .bg-blue-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-200 {
            --tw-bg-opacity: 1;
            background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-300 {
            --tw-bg-opacity: 1;
            background-color: rgb(209 213 219 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
        }

        .bg-gray-900 {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .bg-green-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1))
        }

        .bg-green-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-100 {
            --tw-bg-opacity: 1;
            background-color: rgb(255 237 213 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-400 {
            --tw-bg-opacity: 1;
            background-color: rgb(251 146 60 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(255 247 237 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(249 115 22 / var(--tw-bg-opacity, 1))
        }

        .bg-orange-500\/80 {
            background-color: #f97316cc
        }

        .bg-primary {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .bg-red-500 {
            --tw-bg-opacity: 1;
            background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1))
        }

        .bg-red-600 {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
        }

        .bg-surface-light {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .bg-transparent {
            background-color: transparent
        }

        .bg-white {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-300 {
            --tw-bg-opacity: 1;
            background-color: rgb(253 224 71 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-50 {
            --tw-bg-opacity: 1;
            background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1))
        }

        .bg-yellow-600\/90 {
            background-color: #ca8a04e6
        }

        .bg-\[url\(\'data\:image\/svg\+xml\;charset\=US-ASCII\,\%3Csvg\%20xmlns\%3D\%22http\%3A\%2F\%2Fwww\.w3\.org\%2F2000\%2Fsvg\%22\%20width\%3D\%22292\.4\%22\%20height\%3D\%22292\.4\%22\%3E\%3Cpath\%20fill\%3D\%22\%239CA3AF\%22\%20d\%3D\%22M287\%2069\.4a17\.6\%2017\.6\%200\%200\%200-13-5\.4H18\.4c-5\%200-9\.3\%201\.8-12\.9\%205\.4A17\.6\%2017\.6\%200\%200\%200\%200\%2082\.2c0\%205\%201\.8\%209\.3\%205\.4\%2012\.9l128\%20127\.9c3\.6\%203\.6\%207\.8\%205\.4\%2012\.8\%205\.4s9\.2-1\.8\%2012\.8-5\.4L287\%2095c3\.5-3\.5\%205\.4-7\.8\%205\.4-12\.8\%200-5-1\.9-9\.2-5\.5-12\.8z\%22\%2F\%3E\%3C\%2Fsvg\%3E\'\)\] {
            background-image: url(data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E)
        }

        .bg-gradient-to-t {
            background-image: linear-gradient(to top, var(--tw-gradient-stops))
        }

        .from-background-light {
            --tw-gradient-from: #FAFAFA var(--tw-gradient-from-position);
            --tw-gradient-to: rgb(250 250 250 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
        }

        .via-transparent {
            --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), transparent var(--tw-gradient-via-position), var(--tw-gradient-to)
        }

        .to-transparent {
            --tw-gradient-to: transparent var(--tw-gradient-to-position)
        }

        .bg-\[length\:0\.7em\] {
            background-size: .7em
        }

        .bg-\[right_0_center\] {
            background-position: right 0 center
        }

        .bg-no-repeat {
            background-repeat: no-repeat
        }

        .object-cover {
            -o-object-fit: cover;
            object-fit: cover
        }

        .p-0 {
            padding: 0
        }

        .p-0\.5 {
            padding: .125rem
        }

        .p-1 {
            padding: .25rem
        }

        .p-2 {
            padding: .5rem
        }

        .p-3 {
            padding: .75rem
        }

        .p-4 {
            padding: 1rem
        }

        .p-6 {
            padding: 1.5rem
        }

        .p-8 {
            padding: 2rem
        }

        .px-1 {
            padding-left: .25rem;
            padding-right: .25rem
        }

        .px-2 {
            padding-left: .5rem;
            padding-right: .5rem
        }

        .px-3 {
            padding-left: .75rem;
            padding-right: .75rem
        }

        .px-4 {
            padding-left: 1rem;
            padding-right: 1rem
        }

        .px-6 {
            padding-left: 1.5rem;
            padding-right: 1.5rem
        }

        .py-1 {
            padding-top: .25rem;
            padding-bottom: .25rem
        }

        .py-1\.5 {
            padding-top: .375rem;
            padding-bottom: .375rem
        }

        .py-10 {
            padding-top: 2.5rem;
            padding-bottom: 2.5rem
        }

        .py-12 {
            padding-top: 3rem;
            padding-bottom: 3rem
        }

        .py-2 {
            padding-top: .5rem;
            padding-bottom: .5rem
        }

        .py-3 {
            padding-top: .75rem;
            padding-bottom: .75rem
        }

        .py-4 {
            padding-top: 1rem;
            padding-bottom: 1rem
        }

        .pb-1 {
            padding-bottom: .25rem
        }

        .pb-16 {
            padding-bottom: 4rem
        }

        .pr-6 {
            padding-right: 1.5rem
        }

        .pt-0 {
            padding-top: 0
        }

        .pt-10 {
            padding-top: 2.5rem
        }

        .pt-3 {
            padding-top: .75rem
        }

        .pt-8 {
            padding-top: 2rem
        }

        .text-left {
            text-align: left
        }

        .text-center {
            text-align: center
        }

        .font-display {
            font-family: ChiayiCity, Times New Roman, serif
        }

        .font-mono {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace
        }

        .text-2xl {
            font-size: 1.5rem;
            line-height: 2rem
        }

        .text-3xl {
            font-size: 1.875rem;
            line-height: 2.25rem
        }

        .text-4xl {
            font-size: 2.25rem;
            line-height: 2.5rem
        }

        .text-\[10px\] {
            font-size: 10px
        }

        .text-base {
            font-size: 1rem;
            line-height: 1.5rem
        }

        .text-lg {
            font-size: 1.125rem;
            line-height: 1.75rem
        }

        .text-sm {
            font-size: .875rem;
            line-height: 1.25rem
        }

        .text-xl {
            font-size: 1.25rem;
            line-height: 1.75rem
        }

        .text-xs {
            font-size: .75rem;
            line-height: 1rem
        }

        .font-bold {
            font-weight: 700
        }

        .font-medium {
            font-weight: 500
        }

        .uppercase {
            text-transform: uppercase
        }

        .italic {
            font-style: italic
        }

        .leading-tight {
            line-height: 1.25
        }

        .tracking-\[0\.2em\] {
            letter-spacing: .2em
        }

        .tracking-wider {
            letter-spacing: .05em
        }

        .text-accent {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .text-blue-500 {
            --tw-text-opacity: 1;
            color: rgb(59 130 246 / var(--tw-text-opacity, 1))
        }

        .text-blue-600 {
            --tw-text-opacity: 1;
            color: rgb(37 99 235 / var(--tw-text-opacity, 1))
        }

        .text-blue-700 {
            --tw-text-opacity: 1;
            color: rgb(29 78 216 / var(--tw-text-opacity, 1))
        }

        .text-gray-300 {
            --tw-text-opacity: 1;
            color: rgb(209 213 219 / var(--tw-text-opacity, 1))
        }

        .text-gray-500 {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1))
        }

        .text-gray-600 {
            --tw-text-opacity: 1;
            color: rgb(75 85 99 / var(--tw-text-opacity, 1))
        }

        .text-green-600 {
            --tw-text-opacity: 1;
            color: rgb(22 163 74 / var(--tw-text-opacity, 1))
        }

        .text-green-700 {
            --tw-text-opacity: 1;
            color: rgb(21 128 61 / var(--tw-text-opacity, 1))
        }

        .text-muted-light {
            --tw-text-opacity: 1;
            color: rgb(107 114 128 / var(--tw-text-opacity, 1))
        }

        .text-orange-500 {
            --tw-text-opacity: 1;
            color: rgb(249 115 22 / var(--tw-text-opacity, 1))
        }

        .text-orange-700 {
            --tw-text-opacity: 1;
            color: rgb(194 65 12 / var(--tw-text-opacity, 1))
        }

        .text-red-500 {
            --tw-text-opacity: 1;
            color: rgb(239 68 68 / var(--tw-text-opacity, 1))
        }

        .text-red-600 {
            --tw-text-opacity: 1;
            color: rgb(220 38 38 / var(--tw-text-opacity, 1))
        }

        .text-text-light {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .text-transparent {
            color: transparent
        }

        .text-white {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        .text-white\/70 {
            color: #ffffffb3
        }

        .text-white\/80 {
            color: #fffc
        }

        .text-white\/90 {
            color: #ffffffe6
        }

        .text-yellow-600 {
            --tw-text-opacity: 1;
            color: rgb(202 138 4 / var(--tw-text-opacity, 1))
        }

        .text-yellow-700 {
            --tw-text-opacity: 1;
            color: rgb(161 98 7 / var(--tw-text-opacity, 1))
        }

        .opacity-0 {
            opacity: 0
        }

        .opacity-30 {
            opacity: .3
        }

        .opacity-50 {
            opacity: .5
        }

        .opacity-70 {
            opacity: .7
        }

        .opacity-80 {
            opacity: .8
        }

        .opacity-90 {
            opacity: .9
        }

        .shadow {
            --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / .1), 0 1px 2px -1px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-lg {
            --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-sm {
            --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);
            --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .shadow-xl {
            --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .outline-none {
            outline: 2px solid transparent;
            outline-offset: 2px
        }

        .ring-1 {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .ring-white\/20 {
            --tw-ring-color: rgb(255 255 255 / .2)
        }

        .blur {
            --tw-blur: blur(8px);
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .filter {
            filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
        }

        .backdrop-blur-sm {
            --tw-backdrop-blur: blur(4px);
            -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
            backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
        }

        .transition {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke, opacity, box-shadow, transform, filter, backdrop-filter;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-all {
            transition-property: all;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-colors {
            transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-opacity {
            transition-property: opacity;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .transition-transform {
            transition-property: transform;
            transition-timing-function: cubic-bezier(.4, 0, .2, 1);
            transition-duration: .15s
        }

        .delay-100 {
            transition-delay: .1s
        }

        .delay-150 {
            transition-delay: .15s
        }

        .delay-200 {
            transition-delay: .2s
        }

        .duration-200 {
            transition-duration: .2s
        }

        .duration-300 {
            transition-duration: .3s
        }

        .duration-700 {
            transition-duration: .7s
        }

        .ease-out {
            transition-timing-function: cubic-bezier(0, 0, .2, 1)
        }

        .\[filter\:drop-shadow\(-2px_0_0_\#32cd32\)_drop-shadow\(2px_0_0_\#ff6347\)\] {
            filter: drop-shadow(-2px 0 0 #32cd32) drop-shadow(2px 0 0 #ff6347)
        }

        ::-webkit-scrollbar {
            width: 8px
        }

        ::-webkit-scrollbar-track {
            background: transparent
        }

        ::-webkit-scrollbar-thumb {
            background-color: #d1d5db;
            border-radius: 20px
        }

        .dark ::-webkit-scrollbar-thumb {
            background-color: #374151
        }

        .prose {
            max-width: 70ch
        }

        .prose p {
            margin-bottom: 2em;
            line-height: var(--prose-body-line-height, 2);
            font-weight: 400;
            font-size: calc(1.125rem * var(--text-scale));
            color: inherit
        }

        .prose h2 {
            font-family: ChiayiCity, Times New Roman, serif;
            font-size: calc(2.25rem * var(--text-scale));
            margin-top: 3em;
            margin-bottom: 1em;
            line-height: 1.25;
            font-weight: 400;
            letter-spacing: -.02em
        }

        .prose h3 {
            font-family: ChiayiCity, Times New Roman, serif;
            font-size: calc(1.75rem * var(--text-scale));
            margin-top: 2.5em;
            margin-bottom: .8em;
            line-height: 1.3;
            font-weight: 400;
            letter-spacing: -.01em
        }

        .prose blockquote {
            border-left: 4px solid var(--tw-prose-quote-borders, #0F766E);
            padding-left: 1.5rem;
            font-style: italic;
            margin: 2.5rem 0;
            color: #4b5563;
            font-size: calc(1.25rem * var(--text-scale));
            line-height: var(--prose-blockquote-line-height, 1.8);
            font-family: ChiayiCity, Times New Roman, serif
        }

        .dark .prose blockquote {
            border-color: #0f766e;
            color: #d1d5db
        }

        .prose ul,
        .prose ol {
            padding-left: 1.75rem;
            margin-bottom: 2em
        }

        .prose ul {
            list-style-type: disc
        }

        .prose ol {
            list-style-type: decimal
        }

        .prose li {
            margin-bottom: .75em;
            line-height: var(--prose-list-line-height, 1.8);
            font-size: calc(1.0625rem * var(--text-scale))
        }

        .prose code {
            font-size: .85em;
            padding: .25em .4em;
            background-color: #f1f5f9;
            border-radius: 4px;
            font-family: Menlo, Monaco, Courier New, monospace;
            color: #0f766e;
            font-weight: 500
        }

        .dark .prose code {
            background-color: #2d333b;
            color: #5eead4
        }

        .prose pre {
            margin: 2em 0;
            padding: 1.25rem;
            overflow-x: auto;
            border-radius: 4px
        }

        .prose a {
            color: inherit;
            text-decoration: underline;
            text-decoration-thickness: 1px;
            text-underline-offset: 3px;
            transition: opacity .2s
        }

        .prose a:hover {
            opacity: .7
        }

        .no-scrollbar::-webkit-scrollbar {
            display: none
        }

        .no-scrollbar {
            -ms-overflow-style: none;
            scrollbar-width: none
        }

        .dark\:prose-invert:is(.dark *) {
            --tw-prose-body: var(--tw-prose-invert-body);
            --tw-prose-headings: var(--tw-prose-invert-headings);
            --tw-prose-lead: var(--tw-prose-invert-lead);
            --tw-prose-links: var(--tw-prose-invert-links);
            --tw-prose-bold: var(--tw-prose-invert-bold);
            --tw-prose-counters: var(--tw-prose-invert-counters);
            --tw-prose-bullets: var(--tw-prose-invert-bullets);
            --tw-prose-hr: var(--tw-prose-invert-hr);
            --tw-prose-quotes: var(--tw-prose-invert-quotes);
            --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
            --tw-prose-captions: var(--tw-prose-invert-captions);
            --tw-prose-kbd: var(--tw-prose-invert-kbd);
            --tw-prose-kbd-shadows: var(--tw-prose-invert-kbd-shadows);
            --tw-prose-code: var(--tw-prose-invert-code);
            --tw-prose-pre-code: var(--tw-prose-invert-pre-code);
            --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
            --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
            --tw-prose-td-borders: var(--tw-prose-invert-td-borders)
        }

        @media (min-width: 768px) {
            .md\:prose-xl {
                font-size: 1.25rem;
                line-height: 1.8
            }

            .md\:prose-xl :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.2em;
                line-height: 1.5;
                margin-top: 1em;
                margin-bottom: 1em
            }

            .md\:prose-xl :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.6em;
                margin-bottom: 1.6em;
                padding-inline-start: 1.0666667em
            }

            .md\:prose-xl :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 2.8em;
                margin-top: 0;
                margin-bottom: .8571429em;
                line-height: 1
            }

            .md\:prose-xl :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.8em;
                margin-top: 1.5555556em;
                margin-bottom: .8888889em;
                line-height: 1.1111111
            }

            .md\:prose-xl :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: 1.5em;
                margin-top: 1.6em;
                margin-bottom: .6666667em;
                line-height: 1.3333333
            }

            .md\:prose-xl :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.8em;
                margin-bottom: .6em;
                line-height: 1.6
            }

            .md\:prose-xl :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0;
                margin-bottom: 0
            }

            .md\:prose-xl :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                border-radius: .3125rem;
                padding-top: .25em;
                padding-inline-end: .4em;
                padding-bottom: .25em;
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em
            }

            .md\:prose-xl :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .8611111em
            }

            .md\:prose-xl :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em
            }

            .md\:prose-xl :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.7777778;
                margin-top: 2em;
                margin-bottom: 2em;
                border-radius: .5rem;
                padding-top: 1.1111111em;
                padding-inline-end: 1.3333333em;
                padding-bottom: 1.1111111em;
                padding-inline-start: 1.3333333em
            }

            .md\:prose-xl :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .6em;
                margin-bottom: .6em
            }

            .md\:prose-xl :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: .4em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .8em;
                margin-bottom: .8em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(.md\:prose-xl>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .8em;
                margin-bottom: .8em
            }

            .md\:prose-xl :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em;
                margin-bottom: 1.2em
            }

            .md\:prose-xl :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 1.2em
            }

            .md\:prose-xl :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: .6em;
                padding-inline-start: 1.6em
            }

            .md\:prose-xl :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2.8em;
                margin-bottom: 2.8em
            }

            .md\:prose-xl :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.5555556
            }

            .md\:prose-xl :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: .6666667em;
                padding-bottom: .8888889em;
                padding-inline-start: .6666667em
            }

            .md\:prose-xl :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: 0
            }

            .md\:prose-xl :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: 0
            }

            .md\:prose-xl :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-top: .8888889em;
                padding-inline-end: .6666667em;
                padding-bottom: .8888889em;
                padding-inline-start: .6666667em
            }

            .md\:prose-xl :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-start: 0
            }

            .md\:prose-xl :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                padding-inline-end: 0
            }

            .md\:prose-xl :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 2em;
                margin-bottom: 2em
            }

            .md\:prose-xl :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0;
                margin-bottom: 0
            }

            .md\:prose-xl :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
                font-size: .9em;
                line-height: 1.5555556;
                margin-top: 1em
            }

            .md\:prose-xl :where(.md\:prose-xl>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-top: 0
            }

            .md\:prose-xl :where(.md\:prose-xl>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
                margin-bottom: 0
            }
        }

        .hover\:border-accent:hover {
            --tw-border-opacity: 1;
            border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
        }

        .hover\:bg-blue-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-blue-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-blue-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(37 99 235 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-200:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-gray-800:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-green-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(22 163 74 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-orange-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(234 88 12 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-100:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(254 226 226 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-50:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-600:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-red-700:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(185 28 28 / var(--tw-bg-opacity, 1))
        }

        .hover\:bg-white:hover {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .hover\:text-accent:hover {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .hover\:text-gray-800:hover {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .hover\:text-gray-900:hover {
            --tw-text-opacity: 1;
            color: rgb(17 24 39 / var(--tw-text-opacity, 1))
        }

        .hover\:text-red-700:hover {
            --tw-text-opacity: 1;
            color: rgb(185 28 28 / var(--tw-text-opacity, 1))
        }

        .hover\:text-text-light:hover {
            --tw-text-opacity: 1;
            color: rgb(31 41 55 / var(--tw-text-opacity, 1))
        }

        .hover\:opacity-70:hover {
            opacity: .7
        }

        .hover\:opacity-80:hover {
            opacity: .8
        }

        .focus\:border-gray-400:focus {
            --tw-border-opacity: 1;
            border-color: rgb(156 163 175 / var(--tw-border-opacity, 1))
        }

        .focus\:outline-none:focus {
            outline: 2px solid transparent;
            outline-offset: 2px
        }

        .focus\:ring-0:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-2:focus {
            --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
            --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
            box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
        }

        .focus\:ring-black:focus {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity, 1))
        }

        .disabled\:cursor-not-allowed:disabled {
            cursor: not-allowed
        }

        .disabled\:opacity-30:disabled {
            opacity: .3
        }

        .disabled\:opacity-50:disabled {
            opacity: .5
        }

        .group:hover .group-hover\:translate-x-0 {
            --tw-translate-x: 0px;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:translate-y-\[-2px\] {
            --tw-translate-y: -2px;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:scale-105 {
            --tw-scale-x: 1.05;
            --tw-scale-y: 1.05;
            transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
        }

        .group:hover .group-hover\:text-accent {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .group:hover .group-hover\:opacity-100 {
            opacity: 1
        }

        .group:hover .group-hover\:shadow-md {
            --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);
            --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
            box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
        }

        .dark\:border-gray-600:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(75 85 99 / var(--tw-border-opacity, 1))
        }

        .dark\:border-gray-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(55 65 81 / var(--tw-border-opacity, 1))
        }

        .dark\:border-gray-800:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(31 41 55 / var(--tw-border-opacity, 1))
        }

        .dark\:border-orange-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(194 65 12 / var(--tw-border-opacity, 1))
        }

        .dark\:border-white:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(255 255 255 / var(--tw-border-opacity, 1))
        }

        .dark\:border-yellow-700:is(.dark *) {
            --tw-border-opacity: 1;
            border-color: rgb(161 98 7 / var(--tw-border-opacity, 1))
        }

        .dark\:bg-background-dark:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-blue-900\/20:is(.dark *) {
            background-color: #1e3a8a33
        }

        .dark\:bg-blue-900\/40:is(.dark *) {
            background-color: #1e3a8a66
        }

        .dark\:bg-gray-600:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(75 85 99 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-700:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-800:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-gray-800\/30:is(.dark *) {
            background-color: #1f29374d
        }

        .dark\:bg-gray-800\/50:is(.dark *) {
            background-color: #1f293780
        }

        .dark\:bg-gray-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-green-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(20 83 45 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-orange-900:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(124 45 18 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-orange-900\/20:is(.dark *) {
            background-color: #7c2d1233
        }

        .dark\:bg-surface-dark:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(24 27 33 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-white:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
        }

        .dark\:bg-yellow-900\/20:is(.dark *) {
            background-color: #713f1233
        }

        .dark\:from-background-dark:is(.dark *) {
            --tw-gradient-from: #0f1115 var(--tw-gradient-from-position);
            --tw-gradient-to: rgb(15 17 21 / 0) var(--tw-gradient-to-position);
            --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
        }

        .dark\:text-black:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(0 0 0 / var(--tw-text-opacity, 1))
        }

        .dark\:text-blue-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(147 197 253 / var(--tw-text-opacity, 1))
        }

        .dark\:text-blue-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(96 165 250 / var(--tw-text-opacity, 1))
        }

        .dark\:text-gray-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1))
        }

        .dark\:text-green-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(134 239 172 / var(--tw-text-opacity, 1))
        }

        .dark\:text-muted-dark:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(156 163 175 / var(--tw-text-opacity, 1))
        }

        .dark\:text-orange-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(253 186 116 / var(--tw-text-opacity, 1))
        }

        .dark\:text-text-dark:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-300:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(253 224 71 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-400:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(250 204 21 / var(--tw-text-opacity, 1))
        }

        .dark\:text-yellow-500:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(234 179 8 / var(--tw-text-opacity, 1))
        }

        .dark\:\[filter\:drop-shadow\(-2px_0_0_rgba\(50\,205\,50\,0\.5\)\)_drop-shadow\(2px_0_0_rgba\(255\,99\,71\,0\.5\)\)_drop-shadow\(0_0_5px_rgba\(50\,205\,50\,0\.15\)\)\]:is(.dark *) {
            filter: drop-shadow(-2px 0 0 rgba(50, 205, 50, .5)) drop-shadow(2px 0 0 rgba(255, 99, 71, .5)) drop-shadow(0 0 5px rgba(50, 205, 50, .15))
        }

        .dark\:hover\:bg-blue-900\/20:hover:is(.dark *) {
            background-color: #1e3a8a33
        }

        .dark\:hover\:bg-blue-900\/30:hover:is(.dark *) {
            background-color: #1e3a8a4d
        }

        .dark\:hover\:bg-gray-700:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-gray-800:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-red-900:hover:is(.dark *) {
            --tw-bg-opacity: 1;
            background-color: rgb(127 29 29 / var(--tw-bg-opacity, 1))
        }

        .dark\:hover\:bg-red-900\/30:hover:is(.dark *) {
            background-color: #7f1d1d4d
        }

        .dark\:hover\:text-accent:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(15 118 110 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-gray-200:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(229 231 235 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-text-dark:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(243 244 246 / var(--tw-text-opacity, 1))
        }

        .dark\:hover\:text-white:hover:is(.dark *) {
            --tw-text-opacity: 1;
            color: rgb(255 255 255 / var(--tw-text-opacity, 1))
        }

        .dark\:focus\:ring-white:focus:is(.dark *) {
            --tw-ring-opacity: 1;
            --tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity, 1))
        }

        @media (min-width: 640px) {
            .sm\:flex {
                display: flex
            }

            .sm\:px-6 {
                padding-left: 1.5rem;
                padding-right: 1.5rem
            }
        }

        @media (min-width: 768px) {
            .md\:static {
                position: static
            }

            .md\:z-auto {
                z-index: auto
            }

            .md\:mb-0 {
                margin-bottom: 0
            }

            .md\:inline {
                display: inline
            }

            .md\:flex {
                display: flex
            }

            .md\:grid {
                display: grid
            }

            .md\:hidden {
                display: none
            }

            .md\:aspect-auto {
                aspect-ratio: auto
            }

            .md\:h-\[60vh\] {
                height: 60vh
            }

            .md\:h-full {
                height: 100%
            }

            .md\:max-h-\[calc\(100vh-64px\)\] {
                max-height: calc(100vh - 64px)
            }

            .md\:grid-cols-2 {
                grid-template-columns: repeat(2, minmax(0, 1fr))
            }

            .md\:gap-8 {
                gap: 2rem
            }

            .md\:space-x-2>:not([hidden])~:not([hidden]) {
                --tw-space-x-reverse: 0;
                margin-right: calc(.5rem * var(--tw-space-x-reverse));
                margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
            }

            .md\:p-12 {
                padding: 3rem
            }

            .md\:px-4 {
                padding-left: 1rem;
                padding-right: 1rem
            }

            .md\:py-4 {
                padding-top: 1rem;
                padding-bottom: 1rem
            }

            .md\:text-2xl {
                font-size: 1.5rem;
                line-height: 2rem
            }

            .md\:text-4xl {
                font-size: 2.25rem;
                line-height: 2.5rem
            }

            .md\:text-base {
                font-size: 1rem;
                line-height: 1.5rem
            }
        }

        @media (min-width: 1024px) {
            .lg\:grid-cols-3 {
                grid-template-columns: repeat(3, minmax(0, 1fr))
            }

            .lg\:px-8 {
                padding-left: 2rem;
                padding-right: 2rem
            }
        }
    </style>
</head>

<body>
    <!-- Loading skeleton - replaced by React when app loads -->
    <div id="root">
        <div class="skeleton-loader">
            <nav class="skeleton-nav">
                <div class="skeleton-logo"></div>
            </nav>
            <main class="skeleton-content">
                <div class="skeleton-title"></div>
                <div class="skeleton-grid">
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                    <div class="skeleton-card">
                        <div class="skeleton-image"></div>
                        <div class="skeleton-text">
                            <div class="skeleton-line"></div>
                            <div class="skeleton-line"></div>
                        </div>
                    </div>
                </div>
            </main>
        </div>
    </div>

</body>

</html>