---
layout: null
title: Blog
permalink: /blog
---
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Blog</title>
  <link rel="icon" type="image/svg+xml" href="/logo.svg" />
  <script type="module"
    crossorigin>var KT = Object.defineProperty; var qT = (e, t, n) => t in e ? KT(e, t, { enumerable: !0, configurable: !0, writable: !0, value: n }) : e[t] = n; var an = (e, t, n) => qT(e, typeof t != "symbol" ? t + "" : t, n); function QT(e, t) { for (var n = 0; n < t.length; n++) { const r = t[n]; if (typeof r != "string" && !Array.isArray(r)) { for (const i in r) if (i !== "default" && !(i in e)) { const u = Object.getOwnPropertyDescriptor(r, i); u && Object.defineProperty(e, i, u.get ? u : { enumerable: !0, get: () => r[i] }) } } } return Object.freeze(Object.defineProperty(e, Symbol.toStringTag, { value: "Module" })) } (function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const u of i) if (u.type === "childList") for (const s of u.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const u = {}; return i.integrity && (u.integrity = i.integrity), i.referrerPolicy && (u.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? u.credentials = "include" : i.crossOrigin === "anonymous" ? u.credentials = "omit" : u.credentials = "same-origin", u } function r(i) { if (i.ep) return; i.ep = !0; const u = n(i); fetch(i.href, u) } })(); var Xs = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function mi(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Bp = { exports: {} }, Ra = {}, Up = { exports: {} }, le = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ju = Symbol.for("react.element"), GT = Symbol.for("react.portal"), XT = Symbol.for("react.fragment"), JT = Symbol.for("react.strict_mode"), ZT = Symbol.for("react.profiler"), ey = Symbol.for("react.provider"), ty = Symbol.for("react.context"), ny = Symbol.for("react.forward_ref"), ry = Symbol.for("react.suspense"), iy = Symbol.for("react.memo"), uy = Symbol.for("react.lazy"), Sd = Symbol.iterator; function sy(e) { return e === null || typeof e != "object" ? null : (e = Sd && e[Sd] || e["@@iterator"], typeof e == "function" ? e : null) } var Hp = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, zp = Object.assign, jp = {}; function gi(e, t, n) { this.props = e, this.context = t, this.refs = jp, this.updater = n || Hp } gi.prototype.isReactComponent = {}; gi.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; gi.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function $p() { } $p.prototype = gi.prototype; function $c(e, t, n) { this.props = e, this.context = t, this.refs = jp, this.updater = n || Hp } var Vc = $c.prototype = new $p; Vc.constructor = $c; zp(Vc, gi.prototype); Vc.isPureReactComponent = !0; var _d = Array.isArray, Vp = Object.prototype.hasOwnProperty, Yc = { current: null }, Yp = { key: !0, ref: !0, __self: !0, __source: !0 }; function Wp(e, t, n) { var r, i = {}, u = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (u = "" + t.key), t) Vp.call(t, r) && !Yp.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var o = Array(a), l = 0; l < a; l++)o[l] = arguments[l + 2]; i.children = o } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: ju, type: e, key: u, ref: s, props: i, _owner: Yc.current } } function ay(e, t) { return { $$typeof: ju, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function Wc(e) { return typeof e == "object" && e !== null && e.$$typeof === ju } function oy(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var Cd = /\/+/g; function Eo(e, t) { return typeof e == "object" && e !== null && e.key != null ? oy("" + e.key) : t.toString(36) } function vs(e, t, n, r, i) { var u = typeof e; (u === "undefined" || u === "boolean") && (e = null); var s = !1; if (e === null) s = !0; else switch (u) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case ju: case GT: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + Eo(s, 0) : r, _d(i) ? (n = "", e != null && (n = e.replace(Cd, "$&/") + "/"), vs(i, t, n, "", function (l) { return l })) : i != null && (Wc(i) && (i = ay(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(Cd, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", _d(e)) for (var a = 0; a < e.length; a++) { u = e[a]; var o = r + Eo(u, a); s += vs(u, t, n, o, i) } else if (o = sy(e), typeof o == "function") for (e = o.call(e), a = 0; !(u = e.next()).done;)u = u.value, o = r + Eo(u, a++), s += vs(u, t, n, o, i); else if (u === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function us(e, t, n) { if (e == null) return e; var r = [], i = 0; return vs(e, r, "", "", function (u) { return t.call(n, u, i++) }), r } function ly(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var nt = { current: null }, Os = { transition: null }, cy = { ReactCurrentDispatcher: nt, ReactCurrentBatchConfig: Os, ReactCurrentOwner: Yc }; function Kp() { throw Error("act(...) is not supported in production builds of React.") } le.Children = { map: us, forEach: function (e, t, n) { us(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return us(e, function () { t++ }), t }, toArray: function (e) { return us(e, function (t) { return t }) || [] }, only: function (e) { if (!Wc(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; le.Component = gi; le.Fragment = XT; le.Profiler = ZT; le.PureComponent = $c; le.StrictMode = JT; le.Suspense = ry; le.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = cy; le.act = Kp; le.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = zp({}, e.props), i = e.key, u = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (u = t.ref, s = Yc.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (o in t) Vp.call(t, o) && !Yp.hasOwnProperty(o) && (r[o] = t[o] === void 0 && a !== void 0 ? a[o] : t[o]) } var o = arguments.length - 2; if (o === 1) r.children = n; else if (1 < o) { a = Array(o); for (var l = 0; l < o; l++)a[l] = arguments[l + 2]; r.children = a } return { $$typeof: ju, type: e.type, key: i, ref: u, props: r, _owner: s } }; le.createContext = function (e) { return e = { $$typeof: ty, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: ey, _context: e }, e.Consumer = e }; le.createElement = Wp; le.createFactory = function (e) { var t = Wp.bind(null, e); return t.type = e, t }; le.createRef = function () { return { current: null } }; le.forwardRef = function (e) { return { $$typeof: ny, render: e } }; le.isValidElement = Wc; le.lazy = function (e) { return { $$typeof: uy, _payload: { _status: -1, _result: e }, _init: ly } }; le.memo = function (e, t) { return { $$typeof: iy, type: e, compare: t === void 0 ? null : t } }; le.startTransition = function (e) { var t = Os.transition; Os.transition = {}; try { e() } finally { Os.transition = t } }; le.unstable_act = Kp; le.useCallback = function (e, t) { return nt.current.useCallback(e, t) }; le.useContext = function (e) { return nt.current.useContext(e) }; le.useDebugValue = function () { }; le.useDeferredValue = function (e) { return nt.current.useDeferredValue(e) }; le.useEffect = function (e, t) { return nt.current.useEffect(e, t) }; le.useId = function () { return nt.current.useId() }; le.useImperativeHandle = function (e, t, n) { return nt.current.useImperativeHandle(e, t, n) }; le.useInsertionEffect = function (e, t) { return nt.current.useInsertionEffect(e, t) }; le.useLayoutEffect = function (e, t) { return nt.current.useLayoutEffect(e, t) }; le.useMemo = function (e, t) { return nt.current.useMemo(e, t) }; le.useReducer = function (e, t, n) { return nt.current.useReducer(e, t, n) }; le.useRef = function (e) { return nt.current.useRef(e) }; le.useState = function (e) { return nt.current.useState(e) }; le.useSyncExternalStore = function (e, t, n) { return nt.current.useSyncExternalStore(e, t, n) }; le.useTransition = function () { return nt.current.useTransition() }; le.version = "18.3.1"; Up.exports = le; var M = Up.exports; const Bt = mi(M), fy = QT({ __proto__: null, default: Bt }, [M]);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var dy = M, hy = Symbol.for("react.element"), py = Symbol.for("react.fragment"), my = Object.prototype.hasOwnProperty, gy = dy.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, Ey = { key: !0, ref: !0, __self: !0, __source: !0 }; function qp(e, t, n) { var r, i = {}, u = null, s = null; n !== void 0 && (u = "" + n), t.key !== void 0 && (u = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) my.call(t, r) && !Ey.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: hy, type: e, key: u, ref: s, props: i, _owner: gy.current } } Ra.Fragment = py; Ra.jsx = qp; Ra.jsxs = qp; Bp.exports = Ra; var w = Bp.exports, Tl = {}, Qp = { exports: {} }, St = {}, Gp = { exports: {} }, Xp = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(H, X) { var S = H.length; H.push(X); e: for (; 0 < S;) { var J = S - 1 >>> 1, ne = H[J]; if (0 < i(ne, X)) H[J] = X, H[S] = ne, S = J; else break e } } function n(H) { return H.length === 0 ? null : H[0] } function r(H) { if (H.length === 0) return null; var X = H[0], S = H.pop(); if (S !== X) { H[0] = S; e: for (var J = 0, ne = H.length, A = ne >>> 1; J < A;) { var pe = 2 * (J + 1) - 1, ze = H[pe], ye = pe + 1, Wt = H[ye]; if (0 > i(ze, S)) ye < ne && 0 > i(Wt, ze) ? (H[J] = Wt, H[ye] = S, J = ye) : (H[J] = ze, H[pe] = S, J = pe); else if (ye < ne && 0 > i(Wt, S)) H[J] = Wt, H[ye] = S, J = ye; else break e } } return X } function i(H, X) { var S = H.sortIndex - X.sortIndex; return S !== 0 ? S : H.id - X.id } if (typeof performance == "object" && typeof performance.now == "function") { var u = performance; e.unstable_now = function () { return u.now() } } else { var s = Date, a = s.now(); e.unstable_now = function () { return s.now() - a } } var o = [], l = [], f = 1, d = null, p = 3, h = !1, m = !1, T = !1, _ = typeof setTimeout == "function" ? setTimeout : null, g = typeof clearTimeout == "function" ? clearTimeout : null, E = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function y(H) { for (var X = n(l); X !== null;) { if (X.callback === null) r(l); else if (X.startTime <= H) r(l), X.sortIndex = X.expirationTime, t(o, X); else break; X = n(l) } } function I(H) { if (T = !1, y(H), !m) if (n(o) !== null) m = !0, ee(L); else { var X = n(l); X !== null && ae(I, X.startTime - H) } } function L(H, X) { m = !1, T && (T = !1, g(j), j = -1), h = !0; var S = p; try { for (y(X), d = n(o); d !== null && (!(d.expirationTime > X) || H && !Y());) { var J = d.callback; if (typeof J == "function") { d.callback = null, p = d.priorityLevel; var ne = J(d.expirationTime <= X); X = e.unstable_now(), typeof ne == "function" ? d.callback = ne : d === n(o) && r(o), y(X) } else r(o); d = n(o) } if (d !== null) var A = !0; else { var pe = n(l); pe !== null && ae(I, pe.startTime - X), A = !1 } return A } finally { d = null, p = S, h = !1 } } var k = !1, P = null, j = -1, W = 5, N = -1; function Y() { return !(e.unstable_now() - N < W) } function U() { if (P !== null) { var H = e.unstable_now(); N = H; var X = !0; try { X = P(!0, H) } finally { X ? K() : (k = !1, P = null) } } else k = !1 } var K; if (typeof E == "function") K = function () { E(U) }; else if (typeof MessageChannel < "u") { var q = new MessageChannel, G = q.port2; q.port1.onmessage = U, K = function () { G.postMessage(null) } } else K = function () { _(U, 0) }; function ee(H) { P = H, k || (k = !0, K()) } function ae(H, X) { j = _(function () { H(e.unstable_now()) }, X) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (H) { H.callback = null }, e.unstable_continueExecution = function () { m || h || (m = !0, ee(L)) }, e.unstable_forceFrameRate = function (H) { 0 > H || 125 < H ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : W = 0 < H ? Math.floor(1e3 / H) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return p }, e.unstable_getFirstCallbackNode = function () { return n(o) }, e.unstable_next = function (H) { switch (p) { case 1: case 2: case 3: var X = 3; break; default: X = p }var S = p; p = X; try { return H() } finally { p = S } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (H, X) { switch (H) { case 1: case 2: case 3: case 4: case 5: break; default: H = 3 }var S = p; p = H; try { return X() } finally { p = S } }, e.unstable_scheduleCallback = function (H, X, S) { var J = e.unstable_now(); switch (typeof S == "object" && S !== null ? (S = S.delay, S = typeof S == "number" && 0 < S ? J + S : J) : S = J, H) { case 1: var ne = -1; break; case 2: ne = 250; break; case 5: ne = 1073741823; break; case 4: ne = 1e4; break; default: ne = 5e3 }return ne = S + ne, H = { id: f++, callback: X, priorityLevel: H, startTime: S, expirationTime: ne, sortIndex: -1 }, S > J ? (H.sortIndex = S, t(l, H), n(o) === null && H === n(l) && (T ? (g(j), j = -1) : T = !0, ae(I, S - J))) : (H.sortIndex = ne, t(o, H), m || h || (m = !0, ee(L))), H }, e.unstable_shouldYield = Y, e.unstable_wrapCallback = function (H) { var X = p; return function () { var S = p; p = X; try { return H.apply(this, arguments) } finally { p = S } } } })(Xp); Gp.exports = Xp; var Ty = Gp.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var yy = M, xt = Ty; function z(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var Jp = new Set, Tu = {}; function Sr(e, t) { ri(e, t), ri(e + "Capture", t) } function ri(e, t) { for (Tu[e] = t, e = 0; e < t.length; e++)Jp.add(t[e]) } var pn = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), yl = Object.prototype.hasOwnProperty, by = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Ad = {}, kd = {}; function xy(e) { return yl.call(kd, e) ? !0 : yl.call(Ad, e) ? !1 : by.test(e) ? kd[e] = !0 : (Ad[e] = !0, !1) } function Sy(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function _y(e, t, n, r) { if (t === null || typeof t > "u" || Sy(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function rt(e, t, n, r, i, u, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = u, this.removeEmptyString = s } var Ve = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { Ve[e] = new rt(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; Ve[t] = new rt(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { Ve[e] = new rt(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { Ve[e] = new rt(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { Ve[e] = new rt(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { Ve[e] = new rt(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { Ve[e] = new rt(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { Ve[e] = new rt(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { Ve[e] = new rt(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var Kc = /[\-:]([a-z])/g; function qc(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(Kc, qc); Ve[t] = new rt(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(Kc, qc); Ve[t] = new rt(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(Kc, qc); Ve[t] = new rt(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { Ve[e] = new rt(e, 1, !1, e.toLowerCase(), null, !1, !1) }); Ve.xlinkHref = new rt("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { Ve[e] = new rt(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function Qc(e, t, n, r) { var i = Ve.hasOwnProperty(t) ? Ve[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (_y(t, n, i, r) && (n = null), r || i === null ? xy(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var Tn = yy.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, ss = Symbol.for("react.element"), Dr = Symbol.for("react.portal"), Mr = Symbol.for("react.fragment"), Gc = Symbol.for("react.strict_mode"), bl = Symbol.for("react.profiler"), Zp = Symbol.for("react.provider"), em = Symbol.for("react.context"), Xc = Symbol.for("react.forward_ref"), xl = Symbol.for("react.suspense"), Sl = Symbol.for("react.suspense_list"), Jc = Symbol.for("react.memo"), kn = Symbol.for("react.lazy"), tm = Symbol.for("react.offscreen"), Nd = Symbol.iterator; function wi(e) { return e === null || typeof e != "object" ? null : (e = Nd && e[Nd] || e["@@iterator"], typeof e == "function" ? e : null) } var Ne = Object.assign, To; function Yi(e) {
        if (To === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); To = t && t[1] || "" } return `
`+ To + e
      } var yo = !1; function bo(e, t) {
        if (!e || yo) return ""; yo = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (l) { var r = l } Reflect.construct(e, [], t) } else { try { t.call() } catch (l) { r = l } e.call(t.prototype) } else { try { throw Error() } catch (l) { r = l } e() } } catch (l) {
          if (l && r && typeof l.stack == "string") {
            for (var i = l.stack.split(`
`), u = r.stack.split(`
`), s = i.length - 1, a = u.length - 1; 1 <= s && 0 <= a && i[s] !== u[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== u[a]) {
              if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== u[a]) {
                var o = `
`+ i[s].replace(" at new ", " at "); return e.displayName && o.includes("<anonymous>") && (o = o.replace("<anonymous>", e.displayName)), o
              } while (1 <= s && 0 <= a); break
            }
          }
        } finally { yo = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? Yi(e) : ""
      } function Cy(e) { switch (e.tag) { case 5: return Yi(e.type); case 16: return Yi("Lazy"); case 13: return Yi("Suspense"); case 19: return Yi("SuspenseList"); case 0: case 2: case 15: return e = bo(e.type, !1), e; case 11: return e = bo(e.type.render, !1), e; case 1: return e = bo(e.type, !0), e; default: return "" } } function _l(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Mr: return "Fragment"; case Dr: return "Portal"; case bl: return "Profiler"; case Gc: return "StrictMode"; case xl: return "Suspense"; case Sl: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case em: return (e.displayName || "Context") + ".Consumer"; case Zp: return (e._context.displayName || "Context") + ".Provider"; case Xc: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case Jc: return t = e.displayName || null, t !== null ? t : _l(e.type) || "Memo"; case kn: t = e._payload, e = e._init; try { return _l(e(t)) } catch { } }return null } function Ay(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return _l(t); case 8: return t === Gc ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function $n(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function nm(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function ky(e) { var t = nm(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, u = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, u.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function as(e) { e._valueTracker || (e._valueTracker = ky(e)) } function rm(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = nm(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function Js(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Cl(e, t) { var n = t.checked; return Ne({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function Id(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = $n(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function im(e, t) { t = t.checked, t != null && Qc(e, "checked", t, !1) } function Al(e, t) { im(e, t); var n = $n(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? kl(e, t.type, n) : t.hasOwnProperty("defaultValue") && kl(e, t.type, $n(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function wd(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function kl(e, t, n) { (t !== "number" || Js(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Wi = Array.isArray; function qr(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + $n(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Nl(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(z(91)); return Ne({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function vd(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(z(92)); if (Wi(n)) { if (1 < n.length) throw Error(z(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: $n(n) } } function um(e, t) { var n = $n(t.value), r = $n(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function Od(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function sm(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Il(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? sm(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var os, am = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (os = os || document.createElement("div"), os.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = os.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function yu(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Xi = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, Ny = ["Webkit", "ms", "Moz", "O"]; Object.keys(Xi).forEach(function (e) { Ny.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Xi[t] = Xi[e] }) }); function om(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Xi.hasOwnProperty(e) && Xi[e] ? ("" + t).trim() : t + "px" } function lm(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = om(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var Iy = Ne({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function wl(e, t) { if (t) { if (Iy[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(z(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(z(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(z(61)) } if (t.style != null && typeof t.style != "object") throw Error(z(62)) } } function vl(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ol = null; function Zc(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Ll = null, Qr = null, Gr = null; function Ld(e) { if (e = Yu(e)) { if (typeof Ll != "function") throw Error(z(280)); var t = e.stateNode; t && (t = Ba(t), Ll(e.stateNode, e.type, t)) } } function cm(e) { Qr ? Gr ? Gr.push(e) : Gr = [e] : Qr = e } function fm() { if (Qr) { var e = Qr, t = Gr; if (Gr = Qr = null, Ld(e), t) for (e = 0; e < t.length; e++)Ld(t[e]) } } function dm(e, t) { return e(t) } function hm() { } var xo = !1; function pm(e, t, n) { if (xo) return e(t, n); xo = !0; try { return dm(e, t, n) } finally { xo = !1, (Qr !== null || Gr !== null) && (hm(), fm()) } } function bu(e, t) { var n = e.stateNode; if (n === null) return null; var r = Ba(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(z(231, t, typeof n)); return n } var Rl = !1; if (pn) try { var vi = {}; Object.defineProperty(vi, "passive", { get: function () { Rl = !0 } }), window.addEventListener("test", vi, vi), window.removeEventListener("test", vi, vi) } catch { Rl = !1 } function wy(e, t, n, r, i, u, s, a, o) { var l = Array.prototype.slice.call(arguments, 3); try { t.apply(n, l) } catch (f) { this.onError(f) } } var Ji = !1, Zs = null, ea = !1, Pl = null, vy = { onError: function (e) { Ji = !0, Zs = e } }; function Oy(e, t, n, r, i, u, s, a, o) { Ji = !1, Zs = null, wy.apply(vy, arguments) } function Ly(e, t, n, r, i, u, s, a, o) { if (Oy.apply(this, arguments), Ji) { if (Ji) { var l = Zs; Ji = !1, Zs = null } else throw Error(z(198)); ea || (ea = !0, Pl = l) } } function _r(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function mm(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function Rd(e) { if (_r(e) !== e) throw Error(z(188)) } function Ry(e) { var t = e.alternate; if (!t) { if (t = _r(e), t === null) throw Error(z(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var u = i.alternate; if (u === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === u.child) { for (u = i.child; u;) { if (u === n) return Rd(i), e; if (u === r) return Rd(i), t; u = u.sibling } throw Error(z(188)) } if (n.return !== r.return) n = i, r = u; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = u; break } if (a === r) { s = !0, r = i, n = u; break } a = a.sibling } if (!s) { for (a = u.child; a;) { if (a === n) { s = !0, n = u, r = i; break } if (a === r) { s = !0, r = u, n = i; break } a = a.sibling } if (!s) throw Error(z(189)) } } if (n.alternate !== r) throw Error(z(190)) } if (n.tag !== 3) throw Error(z(188)); return n.stateNode.current === n ? e : t } function gm(e) { return e = Ry(e), e !== null ? Em(e) : null } function Em(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = Em(e); if (t !== null) return t; e = e.sibling } return null } var Tm = xt.unstable_scheduleCallback, Pd = xt.unstable_cancelCallback, Py = xt.unstable_shouldYield, Dy = xt.unstable_requestPaint, we = xt.unstable_now, My = xt.unstable_getCurrentPriorityLevel, ef = xt.unstable_ImmediatePriority, ym = xt.unstable_UserBlockingPriority, ta = xt.unstable_NormalPriority, Fy = xt.unstable_LowPriority, bm = xt.unstable_IdlePriority, Pa = null, en = null; function By(e) { if (en && typeof en.onCommitFiberRoot == "function") try { en.onCommitFiberRoot(Pa, e, void 0, (e.current.flags & 128) === 128) } catch { } } var Ht = Math.clz32 ? Math.clz32 : zy, Uy = Math.log, Hy = Math.LN2; function zy(e) { return e >>>= 0, e === 0 ? 32 : 31 - (Uy(e) / Hy | 0) | 0 } var ls = 64, cs = 4194304; function Ki(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function na(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, u = e.pingedLanes, s = n & 268435455; if (s !== 0) { var a = s & ~i; a !== 0 ? r = Ki(a) : (u &= s, u !== 0 && (r = Ki(u))) } else s = n & ~i, s !== 0 ? r = Ki(s) : u !== 0 && (r = Ki(u)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, u = t & -t, i >= u || i === 16 && (u & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - Ht(t), i = 1 << n, r |= e[n], t &= ~i; return r } function jy(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function $y(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, u = e.pendingLanes; 0 < u;) { var s = 31 - Ht(u), a = 1 << s, o = i[s]; o === -1 ? (!(a & n) || a & r) && (i[s] = jy(a, t)) : o <= t && (e.expiredLanes |= a), u &= ~a } } function Dl(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function xm() { var e = ls; return ls <<= 1, !(ls & 4194240) && (ls = 64), e } function So(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function $u(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - Ht(t), e[t] = n } function Vy(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - Ht(n), u = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~u } } function tf(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - Ht(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var he = 0; function Sm(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var _m, nf, Cm, Am, km, Ml = !1, fs = [], Pn = null, Dn = null, Mn = null, xu = new Map, Su = new Map, In = [], Yy = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function Dd(e, t) { switch (e) { case "focusin": case "focusout": Pn = null; break; case "dragenter": case "dragleave": Dn = null; break; case "mouseover": case "mouseout": Mn = null; break; case "pointerover": case "pointerout": xu.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": Su.delete(t.pointerId) } } function Oi(e, t, n, r, i, u) { return e === null || e.nativeEvent !== u ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: u, targetContainers: [i] }, t !== null && (t = Yu(t), t !== null && nf(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function Wy(e, t, n, r, i) { switch (t) { case "focusin": return Pn = Oi(Pn, e, t, n, r, i), !0; case "dragenter": return Dn = Oi(Dn, e, t, n, r, i), !0; case "mouseover": return Mn = Oi(Mn, e, t, n, r, i), !0; case "pointerover": var u = i.pointerId; return xu.set(u, Oi(xu.get(u) || null, e, t, n, r, i)), !0; case "gotpointercapture": return u = i.pointerId, Su.set(u, Oi(Su.get(u) || null, e, t, n, r, i)), !0 }return !1 } function Nm(e) { var t = ir(e.target); if (t !== null) { var n = _r(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = mm(n), t !== null) { e.blockedOn = t, km(e.priority, function () { Cm(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function Ls(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = Fl(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); Ol = r, n.target.dispatchEvent(r), Ol = null } else return t = Yu(n), t !== null && nf(t), e.blockedOn = n, !1; t.shift() } return !0 } function Md(e, t, n) { Ls(e) && n.delete(t) } function Ky() { Ml = !1, Pn !== null && Ls(Pn) && (Pn = null), Dn !== null && Ls(Dn) && (Dn = null), Mn !== null && Ls(Mn) && (Mn = null), xu.forEach(Md), Su.forEach(Md) } function Li(e, t) { e.blockedOn === t && (e.blockedOn = null, Ml || (Ml = !0, xt.unstable_scheduleCallback(xt.unstable_NormalPriority, Ky))) } function _u(e) { function t(i) { return Li(i, e) } if (0 < fs.length) { Li(fs[0], e); for (var n = 1; n < fs.length; n++) { var r = fs[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Pn !== null && Li(Pn, e), Dn !== null && Li(Dn, e), Mn !== null && Li(Mn, e), xu.forEach(t), Su.forEach(t), n = 0; n < In.length; n++)r = In[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < In.length && (n = In[0], n.blockedOn === null);)Nm(n), n.blockedOn === null && In.shift() } var Xr = Tn.ReactCurrentBatchConfig, ra = !0; function qy(e, t, n, r) { var i = he, u = Xr.transition; Xr.transition = null; try { he = 1, rf(e, t, n, r) } finally { he = i, Xr.transition = u } } function Qy(e, t, n, r) { var i = he, u = Xr.transition; Xr.transition = null; try { he = 4, rf(e, t, n, r) } finally { he = i, Xr.transition = u } } function rf(e, t, n, r) { if (ra) { var i = Fl(e, t, n, r); if (i === null) Lo(e, t, r, ia, n), Dd(e, r); else if (Wy(i, e, t, n, r)) r.stopPropagation(); else if (Dd(e, r), t & 4 && -1 < Yy.indexOf(e)) { for (; i !== null;) { var u = Yu(i); if (u !== null && _m(u), u = Fl(e, t, n, r), u === null && Lo(e, t, r, ia, n), u === i) break; i = u } i !== null && r.stopPropagation() } else Lo(e, t, r, null, n) } } var ia = null; function Fl(e, t, n, r) { if (ia = null, e = Zc(r), e = ir(e), e !== null) if (t = _r(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = mm(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return ia = e, null } function Im(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (My()) { case ef: return 1; case ym: return 4; case ta: case Fy: return 16; case bm: return 536870912; default: return 16 }default: return 16 } } var vn = null, uf = null, Rs = null; function wm() { if (Rs) return Rs; var e, t = uf, n = t.length, r, i = "value" in vn ? vn.value : vn.textContent, u = i.length; for (e = 0; e < n && t[e] === i[e]; e++); var s = n - e; for (r = 1; r <= s && t[n - r] === i[u - r]; r++); return Rs = i.slice(e, 1 < r ? 1 - r : void 0) } function Ps(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function ds() { return !0 } function Fd() { return !1 } function _t(e) { function t(n, r, i, u, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = u, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(u) : u[a]); return this.isDefaultPrevented = (u.defaultPrevented != null ? u.defaultPrevented : u.returnValue === !1) ? ds : Fd, this.isPropagationStopped = Fd, this } return Ne(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = ds) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = ds) }, persist: function () { }, isPersistent: ds }), t } var Ei = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, sf = _t(Ei), Vu = Ne({}, Ei, { view: 0, detail: 0 }), Gy = _t(Vu), _o, Co, Ri, Da = Ne({}, Vu, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: af, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Ri && (Ri && e.type === "mousemove" ? (_o = e.screenX - Ri.screenX, Co = e.screenY - Ri.screenY) : Co = _o = 0, Ri = e), _o) }, movementY: function (e) { return "movementY" in e ? e.movementY : Co } }), Bd = _t(Da), Xy = Ne({}, Da, { dataTransfer: 0 }), Jy = _t(Xy), Zy = Ne({}, Vu, { relatedTarget: 0 }), Ao = _t(Zy), e2 = Ne({}, Ei, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), t2 = _t(e2), n2 = Ne({}, Ei, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), r2 = _t(n2), i2 = Ne({}, Ei, { data: 0 }), Ud = _t(i2), u2 = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, s2 = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, a2 = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function o2(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = a2[e]) ? !!t[e] : !1 } function af() { return o2 } var l2 = Ne({}, Vu, { key: function (e) { if (e.key) { var t = u2[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = Ps(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? s2[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: af, charCode: function (e) { return e.type === "keypress" ? Ps(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? Ps(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), c2 = _t(l2), f2 = Ne({}, Da, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Hd = _t(f2), d2 = Ne({}, Vu, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: af }), h2 = _t(d2), p2 = Ne({}, Ei, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), m2 = _t(p2), g2 = Ne({}, Da, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), E2 = _t(g2), T2 = [9, 13, 27, 32], of = pn && "CompositionEvent" in window, Zi = null; pn && "documentMode" in document && (Zi = document.documentMode); var y2 = pn && "TextEvent" in window && !Zi, vm = pn && (!of || Zi && 8 < Zi && 11 >= Zi), zd = " ", jd = !1; function Om(e, t) { switch (e) { case "keyup": return T2.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Lm(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var Fr = !1; function b2(e, t) { switch (e) { case "compositionend": return Lm(t); case "keypress": return t.which !== 32 ? null : (jd = !0, zd); case "textInput": return e = t.data, e === zd && jd ? null : e; default: return null } } function x2(e, t) { if (Fr) return e === "compositionend" || !of && Om(e, t) ? (e = wm(), Rs = uf = vn = null, Fr = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return vm && t.locale !== "ko" ? null : t.data; default: return null } } var S2 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function $d(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!S2[e.type] : t === "textarea" } function Rm(e, t, n, r) { cm(r), t = ua(t, "onChange"), 0 < t.length && (n = new sf("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var eu = null, Cu = null; function _2(e) { Vm(e, 0) } function Ma(e) { var t = Hr(e); if (rm(t)) return e } function C2(e, t) { if (e === "change") return t } var Pm = !1; if (pn) { var ko; if (pn) { var No = "oninput" in document; if (!No) { var Vd = document.createElement("div"); Vd.setAttribute("oninput", "return;"), No = typeof Vd.oninput == "function" } ko = No } else ko = !1; Pm = ko && (!document.documentMode || 9 < document.documentMode) } function Yd() { eu && (eu.detachEvent("onpropertychange", Dm), Cu = eu = null) } function Dm(e) { if (e.propertyName === "value" && Ma(Cu)) { var t = []; Rm(t, Cu, e, Zc(e)), pm(_2, t) } } function A2(e, t, n) { e === "focusin" ? (Yd(), eu = t, Cu = n, eu.attachEvent("onpropertychange", Dm)) : e === "focusout" && Yd() } function k2(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return Ma(Cu) } function N2(e, t) { if (e === "click") return Ma(t) } function I2(e, t) { if (e === "input" || e === "change") return Ma(t) } function w2(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var $t = typeof Object.is == "function" ? Object.is : w2; function Au(e, t) { if ($t(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!yl.call(t, i) || !$t(e[i], t[i])) return !1 } return !0 } function Wd(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function Kd(e, t) { var n = Wd(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Wd(n) } } function Mm(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Mm(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Fm() { for (var e = window, t = Js(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = Js(e.document) } return t } function lf(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function v2(e) { var t = Fm(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && Mm(n.ownerDocument.documentElement, n)) { if (r !== null && lf(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, u = Math.min(r.start, i); r = r.end === void 0 ? u : Math.min(r.end, i), !e.extend && u > r && (i = r, r = u, u = i), i = Kd(n, u); var s = Kd(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), u > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var O2 = pn && "documentMode" in document && 11 >= document.documentMode, Br = null, Bl = null, tu = null, Ul = !1; function qd(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; Ul || Br == null || Br !== Js(r) || (r = Br, "selectionStart" in r && lf(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), tu && Au(tu, r) || (tu = r, r = ua(Bl, "onSelect"), 0 < r.length && (t = new sf("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Br))) } function hs(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var Ur = { animationend: hs("Animation", "AnimationEnd"), animationiteration: hs("Animation", "AnimationIteration"), animationstart: hs("Animation", "AnimationStart"), transitionend: hs("Transition", "TransitionEnd") }, Io = {}, Bm = {}; pn && (Bm = document.createElement("div").style, "AnimationEvent" in window || (delete Ur.animationend.animation, delete Ur.animationiteration.animation, delete Ur.animationstart.animation), "TransitionEvent" in window || delete Ur.transitionend.transition); function Fa(e) { if (Io[e]) return Io[e]; if (!Ur[e]) return e; var t = Ur[e], n; for (n in t) if (t.hasOwnProperty(n) && n in Bm) return Io[e] = t[n]; return e } var Um = Fa("animationend"), Hm = Fa("animationiteration"), zm = Fa("animationstart"), jm = Fa("transitionend"), $m = new Map, Qd = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function Yn(e, t) { $m.set(e, t), Sr(t, [e]) } for (var wo = 0; wo < Qd.length; wo++) { var vo = Qd[wo], L2 = vo.toLowerCase(), R2 = vo[0].toUpperCase() + vo.slice(1); Yn(L2, "on" + R2) } Yn(Um, "onAnimationEnd"); Yn(Hm, "onAnimationIteration"); Yn(zm, "onAnimationStart"); Yn("dblclick", "onDoubleClick"); Yn("focusin", "onFocus"); Yn("focusout", "onBlur"); Yn(jm, "onTransitionEnd"); ri("onMouseEnter", ["mouseout", "mouseover"]); ri("onMouseLeave", ["mouseout", "mouseover"]); ri("onPointerEnter", ["pointerout", "pointerover"]); ri("onPointerLeave", ["pointerout", "pointerover"]); Sr("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Sr("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Sr("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Sr("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Sr("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Sr("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var qi = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), P2 = new Set("cancel close invalid load scroll toggle".split(" ").concat(qi)); function Gd(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, Ly(r, t, void 0, e), e.currentTarget = null } function Vm(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var u = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], o = a.instance, l = a.currentTarget; if (a = a.listener, o !== u && i.isPropagationStopped()) break e; Gd(i, a, l), u = o } else for (s = 0; s < r.length; s++) { if (a = r[s], o = a.instance, l = a.currentTarget, a = a.listener, o !== u && i.isPropagationStopped()) break e; Gd(i, a, l), u = o } } } if (ea) throw e = Pl, ea = !1, Pl = null, e } function be(e, t) { var n = t[Vl]; n === void 0 && (n = t[Vl] = new Set); var r = e + "__bubble"; n.has(r) || (Ym(t, e, 2, !1), n.add(r)) } function Oo(e, t, n) { var r = 0; t && (r |= 4), Ym(n, e, r, t) } var ps = "_reactListening" + Math.random().toString(36).slice(2); function ku(e) { if (!e[ps]) { e[ps] = !0, Jp.forEach(function (n) { n !== "selectionchange" && (P2.has(n) || Oo(n, !1, e), Oo(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[ps] || (t[ps] = !0, Oo("selectionchange", !1, t)) } } function Ym(e, t, n, r) { switch (Im(t)) { case 1: var i = qy; break; case 4: i = Qy; break; default: i = rf }n = i.bind(null, t, n, e), i = void 0, !Rl || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function Lo(e, t, n, r, i) { var u = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var o = s.tag; if ((o === 3 || o === 4) && (o = s.stateNode.containerInfo, o === i || o.nodeType === 8 && o.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = ir(a), s === null) return; if (o = s.tag, o === 5 || o === 6) { r = u = s; continue e } a = a.parentNode } } r = r.return } pm(function () { var l = u, f = Zc(n), d = []; e: { var p = $m.get(e); if (p !== void 0) { var h = sf, m = e; switch (e) { case "keypress": if (Ps(n) === 0) break e; case "keydown": case "keyup": h = c2; break; case "focusin": m = "focus", h = Ao; break; case "focusout": m = "blur", h = Ao; break; case "beforeblur": case "afterblur": h = Ao; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": h = Bd; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": h = Jy; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": h = h2; break; case Um: case Hm: case zm: h = t2; break; case jm: h = m2; break; case "scroll": h = Gy; break; case "wheel": h = E2; break; case "copy": case "cut": case "paste": h = r2; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": h = Hd }var T = (t & 4) !== 0, _ = !T && e === "scroll", g = T ? p !== null ? p + "Capture" : null : p; T = []; for (var E = l, y; E !== null;) { y = E; var I = y.stateNode; if (y.tag === 5 && I !== null && (y = I, g !== null && (I = bu(E, g), I != null && T.push(Nu(E, I, y)))), _) break; E = E.return } 0 < T.length && (p = new h(p, m, null, n, f), d.push({ event: p, listeners: T })) } } if (!(t & 7)) { e: { if (p = e === "mouseover" || e === "pointerover", h = e === "mouseout" || e === "pointerout", p && n !== Ol && (m = n.relatedTarget || n.fromElement) && (ir(m) || m[mn])) break e; if ((h || p) && (p = f.window === f ? f : (p = f.ownerDocument) ? p.defaultView || p.parentWindow : window, h ? (m = n.relatedTarget || n.toElement, h = l, m = m ? ir(m) : null, m !== null && (_ = _r(m), m !== _ || m.tag !== 5 && m.tag !== 6) && (m = null)) : (h = null, m = l), h !== m)) { if (T = Bd, I = "onMouseLeave", g = "onMouseEnter", E = "mouse", (e === "pointerout" || e === "pointerover") && (T = Hd, I = "onPointerLeave", g = "onPointerEnter", E = "pointer"), _ = h == null ? p : Hr(h), y = m == null ? p : Hr(m), p = new T(I, E + "leave", h, n, f), p.target = _, p.relatedTarget = y, I = null, ir(f) === l && (T = new T(g, E + "enter", m, n, f), T.target = y, T.relatedTarget = _, I = T), _ = I, h && m) t: { for (T = h, g = m, E = 0, y = T; y; y = vr(y))E++; for (y = 0, I = g; I; I = vr(I))y++; for (; 0 < E - y;)T = vr(T), E--; for (; 0 < y - E;)g = vr(g), y--; for (; E--;) { if (T === g || g !== null && T === g.alternate) break t; T = vr(T), g = vr(g) } T = null } else T = null; h !== null && Xd(d, p, h, T, !1), m !== null && _ !== null && Xd(d, _, m, T, !0) } } e: { if (p = l ? Hr(l) : window, h = p.nodeName && p.nodeName.toLowerCase(), h === "select" || h === "input" && p.type === "file") var L = C2; else if ($d(p)) if (Pm) L = I2; else { L = k2; var k = A2 } else (h = p.nodeName) && h.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (L = N2); if (L && (L = L(e, l))) { Rm(d, L, n, f); break e } k && k(e, p, l), e === "focusout" && (k = p._wrapperState) && k.controlled && p.type === "number" && kl(p, "number", p.value) } switch (k = l ? Hr(l) : window, e) { case "focusin": ($d(k) || k.contentEditable === "true") && (Br = k, Bl = l, tu = null); break; case "focusout": tu = Bl = Br = null; break; case "mousedown": Ul = !0; break; case "contextmenu": case "mouseup": case "dragend": Ul = !1, qd(d, n, f); break; case "selectionchange": if (O2) break; case "keydown": case "keyup": qd(d, n, f) }var P; if (of) e: { switch (e) { case "compositionstart": var j = "onCompositionStart"; break e; case "compositionend": j = "onCompositionEnd"; break e; case "compositionupdate": j = "onCompositionUpdate"; break e }j = void 0 } else Fr ? Om(e, n) && (j = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (j = "onCompositionStart"); j && (vm && n.locale !== "ko" && (Fr || j !== "onCompositionStart" ? j === "onCompositionEnd" && Fr && (P = wm()) : (vn = f, uf = "value" in vn ? vn.value : vn.textContent, Fr = !0)), k = ua(l, j), 0 < k.length && (j = new Ud(j, e, null, n, f), d.push({ event: j, listeners: k }), P ? j.data = P : (P = Lm(n), P !== null && (j.data = P)))), (P = y2 ? b2(e, n) : x2(e, n)) && (l = ua(l, "onBeforeInput"), 0 < l.length && (f = new Ud("onBeforeInput", "beforeinput", null, n, f), d.push({ event: f, listeners: l }), f.data = P)) } Vm(d, t) }) } function Nu(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function ua(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, u = i.stateNode; i.tag === 5 && u !== null && (i = u, u = bu(e, n), u != null && r.unshift(Nu(e, u, i)), u = bu(e, t), u != null && r.push(Nu(e, u, i))), e = e.return } return r } function vr(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Xd(e, t, n, r, i) { for (var u = t._reactName, s = []; n !== null && n !== r;) { var a = n, o = a.alternate, l = a.stateNode; if (o !== null && o === r) break; a.tag === 5 && l !== null && (a = l, i ? (o = bu(n, u), o != null && s.unshift(Nu(n, o, a))) : i || (o = bu(n, u), o != null && s.push(Nu(n, o, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var D2 = /\r\n?/g, M2 = /\u0000|\uFFFD/g; function Jd(e) {
        return (typeof e == "string" ? e : "" + e).replace(D2, `
`).replace(M2, "")
      } function ms(e, t, n) { if (t = Jd(t), Jd(e) !== t && n) throw Error(z(425)) } function sa() { } var Hl = null, zl = null; function jl(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var $l = typeof setTimeout == "function" ? setTimeout : void 0, F2 = typeof clearTimeout == "function" ? clearTimeout : void 0, Zd = typeof Promise == "function" ? Promise : void 0, B2 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Zd < "u" ? function (e) { return Zd.resolve(null).then(e).catch(U2) } : $l; function U2(e) { setTimeout(function () { throw e }) } function Ro(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), _u(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); _u(t) } function Fn(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function eh(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var Ti = Math.random().toString(36).slice(2), Jt = "__reactFiber$" + Ti, Iu = "__reactProps$" + Ti, mn = "__reactContainer$" + Ti, Vl = "__reactEvents$" + Ti, H2 = "__reactListeners$" + Ti, z2 = "__reactHandles$" + Ti; function ir(e) { var t = e[Jt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[mn] || n[Jt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = eh(e); e !== null;) { if (n = e[Jt]) return n; e = eh(e) } return t } e = n, n = e.parentNode } return null } function Yu(e) { return e = e[Jt] || e[mn], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function Hr(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(z(33)) } function Ba(e) { return e[Iu] || null } var Yl = [], zr = -1; function Wn(e) { return { current: e } } function xe(e) { 0 > zr || (e.current = Yl[zr], Yl[zr] = null, zr--) } function Te(e, t) { zr++, Yl[zr] = e.current, e.current = t } var Vn = {}, Ge = Wn(Vn), lt = Wn(!1), pr = Vn; function ii(e, t) { var n = e.type.contextTypes; if (!n) return Vn; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, u; for (u in n) i[u] = t[u]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i } function ct(e) { return e = e.childContextTypes, e != null } function aa() { xe(lt), xe(Ge) } function th(e, t, n) { if (Ge.current !== Vn) throw Error(z(168)); Te(Ge, t), Te(lt, n) } function Wm(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(z(108, Ay(e) || "Unknown", i)); return Ne({}, n, r) } function oa(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || Vn, pr = Ge.current, Te(Ge, e), Te(lt, lt.current), !0 } function nh(e, t, n) { var r = e.stateNode; if (!r) throw Error(z(169)); n ? (e = Wm(e, t, pr), r.__reactInternalMemoizedMergedChildContext = e, xe(lt), xe(Ge), Te(Ge, e)) : xe(lt), Te(lt, n) } var ln = null, Ua = !1, Po = !1; function Km(e) { ln === null ? ln = [e] : ln.push(e) } function j2(e) { Ua = !0, Km(e) } function Kn() { if (!Po && ln !== null) { Po = !0; var e = 0, t = he; try { var n = ln; for (he = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } ln = null, Ua = !1 } catch (i) { throw ln !== null && (ln = ln.slice(e + 1)), Tm(ef, Kn), i } finally { he = t, Po = !1 } } return null } var jr = [], $r = 0, la = null, ca = 0, At = [], kt = 0, mr = null, fn = 1, dn = ""; function Zn(e, t) { jr[$r++] = ca, jr[$r++] = la, la = e, ca = t } function qm(e, t, n) { At[kt++] = fn, At[kt++] = dn, At[kt++] = mr, mr = e; var r = fn; e = dn; var i = 32 - Ht(r) - 1; r &= ~(1 << i), n += 1; var u = 32 - Ht(t) + i; if (30 < u) { var s = i - i % 5; u = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, fn = 1 << 32 - Ht(t) + i | n << i | r, dn = u + e } else fn = 1 << u | n << i | r, dn = e } function cf(e) { e.return !== null && (Zn(e, 1), qm(e, 1, 0)) } function ff(e) { for (; e === la;)la = jr[--$r], jr[$r] = null, ca = jr[--$r], jr[$r] = null; for (; e === mr;)mr = At[--kt], At[kt] = null, dn = At[--kt], At[kt] = null, fn = At[--kt], At[kt] = null } var yt = null, Tt = null, _e = !1, Ft = null; function Qm(e, t) { var n = wt(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function rh(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, yt = e, Tt = Fn(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, yt = e, Tt = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = mr !== null ? { id: fn, overflow: dn } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = wt(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, yt = e, Tt = null, !0) : !1; default: return !1 } } function Wl(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function Kl(e) { if (_e) { var t = Tt; if (t) { var n = t; if (!rh(e, t)) { if (Wl(e)) throw Error(z(418)); t = Fn(n.nextSibling); var r = yt; t && rh(e, t) ? Qm(r, n) : (e.flags = e.flags & -4097 | 2, _e = !1, yt = e) } } else { if (Wl(e)) throw Error(z(418)); e.flags = e.flags & -4097 | 2, _e = !1, yt = e } } } function ih(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; yt = e } function gs(e) { if (e !== yt) return !1; if (!_e) return ih(e), _e = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !jl(e.type, e.memoizedProps)), t && (t = Tt)) { if (Wl(e)) throw Gm(), Error(z(418)); for (; t;)Qm(e, t), t = Fn(t.nextSibling) } if (ih(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(z(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { Tt = Fn(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } Tt = null } } else Tt = yt ? Fn(e.stateNode.nextSibling) : null; return !0 } function Gm() { for (var e = Tt; e;)e = Fn(e.nextSibling) } function ui() { Tt = yt = null, _e = !1 } function df(e) { Ft === null ? Ft = [e] : Ft.push(e) } var $2 = Tn.ReactCurrentBatchConfig; function Pi(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(z(309)); var r = n.stateNode } if (!r) throw Error(z(147, e)); var i = r, u = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === u ? t.ref : (t = function (s) { var a = i.refs; s === null ? delete a[u] : a[u] = s }, t._stringRef = u, t) } if (typeof e != "string") throw Error(z(284)); if (!n._owner) throw Error(z(290, e)) } return e } function Es(e, t) { throw e = Object.prototype.toString.call(t), Error(z(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function uh(e) { var t = e._init; return t(e._payload) } function Xm(e) { function t(g, E) { if (e) { var y = g.deletions; y === null ? (g.deletions = [E], g.flags |= 16) : y.push(E) } } function n(g, E) { if (!e) return null; for (; E !== null;)t(g, E), E = E.sibling; return null } function r(g, E) { for (g = new Map; E !== null;)E.key !== null ? g.set(E.key, E) : g.set(E.index, E), E = E.sibling; return g } function i(g, E) { return g = zn(g, E), g.index = 0, g.sibling = null, g } function u(g, E, y) { return g.index = y, e ? (y = g.alternate, y !== null ? (y = y.index, y < E ? (g.flags |= 2, E) : y) : (g.flags |= 2, E)) : (g.flags |= 1048576, E) } function s(g) { return e && g.alternate === null && (g.flags |= 2), g } function a(g, E, y, I) { return E === null || E.tag !== 6 ? (E = zo(y, g.mode, I), E.return = g, E) : (E = i(E, y), E.return = g, E) } function o(g, E, y, I) { var L = y.type; return L === Mr ? f(g, E, y.props.children, I, y.key) : E !== null && (E.elementType === L || typeof L == "object" && L !== null && L.$$typeof === kn && uh(L) === E.type) ? (I = i(E, y.props), I.ref = Pi(g, E, y), I.return = g, I) : (I = zs(y.type, y.key, y.props, null, g.mode, I), I.ref = Pi(g, E, y), I.return = g, I) } function l(g, E, y, I) { return E === null || E.tag !== 4 || E.stateNode.containerInfo !== y.containerInfo || E.stateNode.implementation !== y.implementation ? (E = jo(y, g.mode, I), E.return = g, E) : (E = i(E, y.children || []), E.return = g, E) } function f(g, E, y, I, L) { return E === null || E.tag !== 7 ? (E = fr(y, g.mode, I, L), E.return = g, E) : (E = i(E, y), E.return = g, E) } function d(g, E, y) { if (typeof E == "string" && E !== "" || typeof E == "number") return E = zo("" + E, g.mode, y), E.return = g, E; if (typeof E == "object" && E !== null) { switch (E.$$typeof) { case ss: return y = zs(E.type, E.key, E.props, null, g.mode, y), y.ref = Pi(g, null, E), y.return = g, y; case Dr: return E = jo(E, g.mode, y), E.return = g, E; case kn: var I = E._init; return d(g, I(E._payload), y) }if (Wi(E) || wi(E)) return E = fr(E, g.mode, y, null), E.return = g, E; Es(g, E) } return null } function p(g, E, y, I) { var L = E !== null ? E.key : null; if (typeof y == "string" && y !== "" || typeof y == "number") return L !== null ? null : a(g, E, "" + y, I); if (typeof y == "object" && y !== null) { switch (y.$$typeof) { case ss: return y.key === L ? o(g, E, y, I) : null; case Dr: return y.key === L ? l(g, E, y, I) : null; case kn: return L = y._init, p(g, E, L(y._payload), I) }if (Wi(y) || wi(y)) return L !== null ? null : f(g, E, y, I, null); Es(g, y) } return null } function h(g, E, y, I, L) { if (typeof I == "string" && I !== "" || typeof I == "number") return g = g.get(y) || null, a(E, g, "" + I, L); if (typeof I == "object" && I !== null) { switch (I.$$typeof) { case ss: return g = g.get(I.key === null ? y : I.key) || null, o(E, g, I, L); case Dr: return g = g.get(I.key === null ? y : I.key) || null, l(E, g, I, L); case kn: var k = I._init; return h(g, E, y, k(I._payload), L) }if (Wi(I) || wi(I)) return g = g.get(y) || null, f(E, g, I, L, null); Es(E, I) } return null } function m(g, E, y, I) { for (var L = null, k = null, P = E, j = E = 0, W = null; P !== null && j < y.length; j++) { P.index > j ? (W = P, P = null) : W = P.sibling; var N = p(g, P, y[j], I); if (N === null) { P === null && (P = W); break } e && P && N.alternate === null && t(g, P), E = u(N, E, j), k === null ? L = N : k.sibling = N, k = N, P = W } if (j === y.length) return n(g, P), _e && Zn(g, j), L; if (P === null) { for (; j < y.length; j++)P = d(g, y[j], I), P !== null && (E = u(P, E, j), k === null ? L = P : k.sibling = P, k = P); return _e && Zn(g, j), L } for (P = r(g, P); j < y.length; j++)W = h(P, g, j, y[j], I), W !== null && (e && W.alternate !== null && P.delete(W.key === null ? j : W.key), E = u(W, E, j), k === null ? L = W : k.sibling = W, k = W); return e && P.forEach(function (Y) { return t(g, Y) }), _e && Zn(g, j), L } function T(g, E, y, I) { var L = wi(y); if (typeof L != "function") throw Error(z(150)); if (y = L.call(y), y == null) throw Error(z(151)); for (var k = L = null, P = E, j = E = 0, W = null, N = y.next(); P !== null && !N.done; j++, N = y.next()) { P.index > j ? (W = P, P = null) : W = P.sibling; var Y = p(g, P, N.value, I); if (Y === null) { P === null && (P = W); break } e && P && Y.alternate === null && t(g, P), E = u(Y, E, j), k === null ? L = Y : k.sibling = Y, k = Y, P = W } if (N.done) return n(g, P), _e && Zn(g, j), L; if (P === null) { for (; !N.done; j++, N = y.next())N = d(g, N.value, I), N !== null && (E = u(N, E, j), k === null ? L = N : k.sibling = N, k = N); return _e && Zn(g, j), L } for (P = r(g, P); !N.done; j++, N = y.next())N = h(P, g, j, N.value, I), N !== null && (e && N.alternate !== null && P.delete(N.key === null ? j : N.key), E = u(N, E, j), k === null ? L = N : k.sibling = N, k = N); return e && P.forEach(function (U) { return t(g, U) }), _e && Zn(g, j), L } function _(g, E, y, I) { if (typeof y == "object" && y !== null && y.type === Mr && y.key === null && (y = y.props.children), typeof y == "object" && y !== null) { switch (y.$$typeof) { case ss: e: { for (var L = y.key, k = E; k !== null;) { if (k.key === L) { if (L = y.type, L === Mr) { if (k.tag === 7) { n(g, k.sibling), E = i(k, y.props.children), E.return = g, g = E; break e } } else if (k.elementType === L || typeof L == "object" && L !== null && L.$$typeof === kn && uh(L) === k.type) { n(g, k.sibling), E = i(k, y.props), E.ref = Pi(g, k, y), E.return = g, g = E; break e } n(g, k); break } else t(g, k); k = k.sibling } y.type === Mr ? (E = fr(y.props.children, g.mode, I, y.key), E.return = g, g = E) : (I = zs(y.type, y.key, y.props, null, g.mode, I), I.ref = Pi(g, E, y), I.return = g, g = I) } return s(g); case Dr: e: { for (k = y.key; E !== null;) { if (E.key === k) if (E.tag === 4 && E.stateNode.containerInfo === y.containerInfo && E.stateNode.implementation === y.implementation) { n(g, E.sibling), E = i(E, y.children || []), E.return = g, g = E; break e } else { n(g, E); break } else t(g, E); E = E.sibling } E = jo(y, g.mode, I), E.return = g, g = E } return s(g); case kn: return k = y._init, _(g, E, k(y._payload), I) }if (Wi(y)) return m(g, E, y, I); if (wi(y)) return T(g, E, y, I); Es(g, y) } return typeof y == "string" && y !== "" || typeof y == "number" ? (y = "" + y, E !== null && E.tag === 6 ? (n(g, E.sibling), E = i(E, y), E.return = g, g = E) : (n(g, E), E = zo(y, g.mode, I), E.return = g, g = E), s(g)) : n(g, E) } return _ } var si = Xm(!0), Jm = Xm(!1), fa = Wn(null), da = null, Vr = null, hf = null; function pf() { hf = Vr = da = null } function mf(e) { var t = fa.current; xe(fa), e._currentValue = t } function ql(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function Jr(e, t) { da = e, hf = Vr = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (ot = !0), e.firstContext = null) } function Ot(e) { var t = e._currentValue; if (hf !== e) if (e = { context: e, memoizedValue: t, next: null }, Vr === null) { if (da === null) throw Error(z(308)); Vr = e, da.dependencies = { lanes: 0, firstContext: e } } else Vr = Vr.next = e; return t } var ur = null; function gf(e) { ur === null ? ur = [e] : ur.push(e) } function Zm(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, gf(t)) : (n.next = i.next, i.next = n), t.interleaved = n, gn(e, r) } function gn(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var Nn = !1; function Ef(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function eg(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function hn(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Bn(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, de & 2) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, gn(e, n) } return i = r.interleaved, i === null ? (t.next = t, gf(r)) : (t.next = i.next, i.next = t), r.interleaved = t, gn(e, n) } function Ds(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, tf(e, n) } } function sh(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, u = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; u === null ? i = u = s : u = u.next = s, n = n.next } while (n !== null); u === null ? i = u = t : u = u.next = t } else i = u = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: u, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function ha(e, t, n, r) { var i = e.updateQueue; Nn = !1; var u = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var o = a, l = o.next; o.next = null, s === null ? u = l : s.next = l, s = o; var f = e.alternate; f !== null && (f = f.updateQueue, a = f.lastBaseUpdate, a !== s && (a === null ? f.firstBaseUpdate = l : a.next = l, f.lastBaseUpdate = o)) } if (u !== null) { var d = i.baseState; s = 0, f = l = o = null, a = u; do { var p = a.lane, h = a.eventTime; if ((r & p) === p) { f !== null && (f = f.next = { eventTime: h, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var m = e, T = a; switch (p = t, h = n, T.tag) { case 1: if (m = T.payload, typeof m == "function") { d = m.call(h, d, p); break e } d = m; break e; case 3: m.flags = m.flags & -65537 | 128; case 0: if (m = T.payload, p = typeof m == "function" ? m.call(h, d, p) : m, p == null) break e; d = Ne({}, d, p); break e; case 2: Nn = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, p = i.effects, p === null ? i.effects = [a] : p.push(a)) } else h = { eventTime: h, lane: p, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, f === null ? (l = f = h, o = d) : f = f.next = h, s |= p; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; p = a, a = p.next, p.next = null, i.lastBaseUpdate = p, i.shared.pending = null } } while (!0); if (f === null && (o = d), i.baseState = o, i.firstBaseUpdate = l, i.lastBaseUpdate = f, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else u === null && (i.shared.lanes = 0); Er |= s, e.lanes = s, e.memoizedState = d } } function ah(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(z(191, i)); i.call(r) } } } var Wu = {}, tn = Wn(Wu), wu = Wn(Wu), vu = Wn(Wu); function sr(e) { if (e === Wu) throw Error(z(174)); return e } function Tf(e, t) { switch (Te(vu, t), Te(wu, e), Te(tn, Wu), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Il(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Il(t, e) }xe(tn), Te(tn, t) } function ai() { xe(tn), xe(wu), xe(vu) } function tg(e) { sr(vu.current); var t = sr(tn.current), n = Il(t, e.type); t !== n && (Te(wu, e), Te(tn, n)) } function yf(e) { wu.current === e && (xe(tn), xe(wu)) } var Ae = Wn(0); function pa(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var Do = []; function bf() { for (var e = 0; e < Do.length; e++)Do[e]._workInProgressVersionPrimary = null; Do.length = 0 } var Ms = Tn.ReactCurrentDispatcher, Mo = Tn.ReactCurrentBatchConfig, gr = 0, ke = null, De = null, Be = null, ma = !1, nu = !1, Ou = 0, V2 = 0; function Ye() { throw Error(z(321)) } function xf(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!$t(e[n], t[n])) return !1; return !0 } function Sf(e, t, n, r, i, u) { if (gr = u, ke = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, Ms.current = e === null || e.memoizedState === null ? q2 : Q2, e = n(r, i), nu) { u = 0; do { if (nu = !1, Ou = 0, 25 <= u) throw Error(z(301)); u += 1, Be = De = null, t.updateQueue = null, Ms.current = G2, e = n(r, i) } while (nu) } if (Ms.current = ga, t = De !== null && De.next !== null, gr = 0, Be = De = ke = null, ma = !1, t) throw Error(z(300)); return e } function _f() { var e = Ou !== 0; return Ou = 0, e } function Qt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return Be === null ? ke.memoizedState = Be = e : Be = Be.next = e, Be } function Lt() { if (De === null) { var e = ke.alternate; e = e !== null ? e.memoizedState : null } else e = De.next; var t = Be === null ? ke.memoizedState : Be.next; if (t !== null) Be = t, De = e; else { if (e === null) throw Error(z(310)); De = e, e = { memoizedState: De.memoizedState, baseState: De.baseState, baseQueue: De.baseQueue, queue: De.queue, next: null }, Be === null ? ke.memoizedState = Be = e : Be = Be.next = e } return Be } function Lu(e, t) { return typeof t == "function" ? t(e) : t } function Fo(e) { var t = Lt(), n = t.queue; if (n === null) throw Error(z(311)); n.lastRenderedReducer = e; var r = De, i = r.baseQueue, u = n.pending; if (u !== null) { if (i !== null) { var s = i.next; i.next = u.next, u.next = s } r.baseQueue = i = u, n.pending = null } if (i !== null) { u = i.next, r = r.baseState; var a = s = null, o = null, l = u; do { var f = l.lane; if ((gr & f) === f) o !== null && (o = o.next = { lane: 0, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }), r = l.hasEagerState ? l.eagerState : e(r, l.action); else { var d = { lane: f, action: l.action, hasEagerState: l.hasEagerState, eagerState: l.eagerState, next: null }; o === null ? (a = o = d, s = r) : o = o.next = d, ke.lanes |= f, Er |= f } l = l.next } while (l !== null && l !== u); o === null ? s = r : o.next = a, $t(r, t.memoizedState) || (ot = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = o, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do u = i.lane, ke.lanes |= u, Er |= u, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function Bo(e) { var t = Lt(), n = t.queue; if (n === null) throw Error(z(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, u = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do u = e(u, s.action), s = s.next; while (s !== i); $t(u, t.memoizedState) || (ot = !0), t.memoizedState = u, t.baseQueue === null && (t.baseState = u), n.lastRenderedState = u } return [u, r] } function ng() { } function rg(e, t) { var n = ke, r = Lt(), i = t(), u = !$t(r.memoizedState, i); if (u && (r.memoizedState = i, ot = !0), r = r.queue, Cf(sg.bind(null, n, r, e), [e]), r.getSnapshot !== t || u || Be !== null && Be.memoizedState.tag & 1) { if (n.flags |= 2048, Ru(9, ug.bind(null, n, r, i, t), void 0, null), He === null) throw Error(z(349)); gr & 30 || ig(n, t, i) } return i } function ig(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = ke.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ke.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function ug(e, t, n, r) { t.value = n, t.getSnapshot = r, ag(t) && og(e) } function sg(e, t, n) { return n(function () { ag(t) && og(e) }) } function ag(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !$t(e, n) } catch { return !0 } } function og(e) { var t = gn(e, 1); t !== null && zt(t, e, 1, -1) } function oh(e) { var t = Qt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Lu, lastRenderedState: e }, t.queue = e, e = e.dispatch = K2.bind(null, ke, e), [t.memoizedState, e] } function Ru(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = ke.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, ke.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function lg() { return Lt().memoizedState } function Fs(e, t, n, r) { var i = Qt(); ke.flags |= e, i.memoizedState = Ru(1 | t, n, void 0, r === void 0 ? null : r) } function Ha(e, t, n, r) { var i = Lt(); r = r === void 0 ? null : r; var u = void 0; if (De !== null) { var s = De.memoizedState; if (u = s.destroy, r !== null && xf(r, s.deps)) { i.memoizedState = Ru(t, n, u, r); return } } ke.flags |= e, i.memoizedState = Ru(1 | t, n, u, r) } function lh(e, t) { return Fs(8390656, 8, e, t) } function Cf(e, t) { return Ha(2048, 8, e, t) } function cg(e, t) { return Ha(4, 2, e, t) } function fg(e, t) { return Ha(4, 4, e, t) } function dg(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function hg(e, t, n) { return n = n != null ? n.concat([e]) : null, Ha(4, 4, dg.bind(null, t, e), n) } function Af() { } function pg(e, t) { var n = Lt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && xf(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function mg(e, t) { var n = Lt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && xf(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function gg(e, t, n) { return gr & 21 ? ($t(n, t) || (n = xm(), ke.lanes |= n, Er |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, ot = !0), e.memoizedState = n) } function Y2(e, t) { var n = he; he = n !== 0 && 4 > n ? n : 4, e(!0); var r = Mo.transition; Mo.transition = {}; try { e(!1), t() } finally { he = n, Mo.transition = r } } function Eg() { return Lt().memoizedState } function W2(e, t, n) { var r = Hn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Tg(e)) yg(t, n); else if (n = Zm(e, t, n, r), n !== null) { var i = tt(); zt(n, e, r, i), bg(n, t, r) } } function K2(e, t, n) { var r = Hn(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Tg(e)) yg(t, i); else { var u = e.alternate; if (e.lanes === 0 && (u === null || u.lanes === 0) && (u = t.lastRenderedReducer, u !== null)) try { var s = t.lastRenderedState, a = u(s, n); if (i.hasEagerState = !0, i.eagerState = a, $t(a, s)) { var o = t.interleaved; o === null ? (i.next = i, gf(t)) : (i.next = o.next, o.next = i), t.interleaved = i; return } } catch { } finally { } n = Zm(e, t, i, r), n !== null && (i = tt(), zt(n, e, r, i), bg(n, t, r)) } } function Tg(e) { var t = e.alternate; return e === ke || t !== null && t === ke } function yg(e, t) { nu = ma = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function bg(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, tf(e, n) } } var ga = { readContext: Ot, useCallback: Ye, useContext: Ye, useEffect: Ye, useImperativeHandle: Ye, useInsertionEffect: Ye, useLayoutEffect: Ye, useMemo: Ye, useReducer: Ye, useRef: Ye, useState: Ye, useDebugValue: Ye, useDeferredValue: Ye, useTransition: Ye, useMutableSource: Ye, useSyncExternalStore: Ye, useId: Ye, unstable_isNewReconciler: !1 }, q2 = { readContext: Ot, useCallback: function (e, t) { return Qt().memoizedState = [e, t === void 0 ? null : t], e }, useContext: Ot, useEffect: lh, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, Fs(4194308, 4, dg.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return Fs(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return Fs(4, 2, e, t) }, useMemo: function (e, t) { var n = Qt(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = Qt(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = W2.bind(null, ke, e), [r.memoizedState, e] }, useRef: function (e) { var t = Qt(); return e = { current: e }, t.memoizedState = e }, useState: oh, useDebugValue: Af, useDeferredValue: function (e) { return Qt().memoizedState = e }, useTransition: function () { var e = oh(!1), t = e[0]; return e = Y2.bind(null, e[1]), Qt().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = ke, i = Qt(); if (_e) { if (n === void 0) throw Error(z(407)); n = n() } else { if (n = t(), He === null) throw Error(z(349)); gr & 30 || ig(r, t, n) } i.memoizedState = n; var u = { value: n, getSnapshot: t }; return i.queue = u, lh(sg.bind(null, r, u, e), [e]), r.flags |= 2048, Ru(9, ug.bind(null, r, u, n, t), void 0, null), n }, useId: function () { var e = Qt(), t = He.identifierPrefix; if (_e) { var n = dn, r = fn; n = (r & ~(1 << 32 - Ht(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = Ou++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = V2++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, Q2 = { readContext: Ot, useCallback: pg, useContext: Ot, useEffect: Cf, useImperativeHandle: hg, useInsertionEffect: cg, useLayoutEffect: fg, useMemo: mg, useReducer: Fo, useRef: lg, useState: function () { return Fo(Lu) }, useDebugValue: Af, useDeferredValue: function (e) { var t = Lt(); return gg(t, De.memoizedState, e) }, useTransition: function () { var e = Fo(Lu)[0], t = Lt().memoizedState; return [e, t] }, useMutableSource: ng, useSyncExternalStore: rg, useId: Eg, unstable_isNewReconciler: !1 }, G2 = { readContext: Ot, useCallback: pg, useContext: Ot, useEffect: Cf, useImperativeHandle: hg, useInsertionEffect: cg, useLayoutEffect: fg, useMemo: mg, useReducer: Bo, useRef: lg, useState: function () { return Bo(Lu) }, useDebugValue: Af, useDeferredValue: function (e) { var t = Lt(); return De === null ? t.memoizedState = e : gg(t, De.memoizedState, e) }, useTransition: function () { var e = Bo(Lu)[0], t = Lt().memoizedState; return [e, t] }, useMutableSource: ng, useSyncExternalStore: rg, useId: Eg, unstable_isNewReconciler: !1 }; function Dt(e, t) { if (e && e.defaultProps) { t = Ne({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function Ql(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : Ne({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var za = { isMounted: function (e) { return (e = e._reactInternals) ? _r(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = tt(), i = Hn(e), u = hn(r, i); u.payload = t, n != null && (u.callback = n), t = Bn(e, u, i), t !== null && (zt(t, e, i, r), Ds(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = tt(), i = Hn(e), u = hn(r, i); u.tag = 1, u.payload = t, n != null && (u.callback = n), t = Bn(e, u, i), t !== null && (zt(t, e, i, r), Ds(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = tt(), r = Hn(e), i = hn(n, r); i.tag = 2, t != null && (i.callback = t), t = Bn(e, i, r), t !== null && (zt(t, e, r, n), Ds(t, e, r)) } }; function ch(e, t, n, r, i, u, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, u, s) : t.prototype && t.prototype.isPureReactComponent ? !Au(n, r) || !Au(i, u) : !0 } function xg(e, t, n) { var r = !1, i = Vn, u = t.contextType; return typeof u == "object" && u !== null ? u = Ot(u) : (i = ct(t) ? pr : Ge.current, r = t.contextTypes, u = (r = r != null) ? ii(e, i) : Vn), t = new t(n, u), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = za, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = u), t } function fh(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && za.enqueueReplaceState(t, t.state, null) } function Gl(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = {}, Ef(e); var u = t.contextType; typeof u == "object" && u !== null ? i.context = Ot(u) : (u = ct(t) ? pr : Ge.current, i.context = ii(e, u)), i.state = e.memoizedState, u = t.getDerivedStateFromProps, typeof u == "function" && (Ql(e, t, u, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && za.enqueueReplaceState(i, i.state, null), ha(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function oi(e, t) {
        try { var n = "", r = t; do n += Cy(r), r = r.return; while (r); var i = n } catch (u) {
          i = `
Error generating stack: `+ u.message + `
`+ u.stack
        } return { value: e, source: t, stack: i, digest: null }
      } function Uo(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function Xl(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var X2 = typeof WeakMap == "function" ? WeakMap : Map; function Sg(e, t, n) { n = hn(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { Ta || (Ta = !0, ac = r), Xl(e, t) }, n } function _g(e, t, n) { n = hn(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { Xl(e, t) } } var u = e.stateNode; return u !== null && typeof u.componentDidCatch == "function" && (n.callback = function () { Xl(e, t), typeof r != "function" && (Un === null ? Un = new Set([this]) : Un.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function dh(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new X2; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = fb.bind(null, e, t, n), t.then(e, e)) } function hh(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function ph(e, t, n, r, i) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = hn(-1, 1), t.tag = 2, Bn(n, t, 1))), n.lanes |= 1), e) } var J2 = Tn.ReactCurrentOwner, ot = !1; function Ze(e, t, n, r) { t.child = e === null ? Jm(t, null, n, r) : si(t, e.child, n, r) } function mh(e, t, n, r, i) { n = n.render; var u = t.ref; return Jr(t, i), r = Sf(e, t, n, r, u, i), n = _f(), e !== null && !ot ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, En(e, t, i)) : (_e && n && cf(t), t.flags |= 1, Ze(e, t, r, i), t.child) } function gh(e, t, n, r, i) { if (e === null) { var u = n.type; return typeof u == "function" && !Rf(u) && u.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = u, Cg(e, t, u, r, i)) : (e = zs(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (u = e.child, !(e.lanes & i)) { var s = u.memoizedProps; if (n = n.compare, n = n !== null ? n : Au, n(s, r) && e.ref === t.ref) return En(e, t, i) } return t.flags |= 1, e = zn(u, r), e.ref = t.ref, e.return = t, t.child = e } function Cg(e, t, n, r, i) { if (e !== null) { var u = e.memoizedProps; if (Au(u, r) && e.ref === t.ref) if (ot = !1, t.pendingProps = r = u, (e.lanes & i) !== 0) e.flags & 131072 && (ot = !0); else return t.lanes = e.lanes, En(e, t, i) } return Jl(e, t, n, r, i) } function Ag(e, t, n) { var r = t.pendingProps, i = r.children, u = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, Te(Wr, Et), Et |= n; else { if (!(n & 1073741824)) return e = u !== null ? u.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, Te(Wr, Et), Et |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = u !== null ? u.baseLanes : n, Te(Wr, Et), Et |= r } else u !== null ? (r = u.baseLanes | n, t.memoizedState = null) : r = n, Te(Wr, Et), Et |= r; return Ze(e, t, i, n), t.child } function kg(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function Jl(e, t, n, r, i) { var u = ct(n) ? pr : Ge.current; return u = ii(t, u), Jr(t, i), n = Sf(e, t, n, r, u, i), r = _f(), e !== null && !ot ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, En(e, t, i)) : (_e && r && cf(t), t.flags |= 1, Ze(e, t, n, i), t.child) } function Eh(e, t, n, r, i) { if (ct(n)) { var u = !0; oa(t) } else u = !1; if (Jr(t, i), t.stateNode === null) Bs(e, t), xg(t, n, r), Gl(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var o = s.context, l = n.contextType; typeof l == "object" && l !== null ? l = Ot(l) : (l = ct(n) ? pr : Ge.current, l = ii(t, l)); var f = n.getDerivedStateFromProps, d = typeof f == "function" || typeof s.getSnapshotBeforeUpdate == "function"; d || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || o !== l) && fh(t, s, r, l), Nn = !1; var p = t.memoizedState; s.state = p, ha(t, r, s, i), o = t.memoizedState, a !== r || p !== o || lt.current || Nn ? (typeof f == "function" && (Ql(t, n, f, r), o = t.memoizedState), (a = Nn || ch(t, n, a, r, p, o, l)) ? (d || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = o), s.props = r, s.state = o, s.context = l, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, eg(e, t), a = t.memoizedProps, l = t.type === t.elementType ? a : Dt(t.type, a), s.props = l, d = t.pendingProps, p = s.context, o = n.contextType, typeof o == "object" && o !== null ? o = Ot(o) : (o = ct(n) ? pr : Ge.current, o = ii(t, o)); var h = n.getDerivedStateFromProps; (f = typeof h == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== d || p !== o) && fh(t, s, r, o), Nn = !1, p = t.memoizedState, s.state = p, ha(t, r, s, i); var m = t.memoizedState; a !== d || p !== m || lt.current || Nn ? (typeof h == "function" && (Ql(t, n, h, r), m = t.memoizedState), (l = Nn || ch(t, n, l, r, p, m, o) || !1) ? (f || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, m, o), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, m, o)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && p === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && p === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = m), s.props = r, s.state = m, s.context = o, r = l) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && p === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && p === e.memoizedState || (t.flags |= 1024), r = !1) } return Zl(e, t, n, r, u, i) } function Zl(e, t, n, r, i, u) { kg(e, t); var s = (t.flags & 128) !== 0; if (!r && !s) return i && nh(t, n, !1), En(e, t, u); r = t.stateNode, J2.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = si(t, e.child, null, u), t.child = si(t, null, a, u)) : Ze(e, t, a, u), t.memoizedState = r.state, i && nh(t, n, !0), t.child } function Ng(e) { var t = e.stateNode; t.pendingContext ? th(e, t.pendingContext, t.pendingContext !== t.context) : t.context && th(e, t.context, !1), Tf(e, t.containerInfo) } function Th(e, t, n, r, i) { return ui(), df(i), t.flags |= 256, Ze(e, t, n, r), t.child } var ec = { dehydrated: null, treeContext: null, retryLane: 0 }; function tc(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Ig(e, t, n) { var r = t.pendingProps, i = Ae.current, u = !1, s = (t.flags & 128) !== 0, a; if ((a = s) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (u = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), Te(Ae, i & 1), e === null) return Kl(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (s = r.children, e = r.fallback, u ? (r = t.mode, u = t.child, s = { mode: "hidden", children: s }, !(r & 1) && u !== null ? (u.childLanes = 0, u.pendingProps = s) : u = Va(s, r, 0, null), e = fr(e, r, n, null), u.return = t, e.return = t, u.sibling = e, t.child = u, t.child.memoizedState = tc(n), t.memoizedState = ec, e) : kf(t, s)); if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return Z2(e, t, s, r, a, i, n); if (u) { u = r.fallback, s = t.mode, i = e.child, a = i.sibling; var o = { mode: "hidden", children: r.children }; return !(s & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = o, t.deletions = null) : (r = zn(i, o), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? u = zn(a, u) : (u = fr(u, s, n, null), u.flags |= 2), u.return = t, r.return = t, r.sibling = u, t.child = r, r = u, u = t.child, s = e.child.memoizedState, s = s === null ? tc(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, u.memoizedState = s, u.childLanes = e.childLanes & ~n, t.memoizedState = ec, r } return u = e.child, e = u.sibling, r = zn(u, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function kf(e, t) { return t = Va({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function Ts(e, t, n, r) { return r !== null && df(r), si(t, e.child, null, n), e = kf(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function Z2(e, t, n, r, i, u, s) { if (n) return t.flags & 256 ? (t.flags &= -257, r = Uo(Error(z(422))), Ts(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (u = r.fallback, i = t.mode, r = Va({ mode: "visible", children: r.children }, i, 0, null), u = fr(u, i, s, null), u.flags |= 2, r.return = t, u.return = t, r.sibling = u, t.child = r, t.mode & 1 && si(t, e.child, null, s), t.child.memoizedState = tc(s), t.memoizedState = ec, u); if (!(t.mode & 1)) return Ts(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, u = Error(z(419)), r = Uo(u, r, void 0), Ts(e, t, s, r) } if (a = (s & e.childLanes) !== 0, ot || a) { if (r = He, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== u.retryLane && (u.retryLane = i, gn(e, i), zt(r, e, i, -1)) } return Lf(), r = Uo(Error(z(421))), Ts(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = db.bind(null, e), i._reactRetry = t, null) : (e = u.treeContext, Tt = Fn(i.nextSibling), yt = t, _e = !0, Ft = null, e !== null && (At[kt++] = fn, At[kt++] = dn, At[kt++] = mr, fn = e.id, dn = e.overflow, mr = t), t = kf(t, r.children), t.flags |= 4096, t) } function yh(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), ql(e.return, t, n) } function Ho(e, t, n, r, i) { var u = e.memoizedState; u === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (u.isBackwards = t, u.rendering = null, u.renderingStartTime = 0, u.last = r, u.tail = n, u.tailMode = i) } function wg(e, t, n) { var r = t.pendingProps, i = r.revealOrder, u = r.tail; if (Ze(e, t, r.children, n), r = Ae.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && yh(e, n, t); else if (e.tag === 19) yh(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (Te(Ae, r), !(t.mode & 1)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && pa(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), Ho(t, !1, i, n, u); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && pa(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } Ho(t, !0, n, null, u); break; case "together": Ho(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Bs(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function En(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Er |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(z(153)); if (t.child !== null) { for (e = t.child, n = zn(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = zn(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function eb(e, t, n) { switch (t.tag) { case 3: Ng(t), ui(); break; case 5: tg(t); break; case 1: ct(t.type) && oa(t); break; case 4: Tf(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; Te(fa, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (Te(Ae, Ae.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Ig(e, t, n) : (Te(Ae, Ae.current & 1), e = En(e, t, n), e !== null ? e.sibling : null); Te(Ae, Ae.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return wg(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), Te(Ae, Ae.current), r) break; return null; case 22: case 23: return t.lanes = 0, Ag(e, t, n) }return En(e, t, n) } var vg, nc, Og, Lg; vg = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; nc = function () { }; Og = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, sr(tn.current); var u = null; switch (n) { case "input": i = Cl(e, i), r = Cl(e, r), u = []; break; case "select": i = Ne({}, i, { value: void 0 }), r = Ne({}, r, { value: void 0 }), u = []; break; case "textarea": i = Nl(e, i), r = Nl(e, r), u = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = sa) }wl(n, r); var s; n = null; for (l in i) if (!r.hasOwnProperty(l) && i.hasOwnProperty(l) && i[l] != null) if (l === "style") { var a = i[l]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else l !== "dangerouslySetInnerHTML" && l !== "children" && l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && l !== "autoFocus" && (Tu.hasOwnProperty(l) ? u || (u = []) : (u = u || []).push(l, null)); for (l in r) { var o = r[l]; if (a = i != null ? i[l] : void 0, r.hasOwnProperty(l) && o !== a && (o != null || a != null)) if (l === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || o && o.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in o) o.hasOwnProperty(s) && a[s] !== o[s] && (n || (n = {}), n[s] = o[s]) } else n || (u || (u = []), u.push(l, n)), n = o; else l === "dangerouslySetInnerHTML" ? (o = o ? o.__html : void 0, a = a ? a.__html : void 0, o != null && a !== o && (u = u || []).push(l, o)) : l === "children" ? typeof o != "string" && typeof o != "number" || (u = u || []).push(l, "" + o) : l !== "suppressContentEditableWarning" && l !== "suppressHydrationWarning" && (Tu.hasOwnProperty(l) ? (o != null && l === "onScroll" && be("scroll", e), u || a === o || (u = [])) : (u = u || []).push(l, o)) } n && (u = u || []).push("style", n); var l = u; (t.updateQueue = l) && (t.flags |= 4) } }; Lg = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function Di(e, t) { if (!_e) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function We(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function tb(e, t, n) { var r = t.pendingProps; switch (ff(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return We(t), null; case 1: return ct(t.type) && aa(), We(t), null; case 3: return r = t.stateNode, ai(), xe(lt), xe(Ge), bf(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (gs(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, Ft !== null && (cc(Ft), Ft = null))), nc(e, t), We(t), null; case 5: yf(t); var i = sr(vu.current); if (n = t.type, e !== null && t.stateNode != null) Og(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(z(166)); return We(t), null } if (e = sr(tn.current), gs(t)) { r = t.stateNode, n = t.type; var u = t.memoizedProps; switch (r[Jt] = t, r[Iu] = u, e = (t.mode & 1) !== 0, n) { case "dialog": be("cancel", r), be("close", r); break; case "iframe": case "object": case "embed": be("load", r); break; case "video": case "audio": for (i = 0; i < qi.length; i++)be(qi[i], r); break; case "source": be("error", r); break; case "img": case "image": case "link": be("error", r), be("load", r); break; case "details": be("toggle", r); break; case "input": Id(r, u), be("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!u.multiple }, be("invalid", r); break; case "textarea": vd(r, u), be("invalid", r) }wl(n, u), i = null; for (var s in u) if (u.hasOwnProperty(s)) { var a = u[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (u.suppressHydrationWarning !== !0 && ms(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (u.suppressHydrationWarning !== !0 && ms(r.textContent, a, e), i = ["children", "" + a]) : Tu.hasOwnProperty(s) && a != null && s === "onScroll" && be("scroll", r) } switch (n) { case "input": as(r), wd(r, u, !0); break; case "textarea": as(r), Od(r); break; case "select": case "option": break; default: typeof u.onClick == "function" && (r.onclick = sa) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = sm(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[Jt] = t, e[Iu] = r, vg(e, t, !1, !1), t.stateNode = e; e: { switch (s = vl(n, r), n) { case "dialog": be("cancel", e), be("close", e), i = r; break; case "iframe": case "object": case "embed": be("load", e), i = r; break; case "video": case "audio": for (i = 0; i < qi.length; i++)be(qi[i], e); i = r; break; case "source": be("error", e), i = r; break; case "img": case "image": case "link": be("error", e), be("load", e), i = r; break; case "details": be("toggle", e), i = r; break; case "input": Id(e, r), i = Cl(e, r), be("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = Ne({}, r, { value: void 0 }), be("invalid", e); break; case "textarea": vd(e, r), i = Nl(e, r), be("invalid", e); break; default: i = r }wl(n, i), a = i; for (u in a) if (a.hasOwnProperty(u)) { var o = a[u]; u === "style" ? lm(e, o) : u === "dangerouslySetInnerHTML" ? (o = o ? o.__html : void 0, o != null && am(e, o)) : u === "children" ? typeof o == "string" ? (n !== "textarea" || o !== "") && yu(e, o) : typeof o == "number" && yu(e, "" + o) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (Tu.hasOwnProperty(u) ? o != null && u === "onScroll" && be("scroll", e) : o != null && Qc(e, u, o, s)) } switch (n) { case "input": as(e), wd(e, r, !1); break; case "textarea": as(e), Od(e); break; case "option": r.value != null && e.setAttribute("value", "" + $n(r.value)); break; case "select": e.multiple = !!r.multiple, u = r.value, u != null ? qr(e, !!r.multiple, u, !1) : r.defaultValue != null && qr(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = sa) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return We(t), null; case 6: if (e && t.stateNode != null) Lg(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(z(166)); if (n = sr(vu.current), sr(tn.current), gs(t)) { if (r = t.stateNode, n = t.memoizedProps, r[Jt] = t, (u = r.nodeValue !== n) && (e = yt, e !== null)) switch (e.tag) { case 3: ms(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && ms(r.nodeValue, n, (e.mode & 1) !== 0) }u && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[Jt] = t, t.stateNode = r } return We(t), null; case 13: if (xe(Ae), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (_e && Tt !== null && t.mode & 1 && !(t.flags & 128)) Gm(), ui(), t.flags |= 98560, u = !1; else if (u = gs(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!u) throw Error(z(318)); if (u = t.memoizedState, u = u !== null ? u.dehydrated : null, !u) throw Error(z(317)); u[Jt] = t } else ui(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; We(t), u = !1 } else Ft !== null && (cc(Ft), Ft = null), u = !0; if (!u) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || Ae.current & 1 ? Me === 0 && (Me = 3) : Lf())), t.updateQueue !== null && (t.flags |= 4), We(t), null); case 4: return ai(), nc(e, t), e === null && ku(t.stateNode.containerInfo), We(t), null; case 10: return mf(t.type._context), We(t), null; case 17: return ct(t.type) && aa(), We(t), null; case 19: if (xe(Ae), u = t.memoizedState, u === null) return We(t), null; if (r = (t.flags & 128) !== 0, s = u.rendering, s === null) if (r) Di(u, !1); else { if (Me !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (s = pa(e), s !== null) { for (t.flags |= 128, Di(u, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)u = n, e = r, u.flags &= 14680066, s = u.alternate, s === null ? (u.childLanes = 0, u.lanes = e, u.child = null, u.subtreeFlags = 0, u.memoizedProps = null, u.memoizedState = null, u.updateQueue = null, u.dependencies = null, u.stateNode = null) : (u.childLanes = s.childLanes, u.lanes = s.lanes, u.child = s.child, u.subtreeFlags = 0, u.deletions = null, u.memoizedProps = s.memoizedProps, u.memoizedState = s.memoizedState, u.updateQueue = s.updateQueue, u.type = s.type, e = s.dependencies, u.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return Te(Ae, Ae.current & 1 | 2), t.child } e = e.sibling } u.tail !== null && we() > li && (t.flags |= 128, r = !0, Di(u, !1), t.lanes = 4194304) } else { if (!r) if (e = pa(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Di(u, !0), u.tail === null && u.tailMode === "hidden" && !s.alternate && !_e) return We(t), null } else 2 * we() - u.renderingStartTime > li && n !== 1073741824 && (t.flags |= 128, r = !0, Di(u, !1), t.lanes = 4194304); u.isBackwards ? (s.sibling = t.child, t.child = s) : (n = u.last, n !== null ? n.sibling = s : t.child = s, u.last = s) } return u.tail !== null ? (t = u.tail, u.rendering = t, u.tail = t.sibling, u.renderingStartTime = we(), t.sibling = null, n = Ae.current, Te(Ae, r ? n & 1 | 2 : n & 1), t) : (We(t), null); case 22: case 23: return Of(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Et & 1073741824 && (We(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : We(t), null; case 24: return null; case 25: return null }throw Error(z(156, t.tag)) } function nb(e, t) { switch (ff(t), t.tag) { case 1: return ct(t.type) && aa(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return ai(), xe(lt), xe(Ge), bf(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return yf(t), null; case 13: if (xe(Ae), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(z(340)); ui() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return xe(Ae), null; case 4: return ai(), null; case 10: return mf(t.type._context), null; case 22: case 23: return Of(), null; case 24: return null; default: return null } } var ys = !1, Ke = !1, rb = typeof WeakSet == "function" ? WeakSet : Set, Q = null; function Yr(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { Ie(e, t, r) } else n.current = null } function rc(e, t, n) { try { n() } catch (r) { Ie(e, t, r) } } var bh = !1; function ib(e, t) { if (Hl = ra, e = Fm(), lf(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, u = r.focusNode; r = r.focusOffset; try { n.nodeType, u.nodeType } catch { n = null; break e } var s = 0, a = -1, o = -1, l = 0, f = 0, d = e, p = null; t: for (; ;) { for (var h; d !== n || i !== 0 && d.nodeType !== 3 || (a = s + i), d !== u || r !== 0 && d.nodeType !== 3 || (o = s + r), d.nodeType === 3 && (s += d.nodeValue.length), (h = d.firstChild) !== null;)p = d, d = h; for (; ;) { if (d === e) break t; if (p === n && ++l === i && (a = s), p === u && ++f === r && (o = s), (h = d.nextSibling) !== null) break; d = p, p = d.parentNode } d = h } n = a === -1 || o === -1 ? null : { start: a, end: o } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (zl = { focusedElem: e, selectionRange: n }, ra = !1, Q = t; Q !== null;)if (t = Q, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, Q = e; else for (; Q !== null;) { t = Q; try { var m = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (m !== null) { var T = m.memoizedProps, _ = m.memoizedState, g = t.stateNode, E = g.getSnapshotBeforeUpdate(t.elementType === t.type ? T : Dt(t.type, T), _); g.__reactInternalSnapshotBeforeUpdate = E } break; case 3: var y = t.stateNode.containerInfo; y.nodeType === 1 ? y.textContent = "" : y.nodeType === 9 && y.documentElement && y.removeChild(y.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(z(163)) } } catch (I) { Ie(t, t.return, I) } if (e = t.sibling, e !== null) { e.return = t.return, Q = e; break } Q = t.return } return m = bh, bh = !1, m } function ru(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var u = i.destroy; i.destroy = void 0, u !== void 0 && rc(t, n, u) } i = i.next } while (i !== r) } } function ja(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function ic(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function Rg(e) { var t = e.alternate; t !== null && (e.alternate = null, Rg(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[Jt], delete t[Iu], delete t[Vl], delete t[H2], delete t[z2])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function Pg(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function xh(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || Pg(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function uc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = sa)); else if (r !== 4 && (e = e.child, e !== null)) for (uc(e, t, n), e = e.sibling; e !== null;)uc(e, t, n), e = e.sibling } function sc(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (sc(e, t, n), e = e.sibling; e !== null;)sc(e, t, n), e = e.sibling } var je = null, Mt = !1; function Sn(e, t, n) { for (n = n.child; n !== null;)Dg(e, t, n), n = n.sibling } function Dg(e, t, n) { if (en && typeof en.onCommitFiberUnmount == "function") try { en.onCommitFiberUnmount(Pa, n) } catch { } switch (n.tag) { case 5: Ke || Yr(n, t); case 6: var r = je, i = Mt; je = null, Sn(e, t, n), je = r, Mt = i, je !== null && (Mt ? (e = je, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : je.removeChild(n.stateNode)); break; case 18: je !== null && (Mt ? (e = je, n = n.stateNode, e.nodeType === 8 ? Ro(e.parentNode, n) : e.nodeType === 1 && Ro(e, n), _u(e)) : Ro(je, n.stateNode)); break; case 4: r = je, i = Mt, je = n.stateNode.containerInfo, Mt = !0, Sn(e, t, n), je = r, Mt = i; break; case 0: case 11: case 14: case 15: if (!Ke && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var u = i, s = u.destroy; u = u.tag, s !== void 0 && (u & 2 || u & 4) && rc(n, t, s), i = i.next } while (i !== r) } Sn(e, t, n); break; case 1: if (!Ke && (Yr(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { Ie(n, t, a) } Sn(e, t, n); break; case 21: Sn(e, t, n); break; case 22: n.mode & 1 ? (Ke = (r = Ke) || n.memoizedState !== null, Sn(e, t, n), Ke = r) : Sn(e, t, n); break; default: Sn(e, t, n) } } function Sh(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new rb), t.forEach(function (r) { var i = hb.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function Pt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var u = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: je = a.stateNode, Mt = !1; break e; case 3: je = a.stateNode.containerInfo, Mt = !0; break e; case 4: je = a.stateNode.containerInfo, Mt = !0; break e }a = a.return } if (je === null) throw Error(z(160)); Dg(u, s, i), je = null, Mt = !1; var o = i.alternate; o !== null && (o.return = null), i.return = null } catch (l) { Ie(i, t, l) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)Mg(t, e), t = t.sibling } function Mg(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (Pt(t, e), Kt(e), r & 4) { try { ru(3, e, e.return), ja(3, e) } catch (T) { Ie(e, e.return, T) } try { ru(5, e, e.return) } catch (T) { Ie(e, e.return, T) } } break; case 1: Pt(t, e), Kt(e), r & 512 && n !== null && Yr(n, n.return); break; case 5: if (Pt(t, e), Kt(e), r & 512 && n !== null && Yr(n, n.return), e.flags & 32) { var i = e.stateNode; try { yu(i, "") } catch (T) { Ie(e, e.return, T) } } if (r & 4 && (i = e.stateNode, i != null)) { var u = e.memoizedProps, s = n !== null ? n.memoizedProps : u, a = e.type, o = e.updateQueue; if (e.updateQueue = null, o !== null) try { a === "input" && u.type === "radio" && u.name != null && im(i, u), vl(a, s); var l = vl(a, u); for (s = 0; s < o.length; s += 2) { var f = o[s], d = o[s + 1]; f === "style" ? lm(i, d) : f === "dangerouslySetInnerHTML" ? am(i, d) : f === "children" ? yu(i, d) : Qc(i, f, d, l) } switch (a) { case "input": Al(i, u); break; case "textarea": um(i, u); break; case "select": var p = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!u.multiple; var h = u.value; h != null ? qr(i, !!u.multiple, h, !1) : p !== !!u.multiple && (u.defaultValue != null ? qr(i, !!u.multiple, u.defaultValue, !0) : qr(i, !!u.multiple, u.multiple ? [] : "", !1)) }i[Iu] = u } catch (T) { Ie(e, e.return, T) } } break; case 6: if (Pt(t, e), Kt(e), r & 4) { if (e.stateNode === null) throw Error(z(162)); i = e.stateNode, u = e.memoizedProps; try { i.nodeValue = u } catch (T) { Ie(e, e.return, T) } } break; case 3: if (Pt(t, e), Kt(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { _u(t.containerInfo) } catch (T) { Ie(e, e.return, T) } break; case 4: Pt(t, e), Kt(e); break; case 13: Pt(t, e), Kt(e), i = e.child, i.flags & 8192 && (u = i.memoizedState !== null, i.stateNode.isHidden = u, !u || i.alternate !== null && i.alternate.memoizedState !== null || (wf = we())), r & 4 && Sh(e); break; case 22: if (f = n !== null && n.memoizedState !== null, e.mode & 1 ? (Ke = (l = Ke) || f, Pt(t, e), Ke = l) : Pt(t, e), Kt(e), r & 8192) { if (l = e.memoizedState !== null, (e.stateNode.isHidden = l) && !f && e.mode & 1) for (Q = e, f = e.child; f !== null;) { for (d = Q = f; Q !== null;) { switch (p = Q, h = p.child, p.tag) { case 0: case 11: case 14: case 15: ru(4, p, p.return); break; case 1: Yr(p, p.return); var m = p.stateNode; if (typeof m.componentWillUnmount == "function") { r = p, n = p.return; try { t = r, m.props = t.memoizedProps, m.state = t.memoizedState, m.componentWillUnmount() } catch (T) { Ie(r, n, T) } } break; case 5: Yr(p, p.return); break; case 22: if (p.memoizedState !== null) { Ch(d); continue } }h !== null ? (h.return = p, Q = h) : Ch(d) } f = f.sibling } e: for (f = null, d = e; ;) { if (d.tag === 5) { if (f === null) { f = d; try { i = d.stateNode, l ? (u = i.style, typeof u.setProperty == "function" ? u.setProperty("display", "none", "important") : u.display = "none") : (a = d.stateNode, o = d.memoizedProps.style, s = o != null && o.hasOwnProperty("display") ? o.display : null, a.style.display = om("display", s)) } catch (T) { Ie(e, e.return, T) } } } else if (d.tag === 6) { if (f === null) try { d.stateNode.nodeValue = l ? "" : d.memoizedProps } catch (T) { Ie(e, e.return, T) } } else if ((d.tag !== 22 && d.tag !== 23 || d.memoizedState === null || d === e) && d.child !== null) { d.child.return = d, d = d.child; continue } if (d === e) break e; for (; d.sibling === null;) { if (d.return === null || d.return === e) break e; f === d && (f = null), d = d.return } f === d && (f = null), d.sibling.return = d.return, d = d.sibling } } break; case 19: Pt(t, e), Kt(e), r & 4 && Sh(e); break; case 21: break; default: Pt(t, e), Kt(e) } } function Kt(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (Pg(n)) { var r = n; break e } n = n.return } throw Error(z(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (yu(i, ""), r.flags &= -33); var u = xh(e); sc(e, u, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = xh(e); uc(e, a, s); break; default: throw Error(z(161)) } } catch (o) { Ie(e, e.return, o) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function ub(e, t, n) { Q = e, Fg(e) } function Fg(e, t, n) { for (var r = (e.mode & 1) !== 0; Q !== null;) { var i = Q, u = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || ys; if (!s) { var a = i.alternate, o = a !== null && a.memoizedState !== null || Ke; a = ys; var l = Ke; if (ys = s, (Ke = o) && !l) for (Q = i; Q !== null;)s = Q, o = s.child, s.tag === 22 && s.memoizedState !== null ? Ah(i) : o !== null ? (o.return = s, Q = o) : Ah(i); for (; u !== null;)Q = u, Fg(u), u = u.sibling; Q = i, ys = a, Ke = l } _h(e) } else i.subtreeFlags & 8772 && u !== null ? (u.return = i, Q = u) : _h(e) } } function _h(e) { for (; Q !== null;) { var t = Q; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: Ke || ja(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !Ke) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : Dt(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var u = t.updateQueue; u !== null && ah(t, u, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }ah(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var o = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": o.autoFocus && n.focus(); break; case "img": o.src && (n.src = o.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var l = t.alternate; if (l !== null) { var f = l.memoizedState; if (f !== null) { var d = f.dehydrated; d !== null && _u(d) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(z(163)) }Ke || t.flags & 512 && ic(t) } catch (p) { Ie(t, t.return, p) } } if (t === e) { Q = null; break } if (n = t.sibling, n !== null) { n.return = t.return, Q = n; break } Q = t.return } } function Ch(e) { for (; Q !== null;) { var t = Q; if (t === e) { Q = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, Q = n; break } Q = t.return } } function Ah(e) { for (; Q !== null;) { var t = Q; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { ja(4, t) } catch (o) { Ie(t, n, o) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (o) { Ie(t, i, o) } } var u = t.return; try { ic(t) } catch (o) { Ie(t, u, o) } break; case 5: var s = t.return; try { ic(t) } catch (o) { Ie(t, s, o) } } } catch (o) { Ie(t, t.return, o) } if (t === e) { Q = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, Q = a; break } Q = t.return } } var sb = Math.ceil, Ea = Tn.ReactCurrentDispatcher, Nf = Tn.ReactCurrentOwner, vt = Tn.ReactCurrentBatchConfig, de = 0, He = null, Pe = null, $e = 0, Et = 0, Wr = Wn(0), Me = 0, Pu = null, Er = 0, $a = 0, If = 0, iu = null, at = null, wf = 0, li = 1 / 0, on = null, Ta = !1, ac = null, Un = null, bs = !1, On = null, ya = 0, uu = 0, oc = null, Us = -1, Hs = 0; function tt() { return de & 6 ? we() : Us !== -1 ? Us : Us = we() } function Hn(e) { return e.mode & 1 ? de & 2 && $e !== 0 ? $e & -$e : $2.transition !== null ? (Hs === 0 && (Hs = xm()), Hs) : (e = he, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Im(e.type)), e) : 1 } function zt(e, t, n, r) { if (50 < uu) throw uu = 0, oc = null, Error(z(185)); $u(e, n, r), (!(de & 2) || e !== He) && (e === He && (!(de & 2) && ($a |= n), Me === 4 && wn(e, $e)), ft(e, r), n === 1 && de === 0 && !(t.mode & 1) && (li = we() + 500, Ua && Kn())) } function ft(e, t) { var n = e.callbackNode; $y(e, t); var r = na(e, e === He ? $e : 0); if (r === 0) n !== null && Pd(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && Pd(n), t === 1) e.tag === 0 ? j2(kh.bind(null, e)) : Km(kh.bind(null, e)), B2(function () { !(de & 6) && Kn() }), n = null; else { switch (Sm(r)) { case 1: n = ef; break; case 4: n = ym; break; case 16: n = ta; break; case 536870912: n = bm; break; default: n = ta }n = Yg(n, Bg.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function Bg(e, t) { if (Us = -1, Hs = 0, de & 6) throw Error(z(327)); var n = e.callbackNode; if (Zr() && e.callbackNode !== n) return null; var r = na(e, e === He ? $e : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = ba(e, r); else { t = r; var i = de; de |= 2; var u = Hg(); (He !== e || $e !== t) && (on = null, li = we() + 500, cr(e, t)); do try { lb(); break } catch (a) { Ug(e, a) } while (!0); pf(), Ea.current = u, de = i, Pe !== null ? t = 0 : (He = null, $e = 0, t = Me) } if (t !== 0) { if (t === 2 && (i = Dl(e), i !== 0 && (r = i, t = lc(e, i))), t === 1) throw n = Pu, cr(e, 0), wn(e, r), ft(e, we()), n; if (t === 6) wn(e, r); else { if (i = e.current.alternate, !(r & 30) && !ab(i) && (t = ba(e, r), t === 2 && (u = Dl(e), u !== 0 && (r = u, t = lc(e, u))), t === 1)) throw n = Pu, cr(e, 0), wn(e, r), ft(e, we()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(z(345)); case 2: er(e, at, on); break; case 3: if (wn(e, r), (r & 130023424) === r && (t = wf + 500 - we(), 10 < t)) { if (na(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { tt(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = $l(er.bind(null, e, at, on), t); break } er(e, at, on); break; case 4: if (wn(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - Ht(r); u = 1 << s, s = t[s], s > i && (i = s), r &= ~u } if (r = i, r = we() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * sb(r / 1960)) - r, 10 < r) { e.timeoutHandle = $l(er.bind(null, e, at, on), r); break } er(e, at, on); break; case 5: er(e, at, on); break; default: throw Error(z(329)) } } } return ft(e, we()), e.callbackNode === n ? Bg.bind(null, e) : null } function lc(e, t) { var n = iu; return e.current.memoizedState.isDehydrated && (cr(e, t).flags |= 256), e = ba(e, t), e !== 2 && (t = at, at = n, t !== null && cc(t)), e } function cc(e) { at === null ? at = e : at.push.apply(at, e) } function ab(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], u = i.getSnapshot; i = i.value; try { if (!$t(u(), i)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function wn(e, t) { for (t &= ~If, t &= ~$a, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - Ht(t), r = 1 << n; e[n] = -1, t &= ~r } } function kh(e) { if (de & 6) throw Error(z(327)); Zr(); var t = na(e, 0); if (!(t & 1)) return ft(e, we()), null; var n = ba(e, t); if (e.tag !== 0 && n === 2) { var r = Dl(e); r !== 0 && (t = r, n = lc(e, r)) } if (n === 1) throw n = Pu, cr(e, 0), wn(e, t), ft(e, we()), n; if (n === 6) throw Error(z(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, er(e, at, on), ft(e, we()), null } function vf(e, t) { var n = de; de |= 1; try { return e(t) } finally { de = n, de === 0 && (li = we() + 500, Ua && Kn()) } } function Tr(e) { On !== null && On.tag === 0 && !(de & 6) && Zr(); var t = de; de |= 1; var n = vt.transition, r = he; try { if (vt.transition = null, he = 1, e) return e() } finally { he = r, vt.transition = n, de = t, !(de & 6) && Kn() } } function Of() { Et = Wr.current, xe(Wr) } function cr(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, F2(n)), Pe !== null) for (n = Pe.return; n !== null;) { var r = n; switch (ff(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && aa(); break; case 3: ai(), xe(lt), xe(Ge), bf(); break; case 5: yf(r); break; case 4: ai(); break; case 13: xe(Ae); break; case 19: xe(Ae); break; case 10: mf(r.type._context); break; case 22: case 23: Of() }n = n.return } if (He = e, Pe = e = zn(e.current, null), $e = Et = t, Me = 0, Pu = null, If = $a = Er = 0, at = iu = null, ur !== null) { for (t = 0; t < ur.length; t++)if (n = ur[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, u = n.pending; if (u !== null) { var s = u.next; u.next = i, r.next = s } n.pending = r } ur = null } return e } function Ug(e, t) { do { var n = Pe; try { if (pf(), Ms.current = ga, ma) { for (var r = ke.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } ma = !1 } if (gr = 0, Be = De = ke = null, nu = !1, Ou = 0, Nf.current = null, n === null || n.return === null) { Me = 1, Pu = t, Pe = null; break } e: { var u = e, s = n.return, a = n, o = t; if (t = $e, a.flags |= 32768, o !== null && typeof o == "object" && typeof o.then == "function") { var l = o, f = a, d = f.tag; if (!(f.mode & 1) && (d === 0 || d === 11 || d === 15)) { var p = f.alternate; p ? (f.updateQueue = p.updateQueue, f.memoizedState = p.memoizedState, f.lanes = p.lanes) : (f.updateQueue = null, f.memoizedState = null) } var h = hh(s); if (h !== null) { h.flags &= -257, ph(h, s, a, u, t), h.mode & 1 && dh(u, l, t), t = h, o = l; var m = t.updateQueue; if (m === null) { var T = new Set; T.add(o), t.updateQueue = T } else m.add(o); break e } else { if (!(t & 1)) { dh(u, l, t), Lf(); break e } o = Error(z(426)) } } else if (_e && a.mode & 1) { var _ = hh(s); if (_ !== null) { !(_.flags & 65536) && (_.flags |= 256), ph(_, s, a, u, t), df(oi(o, a)); break e } } u = o = oi(o, a), Me !== 4 && (Me = 2), iu === null ? iu = [u] : iu.push(u), u = s; do { switch (u.tag) { case 3: u.flags |= 65536, t &= -t, u.lanes |= t; var g = Sg(u, o, t); sh(u, g); break e; case 1: a = o; var E = u.type, y = u.stateNode; if (!(u.flags & 128) && (typeof E.getDerivedStateFromError == "function" || y !== null && typeof y.componentDidCatch == "function" && (Un === null || !Un.has(y)))) { u.flags |= 65536, t &= -t, u.lanes |= t; var I = _g(u, a, t); sh(u, I); break e } }u = u.return } while (u !== null) } jg(n) } catch (L) { t = L, Pe === n && n !== null && (Pe = n = n.return); continue } break } while (!0) } function Hg() { var e = Ea.current; return Ea.current = ga, e === null ? ga : e } function Lf() { (Me === 0 || Me === 3 || Me === 2) && (Me = 4), He === null || !(Er & 268435455) && !($a & 268435455) || wn(He, $e) } function ba(e, t) { var n = de; de |= 2; var r = Hg(); (He !== e || $e !== t) && (on = null, cr(e, t)); do try { ob(); break } catch (i) { Ug(e, i) } while (!0); if (pf(), de = n, Ea.current = r, Pe !== null) throw Error(z(261)); return He = null, $e = 0, Me } function ob() { for (; Pe !== null;)zg(Pe) } function lb() { for (; Pe !== null && !Py();)zg(Pe) } function zg(e) { var t = Vg(e.alternate, e, Et); e.memoizedProps = e.pendingProps, t === null ? jg(e) : Pe = t, Nf.current = null } function jg(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = nb(n, t), n !== null) { n.flags &= 32767, Pe = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { Me = 6, Pe = null; return } } else if (n = tb(n, t, Et), n !== null) { Pe = n; return } if (t = t.sibling, t !== null) { Pe = t; return } Pe = t = e } while (t !== null); Me === 0 && (Me = 5) } function er(e, t, n) { var r = he, i = vt.transition; try { vt.transition = null, he = 1, cb(e, t, n, r) } finally { vt.transition = i, he = r } return null } function cb(e, t, n, r) { do Zr(); while (On !== null); if (de & 6) throw Error(z(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(z(177)); e.callbackNode = null, e.callbackPriority = 0; var u = n.lanes | n.childLanes; if (Vy(e, u), e === He && (Pe = He = null, $e = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || bs || (bs = !0, Yg(ta, function () { return Zr(), null })), u = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || u) { u = vt.transition, vt.transition = null; var s = he; he = 1; var a = de; de |= 4, Nf.current = null, ib(e, n), Mg(n, e), v2(zl), ra = !!Hl, zl = Hl = null, e.current = n, ub(n), Dy(), de = a, he = s, vt.transition = u } else e.current = n; if (bs && (bs = !1, On = e, ya = i), u = e.pendingLanes, u === 0 && (Un = null), By(n.stateNode), ft(e, we()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (Ta) throw Ta = !1, e = ac, ac = null, e; return ya & 1 && e.tag !== 0 && Zr(), u = e.pendingLanes, u & 1 ? e === oc ? uu++ : (uu = 0, oc = e) : uu = 0, Kn(), null } function Zr() { if (On !== null) { var e = Sm(ya), t = vt.transition, n = he; try { if (vt.transition = null, he = 16 > e ? 16 : e, On === null) var r = !1; else { if (e = On, On = null, ya = 0, de & 6) throw Error(z(331)); var i = de; for (de |= 4, Q = e.current; Q !== null;) { var u = Q, s = u.child; if (Q.flags & 16) { var a = u.deletions; if (a !== null) { for (var o = 0; o < a.length; o++) { var l = a[o]; for (Q = l; Q !== null;) { var f = Q; switch (f.tag) { case 0: case 11: case 15: ru(8, f, u) }var d = f.child; if (d !== null) d.return = f, Q = d; else for (; Q !== null;) { f = Q; var p = f.sibling, h = f.return; if (Rg(f), f === l) { Q = null; break } if (p !== null) { p.return = h, Q = p; break } Q = h } } } var m = u.alternate; if (m !== null) { var T = m.child; if (T !== null) { m.child = null; do { var _ = T.sibling; T.sibling = null, T = _ } while (T !== null) } } Q = u } } if (u.subtreeFlags & 2064 && s !== null) s.return = u, Q = s; else e: for (; Q !== null;) { if (u = Q, u.flags & 2048) switch (u.tag) { case 0: case 11: case 15: ru(9, u, u.return) }var g = u.sibling; if (g !== null) { g.return = u.return, Q = g; break e } Q = u.return } } var E = e.current; for (Q = E; Q !== null;) { s = Q; var y = s.child; if (s.subtreeFlags & 2064 && y !== null) y.return = s, Q = y; else e: for (s = E; Q !== null;) { if (a = Q, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: ja(9, a) } } catch (L) { Ie(a, a.return, L) } if (a === s) { Q = null; break e } var I = a.sibling; if (I !== null) { I.return = a.return, Q = I; break e } Q = a.return } } if (de = i, Kn(), en && typeof en.onPostCommitFiberRoot == "function") try { en.onPostCommitFiberRoot(Pa, e) } catch { } r = !0 } return r } finally { he = n, vt.transition = t } } return !1 } function Nh(e, t, n) { t = oi(n, t), t = Sg(e, t, 1), e = Bn(e, t, 1), t = tt(), e !== null && ($u(e, 1, t), ft(e, t)) } function Ie(e, t, n) { if (e.tag === 3) Nh(e, e, n); else for (; t !== null;) { if (t.tag === 3) { Nh(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (Un === null || !Un.has(r))) { e = oi(n, e), e = _g(t, e, 1), t = Bn(t, e, 1), e = tt(), t !== null && ($u(t, 1, e), ft(t, e)); break } } t = t.return } } function fb(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = tt(), e.pingedLanes |= e.suspendedLanes & n, He === e && ($e & n) === n && (Me === 4 || Me === 3 && ($e & 130023424) === $e && 500 > we() - wf ? cr(e, 0) : If |= n), ft(e, t) } function $g(e, t) { t === 0 && (e.mode & 1 ? (t = cs, cs <<= 1, !(cs & 130023424) && (cs = 4194304)) : t = 1); var n = tt(); e = gn(e, t), e !== null && ($u(e, t, n), ft(e, n)) } function db(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), $g(e, n) } function hb(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(z(314)) }r !== null && r.delete(t), $g(e, n) } var Vg; Vg = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || lt.current) ot = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return ot = !1, eb(e, t, n); ot = !!(e.flags & 131072) } else ot = !1, _e && t.flags & 1048576 && qm(t, ca, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Bs(e, t), e = t.pendingProps; var i = ii(t, Ge.current); Jr(t, n), i = Sf(null, t, r, e, i, n); var u = _f(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, ct(r) ? (u = !0, oa(t)) : u = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Ef(t), i.updater = za, t.stateNode = i, i._reactInternals = t, Gl(t, r, e, n), t = Zl(null, t, r, !0, u, n)) : (t.tag = 0, _e && u && cf(t), Ze(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Bs(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = mb(r), e = Dt(r, e), i) { case 0: t = Jl(null, t, r, e, n); break e; case 1: t = Eh(null, t, r, e, n); break e; case 11: t = mh(null, t, r, e, n); break e; case 14: t = gh(null, t, r, Dt(r.type, e), n); break e }throw Error(z(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Dt(r, i), Jl(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Dt(r, i), Eh(e, t, r, i, n); case 3: e: { if (Ng(t), e === null) throw Error(z(387)); r = t.pendingProps, u = t.memoizedState, i = u.element, eg(e, t), ha(t, r, null, n); var s = t.memoizedState; if (r = s.element, u.isDehydrated) if (u = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = u, t.memoizedState = u, t.flags & 256) { i = oi(Error(z(423)), t), t = Th(e, t, r, n, i); break e } else if (r !== i) { i = oi(Error(z(424)), t), t = Th(e, t, r, n, i); break e } else for (Tt = Fn(t.stateNode.containerInfo.firstChild), yt = t, _e = !0, Ft = null, n = Jm(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (ui(), r === i) { t = En(e, t, n); break e } Ze(e, t, r, n) } t = t.child } return t; case 5: return tg(t), e === null && Kl(t), r = t.type, i = t.pendingProps, u = e !== null ? e.memoizedProps : null, s = i.children, jl(r, i) ? s = null : u !== null && jl(r, u) && (t.flags |= 32), kg(e, t), Ze(e, t, s, n), t.child; case 6: return e === null && Kl(t), null; case 13: return Ig(e, t, n); case 4: return Tf(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = si(t, null, r, n) : Ze(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Dt(r, i), mh(e, t, r, i, n); case 7: return Ze(e, t, t.pendingProps, n), t.child; case 8: return Ze(e, t, t.pendingProps.children, n), t.child; case 12: return Ze(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, u = t.memoizedProps, s = i.value, Te(fa, r._currentValue), r._currentValue = s, u !== null) if ($t(u.value, s)) { if (u.children === i.children && !lt.current) { t = En(e, t, n); break e } } else for (u = t.child, u !== null && (u.return = t); u !== null;) { var a = u.dependencies; if (a !== null) { s = u.child; for (var o = a.firstContext; o !== null;) { if (o.context === r) { if (u.tag === 1) { o = hn(-1, n & -n), o.tag = 2; var l = u.updateQueue; if (l !== null) { l = l.shared; var f = l.pending; f === null ? o.next = o : (o.next = f.next, f.next = o), l.pending = o } } u.lanes |= n, o = u.alternate, o !== null && (o.lanes |= n), ql(u.return, n, t), a.lanes |= n; break } o = o.next } } else if (u.tag === 10) s = u.type === t.type ? null : u.child; else if (u.tag === 18) { if (s = u.return, s === null) throw Error(z(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), ql(s, n, t), s = u.sibling } else s = u.child; if (s !== null) s.return = u; else for (s = u; s !== null;) { if (s === t) { s = null; break } if (u = s.sibling, u !== null) { u.return = s.return, s = u; break } s = s.return } u = s } Ze(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, Jr(t, n), i = Ot(i), r = r(i), t.flags |= 1, Ze(e, t, r, n), t.child; case 14: return r = t.type, i = Dt(r, t.pendingProps), i = Dt(r.type, i), gh(e, t, r, i, n); case 15: return Cg(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : Dt(r, i), Bs(e, t), t.tag = 1, ct(r) ? (e = !0, oa(t)) : e = !1, Jr(t, n), xg(t, r, i), Gl(t, r, i, n), Zl(null, t, r, !0, e, n); case 19: return wg(e, t, n); case 22: return Ag(e, t, n) }throw Error(z(156, t.tag)) }; function Yg(e, t) { return Tm(e, t) } function pb(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function wt(e, t, n, r) { return new pb(e, t, n, r) } function Rf(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function mb(e) { if (typeof e == "function") return Rf(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === Xc) return 11; if (e === Jc) return 14 } return 2 } function zn(e, t) { var n = e.alternate; return n === null ? (n = wt(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function zs(e, t, n, r, i, u) { var s = 2; if (r = e, typeof e == "function") Rf(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case Mr: return fr(n.children, i, u, t); case Gc: s = 8, i |= 8; break; case bl: return e = wt(12, n, t, i | 2), e.elementType = bl, e.lanes = u, e; case xl: return e = wt(13, n, t, i), e.elementType = xl, e.lanes = u, e; case Sl: return e = wt(19, n, t, i), e.elementType = Sl, e.lanes = u, e; case tm: return Va(n, i, u, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case Zp: s = 10; break e; case em: s = 9; break e; case Xc: s = 11; break e; case Jc: s = 14; break e; case kn: s = 16, r = null; break e }throw Error(z(130, e == null ? e : typeof e, "")) }return t = wt(s, n, t, i), t.elementType = e, t.type = r, t.lanes = u, t } function fr(e, t, n, r) { return e = wt(7, e, r, t), e.lanes = n, e } function Va(e, t, n, r) { return e = wt(22, e, r, t), e.elementType = tm, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function zo(e, t, n) { return e = wt(6, e, null, t), e.lanes = n, e } function jo(e, t, n) { return t = wt(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function gb(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = So(0), this.expirationTimes = So(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = So(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Pf(e, t, n, r, i, u, s, a, o) { return e = new gb(e, t, n, a, o), t === 1 ? (t = 1, u === !0 && (t |= 8)) : t = 0, u = wt(3, null, null, t), e.current = u, u.stateNode = e, u.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Ef(u), e } function Eb(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: Dr, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function Wg(e) { if (!e) return Vn; e = e._reactInternals; e: { if (_r(e) !== e || e.tag !== 1) throw Error(z(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (ct(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(z(171)) } if (e.tag === 1) { var n = e.type; if (ct(n)) return Wm(e, n, t) } return t } function Kg(e, t, n, r, i, u, s, a, o) { return e = Pf(n, r, !0, e, i, u, s, a, o), e.context = Wg(null), n = e.current, r = tt(), i = Hn(n), u = hn(r, i), u.callback = t ?? null, Bn(n, u, i), e.current.lanes = i, $u(e, i, r), ft(e, r), e } function Ya(e, t, n, r) { var i = t.current, u = tt(), s = Hn(i); return n = Wg(n), t.context === null ? t.context = n : t.pendingContext = n, t = hn(u, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Bn(i, t, s), e !== null && (zt(e, i, s, u), Ds(e, i, s)), s } function xa(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function Ih(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function Df(e, t) { Ih(e, t), (e = e.alternate) && Ih(e, t) } function Tb() { return null } var qg = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function Mf(e) { this._internalRoot = e } Wa.prototype.render = Mf.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(z(409)); Ya(e, t, null, null) }; Wa.prototype.unmount = Mf.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; Tr(function () { Ya(null, e, null, null) }), t[mn] = null } }; function Wa(e) { this._internalRoot = e } Wa.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Am(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < In.length && t !== 0 && t < In[n].priority; n++); In.splice(n, 0, e), n === 0 && Nm(e) } }; function Ff(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Ka(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function wh() { } function yb(e, t, n, r, i) { if (i) { if (typeof r == "function") { var u = r; r = function () { var l = xa(s); u.call(l) } } var s = Kg(t, r, e, 0, null, !1, !1, "", wh); return e._reactRootContainer = s, e[mn] = s.current, ku(e.nodeType === 8 ? e.parentNode : e), Tr(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var l = xa(o); a.call(l) } } var o = Pf(e, 0, !1, null, null, !1, !1, "", wh); return e._reactRootContainer = o, e[mn] = o.current, ku(e.nodeType === 8 ? e.parentNode : e), Tr(function () { Ya(t, o, n, r) }), o } function qa(e, t, n, r, i) { var u = n._reactRootContainer; if (u) { var s = u; if (typeof i == "function") { var a = i; i = function () { var o = xa(s); a.call(o) } } Ya(t, s, e, i) } else s = yb(n, t, e, i, r); return xa(s) } _m = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = Ki(t.pendingLanes); n !== 0 && (tf(t, n | 1), ft(t, we()), !(de & 6) && (li = we() + 500, Kn())) } break; case 13: Tr(function () { var r = gn(e, 1); if (r !== null) { var i = tt(); zt(r, e, 1, i) } }), Df(e, 1) } }; nf = function (e) { if (e.tag === 13) { var t = gn(e, 134217728); if (t !== null) { var n = tt(); zt(t, e, 134217728, n) } Df(e, 134217728) } }; Cm = function (e) { if (e.tag === 13) { var t = Hn(e), n = gn(e, t); if (n !== null) { var r = tt(); zt(n, e, t, r) } Df(e, t) } }; Am = function () { return he }; km = function (e, t) { var n = he; try { return he = e, t() } finally { he = n } }; Ll = function (e, t, n) { switch (t) { case "input": if (Al(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = Ba(r); if (!i) throw Error(z(90)); rm(r), Al(r, i) } } } break; case "textarea": um(e, n); break; case "select": t = n.value, t != null && qr(e, !!n.multiple, t, !1) } }; dm = vf; hm = Tr; var bb = { usingClientEntryPoint: !1, Events: [Yu, Hr, Ba, cm, fm, vf] }, Mi = { findFiberByHostInstance: ir, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, xb = { bundleType: Mi.bundleType, version: Mi.version, rendererPackageName: Mi.rendererPackageName, rendererConfig: Mi.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: Tn.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = gm(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Mi.findFiberByHostInstance || Tb, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var xs = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!xs.isDisabled && xs.supportsFiber) try { Pa = xs.inject(xb), en = xs } catch { } } St.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = bb; St.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!Ff(t)) throw Error(z(200)); return Eb(e, t, null, n) }; St.createRoot = function (e, t) { if (!Ff(e)) throw Error(z(299)); var n = !1, r = "", i = qg; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = Pf(e, 1, !1, null, null, n, !1, r, i), e[mn] = t.current, ku(e.nodeType === 8 ? e.parentNode : e), new Mf(t) }; St.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(z(188)) : (e = Object.keys(e).join(","), Error(z(268, e))); return e = gm(t), e = e === null ? null : e.stateNode, e }; St.flushSync = function (e) { return Tr(e) }; St.hydrate = function (e, t, n) { if (!Ka(t)) throw Error(z(200)); return qa(null, e, t, !0, n) }; St.hydrateRoot = function (e, t, n) { if (!Ff(e)) throw Error(z(405)); var r = n != null && n.hydratedSources || null, i = !1, u = "", s = qg; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (u = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = Kg(t, null, e, 1, n ?? null, i, !1, u, s), e[mn] = t.current, ku(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Wa(t) }; St.render = function (e, t, n) { if (!Ka(t)) throw Error(z(200)); return qa(null, e, t, !1, n) }; St.unmountComponentAtNode = function (e) { if (!Ka(e)) throw Error(z(40)); return e._reactRootContainer ? (Tr(function () { qa(null, null, e, !1, function () { e._reactRootContainer = null, e[mn] = null }) }), !0) : !1 }; St.unstable_batchedUpdates = vf; St.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Ka(n)) throw Error(z(200)); if (e == null || e._reactInternals === void 0) throw Error(z(38)); return qa(e, t, n, !1, r) }; St.version = "18.3.1-next-f1338f8080-20240426"; function Qg() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(Qg) } catch (e) { console.error(e) } } Qg(), Qp.exports = St; var Sb = Qp.exports, vh = Sb; Tl.createRoot = vh.createRoot, Tl.hydrateRoot = vh.hydrateRoot;/**
 * @remix-run/router v1.23.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Du() { return Du = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Du.apply(this, arguments) } var Ln; (function (e) { e.Pop = "POP", e.Push = "PUSH", e.Replace = "REPLACE" })(Ln || (Ln = {})); const Oh = "popstate"; function _b(e) { e === void 0 && (e = {}); function t(i, u) { let { pathname: s = "/", search: a = "", hash: o = "" } = Cr(i.location.hash.substr(1)); return !s.startsWith("/") && !s.startsWith(".") && (s = "/" + s), fc("", { pathname: s, search: a, hash: o }, u.state && u.state.usr || null, u.state && u.state.key || "default") } function n(i, u) { let s = i.document.querySelector("base"), a = ""; if (s && s.getAttribute("href")) { let o = i.location.href, l = o.indexOf("#"); a = l === -1 ? o : o.slice(0, l) } return a + "#" + (typeof u == "string" ? u : Sa(u)) } function r(i, u) { Qa(i.pathname.charAt(0) === "/", "relative pathnames are not supported in hash history.push(" + JSON.stringify(u) + ")") } return Ab(t, n, r, e) } function Oe(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function Qa(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function Cb() { return Math.random().toString(36).substr(2, 8) } function Lh(e, t) { return { usr: e.state, key: e.key, idx: t } } function fc(e, t, n, r) { return n === void 0 && (n = null), Du({ pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "" }, typeof t == "string" ? Cr(t) : t, { state: n, key: t && t.key || r || Cb() }) } function Sa(e) { let { pathname: t = "/", search: n = "", hash: r = "" } = e; return n && n !== "?" && (t += n.charAt(0) === "?" ? n : "?" + n), r && r !== "#" && (t += r.charAt(0) === "#" ? r : "#" + r), t } function Cr(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substr(n), e = e.substr(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substr(r), e = e.substr(0, r)), e && (t.pathname = e) } return t } function Ab(e, t, n, r) { r === void 0 && (r = {}); let { window: i = document.defaultView, v5Compat: u = !1 } = r, s = i.history, a = Ln.Pop, o = null, l = f(); l == null && (l = 0, s.replaceState(Du({}, s.state, { idx: l }), "")); function f() { return (s.state || { idx: null }).idx } function d() { a = Ln.Pop; let _ = f(), g = _ == null ? null : _ - l; l = _, o && o({ action: a, location: T.location, delta: g }) } function p(_, g) { a = Ln.Push; let E = fc(T.location, _, g); n && n(E, _), l = f() + 1; let y = Lh(E, l), I = T.createHref(E); try { s.pushState(y, "", I) } catch (L) { if (L instanceof DOMException && L.name === "DataCloneError") throw L; i.location.assign(I) } u && o && o({ action: a, location: T.location, delta: 1 }) } function h(_, g) { a = Ln.Replace; let E = fc(T.location, _, g); n && n(E, _), l = f(); let y = Lh(E, l), I = T.createHref(E); s.replaceState(y, "", I), u && o && o({ action: a, location: T.location, delta: 0 }) } function m(_) { let g = i.location.origin !== "null" ? i.location.origin : i.location.href, E = typeof _ == "string" ? _ : Sa(_); return E = E.replace(/ $/, "%20"), Oe(g, "No window.location.(origin|href) available to create URL for href: " + E), new URL(E, g) } let T = { get action() { return a }, get location() { return e(i, s) }, listen(_) { if (o) throw new Error("A history only accepts one active listener"); return i.addEventListener(Oh, d), o = _, () => { i.removeEventListener(Oh, d), o = null } }, createHref(_) { return t(i, _) }, createURL: m, encodeLocation(_) { let g = m(_); return { pathname: g.pathname, search: g.search, hash: g.hash } }, push: p, replace: h, go(_) { return s.go(_) } }; return T } var Rh; (function (e) { e.data = "data", e.deferred = "deferred", e.redirect = "redirect", e.error = "error" })(Rh || (Rh = {})); function kb(e, t, n) { return n === void 0 && (n = "/"), Nb(e, t, n) } function Nb(e, t, n, r) { let i = typeof t == "string" ? Cr(t) : t, u = Bf(i.pathname || "/", n); if (u == null) return null; let s = Gg(e); Ib(s); let a = null; for (let o = 0; a == null && o < s.length; ++o) { let l = Hb(u); a = Fb(s[o], l) } return a } function Gg(e, t, n, r) { t === void 0 && (t = []), n === void 0 && (n = []), r === void 0 && (r = ""); let i = (u, s, a) => { let o = { relativePath: a === void 0 ? u.path || "" : a, caseSensitive: u.caseSensitive === !0, childrenIndex: s, route: u }; o.relativePath.startsWith("/") && (Oe(o.relativePath.startsWith(r), 'Absolute route path "' + o.relativePath + '" nested under path ' + ('"' + r + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."), o.relativePath = o.relativePath.slice(r.length)); let l = jn([r, o.relativePath]), f = n.concat(o); u.children && u.children.length > 0 && (Oe(u.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + l + '".')), Gg(u.children, t, f, l)), !(u.path == null && !u.index) && t.push({ path: l, score: Db(l, u.index), routesMeta: f }) }; return e.forEach((u, s) => { var a; if (u.path === "" || !((a = u.path) != null && a.includes("?"))) i(u, s); else for (let o of Xg(u.path)) i(u, s, o) }), t } function Xg(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...r] = t, i = n.endsWith("?"), u = n.replace(/\?$/, ""); if (r.length === 0) return i ? [u, ""] : [u]; let s = Xg(r.join("/")), a = []; return a.push(...s.map(o => o === "" ? u : [u, o].join("/"))), i && a.push(...s), a.map(o => e.startsWith("/") && o === "" ? "/" : o) } function Ib(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : Mb(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } const wb = /^:[\w-]+$/, vb = 3, Ob = 2, Lb = 1, Rb = 10, Pb = -2, Ph = e => e === "*"; function Db(e, t) { let n = e.split("/"), r = n.length; return n.some(Ph) && (r += Pb), t && (r += Ob), n.filter(i => !Ph(i)).reduce((i, u) => i + (wb.test(u) ? vb : u === "" ? Lb : Rb), r) } function Mb(e, t) { return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0 } function Fb(e, t, n) { let { routesMeta: r } = e, i = {}, u = "/", s = []; for (let a = 0; a < r.length; ++a) { let o = r[a], l = a === r.length - 1, f = u === "/" ? t : t.slice(u.length) || "/", d = Bb({ path: o.relativePath, caseSensitive: o.caseSensitive, end: l }, f), p = o.route; if (!d) return null; Object.assign(i, d.params), s.push({ params: i, pathname: jn([u, d.pathname]), pathnameBase: Yb(jn([u, d.pathnameBase])), route: p }), d.pathnameBase !== "/" && (u = jn([u, d.pathnameBase])) } return s } function Bb(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = Ub(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let u = i[0], s = u.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce((l, f, d) => { let { paramName: p, isOptional: h } = f; if (p === "*") { let T = a[d] || ""; s = u.slice(0, u.length - T.length).replace(/(.)\/+$/, "$1") } const m = a[d]; return h && !m ? l[p] = void 0 : l[p] = (m || "").replace(/%2F/g, "/"), l }, {}), pathname: u, pathnameBase: s, pattern: e } } function Ub(e, t, n) { t === void 0 && (t = !1), n === void 0 && (n = !0), Qa(e === "*" || !e.endsWith("*") || e.endsWith("/*"), 'Route path "' + e + '" will be treated as if it were ' + ('"' + e.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + e.replace(/\*$/, "/*") + '".')); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, o) => (r.push({ paramName: a, isOptional: o != null }), o ? "/?([^\\/]+)?" : "/([^\\/]+)")); return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r] } function Hb(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return Qa(!1, 'The URL path "' + e + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + t + ").")), e } } function Bf(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && r !== "/" ? null : e.slice(n) || "/" } const zb = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, jb = e => zb.test(e); function $b(e, t) { t === void 0 && (t = "/"); let { pathname: n, search: r = "", hash: i = "" } = typeof e == "string" ? Cr(e) : e, u; if (n) if (jb(n)) u = n; else { if (n.includes("//")) { let s = n; n = n.replace(/\/\/+/g, "/"), Qa(!1, "Pathnames cannot have embedded double slashes - normalizing " + (s + " -> " + n)) } n.startsWith("/") ? u = Dh(n.substring(1), "/") : u = Dh(n, t) } else u = t; return { pathname: u, search: Wb(r), hash: Kb(i) } } function Dh(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function $o(e, t, n, r) { return "Cannot include a '" + e + "' character in a manually specified " + ("`to." + t + "` field [" + JSON.stringify(r) + "].  Please separate it out to the ") + ("`to." + n + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.' } function Vb(e) { return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0) } function Uf(e, t) { let n = Vb(e); return t ? n.map((r, i) => i === n.length - 1 ? r.pathname : r.pathnameBase) : n.map(r => r.pathnameBase) } function Hf(e, t, n, r) { r === void 0 && (r = !1); let i; typeof e == "string" ? i = Cr(e) : (i = Du({}, e), Oe(!i.pathname || !i.pathname.includes("?"), $o("?", "pathname", "search", i)), Oe(!i.pathname || !i.pathname.includes("#"), $o("#", "pathname", "hash", i)), Oe(!i.search || !i.search.includes("#"), $o("#", "search", "hash", i))); let u = e === "" || i.pathname === "", s = u ? "/" : i.pathname, a; if (s == null) a = n; else { let d = t.length - 1; if (!r && s.startsWith("..")) { let p = s.split("/"); for (; p[0] === "..";)p.shift(), d -= 1; i.pathname = p.join("/") } a = d >= 0 ? t[d] : "/" } let o = $b(i, a), l = s && s !== "/" && s.endsWith("/"), f = (u || s === ".") && n.endsWith("/"); return !o.pathname.endsWith("/") && (l || f) && (o.pathname += "/"), o } const jn = e => e.join("/").replace(/\/\/+/g, "/"), Yb = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), Wb = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, Kb = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e; function qb(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } const Jg = ["post", "put", "patch", "delete"]; new Set(Jg); const Qb = ["get", ...Jg]; new Set(Qb);/**
 * React Router v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function Mu() { return Mu = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, Mu.apply(this, arguments) } const zf = M.createContext(null), Gb = M.createContext(null), qn = M.createContext(null), Ga = M.createContext(null), yn = M.createContext({ outlet: null, matches: [], isDataRoute: !1 }), Zg = M.createContext(null); function Xb(e, t) { let { relative: n } = t === void 0 ? {} : t; yi() || Oe(!1); let { basename: r, navigator: i } = M.useContext(qn), { hash: u, pathname: s, search: a } = r1(e, { relative: n }), o = s; return r !== "/" && (o = s === "/" ? r : jn([r, s])), i.createHref({ pathname: o, search: a, hash: u }) } function yi() { return M.useContext(Ga) != null } function Ku() { return yi() || Oe(!1), M.useContext(Ga).location } function e1(e) { M.useContext(qn).static || M.useLayoutEffect(e) } function t1() { let { isDataRoute: e } = M.useContext(yn); return e ? cx() : Jb() } function Jb() { yi() || Oe(!1); let e = M.useContext(zf), { basename: t, future: n, navigator: r } = M.useContext(qn), { matches: i } = M.useContext(yn), { pathname: u } = Ku(), s = JSON.stringify(Uf(i, n.v7_relativeSplatPath)), a = M.useRef(!1); return e1(() => { a.current = !0 }), M.useCallback(function (l, f) { if (f === void 0 && (f = {}), !a.current) return; if (typeof l == "number") { r.go(l); return } let d = Hf(l, JSON.parse(s), u, f.relative === "path"); e == null && t !== "/" && (d.pathname = d.pathname === "/" ? t : jn([t, d.pathname])), (f.replace ? r.replace : r.push)(d, f.state, f) }, [t, r, s, u, e]) } function n1() { let { matches: e } = M.useContext(yn), t = e[e.length - 1]; return t ? t.params : {} } function r1(e, t) { let { relative: n } = t === void 0 ? {} : t, { future: r } = M.useContext(qn), { matches: i } = M.useContext(yn), { pathname: u } = Ku(), s = JSON.stringify(Uf(i, r.v7_relativeSplatPath)); return M.useMemo(() => Hf(e, JSON.parse(s), u, n === "path"), [e, s, u, n]) } function Zb(e, t) { return ex(e, t) } function ex(e, t, n, r) { yi() || Oe(!1); let { navigator: i } = M.useContext(qn), { matches: u } = M.useContext(yn), s = u[u.length - 1], a = s ? s.params : {}; s && s.pathname; let o = s ? s.pathnameBase : "/"; s && s.route; let l = Ku(), f; if (t) { var d; let _ = typeof t == "string" ? Cr(t) : t; o === "/" || (d = _.pathname) != null && d.startsWith(o) || Oe(!1), f = _ } else f = l; let p = f.pathname || "/", h = p; if (o !== "/") { let _ = o.replace(/^\//, "").split("/"); h = "/" + p.replace(/^\//, "").split("/").slice(_.length).join("/") } let m = kb(e, { pathname: h }), T = ux(m && m.map(_ => Object.assign({}, _, { params: Object.assign({}, a, _.params), pathname: jn([o, i.encodeLocation ? i.encodeLocation(_.pathname).pathname : _.pathname]), pathnameBase: _.pathnameBase === "/" ? o : jn([o, i.encodeLocation ? i.encodeLocation(_.pathnameBase).pathname : _.pathnameBase]) })), u, n, r); return t && T ? M.createElement(Ga.Provider, { value: { location: Mu({ pathname: "/", search: "", hash: "", state: null, key: "default" }, f), navigationType: Ln.Pop } }, T) : T } function tx() { let e = lx(), t = qb(e) ? e.status + " " + e.statusText : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, i = { padding: "0.5rem", backgroundColor: "rgba(200,200,200, 0.5)" }; return M.createElement(M.Fragment, null, M.createElement("h2", null, "Unexpected Application Error!"), M.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? M.createElement("pre", { style: i }, n) : null, null) } const nx = M.createElement(tx, null); class rx extends M.Component { constructor(t) { super(t), this.state = { location: t.location, revalidation: t.revalidation, error: t.error } } static getDerivedStateFromError(t) { return { error: t } } static getDerivedStateFromProps(t, n) { return n.location !== t.location || n.revalidation !== "idle" && t.revalidation === "idle" ? { error: t.error, location: t.location, revalidation: t.revalidation } : { error: t.error !== void 0 ? t.error : n.error, location: n.location, revalidation: t.revalidation || n.revalidation } } componentDidCatch(t, n) { console.error("React Router caught the following error during render", t, n) } render() { return this.state.error !== void 0 ? M.createElement(yn.Provider, { value: this.props.routeContext }, M.createElement(Zg.Provider, { value: this.state.error, children: this.props.component })) : this.props.children } } function ix(e) { let { routeContext: t, match: n, children: r } = e, i = M.useContext(zf); return i && i.static && i.staticContext && (n.route.errorElement || n.route.ErrorBoundary) && (i.staticContext._deepestRenderedBoundaryId = n.route.id), M.createElement(yn.Provider, { value: t }, r) } function ux(e, t, n, r) { var i; if (t === void 0 && (t = []), n === void 0 && (n = null), r === void 0 && (r = null), e == null) { var u; if (!n) return null; if (n.errors) e = n.matches; else if ((u = r) != null && u.v7_partialHydration && t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches; else return null } let s = e, a = (i = n) == null ? void 0 : i.errors; if (a != null) { let f = s.findIndex(d => d.route.id && (a == null ? void 0 : a[d.route.id]) !== void 0); f >= 0 || Oe(!1), s = s.slice(0, Math.min(s.length, f + 1)) } let o = !1, l = -1; if (n && r && r.v7_partialHydration) for (let f = 0; f < s.length; f++) { let d = s[f]; if ((d.route.HydrateFallback || d.route.hydrateFallbackElement) && (l = f), d.route.id) { let { loaderData: p, errors: h } = n, m = d.route.loader && p[d.route.id] === void 0 && (!h || h[d.route.id] === void 0); if (d.route.lazy || m) { o = !0, l >= 0 ? s = s.slice(0, l + 1) : s = [s[0]]; break } } } return s.reduceRight((f, d, p) => { let h, m = !1, T = null, _ = null; n && (h = a && d.route.id ? a[d.route.id] : void 0, T = d.route.errorElement || nx, o && (l < 0 && p === 0 ? (fx("route-fallback"), m = !0, _ = null) : l === p && (m = !0, _ = d.route.hydrateFallbackElement || null))); let g = t.concat(s.slice(0, p + 1)), E = () => { let y; return h ? y = T : m ? y = _ : d.route.Component ? y = M.createElement(d.route.Component, null) : d.route.element ? y = d.route.element : y = f, M.createElement(ix, { match: d, routeContext: { outlet: f, matches: g, isDataRoute: n != null }, children: y }) }; return n && (d.route.ErrorBoundary || d.route.errorElement || p === 0) ? M.createElement(rx, { location: n.location, revalidation: n.revalidation, component: T, error: h, children: E(), routeContext: { outlet: null, matches: g, isDataRoute: !0 } }) : E() }, null) } var i1 = function (e) { return e.UseBlocker = "useBlocker", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e }(i1 || {}), u1 = function (e) { return e.UseBlocker = "useBlocker", e.UseLoaderData = "useLoaderData", e.UseActionData = "useActionData", e.UseRouteError = "useRouteError", e.UseNavigation = "useNavigation", e.UseRouteLoaderData = "useRouteLoaderData", e.UseMatches = "useMatches", e.UseRevalidator = "useRevalidator", e.UseNavigateStable = "useNavigate", e.UseRouteId = "useRouteId", e }(u1 || {}); function sx(e) { let t = M.useContext(zf); return t || Oe(!1), t } function ax(e) { let t = M.useContext(Gb); return t || Oe(!1), t } function ox(e) { let t = M.useContext(yn); return t || Oe(!1), t } function s1(e) { let t = ox(), n = t.matches[t.matches.length - 1]; return n.route.id || Oe(!1), n.route.id } function lx() { var e; let t = M.useContext(Zg), n = ax(), r = s1(); return t !== void 0 ? t : (e = n.errors) == null ? void 0 : e[r] } function cx() { let { router: e } = sx(i1.UseNavigateStable), t = s1(u1.UseNavigateStable), n = M.useRef(!1); return e1(() => { n.current = !0 }), M.useCallback(function (i, u) { u === void 0 && (u = {}), n.current && (typeof i == "number" ? e.navigate(i) : e.navigate(i, Mu({ fromRouteId: t }, u))) }, [e, t]) } const Mh = {}; function fx(e, t, n) { Mh[e] || (Mh[e] = !0) } function dx(e, t) { e == null || e.v7_startTransition, e == null || e.v7_relativeSplatPath } function hx(e) { let { to: t, replace: n, state: r, relative: i } = e; yi() || Oe(!1); let { future: u, static: s } = M.useContext(qn), { matches: a } = M.useContext(yn), { pathname: o } = Ku(), l = t1(), f = Hf(t, Uf(a, u.v7_relativeSplatPath), o, i === "path"), d = JSON.stringify(f); return M.useEffect(() => l(JSON.parse(d), { replace: n, state: r, relative: i }), [l, d, i, n, r]), null } function tr(e) { Oe(!1) } function px(e) { let { basename: t = "/", children: n = null, location: r, navigationType: i = Ln.Pop, navigator: u, static: s = !1, future: a } = e; yi() && Oe(!1); let o = t.replace(/^\/*/, "/"), l = M.useMemo(() => ({ basename: o, navigator: u, static: s, future: Mu({ v7_relativeSplatPath: !1 }, a) }), [o, a, u, s]); typeof r == "string" && (r = Cr(r)); let { pathname: f = "/", search: d = "", hash: p = "", state: h = null, key: m = "default" } = r, T = M.useMemo(() => { let _ = Bf(f, o); return _ == null ? null : { location: { pathname: _, search: d, hash: p, state: h, key: m }, navigationType: i } }, [o, f, d, p, h, m, i]); return T == null ? null : M.createElement(qn.Provider, { value: l }, M.createElement(Ga.Provider, { children: n, value: T })) } function mx(e) { let { children: t, location: n } = e; return Zb(dc(t), n) } new Promise(() => { }); function dc(e, t) { t === void 0 && (t = []); let n = []; return M.Children.forEach(e, (r, i) => { if (!M.isValidElement(r)) return; let u = [...t, i]; if (r.type === M.Fragment) { n.push.apply(n, dc(r.props.children, u)); return } r.type !== tr && Oe(!1), !r.props.index || !r.props.children || Oe(!1); let s = { id: r.props.id || u.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, loader: r.props.loader, action: r.props.action, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (s.children = dc(r.props.children, u)), n.push(s) }), n }/**
 * React Router DOM v6.30.2
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */function hc() { return hc = Object.assign ? Object.assign.bind() : function (e) { for (var t = 1; t < arguments.length; t++) { var n = arguments[t]; for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]) } return e }, hc.apply(this, arguments) } function gx(e, t) { if (e == null) return {}; var n = {}, r = Object.keys(e), i, u; for (u = 0; u < r.length; u++)i = r[u], !(t.indexOf(i) >= 0) && (n[i] = e[i]); return n } function Ex(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function Tx(e, t) { return e.button === 0 && (!t || t === "_self") && !Ex(e) } const yx = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"], bx = "6"; try { window.__reactRouterVersion = bx } catch { } const xx = "startTransition", Fh = fy[xx]; function Sx(e) { let { basename: t, children: n, future: r, window: i } = e, u = M.useRef(); u.current == null && (u.current = _b({ window: i, v5Compat: !0 })); let s = u.current, [a, o] = M.useState({ action: s.action, location: s.location }), { v7_startTransition: l } = r || {}, f = M.useCallback(d => { l && Fh ? Fh(() => o(d)) : o(d) }, [o, l]); return M.useLayoutEffect(() => s.listen(f), [s, f]), M.useEffect(() => dx(r), [r]), M.createElement(px, { basename: t, children: n, location: a.location, navigationType: a.action, navigator: s, future: r }) } const _x = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u", Cx = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Qi = M.forwardRef(function (t, n) { let { onClick: r, relative: i, reloadDocument: u, replace: s, state: a, target: o, to: l, preventScrollReset: f, viewTransition: d } = t, p = gx(t, yx), { basename: h } = M.useContext(qn), m, T = !1; if (typeof l == "string" && Cx.test(l) && (m = l, _x)) try { let y = new URL(window.location.href), I = l.startsWith("//") ? new URL(y.protocol + l) : new URL(l), L = Bf(I.pathname, h); I.origin === y.origin && L != null ? l = L + I.search + I.hash : T = !0 } catch { } let _ = Xb(l, { relative: i }), g = Ax(l, { replace: s, state: a, target: o, preventScrollReset: f, relative: i, viewTransition: d }); function E(y) { r && r(y), y.defaultPrevented || g(y) } return M.createElement("a", hc({}, p, { href: m || _, onClick: T || u ? r : E, ref: n, target: o })) }); var Bh; (function (e) { e.UseScrollRestoration = "useScrollRestoration", e.UseSubmit = "useSubmit", e.UseSubmitFetcher = "useSubmitFetcher", e.UseFetcher = "useFetcher", e.useViewTransitionState = "useViewTransitionState" })(Bh || (Bh = {})); var Uh; (function (e) { e.UseFetcher = "useFetcher", e.UseFetchers = "useFetchers", e.UseScrollRestoration = "useScrollRestoration" })(Uh || (Uh = {})); function Ax(e, t) { let { target: n, replace: r, state: i, preventScrollReset: u, relative: s, viewTransition: a } = t === void 0 ? {} : t, o = t1(), l = Ku(), f = r1(e, { relative: s }); return M.useCallback(d => { if (Tx(d, n)) { d.preventDefault(); let p = r !== void 0 ? r : Sa(l) === Sa(f); o(e, { replace: p, state: i, preventScrollReset: u, relative: s, viewTransition: a }) } }, [l, o, f, r, i, n, e, u, s, a]) } var kx = typeof Element < "u", Nx = typeof Map == "function", Ix = typeof Set == "function", wx = typeof ArrayBuffer == "function" && !!ArrayBuffer.isView; function js(e, t) { if (e === t) return !0; if (e && t && typeof e == "object" && typeof t == "object") { if (e.constructor !== t.constructor) return !1; var n, r, i; if (Array.isArray(e)) { if (n = e.length, n != t.length) return !1; for (r = n; r-- !== 0;)if (!js(e[r], t[r])) return !1; return !0 } var u; if (Nx && e instanceof Map && t instanceof Map) { if (e.size !== t.size) return !1; for (u = e.entries(); !(r = u.next()).done;)if (!t.has(r.value[0])) return !1; for (u = e.entries(); !(r = u.next()).done;)if (!js(r.value[1], t.get(r.value[0]))) return !1; return !0 } if (Ix && e instanceof Set && t instanceof Set) { if (e.size !== t.size) return !1; for (u = e.entries(); !(r = u.next()).done;)if (!t.has(r.value[0])) return !1; return !0 } if (wx && ArrayBuffer.isView(e) && ArrayBuffer.isView(t)) { if (n = e.length, n != t.length) return !1; for (r = n; r-- !== 0;)if (e[r] !== t[r]) return !1; return !0 } if (e.constructor === RegExp) return e.source === t.source && e.flags === t.flags; if (e.valueOf !== Object.prototype.valueOf && typeof e.valueOf == "function" && typeof t.valueOf == "function") return e.valueOf() === t.valueOf(); if (e.toString !== Object.prototype.toString && typeof e.toString == "function" && typeof t.toString == "function") return e.toString() === t.toString(); if (i = Object.keys(e), n = i.length, n !== Object.keys(t).length) return !1; for (r = n; r-- !== 0;)if (!Object.prototype.hasOwnProperty.call(t, i[r])) return !1; if (kx && e instanceof Element) return !1; for (r = n; r-- !== 0;)if (!((i[r] === "_owner" || i[r] === "__v" || i[r] === "__o") && e.$$typeof) && !js(e[i[r]], t[i[r]])) return !1; return !0 } return e !== e && t !== t } var vx = function (t, n) { try { return js(t, n) } catch (r) { if ((r.message || "").match(/stack|recursion/i)) return console.warn("react-fast-compare cannot handle circular refs"), !1; throw r } }; const Ox = mi(vx); var Lx = function (e, t, n, r, i, u, s, a) { if (!e) { var o; if (t === void 0) o = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."); else { var l = [n, r, i, u, s, a], f = 0; o = new Error(t.replace(/%s/g, function () { return l[f++] })), o.name = "Invariant Violation" } throw o.framesToPop = 1, o } }, Rx = Lx; const Hh = mi(Rx); var Px = function (t, n, r, i) { var u = r ? r.call(i, t, n) : void 0; if (u !== void 0) return !!u; if (t === n) return !0; if (typeof t != "object" || !t || typeof n != "object" || !n) return !1; var s = Object.keys(t), a = Object.keys(n); if (s.length !== a.length) return !1; for (var o = Object.prototype.hasOwnProperty.bind(n), l = 0; l < s.length; l++) { var f = s[l]; if (!o(f)) return !1; var d = t[f], p = n[f]; if (u = r ? r.call(i, d, p, f) : void 0, u === !1 || u === void 0 && d !== p) return !1 } return !0 }; const Dx = mi(Px); var a1 = (e => (e.BASE = "base", e.BODY = "body", e.HEAD = "head", e.HTML = "html", e.LINK = "link", e.META = "meta", e.NOSCRIPT = "noscript", e.SCRIPT = "script", e.STYLE = "style", e.TITLE = "title", e.FRAGMENT = "Symbol(react.fragment)", e))(a1 || {}), Vo = { link: { rel: ["amphtml", "canonical", "alternate"] }, script: { type: ["application/ld+json"] }, meta: { charset: "", name: ["generator", "robots", "description"], property: ["og:type", "og:title", "og:url", "og:image", "og:image:alt", "og:description", "twitter:url", "twitter:title", "twitter:description", "twitter:image", "twitter:image:alt", "twitter:card", "twitter:site"] } }, zh = Object.values(a1), jf = { accesskey: "accessKey", charset: "charSet", class: "className", contenteditable: "contentEditable", contextmenu: "contextMenu", "http-equiv": "httpEquiv", itemprop: "itemProp", tabindex: "tabIndex" }, Mx = Object.entries(jf).reduce((e, [t, n]) => (e[n] = t, e), {}), Ut = "data-rh", ei = { DEFAULT_TITLE: "defaultTitle", DEFER: "defer", ENCODE_SPECIAL_CHARACTERS: "encodeSpecialCharacters", ON_CHANGE_CLIENT_STATE: "onChangeClientState", TITLE_TEMPLATE: "titleTemplate", PRIORITIZE_SEO_TAGS: "prioritizeSeoTags" }, ti = (e, t) => { for (let n = e.length - 1; n >= 0; n -= 1) { const r = e[n]; if (Object.prototype.hasOwnProperty.call(r, t)) return r[t] } return null }, Fx = e => { let t = ti(e, "title"); const n = ti(e, ei.TITLE_TEMPLATE); if (Array.isArray(t) && (t = t.join("")), n && t) return n.replace(/%s/g, () => t); const r = ti(e, ei.DEFAULT_TITLE); return t || r || void 0 }, Bx = e => ti(e, ei.ON_CHANGE_CLIENT_STATE) || (() => { }), Yo = (e, t) => t.filter(n => typeof n[e] < "u").map(n => n[e]).reduce((n, r) => ({ ...n, ...r }), {}), Ux = (e, t) => t.filter(n => typeof n.base < "u").map(n => n.base).reverse().reduce((n, r) => { if (!n.length) { const i = Object.keys(r); for (let u = 0; u < i.length; u += 1) { const a = i[u].toLowerCase(); if (e.indexOf(a) !== -1 && r[a]) return n.concat(r) } } return n }, []), Hx = e => console && typeof console.warn == "function" && console.warn(e), Fi = (e, t, n) => { const r = {}; return n.filter(i => Array.isArray(i[e]) ? !0 : (typeof i[e] < "u" && Hx(`Helmet: ${e} should be of type "Array". Instead found type "${typeof i[e]}"`), !1)).map(i => i[e]).reverse().reduce((i, u) => { const s = {}; u.filter(o => { let l; const f = Object.keys(o); for (let p = 0; p < f.length; p += 1) { const h = f[p], m = h.toLowerCase(); t.indexOf(m) !== -1 && !(l === "rel" && o[l].toLowerCase() === "canonical") && !(m === "rel" && o[m].toLowerCase() === "stylesheet") && (l = m), t.indexOf(h) !== -1 && (h === "innerHTML" || h === "cssText" || h === "itemprop") && (l = h) } if (!l || !o[l]) return !1; const d = o[l].toLowerCase(); return r[l] || (r[l] = {}), s[l] || (s[l] = {}), r[l][d] ? !1 : (s[l][d] = !0, !0) }).reverse().forEach(o => i.push(o)); const a = Object.keys(s); for (let o = 0; o < a.length; o += 1) { const l = a[o], f = { ...r[l], ...s[l] }; r[l] = f } return i }, []).reverse() }, zx = (e, t) => { if (Array.isArray(e) && e.length) { for (let n = 0; n < e.length; n += 1)if (e[n][t]) return !0 } return !1 }, jx = e => ({ baseTag: Ux(["href"], e), bodyAttributes: Yo("bodyAttributes", e), defer: ti(e, ei.DEFER), encode: ti(e, ei.ENCODE_SPECIAL_CHARACTERS), htmlAttributes: Yo("htmlAttributes", e), linkTags: Fi("link", ["rel", "href"], e), metaTags: Fi("meta", ["name", "charset", "http-equiv", "property", "itemprop"], e), noscriptTags: Fi("noscript", ["innerHTML"], e), onChangeClientState: Bx(e), scriptTags: Fi("script", ["src", "innerHTML"], e), styleTags: Fi("style", ["cssText"], e), title: Fx(e), titleAttributes: Yo("titleAttributes", e), prioritizeSeoTags: zx(e, ei.PRIORITIZE_SEO_TAGS) }), o1 = e => Array.isArray(e) ? e.join("") : e, $x = (e, t) => { const n = Object.keys(e); for (let r = 0; r < n.length; r += 1)if (t[n[r]] && t[n[r]].includes(e[n[r]])) return !0; return !1 }, Wo = (e, t) => Array.isArray(e) ? e.reduce((n, r) => ($x(r, t) ? n.priority.push(r) : n.default.push(r), n), { priority: [], default: [] }) : { default: e, priority: [] }, jh = (e, t) => ({ ...e, [t]: void 0 }), Vx = ["noscript", "script", "style"], pc = (e, t = !0) => t === !1 ? String(e) : String(e).replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#x27;"), l1 = e => Object.keys(e).reduce((t, n) => { const r = typeof e[n] < "u" ? `${n}="${e[n]}"` : `${n}`; return t ? `${t} ${r}` : r }, ""), Yx = (e, t, n, r) => { const i = l1(n), u = o1(t); return i ? `<${e} ${Ut}="true" ${i}>${pc(u, r)}</${e}>` : `<${e} ${Ut}="true">${pc(u, r)}</${e}>` }, Wx = (e, t, n = !0) => t.reduce((r, i) => { const u = i, s = Object.keys(u).filter(l => !(l === "innerHTML" || l === "cssText")).reduce((l, f) => { const d = typeof u[f] > "u" ? f : `${f}="${pc(u[f], n)}"`; return l ? `${l} ${d}` : d }, ""), a = u.innerHTML || u.cssText || "", o = Vx.indexOf(e) === -1; return `${r}<${e} ${Ut}="true" ${s}${o ? "/>" : `>${a}</${e}>`}` }, ""), c1 = (e, t = {}) => Object.keys(e).reduce((n, r) => { const i = jf[r]; return n[i || r] = e[r], n }, t), Kx = (e, t, n) => { const r = { key: t, [Ut]: !0 }, i = c1(n, r); return [Bt.createElement("title", i, t)] }, $s = (e, t) => t.map((n, r) => { const i = { key: r, [Ut]: !0 }; return Object.keys(n).forEach(u => { const a = jf[u] || u; if (a === "innerHTML" || a === "cssText") { const o = n.innerHTML || n.cssText; i.dangerouslySetInnerHTML = { __html: o } } else i[a] = n[u] }), Bt.createElement(e, i) }), Ct = (e, t, n = !0) => { switch (e) { case "title": return { toComponent: () => Kx(e, t.title, t.titleAttributes), toString: () => Yx(e, t.title, t.titleAttributes, n) }; case "bodyAttributes": case "htmlAttributes": return { toComponent: () => c1(t), toString: () => l1(t) }; default: return { toComponent: () => $s(e, t), toString: () => Wx(e, t, n) } } }, qx = ({ metaTags: e, linkTags: t, scriptTags: n, encode: r }) => { const i = Wo(e, Vo.meta), u = Wo(t, Vo.link), s = Wo(n, Vo.script); return { priorityMethods: { toComponent: () => [...$s("meta", i.priority), ...$s("link", u.priority), ...$s("script", s.priority)], toString: () => `${Ct("meta", i.priority, r)} ${Ct("link", u.priority, r)} ${Ct("script", s.priority, r)}` }, metaTags: i.default, linkTags: u.default, scriptTags: s.default } }, Qx = e => { const { baseTag: t, bodyAttributes: n, encode: r = !0, htmlAttributes: i, noscriptTags: u, styleTags: s, title: a = "", titleAttributes: o, prioritizeSeoTags: l } = e; let { linkTags: f, metaTags: d, scriptTags: p } = e, h = { toComponent: () => { }, toString: () => "" }; return l && ({ priorityMethods: h, linkTags: f, metaTags: d, scriptTags: p } = qx(e)), { priority: h, base: Ct("base", t, r), bodyAttributes: Ct("bodyAttributes", n, r), htmlAttributes: Ct("htmlAttributes", i, r), link: Ct("link", f, r), meta: Ct("meta", d, r), noscript: Ct("noscript", u, r), script: Ct("script", p, r), style: Ct("style", s, r), title: Ct("title", { title: a, titleAttributes: o }, r) } }, mc = Qx, Ss = [], f1 = !!(typeof window < "u" && window.document && window.document.createElement), gc = class { constructor(e, t) { an(this, "instances", []); an(this, "canUseDOM", f1); an(this, "context"); an(this, "value", { setHelmet: e => { this.context.helmet = e }, helmetInstances: { get: () => this.canUseDOM ? Ss : this.instances, add: e => { (this.canUseDOM ? Ss : this.instances).push(e) }, remove: e => { const t = (this.canUseDOM ? Ss : this.instances).indexOf(e); (this.canUseDOM ? Ss : this.instances).splice(t, 1) } } }); this.context = e, this.canUseDOM = t || !1, t || (e.helmet = mc({ baseTag: [], bodyAttributes: {}, htmlAttributes: {}, linkTags: [], metaTags: [], noscriptTags: [], scriptTags: [], styleTags: [], title: "", titleAttributes: {} })) } }, Gx = {}, d1 = Bt.createContext(Gx), lr, h1 = (lr = class extends M.Component { constructor(n) { super(n); an(this, "helmetData"); this.helmetData = new gc(this.props.context || {}, lr.canUseDOM) } render() { return Bt.createElement(d1.Provider, { value: this.helmetData.value }, this.props.children) } }, an(lr, "canUseDOM", f1), lr), Or = (e, t) => { const n = document.head || document.querySelector("head"), r = n.querySelectorAll(`${e}[${Ut}]`), i = [].slice.call(r), u = []; let s; return t && t.length && t.forEach(a => { const o = document.createElement(e); for (const l in a) if (Object.prototype.hasOwnProperty.call(a, l)) if (l === "innerHTML") o.innerHTML = a.innerHTML; else if (l === "cssText") o.styleSheet ? o.styleSheet.cssText = a.cssText : o.appendChild(document.createTextNode(a.cssText)); else { const f = l, d = typeof a[f] > "u" ? "" : a[f]; o.setAttribute(l, d) } o.setAttribute(Ut, "true"), i.some((l, f) => (s = f, o.isEqualNode(l))) ? i.splice(s, 1) : u.push(o) }), i.forEach(a => { var o; return (o = a.parentNode) == null ? void 0 : o.removeChild(a) }), u.forEach(a => n.appendChild(a)), { oldTags: i, newTags: u } }, Ec = (e, t) => { const n = document.getElementsByTagName(e)[0]; if (!n) return; const r = n.getAttribute(Ut), i = r ? r.split(",") : [], u = [...i], s = Object.keys(t); for (const a of s) { const o = t[a] || ""; n.getAttribute(a) !== o && n.setAttribute(a, o), i.indexOf(a) === -1 && i.push(a); const l = u.indexOf(a); l !== -1 && u.splice(l, 1) } for (let a = u.length - 1; a >= 0; a -= 1)n.removeAttribute(u[a]); i.length === u.length ? n.removeAttribute(Ut) : n.getAttribute(Ut) !== s.join(",") && n.setAttribute(Ut, s.join(",")) }, Xx = (e, t) => { typeof e < "u" && document.title !== e && (document.title = o1(e)), Ec("title", t) }, $h = (e, t) => { const { baseTag: n, bodyAttributes: r, htmlAttributes: i, linkTags: u, metaTags: s, noscriptTags: a, onChangeClientState: o, scriptTags: l, styleTags: f, title: d, titleAttributes: p } = e; Ec("body", r), Ec("html", i), Xx(d, p); const h = { baseTag: Or("base", n), linkTags: Or("link", u), metaTags: Or("meta", s), noscriptTags: Or("noscript", a), scriptTags: Or("script", l), styleTags: Or("style", f) }, m = {}, T = {}; Object.keys(h).forEach(_ => { const { newTags: g, oldTags: E } = h[_]; g.length && (m[_] = g), E.length && (T[_] = h[_].oldTags) }), t && t(), o(e, m, T) }, Bi = null, Jx = e => { Bi && cancelAnimationFrame(Bi), e.defer ? Bi = requestAnimationFrame(() => { $h(e, () => { Bi = null }) }) : ($h(e), Bi = null) }, Zx = Jx, Vh = class extends M.Component { constructor() { super(...arguments); an(this, "rendered", !1) } shouldComponentUpdate(t) { return !Dx(t, this.props) } componentDidUpdate() { this.emitChange() } componentWillUnmount() { const { helmetInstances: t } = this.props.context; t.remove(this), this.emitChange() } emitChange() { const { helmetInstances: t, setHelmet: n } = this.props.context; let r = null; const i = jx(t.get().map(u => { const s = { ...u.props }; return delete s.context, s })); h1.canUseDOM ? Zx(i) : mc && (r = mc(i)), n(r) } init() { if (this.rendered) return; this.rendered = !0; const { helmetInstances: t } = this.props.context; t.add(this), this.emitChange() } render() { return this.init(), null } }, El, $f = (El = class extends M.Component { shouldComponentUpdate(e) { return !Ox(jh(this.props, "helmetData"), jh(e, "helmetData")) } mapNestedChildrenToProps(e, t) { if (!t) return null; switch (e.type) { case "script": case "noscript": return { innerHTML: t }; case "style": return { cssText: t }; default: throw new Error(`<${e.type} /> elements are self-closing and can not contain children. Refer to our API for more information.`) } } flattenArrayTypeChildren(e, t, n, r) { return { ...t, [e.type]: [...t[e.type] || [], { ...n, ...this.mapNestedChildrenToProps(e, r) }] } } mapObjectTypeChildren(e, t, n, r) { switch (e.type) { case "title": return { ...t, [e.type]: r, titleAttributes: { ...n } }; case "body": return { ...t, bodyAttributes: { ...n } }; case "html": return { ...t, htmlAttributes: { ...n } }; default: return { ...t, [e.type]: { ...n } } } } mapArrayTypeChildrenToProps(e, t) { let n = { ...t }; return Object.keys(e).forEach(r => { n = { ...n, [r]: e[r] } }), n } warnOnInvalidChildren(e, t) { return Hh(zh.some(n => e.type === n), typeof e.type == "function" ? "You may be attempting to nest <Helmet> components within each other, which is not allowed. Refer to our API for more information." : `Only elements types ${zh.join(", ")} are allowed. Helmet does not support rendering <${e.type}> elements. Refer to our API for more information.`), Hh(!t || typeof t == "string" || Array.isArray(t) && !t.some(n => typeof n != "string"), `Helmet expects a string as a child of <${e.type}>. Did you forget to wrap your children in braces? ( <${e.type}>{\`\`}</${e.type}> ) Refer to our API for more information.`), !0 } mapChildrenToProps(e, t) { let n = {}; return Bt.Children.forEach(e, r => { if (!r || !r.props) return; const { children: i, ...u } = r.props, s = Object.keys(u).reduce((o, l) => (o[Mx[l] || l] = u[l], o), {}); let { type: a } = r; switch (typeof a == "symbol" ? a = a.toString() : this.warnOnInvalidChildren(r, i), a) { case "Symbol(react.fragment)": t = this.mapChildrenToProps(i, t); break; case "link": case "meta": case "noscript": case "script": case "style": n = this.flattenArrayTypeChildren(r, n, s, i); break; default: t = this.mapObjectTypeChildren(r, t, s, i); break } }), this.mapArrayTypeChildrenToProps(n, t) } render() { const { children: e, ...t } = this.props; let n = { ...t }, { helmetData: r } = t; if (e && (n = this.mapChildrenToProps(e, n)), r && !(r instanceof gc)) { const i = r; r = new gc(i.context, !0), delete n.helmetData } return r ? Bt.createElement(Vh, { ...n, context: r.value }) : Bt.createElement(d1.Consumer, null, i => Bt.createElement(Vh, { ...n, context: i })) } }, an(El, "defaultProps", { defer: !0, encodeSpecialCharacters: !0, prioritizeSeoTags: !1 }), El); const p1 = M.createContext(void 0); function eS({ children: e }) { const [t, n] = M.useState(() => { try { const a = localStorage.getItem("cr-blog-theme") || localStorage.getItem("theme"); if (a === "dark" || a === "light") return a } catch (a) { console.warn("LocalStorage access denied:", a) } return window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light" }), [r, i] = M.useState(() => { try { const a = localStorage.getItem("cr-blog-text-size") || localStorage.getItem("textSize"); if (a === "small" || a === "medium" || a === "large" || a === "xlarge" || a === "xxlarge" || a === "xxxlarge") return a } catch (a) { console.warn("LocalStorage access denied:", a) } return "medium" }); M.useEffect(() => { const a = document.documentElement; a.classList.remove("light", "dark"), a.classList.add(t); try { localStorage.setItem("cr-blog-theme", t), localStorage.removeItem("theme") } catch { } }, [t]), M.useEffect(() => { document.documentElement.setAttribute("data-text-size", r); try { localStorage.setItem("cr-blog-text-size", r), localStorage.removeItem("textSize") } catch { } }, [r]); const u = () => { n(a => a === "light" ? "dark" : "light") }, s = a => { i(a) }; return w.jsx(p1.Provider, { value: { theme: t, textSize: r, toggleTheme: u, setTextSize: s }, children: e }) } function tS() { const e = M.useContext(p1); if (!e) throw new Error("useTheme must be used within ThemeProvider"); return e } const m1 = M.createContext({ user: null, isAuthenticated: !1, isLoading: !1, login: async () => !1, logout: () => { } }); function nS({ children: e }) { const t = { user: null, isAuthenticated: !1, isLoading: !1, login: async () => !1, logout: () => { } }; return w.jsx(m1.Provider, { value: t, children: e }) } function g1() { return M.useContext(m1) } const te = e => typeof e == "string", Ui = () => { let e, t; const n = new Promise((r, i) => { e = r, t = i }); return n.resolve = e, n.reject = t, n }, Yh = e => e == null ? "" : "" + e, rS = (e, t, n) => { e.forEach(r => { t[r] && (n[r] = t[r]) }) }, iS = /###/g, Wh = e => e && e.indexOf("###") > -1 ? e.replace(iS, ".") : e, Kh = e => !e || te(e), su = (e, t, n) => { const r = te(t) ? t.split(".") : t; let i = 0; for (; i < r.length - 1;) { if (Kh(e)) return {}; const u = Wh(r[i]); !e[u] && n && (e[u] = new n), Object.prototype.hasOwnProperty.call(e, u) ? e = e[u] : e = {}, ++i } return Kh(e) ? {} : { obj: e, k: Wh(r[i]) } }, qh = (e, t, n) => { const { obj: r, k: i } = su(e, t, Object); if (r !== void 0 || t.length === 1) { r[i] = n; return } let u = t[t.length - 1], s = t.slice(0, t.length - 1), a = su(e, s, Object); for (; a.obj === void 0 && s.length;)u = `${s[s.length - 1]}.${u}`, s = s.slice(0, s.length - 1), a = su(e, s, Object), a != null && a.obj && typeof a.obj[`${a.k}.${u}`] < "u" && (a.obj = void 0); a.obj[`${a.k}.${u}`] = n }, uS = (e, t, n, r) => { const { obj: i, k: u } = su(e, t, Object); i[u] = i[u] || [], i[u].push(n) }, _a = (e, t) => { const { obj: n, k: r } = su(e, t); if (n && Object.prototype.hasOwnProperty.call(n, r)) return n[r] }, sS = (e, t, n) => { const r = _a(e, n); return r !== void 0 ? r : _a(t, n) }, E1 = (e, t, n) => { for (const r in t) r !== "__proto__" && r !== "constructor" && (r in e ? te(e[r]) || e[r] instanceof String || te(t[r]) || t[r] instanceof String ? n && (e[r] = t[r]) : E1(e[r], t[r], n) : e[r] = t[r]); return e }, Lr = e => e.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&"); var aS = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;", "/": "&#x2F;" }; const oS = e => te(e) ? e.replace(/[&<>"'\/]/g, t => aS[t]) : e; class lS { constructor(t) { this.capacity = t, this.regExpMap = new Map, this.regExpQueue = [] } getRegExp(t) { const n = this.regExpMap.get(t); if (n !== void 0) return n; const r = new RegExp(t); return this.regExpQueue.length === this.capacity && this.regExpMap.delete(this.regExpQueue.shift()), this.regExpMap.set(t, r), this.regExpQueue.push(t), r } } const cS = [" ", ",", "?", "!", ";"], fS = new lS(20), dS = (e, t, n) => { t = t || "", n = n || ""; const r = cS.filter(s => t.indexOf(s) < 0 && n.indexOf(s) < 0); if (r.length === 0) return !0; const i = fS.getRegExp(`(${r.map(s => s === "?" ? "\\?" : s).join("|")})`); let u = !i.test(e); if (!u) { const s = e.indexOf(n); s > 0 && !i.test(e.substring(0, s)) && (u = !0) } return u }, Tc = (e, t, n = ".") => { if (!e) return; if (e[t]) return Object.prototype.hasOwnProperty.call(e, t) ? e[t] : void 0; const r = t.split(n); let i = e; for (let u = 0; u < r.length;) { if (!i || typeof i != "object") return; let s, a = ""; for (let o = u; o < r.length; ++o)if (o !== u && (a += n), a += r[o], s = i[a], s !== void 0) { if (["string", "number", "boolean"].indexOf(typeof s) > -1 && o < r.length - 1) continue; u += o - u + 1; break } i = s } return i }, Fu = e => e == null ? void 0 : e.replace("_", "-"), hS = { type: "logger", log(e) { this.output("log", e) }, warn(e) { this.output("warn", e) }, error(e) { this.output("error", e) }, output(e, t) { var n, r; (r = (n = console == null ? void 0 : console[e]) == null ? void 0 : n.apply) == null || r.call(n, console, t) } }; class Ca { constructor(t, n = {}) { this.init(t, n) } init(t, n = {}) { this.prefix = n.prefix || "i18next:", this.logger = t || hS, this.options = n, this.debug = n.debug } log(...t) { return this.forward(t, "log", "", !0) } warn(...t) { return this.forward(t, "warn", "", !0) } error(...t) { return this.forward(t, "error", "") } deprecate(...t) { return this.forward(t, "warn", "WARNING DEPRECATED: ", !0) } forward(t, n, r, i) { return i && !this.debug ? null : (te(t[0]) && (t[0] = `${r}${this.prefix} ${t[0]}`), this.logger[n](t)) } create(t) { return new Ca(this.logger, { prefix: `${this.prefix}:${t}:`, ...this.options }) } clone(t) { return t = t || this.options, t.prefix = t.prefix || this.prefix, new Ca(this.logger, t) } } var Zt = new Ca; class Xa { constructor() { this.observers = {} } on(t, n) { return t.split(" ").forEach(r => { this.observers[r] || (this.observers[r] = new Map); const i = this.observers[r].get(n) || 0; this.observers[r].set(n, i + 1) }), this } off(t, n) { if (this.observers[t]) { if (!n) { delete this.observers[t]; return } this.observers[t].delete(n) } } emit(t, ...n) { this.observers[t] && Array.from(this.observers[t].entries()).forEach(([i, u]) => { for (let s = 0; s < u; s++)i(...n) }), this.observers["*"] && Array.from(this.observers["*"].entries()).forEach(([i, u]) => { for (let s = 0; s < u; s++)i.apply(i, [t, ...n]) }) } } class Qh extends Xa { constructor(t, n = { ns: ["translation"], defaultNS: "translation" }) { super(), this.data = t || {}, this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.options.ignoreJSONStructure === void 0 && (this.options.ignoreJSONStructure = !0) } addNamespaces(t) { this.options.ns.indexOf(t) < 0 && this.options.ns.push(t) } removeNamespaces(t) { const n = this.options.ns.indexOf(t); n > -1 && this.options.ns.splice(n, 1) } getResource(t, n, r, i = {}) { var l, f; const u = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, s = i.ignoreJSONStructure !== void 0 ? i.ignoreJSONStructure : this.options.ignoreJSONStructure; let a; t.indexOf(".") > -1 ? a = t.split(".") : (a = [t, n], r && (Array.isArray(r) ? a.push(...r) : te(r) && u ? a.push(...r.split(u)) : a.push(r))); const o = _a(this.data, a); return !o && !n && !r && t.indexOf(".") > -1 && (t = a[0], n = a[1], r = a.slice(2).join(".")), o || !s || !te(r) ? o : Tc((f = (l = this.data) == null ? void 0 : l[t]) == null ? void 0 : f[n], r, u) } addResource(t, n, r, i, u = { silent: !1 }) { const s = u.keySeparator !== void 0 ? u.keySeparator : this.options.keySeparator; let a = [t, n]; r && (a = a.concat(s ? r.split(s) : r)), t.indexOf(".") > -1 && (a = t.split("."), i = n, n = a[1]), this.addNamespaces(n), qh(this.data, a, i), u.silent || this.emit("added", t, n, r, i) } addResources(t, n, r, i = { silent: !1 }) { for (const u in r) (te(r[u]) || Array.isArray(r[u])) && this.addResource(t, n, u, r[u], { silent: !0 }); i.silent || this.emit("added", t, n, r) } addResourceBundle(t, n, r, i, u, s = { silent: !1, skipCopy: !1 }) { let a = [t, n]; t.indexOf(".") > -1 && (a = t.split("."), i = r, r = n, n = a[1]), this.addNamespaces(n); let o = _a(this.data, a) || {}; s.skipCopy || (r = JSON.parse(JSON.stringify(r))), i ? E1(o, r, u) : o = { ...o, ...r }, qh(this.data, a, o), s.silent || this.emit("added", t, n, r) } removeResourceBundle(t, n) { this.hasResourceBundle(t, n) && delete this.data[t][n], this.removeNamespaces(n), this.emit("removed", t, n) } hasResourceBundle(t, n) { return this.getResource(t, n) !== void 0 } getResourceBundle(t, n) { return n || (n = this.options.defaultNS), this.getResource(t, n) } getDataByLanguage(t) { return this.data[t] } hasLanguageSomeTranslations(t) { const n = this.getDataByLanguage(t); return !!(n && Object.keys(n) || []).find(i => n[i] && Object.keys(n[i]).length > 0) } toJSON() { return this.data } } var T1 = { processors: {}, addPostProcessor(e) { this.processors[e.name] = e }, handle(e, t, n, r, i) { return e.forEach(u => { var s; t = ((s = this.processors[u]) == null ? void 0 : s.process(t, n, r, i)) ?? t }), t } }; const y1 = Symbol("i18next/PATH_KEY"); function pS() { const e = [], t = Object.create(null); let n; return t.get = (r, i) => { var u; return (u = n == null ? void 0 : n.revoke) == null || u.call(n), i === y1 ? e : (e.push(i), n = Proxy.revocable(r, t), n.proxy) }, Proxy.revocable(Object.create(null), t).proxy } function yc(e, t) { const { [y1]: n } = e(pS()); return n.join((t == null ? void 0 : t.keySeparator) ?? ".") } const Gh = {}, Ko = e => !te(e) && typeof e != "boolean" && typeof e != "number"; class Aa extends Xa { constructor(t, n = {}) { super(), rS(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], t, this), this.options = n, this.options.keySeparator === void 0 && (this.options.keySeparator = "."), this.logger = Zt.create("translator") } changeLanguage(t) { t && (this.language = t) } exists(t, n = { interpolation: {} }) { const r = { ...n }; if (t == null) return !1; const i = this.resolve(t, r); if ((i == null ? void 0 : i.res) === void 0) return !1; const u = Ko(i.res); return !(r.returnObjects === !1 && u) } extractFromKey(t, n) { let r = n.nsSeparator !== void 0 ? n.nsSeparator : this.options.nsSeparator; r === void 0 && (r = ":"); const i = n.keySeparator !== void 0 ? n.keySeparator : this.options.keySeparator; let u = n.ns || this.options.defaultNS || []; const s = r && t.indexOf(r) > -1, a = !this.options.userDefinedKeySeparator && !n.keySeparator && !this.options.userDefinedNsSeparator && !n.nsSeparator && !dS(t, r, i); if (s && !a) { const o = t.match(this.interpolator.nestingRegexp); if (o && o.length > 0) return { key: t, namespaces: te(u) ? [u] : u }; const l = t.split(r); (r !== i || r === i && this.options.ns.indexOf(l[0]) > -1) && (u = l.shift()), t = l.join(i) } return { key: t, namespaces: te(u) ? [u] : u } } translate(t, n, r) { let i = typeof n == "object" ? { ...n } : n; if (typeof i != "object" && this.options.overloadTranslationOptionHandler && (i = this.options.overloadTranslationOptionHandler(arguments)), typeof i == "object" && (i = { ...i }), i || (i = {}), t == null) return ""; typeof t == "function" && (t = yc(t, { ...this.options, ...i })), Array.isArray(t) || (t = [String(t)]); const u = i.returnDetails !== void 0 ? i.returnDetails : this.options.returnDetails, s = i.keySeparator !== void 0 ? i.keySeparator : this.options.keySeparator, { key: a, namespaces: o } = this.extractFromKey(t[t.length - 1], i), l = o[o.length - 1]; let f = i.nsSeparator !== void 0 ? i.nsSeparator : this.options.nsSeparator; f === void 0 && (f = ":"); const d = i.lng || this.language, p = i.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode; if ((d == null ? void 0 : d.toLowerCase()) === "cimode") return p ? u ? { res: `${l}${f}${a}`, usedKey: a, exactUsedKey: a, usedLng: d, usedNS: l, usedParams: this.getUsedParamsDetails(i) } : `${l}${f}${a}` : u ? { res: a, usedKey: a, exactUsedKey: a, usedLng: d, usedNS: l, usedParams: this.getUsedParamsDetails(i) } : a; const h = this.resolve(t, i); let m = h == null ? void 0 : h.res; const T = (h == null ? void 0 : h.usedKey) || a, _ = (h == null ? void 0 : h.exactUsedKey) || a, g = ["[object Number]", "[object Function]", "[object RegExp]"], E = i.joinArrays !== void 0 ? i.joinArrays : this.options.joinArrays, y = !this.i18nFormat || this.i18nFormat.handleAsObject, I = i.count !== void 0 && !te(i.count), L = Aa.hasDefaultValue(i), k = I ? this.pluralResolver.getSuffix(d, i.count, i) : "", P = i.ordinal && I ? this.pluralResolver.getSuffix(d, i.count, { ordinal: !1 }) : "", j = I && !i.ordinal && i.count === 0, W = j && i[`defaultValue${this.options.pluralSeparator}zero`] || i[`defaultValue${k}`] || i[`defaultValue${P}`] || i.defaultValue; let N = m; y && !m && L && (N = W); const Y = Ko(N), U = Object.prototype.toString.apply(N); if (y && N && Y && g.indexOf(U) < 0 && !(te(E) && Array.isArray(N))) { if (!i.returnObjects && !this.options.returnObjects) { this.options.returnedObjectHandler || this.logger.warn("accessing an object - but returnObjects options is not enabled!"); const K = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(T, N, { ...i, ns: o }) : `key '${a} (${this.language})' returned an object instead of string.`; return u ? (h.res = K, h.usedParams = this.getUsedParamsDetails(i), h) : K } if (s) { const K = Array.isArray(N), q = K ? [] : {}, G = K ? _ : T; for (const ee in N) if (Object.prototype.hasOwnProperty.call(N, ee)) { const ae = `${G}${s}${ee}`; L && !m ? q[ee] = this.translate(ae, { ...i, defaultValue: Ko(W) ? W[ee] : void 0, joinArrays: !1, ns: o }) : q[ee] = this.translate(ae, { ...i, joinArrays: !1, ns: o }), q[ee] === ae && (q[ee] = N[ee]) } m = q } } else if (y && te(E) && Array.isArray(m)) m = m.join(E), m && (m = this.extendTranslation(m, t, i, r)); else { let K = !1, q = !1; !this.isValidLookup(m) && L && (K = !0, m = W), this.isValidLookup(m) || (q = !0, m = a); const ee = (i.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey) && q ? void 0 : m, ae = L && W !== m && this.options.updateMissing; if (q || K || ae) { if (this.logger.log(ae ? "updateKey" : "missingKey", d, l, a, ae ? W : m), s) { const J = this.resolve(a, { ...i, keySeparator: !1 }); J && J.res && this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.") } let H = []; const X = this.languageUtils.getFallbackCodes(this.options.fallbackLng, i.lng || this.language); if (this.options.saveMissingTo === "fallback" && X && X[0]) for (let J = 0; J < X.length; J++)H.push(X[J]); else this.options.saveMissingTo === "all" ? H = this.languageUtils.toResolveHierarchy(i.lng || this.language) : H.push(i.lng || this.language); const S = (J, ne, A) => { var ze; const pe = L && A !== m ? A : ee; this.options.missingKeyHandler ? this.options.missingKeyHandler(J, l, ne, pe, ae, i) : (ze = this.backendConnector) != null && ze.saveMissing && this.backendConnector.saveMissing(J, l, ne, pe, ae, i), this.emit("missingKey", J, l, ne, m) }; this.options.saveMissing && (this.options.saveMissingPlurals && I ? H.forEach(J => { const ne = this.pluralResolver.getSuffixes(J, i); j && i[`defaultValue${this.options.pluralSeparator}zero`] && ne.indexOf(`${this.options.pluralSeparator}zero`) < 0 && ne.push(`${this.options.pluralSeparator}zero`), ne.forEach(A => { S([J], a + A, i[`defaultValue${A}`] || W) }) }) : S(H, a, W)) } m = this.extendTranslation(m, t, i, h, r), q && m === a && this.options.appendNamespaceToMissingKey && (m = `${l}${f}${a}`), (q || K) && this.options.parseMissingKeyHandler && (m = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${l}${f}${a}` : a, K ? m : void 0, i)) } return u ? (h.res = m, h.usedParams = this.getUsedParamsDetails(i), h) : m } extendTranslation(t, n, r, i, u) { var o, l; if ((o = this.i18nFormat) != null && o.parse) t = this.i18nFormat.parse(t, { ...this.options.interpolation.defaultVariables, ...r }, r.lng || this.language || i.usedLng, i.usedNS, i.usedKey, { resolved: i }); else if (!r.skipInterpolation) { r.interpolation && this.interpolator.init({ ...r, interpolation: { ...this.options.interpolation, ...r.interpolation } }); const f = te(t) && (((l = r == null ? void 0 : r.interpolation) == null ? void 0 : l.skipOnVariables) !== void 0 ? r.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables); let d; if (f) { const h = t.match(this.interpolator.nestingRegexp); d = h && h.length } let p = r.replace && !te(r.replace) ? r.replace : r; if (this.options.interpolation.defaultVariables && (p = { ...this.options.interpolation.defaultVariables, ...p }), t = this.interpolator.interpolate(t, p, r.lng || this.language || i.usedLng, r), f) { const h = t.match(this.interpolator.nestingRegexp), m = h && h.length; d < m && (r.nest = !1) } !r.lng && i && i.res && (r.lng = this.language || i.usedLng), r.nest !== !1 && (t = this.interpolator.nest(t, (...h) => (u == null ? void 0 : u[0]) === h[0] && !r.context ? (this.logger.warn(`It seems you are nesting recursively key: ${h[0]} in key: ${n[0]}`), null) : this.translate(...h, n), r)), r.interpolation && this.interpolator.reset() } const s = r.postProcess || this.options.postProcess, a = te(s) ? [s] : s; return t != null && (a != null && a.length) && r.applyPostProcessor !== !1 && (t = T1.handle(a, t, n, this.options && this.options.postProcessPassResolved ? { i18nResolved: { ...i, usedParams: this.getUsedParamsDetails(r) }, ...r } : r, this)), t } resolve(t, n = {}) { let r, i, u, s, a; return te(t) && (t = [t]), t.forEach(o => { if (this.isValidLookup(r)) return; const l = this.extractFromKey(o, n), f = l.key; i = f; let d = l.namespaces; this.options.fallbackNS && (d = d.concat(this.options.fallbackNS)); const p = n.count !== void 0 && !te(n.count), h = p && !n.ordinal && n.count === 0, m = n.context !== void 0 && (te(n.context) || typeof n.context == "number") && n.context !== "", T = n.lngs ? n.lngs : this.languageUtils.toResolveHierarchy(n.lng || this.language, n.fallbackLng); d.forEach(_ => { var g, E; this.isValidLookup(r) || (a = _, !Gh[`${T[0]}-${_}`] && ((g = this.utils) != null && g.hasLoadedNamespace) && !((E = this.utils) != null && E.hasLoadedNamespace(a)) && (Gh[`${T[0]}-${_}`] = !0, this.logger.warn(`key "${i}" for languages "${T.join(", ")}" won't get resolved as namespace "${a}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!")), T.forEach(y => { var k; if (this.isValidLookup(r)) return; s = y; const I = [f]; if ((k = this.i18nFormat) != null && k.addLookupKeys) this.i18nFormat.addLookupKeys(I, f, y, _, n); else { let P; p && (P = this.pluralResolver.getSuffix(y, n.count, n)); const j = `${this.options.pluralSeparator}zero`, W = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`; if (p && (n.ordinal && P.indexOf(W) === 0 && I.push(f + P.replace(W, this.options.pluralSeparator)), I.push(f + P), h && I.push(f + j)), m) { const N = `${f}${this.options.contextSeparator || "_"}${n.context}`; I.push(N), p && (n.ordinal && P.indexOf(W) === 0 && I.push(N + P.replace(W, this.options.pluralSeparator)), I.push(N + P), h && I.push(N + j)) } } let L; for (; L = I.pop();)this.isValidLookup(r) || (u = L, r = this.getResource(y, _, L, n)) })) }) }), { res: r, usedKey: i, exactUsedKey: u, usedLng: s, usedNS: a } } isValidLookup(t) { return t !== void 0 && !(!this.options.returnNull && t === null) && !(!this.options.returnEmptyString && t === "") } getResource(t, n, r, i = {}) { var u; return (u = this.i18nFormat) != null && u.getResource ? this.i18nFormat.getResource(t, n, r, i) : this.resourceStore.getResource(t, n, r, i) } getUsedParamsDetails(t = {}) { const n = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"], r = t.replace && !te(t.replace); let i = r ? t.replace : t; if (r && typeof t.count < "u" && (i.count = t.count), this.options.interpolation.defaultVariables && (i = { ...this.options.interpolation.defaultVariables, ...i }), !r) { i = { ...i }; for (const u of n) delete i[u] } return i } static hasDefaultValue(t) { const n = "defaultValue"; for (const r in t) if (Object.prototype.hasOwnProperty.call(t, r) && n === r.substring(0, n.length) && t[r] !== void 0) return !0; return !1 } } class Xh { constructor(t) { this.options = t, this.supportedLngs = this.options.supportedLngs || !1, this.logger = Zt.create("languageUtils") } getScriptPartFromCode(t) { if (t = Fu(t), !t || t.indexOf("-") < 0) return null; const n = t.split("-"); return n.length === 2 || (n.pop(), n[n.length - 1].toLowerCase() === "x") ? null : this.formatLanguageCode(n.join("-")) } getLanguagePartFromCode(t) { if (t = Fu(t), !t || t.indexOf("-") < 0) return t; const n = t.split("-"); return this.formatLanguageCode(n[0]) } formatLanguageCode(t) { if (te(t) && t.indexOf("-") > -1) { let n; try { n = Intl.getCanonicalLocales(t)[0] } catch { } return n && this.options.lowerCaseLng && (n = n.toLowerCase()), n || (this.options.lowerCaseLng ? t.toLowerCase() : t) } return this.options.cleanCode || this.options.lowerCaseLng ? t.toLowerCase() : t } isSupportedCode(t) { return (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) && (t = this.getLanguagePartFromCode(t)), !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(t) > -1 } getBestMatchFromCodes(t) { if (!t) return null; let n; return t.forEach(r => { if (n) return; const i = this.formatLanguageCode(r); (!this.options.supportedLngs || this.isSupportedCode(i)) && (n = i) }), !n && this.options.supportedLngs && t.forEach(r => { if (n) return; const i = this.getScriptPartFromCode(r); if (this.isSupportedCode(i)) return n = i; const u = this.getLanguagePartFromCode(r); if (this.isSupportedCode(u)) return n = u; n = this.options.supportedLngs.find(s => { if (s === u) return s; if (!(s.indexOf("-") < 0 && u.indexOf("-") < 0) && (s.indexOf("-") > 0 && u.indexOf("-") < 0 && s.substring(0, s.indexOf("-")) === u || s.indexOf(u) === 0 && u.length > 1)) return s }) }), n || (n = this.getFallbackCodes(this.options.fallbackLng)[0]), n } getFallbackCodes(t, n) { if (!t) return []; if (typeof t == "function" && (t = t(n)), te(t) && (t = [t]), Array.isArray(t)) return t; if (!n) return t.default || []; let r = t[n]; return r || (r = t[this.getScriptPartFromCode(n)]), r || (r = t[this.formatLanguageCode(n)]), r || (r = t[this.getLanguagePartFromCode(n)]), r || (r = t.default), r || [] } toResolveHierarchy(t, n) { const r = this.getFallbackCodes((n === !1 ? [] : n) || this.options.fallbackLng || [], t), i = [], u = s => { s && (this.isSupportedCode(s) ? i.push(s) : this.logger.warn(`rejecting language code not found in supportedLngs: ${s}`)) }; return te(t) && (t.indexOf("-") > -1 || t.indexOf("_") > -1) ? (this.options.load !== "languageOnly" && u(this.formatLanguageCode(t)), this.options.load !== "languageOnly" && this.options.load !== "currentOnly" && u(this.getScriptPartFromCode(t)), this.options.load !== "currentOnly" && u(this.getLanguagePartFromCode(t))) : te(t) && u(this.formatLanguageCode(t)), r.forEach(s => { i.indexOf(s) < 0 && u(this.formatLanguageCode(s)) }), i } } const Jh = { zero: 0, one: 1, two: 2, few: 3, many: 4, other: 5 }, Zh = { select: e => e === 1 ? "one" : "other", resolvedOptions: () => ({ pluralCategories: ["one", "other"] }) }; class mS { constructor(t, n = {}) { this.languageUtils = t, this.options = n, this.logger = Zt.create("pluralResolver"), this.pluralRulesCache = {} } addRule(t, n) { this.rules[t] = n } clearCache() { this.pluralRulesCache = {} } getRule(t, n = {}) { const r = Fu(t === "dev" ? "en" : t), i = n.ordinal ? "ordinal" : "cardinal", u = JSON.stringify({ cleanedCode: r, type: i }); if (u in this.pluralRulesCache) return this.pluralRulesCache[u]; let s; try { s = new Intl.PluralRules(r, { type: i }) } catch { if (!Intl) return this.logger.error("No Intl support, please use an Intl polyfill!"), Zh; if (!t.match(/-|_/)) return Zh; const o = this.languageUtils.getLanguagePartFromCode(t); s = this.getRule(o, n) } return this.pluralRulesCache[u] = s, s } needsPlural(t, n = {}) { let r = this.getRule(t, n); return r || (r = this.getRule("dev", n)), (r == null ? void 0 : r.resolvedOptions().pluralCategories.length) > 1 } getPluralFormsOfKey(t, n, r = {}) { return this.getSuffixes(t, r).map(i => `${n}${i}`) } getSuffixes(t, n = {}) { let r = this.getRule(t, n); return r || (r = this.getRule("dev", n)), r ? r.resolvedOptions().pluralCategories.sort((i, u) => Jh[i] - Jh[u]).map(i => `${this.options.prepend}${n.ordinal ? `ordinal${this.options.prepend}` : ""}${i}`) : [] } getSuffix(t, n, r = {}) { const i = this.getRule(t, r); return i ? `${this.options.prepend}${r.ordinal ? `ordinal${this.options.prepend}` : ""}${i.select(n)}` : (this.logger.warn(`no plural rule found for: ${t}`), this.getSuffix("dev", n, r)) } } const e0 = (e, t, n, r = ".", i = !0) => { let u = sS(e, t, n); return !u && i && te(n) && (u = Tc(e, n, r), u === void 0 && (u = Tc(t, n, r))), u }, qo = e => e.replace(/\$/g, "$$$$"); class t0 { constructor(t = {}) { var n; this.logger = Zt.create("interpolator"), this.options = t, this.format = ((n = t == null ? void 0 : t.interpolation) == null ? void 0 : n.format) || (r => r), this.init(t) } init(t = {}) { t.interpolation || (t.interpolation = { escapeValue: !0 }); const { escape: n, escapeValue: r, useRawValueToEscape: i, prefix: u, prefixEscaped: s, suffix: a, suffixEscaped: o, formatSeparator: l, unescapeSuffix: f, unescapePrefix: d, nestingPrefix: p, nestingPrefixEscaped: h, nestingSuffix: m, nestingSuffixEscaped: T, nestingOptionsSeparator: _, maxReplaces: g, alwaysFormat: E } = t.interpolation; this.escape = n !== void 0 ? n : oS, this.escapeValue = r !== void 0 ? r : !0, this.useRawValueToEscape = i !== void 0 ? i : !1, this.prefix = u ? Lr(u) : s || "{{", this.suffix = a ? Lr(a) : o || "}}", this.formatSeparator = l || ",", this.unescapePrefix = f ? "" : d || "-", this.unescapeSuffix = this.unescapePrefix ? "" : f || "", this.nestingPrefix = p ? Lr(p) : h || Lr("$t("), this.nestingSuffix = m ? Lr(m) : T || Lr(")"), this.nestingOptionsSeparator = _ || ",", this.maxReplaces = g || 1e3, this.alwaysFormat = E !== void 0 ? E : !1, this.resetRegExp() } reset() { this.options && this.init(this.options) } resetRegExp() { const t = (n, r) => (n == null ? void 0 : n.source) === r ? (n.lastIndex = 0, n) : new RegExp(r, "g"); this.regexp = t(this.regexp, `${this.prefix}(.+?)${this.suffix}`), this.regexpUnescape = t(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`), this.nestingRegexp = t(this.nestingRegexp, `${this.nestingPrefix}((?:[^()"']+|"[^"]*"|'[^']*'|\\((?:[^()]|"[^"]*"|'[^']*')*\\))*?)${this.nestingSuffix}`) } interpolate(t, n, r, i) { var h; let u, s, a; const o = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {}, l = m => { if (m.indexOf(this.formatSeparator) < 0) { const E = e0(n, o, m, this.options.keySeparator, this.options.ignoreJSONStructure); return this.alwaysFormat ? this.format(E, void 0, r, { ...i, ...n, interpolationkey: m }) : E } const T = m.split(this.formatSeparator), _ = T.shift().trim(), g = T.join(this.formatSeparator).trim(); return this.format(e0(n, o, _, this.options.keySeparator, this.options.ignoreJSONStructure), g, r, { ...i, ...n, interpolationkey: _ }) }; this.resetRegExp(); const f = (i == null ? void 0 : i.missingInterpolationHandler) || this.options.missingInterpolationHandler, d = ((h = i == null ? void 0 : i.interpolation) == null ? void 0 : h.skipOnVariables) !== void 0 ? i.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables; return [{ regex: this.regexpUnescape, safeValue: m => qo(m) }, { regex: this.regexp, safeValue: m => this.escapeValue ? qo(this.escape(m)) : qo(m) }].forEach(m => { for (a = 0; u = m.regex.exec(t);) { const T = u[1].trim(); if (s = l(T), s === void 0) if (typeof f == "function") { const g = f(t, u, i); s = te(g) ? g : "" } else if (i && Object.prototype.hasOwnProperty.call(i, T)) s = ""; else if (d) { s = u[0]; continue } else this.logger.warn(`missed to pass in variable ${T} for interpolating ${t}`), s = ""; else !te(s) && !this.useRawValueToEscape && (s = Yh(s)); const _ = m.safeValue(s); if (t = t.replace(u[0], _), d ? (m.regex.lastIndex += s.length, m.regex.lastIndex -= u[0].length) : m.regex.lastIndex = 0, a++, a >= this.maxReplaces) break } }), t } nest(t, n, r = {}) { let i, u, s; const a = (o, l) => { const f = this.nestingOptionsSeparator; if (o.indexOf(f) < 0) return o; const d = o.split(new RegExp(`${f}[ ]*{`)); let p = `{${d[1]}`; o = d[0], p = this.interpolate(p, s); const h = p.match(/'/g), m = p.match(/"/g); (((h == null ? void 0 : h.length) ?? 0) % 2 === 0 && !m || m.length % 2 !== 0) && (p = p.replace(/'/g, '"')); try { s = JSON.parse(p), l && (s = { ...l, ...s }) } catch (T) { return this.logger.warn(`failed parsing options string in nesting for key ${o}`, T), `${o}${f}${p}` } return s.defaultValue && s.defaultValue.indexOf(this.prefix) > -1 && delete s.defaultValue, o }; for (; i = this.nestingRegexp.exec(t);) { let o = []; s = { ...r }, s = s.replace && !te(s.replace) ? s.replace : s, s.applyPostProcessor = !1, delete s.defaultValue; const l = /{.*}/.test(i[1]) ? i[1].lastIndexOf("}") + 1 : i[1].indexOf(this.formatSeparator); if (l !== -1 && (o = i[1].slice(l).split(this.formatSeparator).map(f => f.trim()).filter(Boolean), i[1] = i[1].slice(0, l)), u = n(a.call(this, i[1].trim(), s), s), u && i[0] === t && !te(u)) return u; te(u) || (u = Yh(u)), u || (this.logger.warn(`missed to resolve ${i[1]} for nesting ${t}`), u = ""), o.length && (u = o.reduce((f, d) => this.format(f, d, r.lng, { ...r, interpolationkey: i[1].trim() }), u.trim())), t = t.replace(i[0], u), this.regexp.lastIndex = 0 } return t } } const gS = e => { let t = e.toLowerCase().trim(); const n = {}; if (e.indexOf("(") > -1) { const r = e.split("("); t = r[0].toLowerCase().trim(); const i = r[1].substring(0, r[1].length - 1); t === "currency" && i.indexOf(":") < 0 ? n.currency || (n.currency = i.trim()) : t === "relativetime" && i.indexOf(":") < 0 ? n.range || (n.range = i.trim()) : i.split(";").forEach(s => { if (s) { const [a, ...o] = s.split(":"), l = o.join(":").trim().replace(/^'+|'+$/g, ""), f = a.trim(); n[f] || (n[f] = l), l === "false" && (n[f] = !1), l === "true" && (n[f] = !0), isNaN(l) || (n[f] = parseInt(l, 10)) } }) } return { formatName: t, formatOptions: n } }, n0 = e => { const t = {}; return (n, r, i) => { let u = i; i && i.interpolationkey && i.formatParams && i.formatParams[i.interpolationkey] && i[i.interpolationkey] && (u = { ...u, [i.interpolationkey]: void 0 }); const s = r + JSON.stringify(u); let a = t[s]; return a || (a = e(Fu(r), i), t[s] = a), a(n) } }, ES = e => (t, n, r) => e(Fu(n), r)(t); class TS { constructor(t = {}) { this.logger = Zt.create("formatter"), this.options = t, this.init(t) } init(t, n = { interpolation: {} }) { this.formatSeparator = n.interpolation.formatSeparator || ","; const r = n.cacheInBuiltFormats ? n0 : ES; this.formats = { number: r((i, u) => { const s = new Intl.NumberFormat(i, { ...u }); return a => s.format(a) }), currency: r((i, u) => { const s = new Intl.NumberFormat(i, { ...u, style: "currency" }); return a => s.format(a) }), datetime: r((i, u) => { const s = new Intl.DateTimeFormat(i, { ...u }); return a => s.format(a) }), relativetime: r((i, u) => { const s = new Intl.RelativeTimeFormat(i, { ...u }); return a => s.format(a, u.range || "day") }), list: r((i, u) => { const s = new Intl.ListFormat(i, { ...u }); return a => s.format(a) }) } } add(t, n) { this.formats[t.toLowerCase().trim()] = n } addCached(t, n) { this.formats[t.toLowerCase().trim()] = n0(n) } format(t, n, r, i = {}) { const u = n.split(this.formatSeparator); if (u.length > 1 && u[0].indexOf("(") > 1 && u[0].indexOf(")") < 0 && u.find(a => a.indexOf(")") > -1)) { const a = u.findIndex(o => o.indexOf(")") > -1); u[0] = [u[0], ...u.splice(1, a)].join(this.formatSeparator) } return u.reduce((a, o) => { var d; const { formatName: l, formatOptions: f } = gS(o); if (this.formats[l]) { let p = a; try { const h = ((d = i == null ? void 0 : i.formatParams) == null ? void 0 : d[i.interpolationkey]) || {}, m = h.locale || h.lng || i.locale || i.lng || r; p = this.formats[l](a, m, { ...f, ...i, ...h }) } catch (h) { this.logger.warn(h) } return p } else this.logger.warn(`there was no format function for ${l}`); return a }, t) } } const yS = (e, t) => { e.pending[t] !== void 0 && (delete e.pending[t], e.pendingCount--) }; class bS extends Xa { constructor(t, n, r, i = {}) { var u, s; super(), this.backend = t, this.store = n, this.services = r, this.languageUtils = r.languageUtils, this.options = i, this.logger = Zt.create("backendConnector"), this.waitingReads = [], this.maxParallelReads = i.maxParallelReads || 10, this.readingCalls = 0, this.maxRetries = i.maxRetries >= 0 ? i.maxRetries : 5, this.retryTimeout = i.retryTimeout >= 1 ? i.retryTimeout : 350, this.state = {}, this.queue = [], (s = (u = this.backend) == null ? void 0 : u.init) == null || s.call(u, r, i.backend, i) } queueLoad(t, n, r, i) { const u = {}, s = {}, a = {}, o = {}; return t.forEach(l => { let f = !0; n.forEach(d => { const p = `${l}|${d}`; !r.reload && this.store.hasResourceBundle(l, d) ? this.state[p] = 2 : this.state[p] < 0 || (this.state[p] === 1 ? s[p] === void 0 && (s[p] = !0) : (this.state[p] = 1, f = !1, s[p] === void 0 && (s[p] = !0), u[p] === void 0 && (u[p] = !0), o[d] === void 0 && (o[d] = !0))) }), f || (a[l] = !0) }), (Object.keys(u).length || Object.keys(s).length) && this.queue.push({ pending: s, pendingCount: Object.keys(s).length, loaded: {}, errors: [], callback: i }), { toLoad: Object.keys(u), pending: Object.keys(s), toLoadLanguages: Object.keys(a), toLoadNamespaces: Object.keys(o) } } loaded(t, n, r) { const i = t.split("|"), u = i[0], s = i[1]; n && this.emit("failedLoading", u, s, n), !n && r && this.store.addResourceBundle(u, s, r, void 0, void 0, { skipCopy: !0 }), this.state[t] = n ? -1 : 2, n && r && (this.state[t] = 0); const a = {}; this.queue.forEach(o => { uS(o.loaded, [u], s), yS(o, t), n && o.errors.push(n), o.pendingCount === 0 && !o.done && (Object.keys(o.loaded).forEach(l => { a[l] || (a[l] = {}); const f = o.loaded[l]; f.length && f.forEach(d => { a[l][d] === void 0 && (a[l][d] = !0) }) }), o.done = !0, o.errors.length ? o.callback(o.errors) : o.callback()) }), this.emit("loaded", a), this.queue = this.queue.filter(o => !o.done) } read(t, n, r, i = 0, u = this.retryTimeout, s) { if (!t.length) return s(null, {}); if (this.readingCalls >= this.maxParallelReads) { this.waitingReads.push({ lng: t, ns: n, fcName: r, tried: i, wait: u, callback: s }); return } this.readingCalls++; const a = (l, f) => { if (this.readingCalls--, this.waitingReads.length > 0) { const d = this.waitingReads.shift(); this.read(d.lng, d.ns, d.fcName, d.tried, d.wait, d.callback) } if (l && f && i < this.maxRetries) { setTimeout(() => { this.read.call(this, t, n, r, i + 1, u * 2, s) }, u); return } s(l, f) }, o = this.backend[r].bind(this.backend); if (o.length === 2) { try { const l = o(t, n); l && typeof l.then == "function" ? l.then(f => a(null, f)).catch(a) : a(null, l) } catch (l) { a(l) } return } return o(t, n, a) } prepareLoading(t, n, r = {}, i) { if (!this.backend) return this.logger.warn("No backend was added via i18next.use. Will not load resources."), i && i(); te(t) && (t = this.languageUtils.toResolveHierarchy(t)), te(n) && (n = [n]); const u = this.queueLoad(t, n, r, i); if (!u.toLoad.length) return u.pending.length || i(), null; u.toLoad.forEach(s => { this.loadOne(s) }) } load(t, n, r) { this.prepareLoading(t, n, {}, r) } reload(t, n, r) { this.prepareLoading(t, n, { reload: !0 }, r) } loadOne(t, n = "") { const r = t.split("|"), i = r[0], u = r[1]; this.read(i, u, "read", void 0, void 0, (s, a) => { s && this.logger.warn(`${n}loading namespace ${u} for language ${i} failed`, s), !s && a && this.logger.log(`${n}loaded namespace ${u} for language ${i}`, a), this.loaded(t, s, a) }) } saveMissing(t, n, r, i, u, s = {}, a = () => { }) { var o, l, f, d, p; if ((l = (o = this.services) == null ? void 0 : o.utils) != null && l.hasLoadedNamespace && !((d = (f = this.services) == null ? void 0 : f.utils) != null && d.hasLoadedNamespace(n))) { this.logger.warn(`did not save key "${r}" as the namespace "${n}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!"); return } if (!(r == null || r === "")) { if ((p = this.backend) != null && p.create) { const h = { ...s, isUpdate: u }, m = this.backend.create.bind(this.backend); if (m.length < 6) try { let T; m.length === 5 ? T = m(t, n, r, i, h) : T = m(t, n, r, i), T && typeof T.then == "function" ? T.then(_ => a(null, _)).catch(a) : a(null, T) } catch (T) { a(T) } else m(t, n, r, i, a, h) } !t || !t[0] || this.store.addResource(t[0], n, r, i) } } } const r0 = () => ({ debug: !1, initAsync: !0, ns: ["translation"], defaultNS: ["translation"], fallbackLng: ["dev"], fallbackNS: !1, supportedLngs: !1, nonExplicitSupportedLngs: !1, load: "all", preload: !1, simplifyPluralSuffix: !0, keySeparator: ".", nsSeparator: ":", pluralSeparator: "_", contextSeparator: "_", partialBundledLanguages: !1, saveMissing: !1, updateMissing: !1, saveMissingTo: "fallback", saveMissingPlurals: !0, missingKeyHandler: !1, missingInterpolationHandler: !1, postProcess: !1, postProcessPassResolved: !1, returnNull: !1, returnEmptyString: !0, returnObjects: !1, joinArrays: !1, returnedObjectHandler: !1, parseMissingKeyHandler: !1, appendNamespaceToMissingKey: !1, appendNamespaceToCIMode: !1, overloadTranslationOptionHandler: e => { let t = {}; if (typeof e[1] == "object" && (t = e[1]), te(e[1]) && (t.defaultValue = e[1]), te(e[2]) && (t.tDescription = e[2]), typeof e[2] == "object" || typeof e[3] == "object") { const n = e[3] || e[2]; Object.keys(n).forEach(r => { t[r] = n[r] }) } return t }, interpolation: { escapeValue: !0, format: e => e, prefix: "{{", suffix: "}}", formatSeparator: ",", unescapePrefix: "-", nestingPrefix: "$t(", nestingSuffix: ")", nestingOptionsSeparator: ",", maxReplaces: 1e3, skipOnVariables: !0 }, cacheInBuiltFormats: !0 }), i0 = e => { var t, n; return te(e.ns) && (e.ns = [e.ns]), te(e.fallbackLng) && (e.fallbackLng = [e.fallbackLng]), te(e.fallbackNS) && (e.fallbackNS = [e.fallbackNS]), ((n = (t = e.supportedLngs) == null ? void 0 : t.indexOf) == null ? void 0 : n.call(t, "cimode")) < 0 && (e.supportedLngs = e.supportedLngs.concat(["cimode"])), typeof e.initImmediate == "boolean" && (e.initAsync = e.initImmediate), e }, _s = () => { }, xS = e => { Object.getOwnPropertyNames(Object.getPrototypeOf(e)).forEach(n => { typeof e[n] == "function" && (e[n] = e[n].bind(e)) }) }; class au extends Xa { constructor(t = {}, n) { if (super(), this.options = i0(t), this.services = {}, this.logger = Zt, this.modules = { external: [] }, xS(this), n && !this.isInitialized && !t.isClone) { if (!this.options.initAsync) return this.init(t, n), this; setTimeout(() => { this.init(t, n) }, 0) } } init(t = {}, n) { this.isInitializing = !0, typeof t == "function" && (n = t, t = {}), t.defaultNS == null && t.ns && (te(t.ns) ? t.defaultNS = t.ns : t.ns.indexOf("translation") < 0 && (t.defaultNS = t.ns[0])); const r = r0(); this.options = { ...r, ...this.options, ...i0(t) }, this.options.interpolation = { ...r.interpolation, ...this.options.interpolation }, t.keySeparator !== void 0 && (this.options.userDefinedKeySeparator = t.keySeparator), t.nsSeparator !== void 0 && (this.options.userDefinedNsSeparator = t.nsSeparator), typeof this.options.overloadTranslationOptionHandler != "function" && (this.options.overloadTranslationOptionHandler = r.overloadTranslationOptionHandler); const i = l => l ? typeof l == "function" ? new l : l : null; if (!this.options.isClone) { this.modules.logger ? Zt.init(i(this.modules.logger), this.options) : Zt.init(null, this.options); let l; this.modules.formatter ? l = this.modules.formatter : l = TS; const f = new Xh(this.options); this.store = new Qh(this.options.resources, this.options); const d = this.services; d.logger = Zt, d.resourceStore = this.store, d.languageUtils = f, d.pluralResolver = new mS(f, { prepend: this.options.pluralSeparator, simplifyPluralSuffix: this.options.simplifyPluralSuffix }), this.options.interpolation.format && this.options.interpolation.format !== r.interpolation.format && this.logger.deprecate("init: you are still using the legacy format function, please use the new approach: https://www.i18next.com/translation-function/formatting"), l && (!this.options.interpolation.format || this.options.interpolation.format === r.interpolation.format) && (d.formatter = i(l), d.formatter.init && d.formatter.init(d, this.options), this.options.interpolation.format = d.formatter.format.bind(d.formatter)), d.interpolator = new t0(this.options), d.utils = { hasLoadedNamespace: this.hasLoadedNamespace.bind(this) }, d.backendConnector = new bS(i(this.modules.backend), d.resourceStore, d, this.options), d.backendConnector.on("*", (h, ...m) => { this.emit(h, ...m) }), this.modules.languageDetector && (d.languageDetector = i(this.modules.languageDetector), d.languageDetector.init && d.languageDetector.init(d, this.options.detection, this.options)), this.modules.i18nFormat && (d.i18nFormat = i(this.modules.i18nFormat), d.i18nFormat.init && d.i18nFormat.init(this)), this.translator = new Aa(this.services, this.options), this.translator.on("*", (h, ...m) => { this.emit(h, ...m) }), this.modules.external.forEach(h => { h.init && h.init(this) }) } if (this.format = this.options.interpolation.format, n || (n = _s), this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) { const l = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng); l.length > 0 && l[0] !== "dev" && (this.options.lng = l[0]) } !this.services.languageDetector && !this.options.lng && this.logger.warn("init: no languageDetector is used and no lng is defined"), ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"].forEach(l => { this[l] = (...f) => this.store[l](...f) }), ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"].forEach(l => { this[l] = (...f) => (this.store[l](...f), this) }); const a = Ui(), o = () => { const l = (f, d) => { this.isInitializing = !1, this.isInitialized && !this.initializedStoreOnce && this.logger.warn("init: i18next is already initialized. You should call init just once!"), this.isInitialized = !0, this.options.isClone || this.logger.log("initialized", this.options), this.emit("initialized", this.options), a.resolve(d), n(f, d) }; if (this.languages && !this.isInitialized) return l(null, this.t.bind(this)); this.changeLanguage(this.options.lng, l) }; return this.options.resources || !this.options.initAsync ? o() : setTimeout(o, 0), a } loadResources(t, n = _s) { var u, s; let r = n; const i = te(t) ? t : this.language; if (typeof t == "function" && (r = t), !this.options.resources || this.options.partialBundledLanguages) { if ((i == null ? void 0 : i.toLowerCase()) === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return r(); const a = [], o = l => { if (!l || l === "cimode") return; this.services.languageUtils.toResolveHierarchy(l).forEach(d => { d !== "cimode" && a.indexOf(d) < 0 && a.push(d) }) }; i ? o(i) : this.services.languageUtils.getFallbackCodes(this.options.fallbackLng).forEach(f => o(f)), (s = (u = this.options.preload) == null ? void 0 : u.forEach) == null || s.call(u, l => o(l)), this.services.backendConnector.load(a, this.options.ns, l => { !l && !this.resolvedLanguage && this.language && this.setResolvedLanguage(this.language), r(l) }) } else r(null) } reloadResources(t, n, r) { const i = Ui(); return typeof t == "function" && (r = t, t = void 0), typeof n == "function" && (r = n, n = void 0), t || (t = this.languages), n || (n = this.options.ns), r || (r = _s), this.services.backendConnector.reload(t, n, u => { i.resolve(), r(u) }), i } use(t) { if (!t) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()"); if (!t.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()"); return t.type === "backend" && (this.modules.backend = t), (t.type === "logger" || t.log && t.warn && t.error) && (this.modules.logger = t), t.type === "languageDetector" && (this.modules.languageDetector = t), t.type === "i18nFormat" && (this.modules.i18nFormat = t), t.type === "postProcessor" && T1.addPostProcessor(t), t.type === "formatter" && (this.modules.formatter = t), t.type === "3rdParty" && this.modules.external.push(t), this } setResolvedLanguage(t) { if (!(!t || !this.languages) && !(["cimode", "dev"].indexOf(t) > -1)) { for (let n = 0; n < this.languages.length; n++) { const r = this.languages[n]; if (!(["cimode", "dev"].indexOf(r) > -1) && this.store.hasLanguageSomeTranslations(r)) { this.resolvedLanguage = r; break } } !this.resolvedLanguage && this.languages.indexOf(t) < 0 && this.store.hasLanguageSomeTranslations(t) && (this.resolvedLanguage = t, this.languages.unshift(t)) } } changeLanguage(t, n) { this.isLanguageChangingTo = t; const r = Ui(); this.emit("languageChanging", t); const i = a => { this.language = a, this.languages = this.services.languageUtils.toResolveHierarchy(a), this.resolvedLanguage = void 0, this.setResolvedLanguage(a) }, u = (a, o) => { o ? this.isLanguageChangingTo === t && (i(o), this.translator.changeLanguage(o), this.isLanguageChangingTo = void 0, this.emit("languageChanged", o), this.logger.log("languageChanged", o)) : this.isLanguageChangingTo = void 0, r.resolve((...l) => this.t(...l)), n && n(a, (...l) => this.t(...l)) }, s = a => { var f, d; !t && !a && this.services.languageDetector && (a = []); const o = te(a) ? a : a && a[0], l = this.store.hasLanguageSomeTranslations(o) ? o : this.services.languageUtils.getBestMatchFromCodes(te(a) ? [a] : a); l && (this.language || i(l), this.translator.language || this.translator.changeLanguage(l), (d = (f = this.services.languageDetector) == null ? void 0 : f.cacheUserLanguage) == null || d.call(f, l)), this.loadResources(l, p => { u(p, l) }) }; return !t && this.services.languageDetector && !this.services.languageDetector.async ? s(this.services.languageDetector.detect()) : !t && this.services.languageDetector && this.services.languageDetector.async ? this.services.languageDetector.detect.length === 0 ? this.services.languageDetector.detect().then(s) : this.services.languageDetector.detect(s) : s(t), r } getFixedT(t, n, r) { const i = (u, s, ...a) => { let o; typeof s != "object" ? o = this.options.overloadTranslationOptionHandler([u, s].concat(a)) : o = { ...s }, o.lng = o.lng || i.lng, o.lngs = o.lngs || i.lngs, o.ns = o.ns || i.ns, o.keyPrefix !== "" && (o.keyPrefix = o.keyPrefix || r || i.keyPrefix); const l = this.options.keySeparator || "."; let f; return o.keyPrefix && Array.isArray(u) ? f = u.map(d => (typeof d == "function" && (d = yc(d, { ...this.options, ...s })), `${o.keyPrefix}${l}${d}`)) : (typeof u == "function" && (u = yc(u, { ...this.options, ...s })), f = o.keyPrefix ? `${o.keyPrefix}${l}${u}` : u), this.t(f, o) }; return te(t) ? i.lng = t : i.lngs = t, i.ns = n, i.keyPrefix = r, i } t(...t) { var n; return (n = this.translator) == null ? void 0 : n.translate(...t) } exists(...t) { var n; return (n = this.translator) == null ? void 0 : n.exists(...t) } setDefaultNamespace(t) { this.options.defaultNS = t } hasLoadedNamespace(t, n = {}) { if (!this.isInitialized) return this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages), !1; if (!this.languages || !this.languages.length) return this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages), !1; const r = n.lng || this.resolvedLanguage || this.languages[0], i = this.options ? this.options.fallbackLng : !1, u = this.languages[this.languages.length - 1]; if (r.toLowerCase() === "cimode") return !0; const s = (a, o) => { const l = this.services.backendConnector.state[`${a}|${o}`]; return l === -1 || l === 0 || l === 2 }; if (n.precheck) { const a = n.precheck(this, s); if (a !== void 0) return a } return !!(this.hasResourceBundle(r, t) || !this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages || s(r, t) && (!i || s(u, t))) } loadNamespaces(t, n) { const r = Ui(); return this.options.ns ? (te(t) && (t = [t]), t.forEach(i => { this.options.ns.indexOf(i) < 0 && this.options.ns.push(i) }), this.loadResources(i => { r.resolve(), n && n(i) }), r) : (n && n(), Promise.resolve()) } loadLanguages(t, n) { const r = Ui(); te(t) && (t = [t]); const i = this.options.preload || [], u = t.filter(s => i.indexOf(s) < 0 && this.services.languageUtils.isSupportedCode(s)); return u.length ? (this.options.preload = i.concat(u), this.loadResources(s => { r.resolve(), n && n(s) }), r) : (n && n(), Promise.resolve()) } dir(t) { var i, u; if (t || (t = this.resolvedLanguage || (((i = this.languages) == null ? void 0 : i.length) > 0 ? this.languages[0] : this.language)), !t) return "rtl"; try { const s = new Intl.Locale(t); if (s && s.getTextInfo) { const a = s.getTextInfo(); if (a && a.direction) return a.direction } } catch { } const n = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"], r = ((u = this.services) == null ? void 0 : u.languageUtils) || new Xh(r0()); return t.toLowerCase().indexOf("-latn") > 1 ? "ltr" : n.indexOf(r.getLanguagePartFromCode(t)) > -1 || t.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr" } static createInstance(t = {}, n) { const r = new au(t, n); return r.createInstance = au.createInstance, r } cloneInstance(t = {}, n = _s) { const r = t.forkResourceStore; r && delete t.forkResourceStore; const i = { ...this.options, ...t, isClone: !0 }, u = new au(i); if ((t.debug !== void 0 || t.prefix !== void 0) && (u.logger = u.logger.clone(t)), ["store", "services", "language"].forEach(a => { u[a] = this[a] }), u.services = { ...this.services }, u.services.utils = { hasLoadedNamespace: u.hasLoadedNamespace.bind(u) }, r) { const a = Object.keys(this.store.data).reduce((o, l) => (o[l] = { ...this.store.data[l] }, o[l] = Object.keys(o[l]).reduce((f, d) => (f[d] = { ...o[l][d] }, f), o[l]), o), {}); u.store = new Qh(a, i), u.services.resourceStore = u.store } return t.interpolation && (u.services.interpolator = new t0(i)), u.translator = new Aa(u.services, i), u.translator.on("*", (a, ...o) => { u.emit(a, ...o) }), u.init(i, n), u.translator.options = i, u.translator.backendConnector.services.utils = { hasLoadedNamespace: u.hasLoadedNamespace.bind(u) }, u } toJSON() { return { options: this.options, store: this.store, language: this.language, languages: this.languages, resolvedLanguage: this.resolvedLanguage } } } const it = au.createInstance(); it.createInstance; it.dir; it.init; it.loadResources; it.reloadResources; it.use; it.changeLanguage; it.getFixedT; it.t; it.exists; it.setDefaultNamespace; it.hasLoadedNamespace; it.loadNamespaces; it.loadLanguages; const SS = (e, t, n, r) => { var u, s, a, o; const i = [n, { code: t, ...r || {} }]; if ((s = (u = e == null ? void 0 : e.services) == null ? void 0 : u.logger) != null && s.forward) return e.services.logger.forward(i, "warn", "react-i18next::", !0); yr(i[0]) && (i[0] = `react-i18next:: ${i[0]}`), (o = (a = e == null ? void 0 : e.services) == null ? void 0 : a.logger) != null && o.warn ? e.services.logger.warn(...i) : console != null && console.warn && console.warn(...i) }, u0 = {}, b1 = (e, t, n, r) => { yr(n) && u0[n] || (yr(n) && (u0[n] = new Date), SS(e, t, n, r)) }, x1 = (e, t) => () => { if (e.isInitialized) t(); else { const n = () => { setTimeout(() => { e.off("initialized", n) }, 0), t() }; e.on("initialized", n) } }, bc = (e, t, n) => { e.loadNamespaces(t, x1(e, n)) }, s0 = (e, t, n, r) => { if (yr(n) && (n = [n]), e.options.preload && e.options.preload.indexOf(t) > -1) return bc(e, n, r); n.forEach(i => { e.options.ns.indexOf(i) < 0 && e.options.ns.push(i) }), e.loadLanguages(t, x1(e, r)) }, _S = (e, t, n = {}) => !t.languages || !t.languages.length ? (b1(t, "NO_LANGUAGES", "i18n.languages were undefined or empty", { languages: t.languages }), !0) : t.hasLoadedNamespace(e, { lng: n.lng, precheck: (r, i) => { if (n.bindI18n && n.bindI18n.indexOf("languageChanging") > -1 && r.services.backendConnector.backend && r.isLanguageChangingTo && !i(r.isLanguageChangingTo, e)) return !1 } }), yr = e => typeof e == "string", CS = e => typeof e == "object" && e !== null, AS = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g, kS = { "&amp;": "&", "&#38;": "&", "&lt;": "<", "&#60;": "<", "&gt;": ">", "&#62;": ">", "&apos;": "'", "&#39;": "'", "&quot;": '"', "&#34;": '"', "&nbsp;": " ", "&#160;": " ", "&copy;": "", "&#169;": "", "&reg;": "", "&#174;": "", "&hellip;": "", "&#8230;": "", "&#x2F;": "/", "&#47;": "/" }, NS = e => kS[e], IS = e => e.replace(AS, NS); let xc = { bindI18n: "languageChanged", bindI18nStore: "", transEmptyNodeValue: "", transSupportBasicHtmlNodes: !0, transWrapTextNodes: "", transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"], useSuspense: !0, unescape: IS, transDefaultProps: void 0 }; const wS = (e = {}) => { xc = { ...xc, ...e } }, vS = () => xc; let S1; const OS = e => { S1 = e }, LS = () => S1, RS = { type: "3rdParty", init(e) { wS(e.options.react), OS(e) } }, PS = M.createContext(); class DS { constructor() { this.usedNamespaces = {} } addUsedNamespaces(t) { t.forEach(n => { this.usedNamespaces[n] || (this.usedNamespaces[n] = !0) }) } getUsedNamespaces() { return Object.keys(this.usedNamespaces) } } var _1 = { exports: {} }, C1 = {};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var ci = M; function MS(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var FS = typeof Object.is == "function" ? Object.is : MS, BS = ci.useState, US = ci.useEffect, HS = ci.useLayoutEffect, zS = ci.useDebugValue; function jS(e, t) { var n = t(), r = BS({ inst: { value: n, getSnapshot: t } }), i = r[0].inst, u = r[1]; return HS(function () { i.value = n, i.getSnapshot = t, Qo(i) && u({ inst: i }) }, [e, n, t]), US(function () { return Qo(i) && u({ inst: i }), e(function () { Qo(i) && u({ inst: i }) }) }, [e]), zS(n), n } function Qo(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !FS(e, n) } catch { return !0 } } function $S(e, t) { return t() } var VS = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? $S : jS; C1.useSyncExternalStore = ci.useSyncExternalStore !== void 0 ? ci.useSyncExternalStore : VS; _1.exports = C1; var YS = _1.exports; const WS = (e, t) => yr(t) ? t : CS(t) && yr(t.defaultValue) ? t.defaultValue : Array.isArray(e) ? e[e.length - 1] : e, KS = { t: WS, ready: !1 }, qS = () => () => { }, Vf = (e, t = {}) => { var W, N, Y; const { i18n: n } = t, { i18n: r, defaultNS: i } = M.useContext(PS) || {}, u = n || r || LS(); u && !u.reportNamespaces && (u.reportNamespaces = new DS), u || b1(u, "NO_I18NEXT_INSTANCE", "useTranslation: You will need to pass in an i18next instance by using initReactI18next"); const s = M.useMemo(() => { var U; return { ...vS(), ...(U = u == null ? void 0 : u.options) == null ? void 0 : U.react, ...t } }, [u, t]), { useSuspense: a, keyPrefix: o } = s, l = i || ((W = u == null ? void 0 : u.options) == null ? void 0 : W.defaultNS), f = yr(l) ? [l] : l || ["translation"], d = M.useMemo(() => f, f); (Y = (N = u == null ? void 0 : u.reportNamespaces) == null ? void 0 : N.addUsedNamespaces) == null || Y.call(N, d); const p = M.useRef(0), h = M.useCallback(U => { if (!u) return qS; const { bindI18n: K, bindI18nStore: q } = s, G = () => { p.current += 1, U() }; return K && u.on(K, G), q && u.store.on(q, G), () => { K && K.split(" ").forEach(ee => u.off(ee, G)), q && q.split(" ").forEach(ee => u.store.off(ee, G)) } }, [u, s]), m = M.useRef(), T = M.useCallback(() => { if (!u) return KS; const U = !!(u.isInitialized || u.initializedStoreOnce) && d.every(H => _S(H, u, s)), K = t.lng || u.language, q = p.current, G = m.current; if (G && G.ready === U && G.lng === K && G.keyPrefix === o && G.revision === q) return G; const ae = { t: u.getFixedT(K, s.nsMode === "fallback" ? d : d[0], o), ready: U, lng: K, keyPrefix: o, revision: q }; return m.current = ae, ae }, [u, d, o, s, t.lng]), [_, g] = M.useState(0), { t: E, ready: y } = YS.useSyncExternalStore(h, T, T); M.useEffect(() => { if (u && !y && !a) { const U = () => g(K => K + 1); t.lng ? s0(u, t.lng, d, U) : bc(u, d, U) } }, [u, t.lng, d, y, a, _]); const I = u || {}, L = M.useRef(null), k = M.useRef(), P = U => { const K = Object.getOwnPropertyDescriptors(U); K.__original && delete K.__original; const q = Object.create(Object.getPrototypeOf(U), K); if (!Object.prototype.hasOwnProperty.call(q, "__original")) try { Object.defineProperty(q, "__original", { value: U, writable: !1, enumerable: !1, configurable: !1 }) } catch { } return q }, j = M.useMemo(() => { const U = I, K = U == null ? void 0 : U.language; let q = U; U && (L.current && L.current.__original === U ? k.current !== K ? (q = P(U), L.current = q, k.current = K) : q = L.current : (q = P(U), L.current = q, k.current = K)); const G = [E, q, y]; return G.t = E, G.i18n = q, G.ready = y, G }, [E, I, y, I.resolvedLanguage, I.language, I.languages]); if (u && a && !y) throw new Promise(U => { const K = () => U(); t.lng ? s0(u, t.lng, d, K) : bc(u, d, K) }); return j }; function A1(e, t) { return function () { return e.apply(t, arguments) } } const { toString: QS } = Object.prototype, { getPrototypeOf: Yf } = Object, { iterator: Ja, toStringTag: k1 } = Symbol, Za = (e => t => { const n = QS.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), Vt = e => (e = e.toLowerCase(), t => Za(t) === e), eo = e => t => typeof t === e, { isArray: bi } = Array, fi = eo("undefined"); function qu(e) { return e !== null && !fi(e) && e.constructor !== null && !fi(e.constructor) && dt(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const N1 = Vt("ArrayBuffer"); function GS(e) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && N1(e.buffer), t } const XS = eo("string"), dt = eo("function"), I1 = eo("number"), Qu = e => e !== null && typeof e == "object", JS = e => e === !0 || e === !1, Vs = e => { if (Za(e) !== "object") return !1; const t = Yf(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(k1 in e) && !(Ja in e) }, ZS = e => { if (!Qu(e) || qu(e)) return !1; try { return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype } catch { return !1 } }, e_ = Vt("Date"), t_ = Vt("File"), n_ = Vt("Blob"), r_ = Vt("FileList"), i_ = e => Qu(e) && dt(e.pipe), u_ = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || dt(e.append) && ((t = Za(e)) === "formdata" || t === "object" && dt(e.toString) && e.toString() === "[object FormData]")) }, s_ = Vt("URLSearchParams"), [a_, o_, l_, c_] = ["ReadableStream", "Request", "Response", "Headers"].map(Vt), f_ = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Gu(e, t, { allOwnKeys: n = !1 } = {}) { if (e === null || typeof e > "u") return; let r, i; if (typeof e != "object" && (e = [e]), bi(e)) for (r = 0, i = e.length; r < i; r++)t.call(null, e[r], r, e); else { if (qu(e)) return; const u = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = u.length; let a; for (r = 0; r < s; r++)a = u[r], t.call(null, e[a], a, e) } } function w1(e, t) { if (qu(e)) return null; t = t.toLowerCase(); const n = Object.keys(e); let r = n.length, i; for (; r-- > 0;)if (i = n[r], t === i.toLowerCase()) return i; return null } const ar = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, v1 = e => !fi(e) && e !== ar; function Sc() { const { caseless: e, skipUndefined: t } = v1(this) && this || {}, n = {}, r = (i, u) => { const s = e && w1(n, u) || u; Vs(n[s]) && Vs(i) ? n[s] = Sc(n[s], i) : Vs(i) ? n[s] = Sc({}, i) : bi(i) ? n[s] = i.slice() : (!t || !fi(i)) && (n[s] = i) }; for (let i = 0, u = arguments.length; i < u; i++)arguments[i] && Gu(arguments[i], r); return n } const d_ = (e, t, n, { allOwnKeys: r } = {}) => (Gu(t, (i, u) => { n && dt(i) ? e[u] = A1(i, n) : e[u] = i }, { allOwnKeys: r }), e), h_ = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), p_ = (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, m_ = (e, t, n, r) => { let i, u, s; const a = {}; if (t = t || {}, e == null) return t; do { for (i = Object.getOwnPropertyNames(e), u = i.length; u-- > 0;)s = i[u], (!r || r(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0); e = n !== !1 && Yf(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, g_ = (e, t, n) => { e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return r !== -1 && r === n }, E_ = e => { if (!e) return null; if (bi(e)) return e; let t = e.length; if (!I1(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, T_ = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && Yf(Uint8Array)), y_ = (e, t) => { const r = (e && e[Ja]).call(e); let i; for (; (i = r.next()) && !i.done;) { const u = i.value; t.call(e, u[0], u[1]) } }, b_ = (e, t) => { let n; const r = []; for (; (n = e.exec(t)) !== null;)r.push(n); return r }, x_ = Vt("HTMLFormElement"), S_ = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) { return r.toUpperCase() + i }), a0 = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), __ = Vt("RegExp"), O1 = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; Gu(n, (i, u) => { let s; (s = t(i, u, e)) !== !1 && (r[u] = s || i) }), Object.defineProperties(e, r) }, C_ = e => { O1(e, (t, n) => { if (dt(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const r = e[n]; if (dt(r)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, A_ = (e, t) => { const n = {}, r = i => { i.forEach(u => { n[u] = !0 }) }; return bi(e) ? r(e) : r(String(e).split(t)), n }, k_ = () => { }, N_ = (e, t) => e != null && Number.isFinite(e = +e) ? e : t; function I_(e) { return !!(e && dt(e.append) && e[k1] === "FormData" && e[Ja]) } const w_ = e => { const t = new Array(10), n = (r, i) => { if (Qu(r)) { if (t.indexOf(r) >= 0) return; if (qu(r)) return r; if (!("toJSON" in r)) { t[i] = r; const u = bi(r) ? [] : {}; return Gu(r, (s, a) => { const o = n(s, i + 1); !fi(o) && (u[a] = o) }), t[i] = void 0, u } } return r }; return n(e, 0) }, v_ = Vt("AsyncFunction"), O_ = e => e && (Qu(e) || dt(e)) && dt(e.then) && dt(e.catch), L1 = ((e, t) => e ? setImmediate : t ? ((n, r) => (ar.addEventListener("message", ({ source: i, data: u }) => { i === ar && u === n && r.length && r.shift()() }, !1), i => { r.push(i), ar.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", dt(ar.postMessage)), L_ = typeof queueMicrotask < "u" ? queueMicrotask.bind(ar) : typeof process < "u" && process.nextTick || L1, R_ = e => e != null && dt(e[Ja]), O = { isArray: bi, isArrayBuffer: N1, isBuffer: qu, isFormData: u_, isArrayBufferView: GS, isString: XS, isNumber: I1, isBoolean: JS, isObject: Qu, isPlainObject: Vs, isEmptyObject: ZS, isReadableStream: a_, isRequest: o_, isResponse: l_, isHeaders: c_, isUndefined: fi, isDate: e_, isFile: t_, isBlob: n_, isRegExp: __, isFunction: dt, isStream: i_, isURLSearchParams: s_, isTypedArray: T_, isFileList: r_, forEach: Gu, merge: Sc, extend: d_, trim: f_, stripBOM: h_, inherits: p_, toFlatObject: m_, kindOf: Za, kindOfTest: Vt, endsWith: g_, toArray: E_, forEachEntry: y_, matchAll: b_, isHTMLForm: x_, hasOwnProperty: a0, hasOwnProp: a0, reduceDescriptors: O1, freezeMethods: C_, toObjectSet: A_, toCamelCase: S_, noop: k_, toFiniteNumber: N_, findKey: w1, global: ar, isContextDefined: v1, isSpecCompliantForm: I_, toJSONObject: w_, isAsyncFn: v_, isThenable: O_, setImmediate: L1, asap: L_, isIterable: R_ }; function ie(e, t, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null) } O.inherits(ie, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: O.toJSONObject(this.config), code: this.code, status: this.status } } }); const R1 = ie.prototype, P1 = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { P1[e] = { value: e } }); Object.defineProperties(ie, P1); Object.defineProperty(R1, "isAxiosError", { value: !0 }); ie.from = (e, t, n, r, i, u) => { const s = Object.create(R1); O.toFlatObject(e, s, function (f) { return f !== Error.prototype }, l => l !== "isAxiosError"); const a = e && e.message ? e.message : "Error", o = t == null && e ? e.code : t; return ie.call(s, a, o, n, r, i), e && s.cause == null && Object.defineProperty(s, "cause", { value: e, configurable: !0 }), s.name = e && e.name || "Error", u && Object.assign(s, u), s }; const P_ = null; function _c(e) { return O.isPlainObject(e) || O.isArray(e) } function D1(e) { return O.endsWith(e, "[]") ? e.slice(0, -2) : e } function o0(e, t, n) { return e ? e.concat(t).map(function (i, u) { return i = D1(i), !n && u ? "[" + i + "]" : i }).join(n ? "." : "") : t } function D_(e) { return O.isArray(e) && !e.some(_c) } const M_ = O.toFlatObject(O, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function to(e, t, n) { if (!O.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, n = O.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (T, _) { return !O.isUndefined(_[T]) }); const r = n.metaTokens, i = n.visitor || f, u = n.dots, s = n.indexes, o = (n.Blob || typeof Blob < "u" && Blob) && O.isSpecCompliantForm(t); if (!O.isFunction(i)) throw new TypeError("visitor must be a function"); function l(m) { if (m === null) return ""; if (O.isDate(m)) return m.toISOString(); if (O.isBoolean(m)) return m.toString(); if (!o && O.isBlob(m)) throw new ie("Blob is not supported. Use a Buffer instead."); return O.isArrayBuffer(m) || O.isTypedArray(m) ? o && typeof Blob == "function" ? new Blob([m]) : Buffer.from(m) : m } function f(m, T, _) { let g = m; if (m && !_ && typeof m == "object") { if (O.endsWith(T, "{}")) T = r ? T : T.slice(0, -2), m = JSON.stringify(m); else if (O.isArray(m) && D_(m) || (O.isFileList(m) || O.endsWith(T, "[]")) && (g = O.toArray(m))) return T = D1(T), g.forEach(function (y, I) { !(O.isUndefined(y) || y === null) && t.append(s === !0 ? o0([T], I, u) : s === null ? T : T + "[]", l(y)) }), !1 } return _c(m) ? !0 : (t.append(o0(_, T, u), l(m)), !1) } const d = [], p = Object.assign(M_, { defaultVisitor: f, convertValue: l, isVisitable: _c }); function h(m, T) { if (!O.isUndefined(m)) { if (d.indexOf(m) !== -1) throw Error("Circular reference detected in " + T.join(".")); d.push(m), O.forEach(m, function (g, E) { (!(O.isUndefined(g) || g === null) && i.call(t, g, O.isString(E) ? E.trim() : E, T, p)) === !0 && h(g, T ? T.concat(E) : [E]) }), d.pop() } } if (!O.isObject(e)) throw new TypeError("data must be an object"); return h(e), t } function l0(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (r) { return t[r] }) } function Wf(e, t) { this._pairs = [], e && to(e, this, t) } const M1 = Wf.prototype; M1.append = function (t, n) { this._pairs.push([t, n]) }; M1.toString = function (t) { const n = t ? function (r) { return t.call(this, r, l0) } : l0; return this._pairs.map(function (i) { return n(i[0]) + "=" + n(i[1]) }, "").join("&") }; function F_(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function F1(e, t, n) { if (!t) return e; const r = n && n.encode || F_; O.isFunction(n) && (n = { serialize: n }); const i = n && n.serialize; let u; if (i ? u = i(t, n) : u = O.isURLSearchParams(t) ? t.toString() : new Wf(t, n).toString(r), u) { const s = e.indexOf("#"); s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + u } return e } class c0 { constructor() { this.handlers = [] } use(t, n, r) { return this.handlers.push({ fulfilled: t, rejected: n, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { O.forEach(this.handlers, function (r) { r !== null && t(r) }) } } const B1 = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, B_ = typeof URLSearchParams < "u" ? URLSearchParams : Wf, U_ = typeof FormData < "u" ? FormData : null, H_ = typeof Blob < "u" ? Blob : null, z_ = { isBrowser: !0, classes: { URLSearchParams: B_, FormData: U_, Blob: H_ }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Kf = typeof window < "u" && typeof document < "u", Cc = typeof navigator == "object" && navigator || void 0, j_ = Kf && (!Cc || ["ReactNative", "NativeScript", "NS"].indexOf(Cc.product) < 0), $_ = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", V_ = Kf && window.location.href || "http://localhost", Y_ = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Kf, hasStandardBrowserEnv: j_, hasStandardBrowserWebWorkerEnv: $_, navigator: Cc, origin: V_ }, Symbol.toStringTag, { value: "Module" })), qe = { ...Y_, ...z_ }; function W_(e, t) { return to(e, new qe.classes.URLSearchParams, { visitor: function (n, r, i, u) { return qe.isNode && O.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : u.defaultVisitor.apply(this, arguments) }, ...t }) } function K_(e) { return O.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function q_(e) { const t = {}, n = Object.keys(e); let r; const i = n.length; let u; for (r = 0; r < i; r++)u = n[r], t[u] = e[u]; return t } function U1(e) { function t(n, r, i, u) { let s = n[u++]; if (s === "__proto__") return !0; const a = Number.isFinite(+s), o = u >= n.length; return s = !s && O.isArray(i) ? i.length : s, o ? (O.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !a) : ((!i[s] || !O.isObject(i[s])) && (i[s] = []), t(n, r, i[s], u) && O.isArray(i[s]) && (i[s] = q_(i[s])), !a) } if (O.isFormData(e) && O.isFunction(e.entries)) { const n = {}; return O.forEachEntry(e, (r, i) => { t(K_(r), i, n, 0) }), n } return null } function Q_(e, t, n) { if (O.isString(e)) try { return (t || JSON.parse)(e), O.trim(e) } catch (r) { if (r.name !== "SyntaxError") throw r } return (n || JSON.stringify)(e) } const Xu = { transitional: B1, adapter: ["xhr", "http", "fetch"], transformRequest: [function (t, n) { const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, u = O.isObject(t); if (u && O.isHTMLForm(t) && (t = new FormData(t)), O.isFormData(t)) return i ? JSON.stringify(U1(t)) : t; if (O.isArrayBuffer(t) || O.isBuffer(t) || O.isStream(t) || O.isFile(t) || O.isBlob(t) || O.isReadableStream(t)) return t; if (O.isArrayBufferView(t)) return t.buffer; if (O.isURLSearchParams(t)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let a; if (u) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return W_(t, this.formSerializer).toString(); if ((a = O.isFileList(t)) || r.indexOf("multipart/form-data") > -1) { const o = this.env && this.env.FormData; return to(a ? { "files[]": t } : t, o && new o, this.formSerializer) } } return u || i ? (n.setContentType("application/json", !1), Q_(t)) : t }], transformResponse: [function (t) { const n = this.transitional || Xu.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json"; if (O.isResponse(t) || O.isReadableStream(t)) return t; if (t && O.isString(t) && (r && !this.responseType || i)) { const s = !(n && n.silentJSONParsing) && i; try { return JSON.parse(t, this.parseReviver) } catch (a) { if (s) throw a.name === "SyntaxError" ? ie.from(a, ie.ERR_BAD_RESPONSE, this, null, this.response) : a } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: qe.classes.FormData, Blob: qe.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; O.forEach(["delete", "get", "head", "post", "put", "patch"], e => { Xu.headers[e] = {} }); const G_ = O.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), X_ = e => {
        const t = {}; let n, r, i; return e && e.split(`
`).forEach(function (s) { i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && G_[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) }), t
      }, f0 = Symbol("internals"); function Hi(e) { return e && String(e).trim().toLowerCase() } function Ys(e) { return e === !1 || e == null ? e : O.isArray(e) ? e.map(Ys) : String(e) } function J_(e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t } const Z_ = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function Go(e, t, n, r, i) { if (O.isFunction(r)) return r.call(this, t, n); if (i && (t = n), !!O.isString(t)) { if (O.isString(r)) return t.indexOf(r) !== -1; if (O.isRegExp(r)) return r.test(t) } } function eC(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r) } function tC(e, t) { const n = O.toCamelCase(" " + t);["get", "set", "has"].forEach(r => { Object.defineProperty(e, r + n, { value: function (i, u, s) { return this[r].call(this, t, i, u, s) }, configurable: !0 }) }) } let ht = class {
        constructor(t) { t && this.set(t) } set(t, n, r) { const i = this; function u(a, o, l) { const f = Hi(o); if (!f) throw new Error("header name must be a non-empty string"); const d = O.findKey(i, f); (!d || i[d] === void 0 || l === !0 || l === void 0 && i[d] !== !1) && (i[d || o] = Ys(a)) } const s = (a, o) => O.forEach(a, (l, f) => u(l, f, o)); if (O.isPlainObject(t) || t instanceof this.constructor) s(t, n); else if (O.isString(t) && (t = t.trim()) && !Z_(t)) s(X_(t), n); else if (O.isObject(t) && O.isIterable(t)) { let a = {}, o, l; for (const f of t) { if (!O.isArray(f)) throw TypeError("Object iterator must return a key-value pair"); a[l = f[0]] = (o = a[l]) ? O.isArray(o) ? [...o, f[1]] : [o, f[1]] : f[1] } s(a, n) } else t != null && u(n, t, r); return this } get(t, n) { if (t = Hi(t), t) { const r = O.findKey(this, t); if (r) { const i = this[r]; if (!n) return i; if (n === !0) return J_(i); if (O.isFunction(n)) return n.call(this, i, r); if (O.isRegExp(n)) return n.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, n) { if (t = Hi(t), t) { const r = O.findKey(this, t); return !!(r && this[r] !== void 0 && (!n || Go(this, this[r], r, n))) } return !1 } delete(t, n) { const r = this; let i = !1; function u(s) { if (s = Hi(s), s) { const a = O.findKey(r, s); a && (!n || Go(r, r[a], a, n)) && (delete r[a], i = !0) } } return O.isArray(t) ? t.forEach(u) : u(t), i } clear(t) { const n = Object.keys(this); let r = n.length, i = !1; for (; r--;) { const u = n[r]; (!t || Go(this, this[u], u, t, !0)) && (delete this[u], i = !0) } return i } normalize(t) { const n = this, r = {}; return O.forEach(this, (i, u) => { const s = O.findKey(r, u); if (s) { n[s] = Ys(i), delete n[u]; return } const a = t ? eC(u) : String(u).trim(); a !== u && delete n[u], n[a] = Ys(i), r[a] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const n = Object.create(null); return O.forEach(this, (r, i) => { r != null && r !== !1 && (n[i] = t && O.isArray(r) ? r.join(", ") : r) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
          return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`)
        } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...n) { const r = new this(t); return n.forEach(i => r.set(i)), r } static accessor(t) { const r = (this[f0] = this[f0] = { accessors: {} }).accessors, i = this.prototype; function u(s) { const a = Hi(s); r[a] || (tC(i, s), r[a] = !0) } return O.isArray(t) ? t.forEach(u) : u(t), this }
      }; ht.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); O.reduceDescriptors(ht.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(r) { this[n] = r } } }); O.freezeMethods(ht); function Xo(e, t) { const n = this || Xu, r = t || n, i = ht.from(r.headers); let u = r.data; return O.forEach(e, function (a) { u = a.call(n, u, i.normalize(), t ? t.status : void 0) }), i.normalize(), u } function H1(e) { return !!(e && e.__CANCEL__) } function xi(e, t, n) { ie.call(this, e ?? "canceled", ie.ERR_CANCELED, t, n), this.name = "CanceledError" } O.inherits(xi, ie, { __CANCEL__: !0 }); function z1(e, t, n) { const r = n.config.validateStatus; !n.status || !r || r(n.status) ? e(n) : t(new ie("Request failed with status code " + n.status, [ie.ERR_BAD_REQUEST, ie.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function nC(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function rC(e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let i = 0, u = 0, s; return t = t !== void 0 ? t : 1e3, function (o) { const l = Date.now(), f = r[u]; s || (s = l), n[i] = o, r[i] = l; let d = u, p = 0; for (; d !== i;)p += n[d++], d = d % e; if (i = (i + 1) % e, i === u && (u = (u + 1) % e), l - s < t) return; const h = f && l - f; return h ? Math.round(p * 1e3 / h) : void 0 } } function iC(e, t) { let n = 0, r = 1e3 / t, i, u; const s = (l, f = Date.now()) => { n = f, i = null, u && (clearTimeout(u), u = null), e(...l) }; return [(...l) => { const f = Date.now(), d = f - n; d >= r ? s(l, f) : (i = l, u || (u = setTimeout(() => { u = null, s(i) }, r - d))) }, () => i && s(i)] } const ka = (e, t, n = 3) => { let r = 0; const i = rC(50, 250); return iC(u => { const s = u.loaded, a = u.lengthComputable ? u.total : void 0, o = s - r, l = i(o), f = s <= a; r = s; const d = { loaded: s, total: a, progress: a ? s / a : void 0, bytes: o, rate: l || void 0, estimated: l && a && f ? (a - s) / l : void 0, event: u, lengthComputable: a != null, [t ? "download" : "upload"]: !0 }; e(d) }, n) }, d0 = (e, t) => { const n = e != null; return [r => t[0]({ lengthComputable: n, total: e, loaded: r }), t[1]] }, h0 = e => (...t) => O.asap(() => e(...t)), uC = qe.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, qe.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(qe.origin), qe.navigator && /(msie|trident)/i.test(qe.navigator.userAgent)) : () => !0, sC = qe.hasStandardBrowserEnv ? { write(e, t, n, r, i, u, s) { if (typeof document > "u") return; const a = [`${e}=${encodeURIComponent(t)}`]; O.isNumber(n) && a.push(`expires=${new Date(n).toUTCString()}`), O.isString(r) && a.push(`path=${r}`), O.isString(i) && a.push(`domain=${i}`), u === !0 && a.push("secure"), O.isString(s) && a.push(`SameSite=${s}`), document.cookie = a.join("; ") }, read(e) { if (typeof document > "u") return null; const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5, "/") } } : { write() { }, read() { return null }, remove() { } }; function aC(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function oC(e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e } function j1(e, t, n) { let r = !aC(t); return e && (r || n == !1) ? oC(e, t) : t } const p0 = e => e instanceof ht ? { ...e } : e; function br(e, t) { t = t || {}; const n = {}; function r(l, f, d, p) { return O.isPlainObject(l) && O.isPlainObject(f) ? O.merge.call({ caseless: p }, l, f) : O.isPlainObject(f) ? O.merge({}, f) : O.isArray(f) ? f.slice() : f } function i(l, f, d, p) { if (O.isUndefined(f)) { if (!O.isUndefined(l)) return r(void 0, l, d, p) } else return r(l, f, d, p) } function u(l, f) { if (!O.isUndefined(f)) return r(void 0, f) } function s(l, f) { if (O.isUndefined(f)) { if (!O.isUndefined(l)) return r(void 0, l) } else return r(void 0, f) } function a(l, f, d) { if (d in t) return r(l, f); if (d in e) return r(void 0, l) } const o = { url: u, method: u, data: u, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, withXSRFToken: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a, headers: (l, f, d) => i(p0(l), p0(f), d, !0) }; return O.forEach(Object.keys({ ...e, ...t }), function (f) { const d = o[f] || i, p = d(e[f], t[f], f); O.isUndefined(p) && d !== a || (n[f] = p) }), n } const $1 = e => { const t = br({}, e); let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: u, headers: s, auth: a } = t; if (t.headers = s = ht.from(s), t.url = F1(j1(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && s.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))), O.isFormData(n)) { if (qe.hasStandardBrowserEnv || qe.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0); else if (O.isFunction(n.getHeaders)) { const o = n.getHeaders(), l = ["content-type", "content-length"]; Object.entries(o).forEach(([f, d]) => { l.includes(f.toLowerCase()) && s.set(f, d) }) } } if (qe.hasStandardBrowserEnv && (r && O.isFunction(r) && (r = r(t)), r || r !== !1 && uC(t.url))) { const o = i && u && sC.read(u); o && s.set(i, o) } return t }, lC = typeof XMLHttpRequest < "u", cC = lC && function (e) { return new Promise(function (n, r) { const i = $1(e); let u = i.data; const s = ht.from(i.headers).normalize(); let { responseType: a, onUploadProgress: o, onDownloadProgress: l } = i, f, d, p, h, m; function T() { h && h(), m && m(), i.cancelToken && i.cancelToken.unsubscribe(f), i.signal && i.signal.removeEventListener("abort", f) } let _ = new XMLHttpRequest; _.open(i.method.toUpperCase(), i.url, !0), _.timeout = i.timeout; function g() { if (!_) return; const y = ht.from("getAllResponseHeaders" in _ && _.getAllResponseHeaders()), L = { data: !a || a === "text" || a === "json" ? _.responseText : _.response, status: _.status, statusText: _.statusText, headers: y, config: e, request: _ }; z1(function (P) { n(P), T() }, function (P) { r(P), T() }, L), _ = null } "onloadend" in _ ? _.onloadend = g : _.onreadystatechange = function () { !_ || _.readyState !== 4 || _.status === 0 && !(_.responseURL && _.responseURL.indexOf("file:") === 0) || setTimeout(g) }, _.onabort = function () { _ && (r(new ie("Request aborted", ie.ECONNABORTED, e, _)), _ = null) }, _.onerror = function (I) { const L = I && I.message ? I.message : "Network Error", k = new ie(L, ie.ERR_NETWORK, e, _); k.event = I || null, r(k), _ = null }, _.ontimeout = function () { let I = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded"; const L = i.transitional || B1; i.timeoutErrorMessage && (I = i.timeoutErrorMessage), r(new ie(I, L.clarifyTimeoutError ? ie.ETIMEDOUT : ie.ECONNABORTED, e, _)), _ = null }, u === void 0 && s.setContentType(null), "setRequestHeader" in _ && O.forEach(s.toJSON(), function (I, L) { _.setRequestHeader(L, I) }), O.isUndefined(i.withCredentials) || (_.withCredentials = !!i.withCredentials), a && a !== "json" && (_.responseType = i.responseType), l && ([p, m] = ka(l, !0), _.addEventListener("progress", p)), o && _.upload && ([d, h] = ka(o), _.upload.addEventListener("progress", d), _.upload.addEventListener("loadend", h)), (i.cancelToken || i.signal) && (f = y => { _ && (r(!y || y.type ? new xi(null, e, _) : y), _.abort(), _ = null) }, i.cancelToken && i.cancelToken.subscribe(f), i.signal && (i.signal.aborted ? f() : i.signal.addEventListener("abort", f))); const E = nC(i.url); if (E && qe.protocols.indexOf(E) === -1) { r(new ie("Unsupported protocol " + E + ":", ie.ERR_BAD_REQUEST, e)); return } _.send(u || null) }) }, fC = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let r = new AbortController, i; const u = function (l) { if (!i) { i = !0, a(); const f = l instanceof Error ? l : this.reason; r.abort(f instanceof ie ? f : new xi(f instanceof Error ? f.message : f)) } }; let s = t && setTimeout(() => { s = null, u(new ie(`timeout ${t} of ms exceeded`, ie.ETIMEDOUT)) }, t); const a = () => { e && (s && clearTimeout(s), s = null, e.forEach(l => { l.unsubscribe ? l.unsubscribe(u) : l.removeEventListener("abort", u) }), e = null) }; e.forEach(l => l.addEventListener("abort", u)); const { signal: o } = r; return o.unsubscribe = () => O.asap(a), o } }, dC = function* (e, t) { let n = e.byteLength; if (n < t) { yield e; return } let r = 0, i; for (; r < n;)i = r + t, yield e.slice(r, i), r = i }, hC = async function* (e, t) { for await (const n of pC(e)) yield* dC(n, t) }, pC = async function* (e) { if (e[Symbol.asyncIterator]) { yield* e; return } const t = e.getReader(); try { for (; ;) { const { done: n, value: r } = await t.read(); if (n) break; yield r } } finally { await t.cancel() } }, m0 = (e, t, n, r) => { const i = hC(e, t); let u = 0, s, a = o => { s || (s = !0, r && r(o)) }; return new ReadableStream({ async pull(o) { try { const { done: l, value: f } = await i.next(); if (l) { a(), o.close(); return } let d = f.byteLength; if (n) { let p = u += d; n(p) } o.enqueue(new Uint8Array(f)) } catch (l) { throw a(l), l } }, cancel(o) { return a(o), i.return() } }, { highWaterMark: 2 }) }, g0 = 64 * 1024, { isFunction: Cs } = O, mC = (({ Request: e, Response: t }) => ({ Request: e, Response: t }))(O.global), { ReadableStream: E0, TextEncoder: T0 } = O.global, y0 = (e, ...t) => { try { return !!e(...t) } catch { return !1 } }, gC = e => { e = O.merge.call({ skipUndefined: !0 }, mC, e); const { fetch: t, Request: n, Response: r } = e, i = t ? Cs(t) : typeof fetch == "function", u = Cs(n), s = Cs(r); if (!i) return !1; const a = i && Cs(E0), o = i && (typeof T0 == "function" ? (m => T => m.encode(T))(new T0) : async m => new Uint8Array(await new n(m).arrayBuffer())), l = u && a && y0(() => { let m = !1; const T = new n(qe.origin, { body: new E0, method: "POST", get duplex() { return m = !0, "half" } }).headers.has("Content-Type"); return m && !T }), f = s && a && y0(() => O.isReadableStream(new r("").body)), d = { stream: f && (m => m.body) }; i && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(m => { !d[m] && (d[m] = (T, _) => { let g = T && T[m]; if (g) return g.call(T); throw new ie(`Response type '${m}' is not supported`, ie.ERR_NOT_SUPPORT, _) }) }); const p = async m => { if (m == null) return 0; if (O.isBlob(m)) return m.size; if (O.isSpecCompliantForm(m)) return (await new n(qe.origin, { method: "POST", body: m }).arrayBuffer()).byteLength; if (O.isArrayBufferView(m) || O.isArrayBuffer(m)) return m.byteLength; if (O.isURLSearchParams(m) && (m = m + ""), O.isString(m)) return (await o(m)).byteLength }, h = async (m, T) => { const _ = O.toFiniteNumber(m.getContentLength()); return _ ?? p(T) }; return async m => { let { url: T, method: _, data: g, signal: E, cancelToken: y, timeout: I, onDownloadProgress: L, onUploadProgress: k, responseType: P, headers: j, withCredentials: W = "same-origin", fetchOptions: N } = $1(m), Y = t || fetch; P = P ? (P + "").toLowerCase() : "text"; let U = fC([E, y && y.toAbortSignal()], I), K = null; const q = U && U.unsubscribe && (() => { U.unsubscribe() }); let G; try { if (k && l && _ !== "get" && _ !== "head" && (G = await h(j, g)) !== 0) { let J = new n(T, { method: "POST", body: g, duplex: "half" }), ne; if (O.isFormData(g) && (ne = J.headers.get("content-type")) && j.setContentType(ne), J.body) { const [A, pe] = d0(G, ka(h0(k))); g = m0(J.body, g0, A, pe) } } O.isString(W) || (W = W ? "include" : "omit"); const ee = u && "credentials" in n.prototype, ae = { ...N, signal: U, method: _.toUpperCase(), headers: j.normalize().toJSON(), body: g, duplex: "half", credentials: ee ? W : void 0 }; K = u && new n(T, ae); let H = await (u ? Y(K, N) : Y(T, ae)); const X = f && (P === "stream" || P === "response"); if (f && (L || X && q)) { const J = {};["status", "statusText", "headers"].forEach(ze => { J[ze] = H[ze] }); const ne = O.toFiniteNumber(H.headers.get("content-length")), [A, pe] = L && d0(ne, ka(h0(L), !0)) || []; H = new r(m0(H.body, g0, A, () => { pe && pe(), q && q() }), J) } P = P || "text"; let S = await d[O.findKey(d, P) || "text"](H, m); return !X && q && q(), await new Promise((J, ne) => { z1(J, ne, { data: S, headers: ht.from(H.headers), status: H.status, statusText: H.statusText, config: m, request: K }) }) } catch (ee) { throw q && q(), ee && ee.name === "TypeError" && /Load failed|fetch/i.test(ee.message) ? Object.assign(new ie("Network Error", ie.ERR_NETWORK, m, K), { cause: ee.cause || ee }) : ie.from(ee, ee && ee.code, m, K) } } }, EC = new Map, V1 = e => { let t = e && e.env || {}; const { fetch: n, Request: r, Response: i } = t, u = [r, i, n]; let s = u.length, a = s, o, l, f = EC; for (; a--;)o = u[a], l = f.get(o), l === void 0 && f.set(o, l = a ? new Map : gC(t)), f = l; return l }; V1(); const qf = { http: P_, xhr: cC, fetch: { get: V1 } }; O.forEach(qf, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch { } Object.defineProperty(e, "adapterName", { value: t }) } }); const b0 = e => `- ${e}`, TC = e => O.isFunction(e) || e === null || e === !1; function yC(e, t) {
        e = O.isArray(e) ? e : [e]; const { length: n } = e; let r, i; const u = {}; for (let s = 0; s < n; s++) { r = e[s]; let a; if (i = r, !TC(r) && (i = qf[(a = String(r)).toLowerCase()], i === void 0)) throw new ie(`Unknown adapter '${a}'`); if (i && (O.isFunction(i) || (i = i.get(t)))) break; u[a || "#" + s] = i } if (!i) {
          const s = Object.entries(u).map(([o, l]) => `adapter ${o} ` + (l === !1 ? "is not supported by the environment" : "is not available in the build")); let a = n ? s.length > 1 ? `since :
`+ s.map(b0).join(`
`) : " " + b0(s[0]) : "as no adapter specified"; throw new ie("There is no suitable adapter to dispatch the request " + a, "ERR_NOT_SUPPORT")
        } return i
      } const Y1 = { getAdapter: yC, adapters: qf }; function Jo(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new xi(null, e) } function x0(e) { return Jo(e), e.headers = ht.from(e.headers), e.data = Xo.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Y1.getAdapter(e.adapter || Xu.adapter, e)(e).then(function (r) { return Jo(e), r.data = Xo.call(e, e.transformResponse, r), r.headers = ht.from(r.headers), r }, function (r) { return H1(r) || (Jo(e), r && r.response && (r.response.data = Xo.call(e, e.transformResponse, r.response), r.response.headers = ht.from(r.response.headers))), Promise.reject(r) }) } const W1 = "1.13.2", no = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { no[e] = function (r) { return typeof r === e || "a" + (t < 1 ? "n " : " ") + e } }); const S0 = {}; no.transitional = function (t, n, r) { function i(u, s) { return "[Axios v" + W1 + "] Transitional option '" + u + "'" + s + (r ? ". " + r : "") } return (u, s, a) => { if (t === !1) throw new ie(i(s, " has been removed" + (n ? " in " + n : "")), ie.ERR_DEPRECATED); return n && !S0[s] && (S0[s] = !0, console.warn(i(s, " has been deprecated since v" + n + " and will be removed in the near future"))), t ? t(u, s, a) : !0 } }; no.spelling = function (t) { return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0) }; function bC(e, t, n) { if (typeof e != "object") throw new ie("options must be an object", ie.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let i = r.length; for (; i-- > 0;) { const u = r[i], s = t[u]; if (s) { const a = e[u], o = a === void 0 || s(a, u, e); if (o !== !0) throw new ie("option " + u + " must be " + o, ie.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new ie("Unknown option " + u, ie.ERR_BAD_OPTION) } } const Ws = { assertOptions: bC, validators: no }, qt = Ws.validators; let dr = class {
        constructor(t) { this.defaults = t || {}, this.interceptors = { request: new c0, response: new c0 } } async request(t, n) {
          try { return await this._request(t, n) } catch (r) {
            if (r instanceof Error) {
              let i = {}; Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error; const u = i.stack ? i.stack.replace(/^.+\n/, "") : ""; try {
                r.stack ? u && !String(r.stack).endsWith(u.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ u) : r.stack = u
              } catch { }
            } throw r
          }
        } _request(t, n) { typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = br(this.defaults, n); const { transitional: r, paramsSerializer: i, headers: u } = n; r !== void 0 && Ws.assertOptions(r, { silentJSONParsing: qt.transitional(qt.boolean), forcedJSONParsing: qt.transitional(qt.boolean), clarifyTimeoutError: qt.transitional(qt.boolean) }, !1), i != null && (O.isFunction(i) ? n.paramsSerializer = { serialize: i } : Ws.assertOptions(i, { encode: qt.function, serialize: qt.function }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Ws.assertOptions(n, { baseUrl: qt.spelling("baseURL"), withXsrfToken: qt.spelling("withXSRFToken") }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let s = u && O.merge(u.common, u[n.method]); u && O.forEach(["delete", "get", "head", "post", "put", "patch", "common"], m => { delete u[m] }), n.headers = ht.concat(s, u); const a = []; let o = !0; this.interceptors.request.forEach(function (T) { typeof T.runWhen == "function" && T.runWhen(n) === !1 || (o = o && T.synchronous, a.unshift(T.fulfilled, T.rejected)) }); const l = []; this.interceptors.response.forEach(function (T) { l.push(T.fulfilled, T.rejected) }); let f, d = 0, p; if (!o) { const m = [x0.bind(this), void 0]; for (m.unshift(...a), m.push(...l), p = m.length, f = Promise.resolve(n); d < p;)f = f.then(m[d++], m[d++]); return f } p = a.length; let h = n; for (; d < p;) { const m = a[d++], T = a[d++]; try { h = m(h) } catch (_) { T.call(this, _); break } } try { f = x0.call(this, h) } catch (m) { return Promise.reject(m) } for (d = 0, p = l.length; d < p;)f = f.then(l[d++], l[d++]); return f } getUri(t) { t = br(this.defaults, t); const n = j1(t.baseURL, t.url, t.allowAbsoluteUrls); return F1(n, t.params, t.paramsSerializer) }
      }; O.forEach(["delete", "get", "head", "options"], function (t) { dr.prototype[t] = function (n, r) { return this.request(br(r || {}, { method: t, url: n, data: (r || {}).data })) } }); O.forEach(["post", "put", "patch"], function (t) { function n(r) { return function (u, s, a) { return this.request(br(a || {}, { method: t, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: u, data: s })) } } dr.prototype[t] = n(), dr.prototype[t + "Form"] = n(!0) }); let xC = class K1 { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (u) { n = u }); const r = this; this.promise.then(i => { if (!r._listeners) return; let u = r._listeners.length; for (; u-- > 0;)r._listeners[u](i); r._listeners = null }), this.promise.then = i => { let u; const s = new Promise(a => { r.subscribe(a), u = a }).then(i); return s.cancel = function () { r.unsubscribe(u) }, s }, t(function (u, s, a) { r.reason || (r.reason = new xi(u, s, a), n(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const n = this._listeners.indexOf(t); n !== -1 && this._listeners.splice(n, 1) } toAbortSignal() { const t = new AbortController, n = r => { t.abort(r) }; return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal } static source() { let t; return { token: new K1(function (i) { t = i }), cancel: t } } }; function SC(e) { return function (n) { return e.apply(null, n) } } function _C(e) { return O.isObject(e) && e.isAxiosError === !0 } const Ac = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(Ac).forEach(([e, t]) => { Ac[t] = e }); function q1(e) { const t = new dr(e), n = A1(dr.prototype.request, t); return O.extend(n, dr.prototype, t, { allOwnKeys: !0 }), O.extend(n, t, null, { allOwnKeys: !0 }), n.create = function (i) { return q1(br(e, i)) }, n } const Le = q1(Xu); Le.Axios = dr; Le.CanceledError = xi; Le.CancelToken = xC; Le.isCancel = H1; Le.VERSION = W1; Le.toFormData = to; Le.AxiosError = ie; Le.Cancel = Le.CanceledError; Le.all = function (t) { return Promise.all(t) }; Le.spread = SC; Le.isAxiosError = _C; Le.mergeConfig = br; Le.AxiosHeaders = ht; Le.formToJSON = e => U1(O.isHTMLForm(e) ? new FormData(e) : e); Le.getAdapter = Y1.getAdapter; Le.HttpStatusCode = Ac; Le.default = Le; const { Axios: DL, AxiosError: ML, CanceledError: FL, isCancel: BL, CancelToken: UL, VERSION: HL, all: zL, Cancel: jL, isAxiosError: $L, spread: VL, toFormData: YL, AxiosHeaders: WL, HttpStatusCode: KL, formToJSON: qL, getAdapter: QL, mergeConfig: GL } = Le, Ce = Le.create({ baseURL: "https://next-blog-server-226627032790.asia-east1.run.app/api", headers: { "Content-Type": "application/json" } }); Ce.interceptors.request.use(e => { try { const t = localStorage.getItem("auth_token"); t && (e.headers.Authorization = `Bearer ${t}`) } catch (t) { console.warn("LocalStorage access denied in api interceptor:", t) } return e }); const nr = { getPublished: () => Ce.get("/posts"), getByCategory: (e, t = "en") => Ce.get(`/posts?category=${e}&language=${t}`), getByTag: (e, t = "en") => Ce.get(`/posts?tag=${e}&language=${t}`), getByAuthor: (e, t = "en") => Ce.get(`/posts?author=${e}&language=${t}`), getOne: e => Ce.get(`/posts/${e}`), getBySlug: (e, t) => Ce.get(`/posts/by-slug/${e}/${t}`), getAll: (e = 1, t = 15) => Ce.get(`/posts/admin/all?page=${e}&limit=${t}`), create: (e, t) => Ce.post("/posts", { title: e, text: t }), update: (e, t, n) => Ce.put(`/posts/${e}`, { title: t, text: n }), updateMeta: (e, t) => Ce.patch(`/posts/${e}/meta`, t), delete: e => Ce.delete(`/posts/${e}`), publish: e => Ce.post(`/posts/${e}/publish`), unpublish: e => Ce.post(`/posts/${e}/unpublish`), discard: e => Ce.post(`/posts/${e}/discard`), validate: e => Ce.get(`/posts/${e}/validate`), copy: e => Ce.post(`/posts/${e}/copy`) }, Q1 = { getAll: () => Ce.get("/categories"), getOne: e => Ce.get(`/categories/${e}`), create: e => Ce.post("/categories", e), update: (e, t) => Ce.put(`/categories/${e}`, t), delete: e => Ce.delete(`/categories/${e}`), reorder: e => Ce.put("/categories/reorder", { orderedIds: e }) }, CC = "data:image/svg+xml,%3csvg%20width='64'%20height='64'%20viewBox='0%200%2064%2064'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3c!--%20Glow%20Filter%20--%3e%3cdefs%3e%3cfilter%20id='glow'%20x='-50%25'%20y='-50%25'%20width='200%25'%20height='200%25'%3e%3cfeGaussianBlur%20stdDeviation='1.5'%20result='coloredBlur'/%3e%3cfeMerge%3e%3cfeMergeNode%20in='coloredBlur'/%3e%3cfeMergeNode%20in='SourceGraphic'/%3e%3c/feMerge%3e%3c/filter%3e%3c/defs%3e%3c!--%20Bear%20Head%20Base%20(Wider)%20--%3e%3cpath%20d='M10%2024C10%2016%2018%2010%2032%2010C46%2010%2054%2016%2054%2024V32C54%2044%2046%2054%2032%2054C18%2054%2010%2044%2010%2032V24Z'%20fill='%23161b22'%20stroke='%2330363d'%20stroke-width='2'/%3e%3c!--%20Ears%20--%3e%3ccircle%20cx='10'%20cy='18'%20r='7'%20fill='%23161b22'%20stroke='%2330363d'%20stroke-width='2'/%3e%3ccircle%20cx='54'%20cy='18'%20r='7'%20fill='%23161b22'%20stroke='%2330363d'%20stroke-width='2'/%3e%3c!--%20Forehead%20overlay%20--%3e%3cpath%20d='M10%2024C10%2017%2018%2011%2032%2011C46%2011%2054%2017%2054%2024V32C54%2043%2046%2053%2032%2053C18%2053%2010%2043%2010%2032V24Z'%20fill='%23161b22'/%3e%3c!--%20The%20V%20Shape%20(Moved%20Higher)%20--%3e%3cpath%20d='M18%2038%20L32%2046%20L46%2038%20L32%2050%20Z'%20fill='%23F0F6FC'%20opacity='0.9'/%3e%3c!--%20Glowing%20White%20Eyes%20--%3e%3ccircle%20cx='22'%20cy='28'%20r='3.5'%20fill='%23FFFFFF'%20filter='url(%23glow)'/%3e%3ccircle%20cx='42'%20cy='28'%20r='3.5'%20fill='%23FFFFFF'%20filter='url(%23glow)'/%3e%3c!--%20Snout%20--%3e%3cellipse%20cx='32'%20cy='36'%20rx='8'%20ry='5'%20fill='%2321262d'/%3e%3cellipse%20cx='32'%20cy='35'%20rx='3'%20ry='2'%20fill='%230d1117'/%3e%3c/svg%3e"; function ou() { const { t: e, i18n: t } = Vf(), { theme: n, toggleTheme: r, textSize: i, setTextSize: u } = tS(), { isAuthenticated: s, logout: a } = g1(), [o, l] = M.useState([]), [f, d] = M.useState(!1), p = M.useRef(null); return M.useEffect(() => { function h(m) { p.current && !p.current.contains(m.target) && d(!1) } return document.addEventListener("mousedown", h), () => document.removeEventListener("mousedown", h) }, []), M.useEffect(() => { const h = () => { Q1.getAll().then(m => { l(m.data.categories) }).catch(m => { console.error("Failed to load categories:", m) }) }; return h(), window.addEventListener("categories-updated", h), () => window.removeEventListener("categories-updated", h) }, []), w.jsx("nav", { className: "border-b border-gray-200 dark:border-gray-700", children: w.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: w.jsxs("div", { className: "flex justify-between h-16 items-center", children: [w.jsxs(Qi, { to: "/", className: "flex items-center text-2xl font-display text-text-light dark:text-text-dark hover:opacity-70 transition-opacity", children: [w.jsx("img", { src: CC, alt: "Logo", className: "mr-3 dark:invert flex-shrink-0", style: { width: "32px", height: "32px" } }), e("brand")] }), w.jsxs("div", { className: "flex items-center space-x-6", children: [w.jsx(Qi, { to: "/", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: e("nav.home") }), w.jsxs("div", { className: "relative", ref: p, children: [w.jsxs("button", { onClick: () => d(!f), className: "flex items-center gap-1 text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors", children: [e("nav.categories", "Categories"), w.jsx("svg", { className: `w-4 h-4 transition-transform ${f ? "rotate-180" : ""}`, fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: w.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M19 9l-7 7-7-7" }) })] }), f && w.jsx("div", { className: "absolute left-0 mt-2 py-2 w-48 bg-white dark:bg-gray-800 rounded-lg shadow-lg border border-gray-200 dark:border-gray-700 z-50", children: o.filter(h => s || !h.adminOnly).map(h => { var m, T; return w.jsxs(Qi, { to: `/category/${h.slug || h.id}`, className: `block px-4 py-2 text-muted-light dark:text-muted-dark hover:bg-gray-100 dark:hover:bg-gray-700 hover:text-text-light dark:hover:text-text-dark transition-colors ${h.adminOnly ? "opacity-70" : ""}`, onClick: () => d(!1), children: [h.adminOnly ? " " : "", ((T = (m = h.translations) == null ? void 0 : m[t.language]) == null ? void 0 : T.title) || h.title] }, h.id) }) })] }), s && w.jsxs(Qi, { to: "/admin", className: "text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark transition-colors font-medium", children: [" ", e("nav.admin")] })] }), w.jsxs("div", { className: "flex items-center space-x-4", children: [w.jsxs("div", { className: "hidden sm:flex items-center space-x-1 text-sm", children: [w.jsx("button", { onClick: () => { const h = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], m = h.indexOf(i); m > 0 && u(h[m - 1]) }, disabled: i === "small", className: `w-6 h-6 flex items-center justify-center rounded ${i === "small" ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"}`, title: "Decrease text size", children: "" }), w.jsx("span", { className: "w-6 h-6 flex items-center justify-center font-medium", children: "A" }), w.jsx("button", { onClick: () => { const h = ["small", "medium", "large", "xlarge", "xxlarge", "xxxlarge"], m = h.indexOf(i); m < h.length - 1 && u(h[m + 1]) }, disabled: i === "xxxlarge", className: `w-6 h-6 flex items-center justify-center rounded ${i === "xxxlarge" ? "opacity-30 cursor-not-allowed" : "hover:bg-gray-100 dark:hover:bg-gray-800"}`, title: "Increase text size", children: "+" })] }), w.jsxs("select", { value: t.language, onChange: h => t.changeLanguage(h.target.value), className: "bg-transparent text-sm text-muted-light dark:text-muted-dark hover:text-text-light dark:hover:text-text-dark uppercase border-none focus:ring-0 cursor-pointer appearance-none p-0 pr-6 bg-[url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E')] bg-[length:0.7em] bg-[right_0_center] bg-no-repeat", "aria-label": "Select Language", children: [w.jsx("option", { value: "en", className: "bg-white dark:bg-gray-800", children: "EN" }), w.jsx("option", { value: "poj", className: "bg-white dark:bg-gray-800", children: "POJ" }), w.jsx("option", { value: "hanlo", className: "bg-white dark:bg-gray-800", children: "" })] }), w.jsx("button", { onClick: r, className: "p-2 rounded hover:bg-gray-100 dark:hover:bg-gray-800", "aria-label": "Toggle theme", children: n === "light" ? w.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: w.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" }) }) : w.jsx("svg", { className: "w-5 h-5", fill: "none", viewBox: "0 0 24 24", stroke: "currentColor", children: w.jsx("path", { strokeLinecap: "round", strokeLinejoin: "round", strokeWidth: 2, d: "M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" }) }) }), !1] })] }) }) }) } function lu() { const { t: e } = Vf(), t = new Date().getFullYear(); return w.jsx("footer", { className: "border-t border-gray-200 dark:border-gray-700 mt-20 py-10", children: w.jsx("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8", children: w.jsx("div", { className: "text-muted-light dark:text-muted-dark text-sm", children: e("footer.copyright", { year: t }) }) }) }) } const AC = (e, t = 800, n = 600) => `https://picsum.photos/seed/${e}/${t}/${n}`; function kc({ post: e, featured: t = !1, showDraftBadge: n = !1 }) { var l; const r = e.published || e.draft, i = r == null ? void 0 : r.meta, u = e.status !== "published"; if (!r) return null; const s = ((l = i == null ? void 0 : i.date) == null ? void 0 : l.substring(0, 7)) || `${new Date().getFullYear()}-01`, a = (i == null ? void 0 : i.url) || e.id, o = (i == null ? void 0 : i.thumbImage) || AC(e.id); return w.jsxs("article", { className: `group relative flex flex-col ${t ? "col-span-full md:grid md:grid-cols-2 md:gap-8" : "h-full"}`, children: [w.jsx(Qi, { to: `/posts/${s}/${a}`, className: "absolute inset-0 z-10", "aria-label": r.title }), w.jsxs("div", { className: `overflow-hidden rounded-lg bg-gray-100 dark:bg-gray-800 ${t ? "aspect-video md:aspect-auto md:h-full" : "aspect-[16/10]"} mb-4 md:mb-0 relative shadow-sm transition-all duration-300 group-hover:shadow-md group-hover:translate-y-[-2px]`, children: [w.jsx("img", { src: o, alt: r.title, className: "w-full h-full object-cover transition-transform duration-700 ease-out group-hover:scale-105", loading: "lazy" }), n && u && w.jsx("div", { className: "absolute top-4 right-4 z-20", children: w.jsx("span", { className: "inline-block px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-orange-500/80 backdrop-blur-sm rounded-sm", children: "Draft" }) }), (i == null ? void 0 : i.category) && w.jsx("div", { className: "absolute top-4 left-4 z-20", children: w.jsx("span", { className: "inline-block px-2 py-1 text-xs font-bold text-white uppercase tracking-wider bg-black/50 backdrop-blur-sm rounded-sm", children: i.category }) })] }), w.jsxs("div", { className: `flex flex-col ${t ? "justify-center md:py-4" : "flex-1"}`, children: [w.jsxs("div", { className: "flex items-center gap-3 mb-3 text-xs font-medium text-muted-light dark:text-muted-dark", children: [(i == null ? void 0 : i.date) && w.jsx("time", { dateTime: i.date, children: i.date }), (i == null ? void 0 : i.featured) && w.jsx("span", { className: "text-yellow-600 dark:text-yellow-500 font-bold", children: " Featured" }), n && u && w.jsx("span", { className: "text-orange-500 font-bold", children: " Draft" })] }), w.jsx("h2", { className: `font-display font-bold text-text-light dark:text-text-dark ${t ? "text-3xl md:text-4xl" : "text-xl"} leading-tight mb-3 group-hover:text-accent transition-colors duration-200`, children: r.title }), (i == null ? void 0 : i.thumbText) && w.jsx("p", { className: `text-muted-light dark:text-muted-dark ${t ? "text-lg line-clamp-3" : "text-sm line-clamp-2"} mb-4`, children: i.thumbText }), w.jsx("div", { className: "mt-auto flex items-center text-sm font-medium text-accent opacity-0 -translate-x-2 transition-all duration-300 group-hover:opacity-100 group-hover:translate-x-0", children: "Read article " })] })] }) } function kC() { const { t: e, i18n: t } = Vf(), [n, r] = M.useState([]), [i, u] = M.useState(!0), [s, a] = M.useState(null); M.useEffect(() => { o() }, [t.language]); const o = async () => { try { u(!0); const p = await nr.getPublished(); r(p.data.posts) } catch (p) { a("Failed to load posts"), console.error(p) } finally { u(!1) } }, l = n.filter(p => { var m, T, _; return ((_ = (T = (m = p.published) == null ? void 0 : m.meta) == null ? void 0 : T.category) == null ? void 0 : _.toLowerCase()) !== "help" }), f = l.filter(p => { var h, m; return (m = (h = p.published) == null ? void 0 : h.meta) == null ? void 0 : m.featured }), d = l.filter(p => { var h, m; return !((m = (h = p.published) == null ? void 0 : h.meta) != null && m.featured) }); return w.jsxs(w.Fragment, { children: [w.jsxs($f, { children: [w.jsxs("title", { children: [e("home.title"), " | Next Blog"] }), w.jsx("meta", { name: "description", content: "A modern blog built with React and Firestore" })] }), w.jsxs("div", { className: "min-h-screen flex flex-col", children: [w.jsx(ou, {}), w.jsx("main", { className: "flex-1", children: w.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [f.length > 0 && w.jsxs("section", { className: "mb-16", children: [w.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.featured") }), w.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 gap-8", children: f.slice(0, 2).map(p => w.jsx(kc, { post: p, featured: !0 }, p.id)) })] }), w.jsxs("section", { children: [w.jsx("h2", { className: "text-sm uppercase tracking-wider text-muted-light dark:text-muted-dark mb-6", children: e("home.latest") }), i ? w.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((p, h) => w.jsxs("div", { className: "animate-pulse", children: [w.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), w.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-2" }), w.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), w.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, h)) }) : s ? w.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: s }) : d.length === 0 ? w.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: "No posts yet." }) : w.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: d.map(p => w.jsx(kc, { post: p }, p.id)) })] })] }) }), w.jsx(lu, {})] })] }) } function _0(e) { const t = [], n = String(e || ""); let r = n.indexOf(","), i = 0, u = !1; for (; !u;) { r === -1 && (r = n.length, u = !0); const s = n.slice(i, r).trim(); (s || !u) && t.push(s), i = r + 1, r = n.indexOf(",", i) } return t } function G1(e, t) { const n = {}; return (e[e.length - 1] === "" ? [...e, ""] : e).join((n.padRight ? " " : "") + "," + (n.padLeft === !1 ? "" : " ")).trim() } const NC = /^[$_\p{ID_Start}][$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, IC = /^[$_\p{ID_Start}][-$_\u{200C}\u{200D}\p{ID_Continue}]*$/u, wC = {}; function C0(e, t) { return (wC.jsx ? IC : NC).test(e) } const vC = /[ \t\n\f\r]/g; function OC(e) { return typeof e == "object" ? e.type === "text" ? A0(e.value) : !1 : A0(e) } function A0(e) { return e.replace(vC, "") === "" } class Ju { constructor(t, n, r) { this.normal = n, this.property = t, r && (this.space = r) } } Ju.prototype.normal = {}; Ju.prototype.property = {}; Ju.prototype.space = void 0; function X1(e, t) { const n = {}, r = {}; for (const i of e) Object.assign(n, i.property), Object.assign(r, i.normal); return new Ju(n, r, t) } function Bu(e) { return e.toLowerCase() } class pt { constructor(t, n) { this.attribute = n, this.property = t } } pt.prototype.attribute = ""; pt.prototype.booleanish = !1; pt.prototype.boolean = !1; pt.prototype.commaOrSpaceSeparated = !1; pt.prototype.commaSeparated = !1; pt.prototype.defined = !1; pt.prototype.mustUseProperty = !1; pt.prototype.number = !1; pt.prototype.overloadedBoolean = !1; pt.prototype.property = ""; pt.prototype.spaceSeparated = !1; pt.prototype.space = void 0; let LC = 0; const ue = Ar(), Re = Ar(), Nc = Ar(), $ = Ar(), Ee = Ar(), ni = Ar(), gt = Ar(); function Ar() { return 2 ** ++LC } const Ic = Object.freeze(Object.defineProperty({ __proto__: null, boolean: ue, booleanish: Re, commaOrSpaceSeparated: gt, commaSeparated: ni, number: $, overloadedBoolean: Nc, spaceSeparated: Ee }, Symbol.toStringTag, { value: "Module" })), Zo = Object.keys(Ic); class Qf extends pt { constructor(t, n, r, i) { let u = -1; if (super(t, n), k0(this, "space", i), typeof r == "number") for (; ++u < Zo.length;) { const s = Zo[u]; k0(this, Zo[u], (r & Ic[s]) === Ic[s]) } } } Qf.prototype.defined = !0; function k0(e, t, n) { n && (e[t] = n) } function Si(e) { const t = {}, n = {}; for (const [r, i] of Object.entries(e.properties)) { const u = new Qf(r, e.transform(e.attributes || {}, r), i, e.space); e.mustUseProperty && e.mustUseProperty.includes(r) && (u.mustUseProperty = !0), t[r] = u, n[Bu(r)] = r, n[Bu(u.attribute)] = r } return new Ju(t, n, e.space) } const J1 = Si({ properties: { ariaActiveDescendant: null, ariaAtomic: Re, ariaAutoComplete: null, ariaBusy: Re, ariaChecked: Re, ariaColCount: $, ariaColIndex: $, ariaColSpan: $, ariaControls: Ee, ariaCurrent: null, ariaDescribedBy: Ee, ariaDetails: null, ariaDisabled: Re, ariaDropEffect: Ee, ariaErrorMessage: null, ariaExpanded: Re, ariaFlowTo: Ee, ariaGrabbed: Re, ariaHasPopup: null, ariaHidden: Re, ariaInvalid: null, ariaKeyShortcuts: null, ariaLabel: null, ariaLabelledBy: Ee, ariaLevel: $, ariaLive: null, ariaModal: Re, ariaMultiLine: Re, ariaMultiSelectable: Re, ariaOrientation: null, ariaOwns: Ee, ariaPlaceholder: null, ariaPosInSet: $, ariaPressed: Re, ariaReadOnly: Re, ariaRelevant: null, ariaRequired: Re, ariaRoleDescription: Ee, ariaRowCount: $, ariaRowIndex: $, ariaRowSpan: $, ariaSelected: Re, ariaSetSize: $, ariaSort: null, ariaValueMax: $, ariaValueMin: $, ariaValueNow: $, ariaValueText: null, role: null }, transform(e, t) { return t === "role" ? t : "aria-" + t.slice(4).toLowerCase() } }); function Z1(e, t) { return t in e ? e[t] : t } function eE(e, t) { return Z1(e, t.toLowerCase()) } const RC = Si({ attributes: { acceptcharset: "accept-charset", classname: "class", htmlfor: "for", httpequiv: "http-equiv" }, mustUseProperty: ["checked", "multiple", "muted", "selected"], properties: { abbr: null, accept: ni, acceptCharset: Ee, accessKey: Ee, action: null, allow: null, allowFullScreen: ue, allowPaymentRequest: ue, allowUserMedia: ue, alt: null, as: null, async: ue, autoCapitalize: null, autoComplete: Ee, autoFocus: ue, autoPlay: ue, blocking: Ee, capture: null, charSet: null, checked: ue, cite: null, className: Ee, cols: $, colSpan: null, content: null, contentEditable: Re, controls: ue, controlsList: Ee, coords: $ | ni, crossOrigin: null, data: null, dateTime: null, decoding: null, default: ue, defer: ue, dir: null, dirName: null, disabled: ue, download: Nc, draggable: Re, encType: null, enterKeyHint: null, fetchPriority: null, form: null, formAction: null, formEncType: null, formMethod: null, formNoValidate: ue, formTarget: null, headers: Ee, height: $, hidden: Nc, high: $, href: null, hrefLang: null, htmlFor: Ee, httpEquiv: Ee, id: null, imageSizes: null, imageSrcSet: null, inert: ue, inputMode: null, integrity: null, is: null, isMap: ue, itemId: null, itemProp: Ee, itemRef: Ee, itemScope: ue, itemType: Ee, kind: null, label: null, lang: null, language: null, list: null, loading: null, loop: ue, low: $, manifest: null, max: null, maxLength: $, media: null, method: null, min: null, minLength: $, multiple: ue, muted: ue, name: null, nonce: null, noModule: ue, noValidate: ue, onAbort: null, onAfterPrint: null, onAuxClick: null, onBeforeMatch: null, onBeforePrint: null, onBeforeToggle: null, onBeforeUnload: null, onBlur: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onContextLost: null, onContextMenu: null, onContextRestored: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnded: null, onError: null, onFocus: null, onFormData: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLanguageChange: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadEnd: null, onLoadStart: null, onMessage: null, onMessageError: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRejectionHandled: null, onReset: null, onResize: null, onScroll: null, onScrollEnd: null, onSecurityPolicyViolation: null, onSeeked: null, onSeeking: null, onSelect: null, onSlotChange: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnhandledRejection: null, onUnload: null, onVolumeChange: null, onWaiting: null, onWheel: null, open: ue, optimum: $, pattern: null, ping: Ee, placeholder: null, playsInline: ue, popover: null, popoverTarget: null, popoverTargetAction: null, poster: null, preload: null, readOnly: ue, referrerPolicy: null, rel: Ee, required: ue, reversed: ue, rows: $, rowSpan: $, sandbox: Ee, scope: null, scoped: ue, seamless: ue, selected: ue, shadowRootClonable: ue, shadowRootDelegatesFocus: ue, shadowRootMode: null, shape: null, size: $, sizes: null, slot: null, span: $, spellCheck: Re, src: null, srcDoc: null, srcLang: null, srcSet: null, start: $, step: null, style: null, tabIndex: $, target: null, title: null, translate: null, type: null, typeMustMatch: ue, useMap: null, value: Re, width: $, wrap: null, writingSuggestions: null, align: null, aLink: null, archive: Ee, axis: null, background: null, bgColor: null, border: $, borderColor: null, bottomMargin: $, cellPadding: null, cellSpacing: null, char: null, charOff: null, classId: null, clear: null, code: null, codeBase: null, codeType: null, color: null, compact: ue, declare: ue, event: null, face: null, frame: null, frameBorder: null, hSpace: $, leftMargin: $, link: null, longDesc: null, lowSrc: null, marginHeight: $, marginWidth: $, noResize: ue, noHref: ue, noShade: ue, noWrap: ue, object: null, profile: null, prompt: null, rev: null, rightMargin: $, rules: null, scheme: null, scrolling: Re, standby: null, summary: null, text: null, topMargin: $, valueType: null, version: null, vAlign: null, vLink: null, vSpace: $, allowTransparency: null, autoCorrect: null, autoSave: null, disablePictureInPicture: ue, disableRemotePlayback: ue, prefix: null, property: null, results: $, security: null, unselectable: null }, space: "html", transform: eE }), PC = Si({ attributes: { accentHeight: "accent-height", alignmentBaseline: "alignment-baseline", arabicForm: "arabic-form", baselineShift: "baseline-shift", capHeight: "cap-height", className: "class", clipPath: "clip-path", clipRule: "clip-rule", colorInterpolation: "color-interpolation", colorInterpolationFilters: "color-interpolation-filters", colorProfile: "color-profile", colorRendering: "color-rendering", crossOrigin: "crossorigin", dataType: "datatype", dominantBaseline: "dominant-baseline", enableBackground: "enable-background", fillOpacity: "fill-opacity", fillRule: "fill-rule", floodColor: "flood-color", floodOpacity: "flood-opacity", fontFamily: "font-family", fontSize: "font-size", fontSizeAdjust: "font-size-adjust", fontStretch: "font-stretch", fontStyle: "font-style", fontVariant: "font-variant", fontWeight: "font-weight", glyphName: "glyph-name", glyphOrientationHorizontal: "glyph-orientation-horizontal", glyphOrientationVertical: "glyph-orientation-vertical", hrefLang: "hreflang", horizAdvX: "horiz-adv-x", horizOriginX: "horiz-origin-x", horizOriginY: "horiz-origin-y", imageRendering: "image-rendering", letterSpacing: "letter-spacing", lightingColor: "lighting-color", markerEnd: "marker-end", markerMid: "marker-mid", markerStart: "marker-start", navDown: "nav-down", navDownLeft: "nav-down-left", navDownRight: "nav-down-right", navLeft: "nav-left", navNext: "nav-next", navPrev: "nav-prev", navRight: "nav-right", navUp: "nav-up", navUpLeft: "nav-up-left", navUpRight: "nav-up-right", onAbort: "onabort", onActivate: "onactivate", onAfterPrint: "onafterprint", onBeforePrint: "onbeforeprint", onBegin: "onbegin", onCancel: "oncancel", onCanPlay: "oncanplay", onCanPlayThrough: "oncanplaythrough", onChange: "onchange", onClick: "onclick", onClose: "onclose", onCopy: "oncopy", onCueChange: "oncuechange", onCut: "oncut", onDblClick: "ondblclick", onDrag: "ondrag", onDragEnd: "ondragend", onDragEnter: "ondragenter", onDragExit: "ondragexit", onDragLeave: "ondragleave", onDragOver: "ondragover", onDragStart: "ondragstart", onDrop: "ondrop", onDurationChange: "ondurationchange", onEmptied: "onemptied", onEnd: "onend", onEnded: "onended", onError: "onerror", onFocus: "onfocus", onFocusIn: "onfocusin", onFocusOut: "onfocusout", onHashChange: "onhashchange", onInput: "oninput", onInvalid: "oninvalid", onKeyDown: "onkeydown", onKeyPress: "onkeypress", onKeyUp: "onkeyup", onLoad: "onload", onLoadedData: "onloadeddata", onLoadedMetadata: "onloadedmetadata", onLoadStart: "onloadstart", onMessage: "onmessage", onMouseDown: "onmousedown", onMouseEnter: "onmouseenter", onMouseLeave: "onmouseleave", onMouseMove: "onmousemove", onMouseOut: "onmouseout", onMouseOver: "onmouseover", onMouseUp: "onmouseup", onMouseWheel: "onmousewheel", onOffline: "onoffline", onOnline: "ononline", onPageHide: "onpagehide", onPageShow: "onpageshow", onPaste: "onpaste", onPause: "onpause", onPlay: "onplay", onPlaying: "onplaying", onPopState: "onpopstate", onProgress: "onprogress", onRateChange: "onratechange", onRepeat: "onrepeat", onReset: "onreset", onResize: "onresize", onScroll: "onscroll", onSeeked: "onseeked", onSeeking: "onseeking", onSelect: "onselect", onShow: "onshow", onStalled: "onstalled", onStorage: "onstorage", onSubmit: "onsubmit", onSuspend: "onsuspend", onTimeUpdate: "ontimeupdate", onToggle: "ontoggle", onUnload: "onunload", onVolumeChange: "onvolumechange", onWaiting: "onwaiting", onZoom: "onzoom", overlinePosition: "overline-position", overlineThickness: "overline-thickness", paintOrder: "paint-order", panose1: "panose-1", pointerEvents: "pointer-events", referrerPolicy: "referrerpolicy", renderingIntent: "rendering-intent", shapeRendering: "shape-rendering", stopColor: "stop-color", stopOpacity: "stop-opacity", strikethroughPosition: "strikethrough-position", strikethroughThickness: "strikethrough-thickness", strokeDashArray: "stroke-dasharray", strokeDashOffset: "stroke-dashoffset", strokeLineCap: "stroke-linecap", strokeLineJoin: "stroke-linejoin", strokeMiterLimit: "stroke-miterlimit", strokeOpacity: "stroke-opacity", strokeWidth: "stroke-width", tabIndex: "tabindex", textAnchor: "text-anchor", textDecoration: "text-decoration", textRendering: "text-rendering", transformOrigin: "transform-origin", typeOf: "typeof", underlinePosition: "underline-position", underlineThickness: "underline-thickness", unicodeBidi: "unicode-bidi", unicodeRange: "unicode-range", unitsPerEm: "units-per-em", vAlphabetic: "v-alphabetic", vHanging: "v-hanging", vIdeographic: "v-ideographic", vMathematical: "v-mathematical", vectorEffect: "vector-effect", vertAdvY: "vert-adv-y", vertOriginX: "vert-origin-x", vertOriginY: "vert-origin-y", wordSpacing: "word-spacing", writingMode: "writing-mode", xHeight: "x-height", playbackOrder: "playbackorder", timelineBegin: "timelinebegin" }, properties: { about: gt, accentHeight: $, accumulate: null, additive: null, alignmentBaseline: null, alphabetic: $, amplitude: $, arabicForm: null, ascent: $, attributeName: null, attributeType: null, azimuth: $, bandwidth: null, baselineShift: null, baseFrequency: null, baseProfile: null, bbox: null, begin: null, bias: $, by: null, calcMode: null, capHeight: $, className: Ee, clip: null, clipPath: null, clipPathUnits: null, clipRule: null, color: null, colorInterpolation: null, colorInterpolationFilters: null, colorProfile: null, colorRendering: null, content: null, contentScriptType: null, contentStyleType: null, crossOrigin: null, cursor: null, cx: null, cy: null, d: null, dataType: null, defaultAction: null, descent: $, diffuseConstant: $, direction: null, display: null, dur: null, divisor: $, dominantBaseline: null, download: ue, dx: null, dy: null, edgeMode: null, editable: null, elevation: $, enableBackground: null, end: null, event: null, exponent: $, externalResourcesRequired: null, fill: null, fillOpacity: $, fillRule: null, filter: null, filterRes: null, filterUnits: null, floodColor: null, floodOpacity: null, focusable: null, focusHighlight: null, fontFamily: null, fontSize: null, fontSizeAdjust: null, fontStretch: null, fontStyle: null, fontVariant: null, fontWeight: null, format: null, fr: null, from: null, fx: null, fy: null, g1: ni, g2: ni, glyphName: ni, glyphOrientationHorizontal: null, glyphOrientationVertical: null, glyphRef: null, gradientTransform: null, gradientUnits: null, handler: null, hanging: $, hatchContentUnits: null, hatchUnits: null, height: null, href: null, hrefLang: null, horizAdvX: $, horizOriginX: $, horizOriginY: $, id: null, ideographic: $, imageRendering: null, initialVisibility: null, in: null, in2: null, intercept: $, k: $, k1: $, k2: $, k3: $, k4: $, kernelMatrix: gt, kernelUnitLength: null, keyPoints: null, keySplines: null, keyTimes: null, kerning: null, lang: null, lengthAdjust: null, letterSpacing: null, lightingColor: null, limitingConeAngle: $, local: null, markerEnd: null, markerMid: null, markerStart: null, markerHeight: null, markerUnits: null, markerWidth: null, mask: null, maskContentUnits: null, maskUnits: null, mathematical: null, max: null, media: null, mediaCharacterEncoding: null, mediaContentEncodings: null, mediaSize: $, mediaTime: null, method: null, min: null, mode: null, name: null, navDown: null, navDownLeft: null, navDownRight: null, navLeft: null, navNext: null, navPrev: null, navRight: null, navUp: null, navUpLeft: null, navUpRight: null, numOctaves: null, observer: null, offset: null, onAbort: null, onActivate: null, onAfterPrint: null, onBeforePrint: null, onBegin: null, onCancel: null, onCanPlay: null, onCanPlayThrough: null, onChange: null, onClick: null, onClose: null, onCopy: null, onCueChange: null, onCut: null, onDblClick: null, onDrag: null, onDragEnd: null, onDragEnter: null, onDragExit: null, onDragLeave: null, onDragOver: null, onDragStart: null, onDrop: null, onDurationChange: null, onEmptied: null, onEnd: null, onEnded: null, onError: null, onFocus: null, onFocusIn: null, onFocusOut: null, onHashChange: null, onInput: null, onInvalid: null, onKeyDown: null, onKeyPress: null, onKeyUp: null, onLoad: null, onLoadedData: null, onLoadedMetadata: null, onLoadStart: null, onMessage: null, onMouseDown: null, onMouseEnter: null, onMouseLeave: null, onMouseMove: null, onMouseOut: null, onMouseOver: null, onMouseUp: null, onMouseWheel: null, onOffline: null, onOnline: null, onPageHide: null, onPageShow: null, onPaste: null, onPause: null, onPlay: null, onPlaying: null, onPopState: null, onProgress: null, onRateChange: null, onRepeat: null, onReset: null, onResize: null, onScroll: null, onSeeked: null, onSeeking: null, onSelect: null, onShow: null, onStalled: null, onStorage: null, onSubmit: null, onSuspend: null, onTimeUpdate: null, onToggle: null, onUnload: null, onVolumeChange: null, onWaiting: null, onZoom: null, opacity: null, operator: null, order: null, orient: null, orientation: null, origin: null, overflow: null, overlay: null, overlinePosition: $, overlineThickness: $, paintOrder: null, panose1: null, path: null, pathLength: $, patternContentUnits: null, patternTransform: null, patternUnits: null, phase: null, ping: Ee, pitch: null, playbackOrder: null, pointerEvents: null, points: null, pointsAtX: $, pointsAtY: $, pointsAtZ: $, preserveAlpha: null, preserveAspectRatio: null, primitiveUnits: null, propagate: null, property: gt, r: null, radius: null, referrerPolicy: null, refX: null, refY: null, rel: gt, rev: gt, renderingIntent: null, repeatCount: null, repeatDur: null, requiredExtensions: gt, requiredFeatures: gt, requiredFonts: gt, requiredFormats: gt, resource: null, restart: null, result: null, rotate: null, rx: null, ry: null, scale: null, seed: null, shapeRendering: null, side: null, slope: null, snapshotTime: null, specularConstant: $, specularExponent: $, spreadMethod: null, spacing: null, startOffset: null, stdDeviation: null, stemh: null, stemv: null, stitchTiles: null, stopColor: null, stopOpacity: null, strikethroughPosition: $, strikethroughThickness: $, string: null, stroke: null, strokeDashArray: gt, strokeDashOffset: null, strokeLineCap: null, strokeLineJoin: null, strokeMiterLimit: $, strokeOpacity: $, strokeWidth: null, style: null, surfaceScale: $, syncBehavior: null, syncBehaviorDefault: null, syncMaster: null, syncTolerance: null, syncToleranceDefault: null, systemLanguage: gt, tabIndex: $, tableValues: null, target: null, targetX: $, targetY: $, textAnchor: null, textDecoration: null, textRendering: null, textLength: null, timelineBegin: null, title: null, transformBehavior: null, type: null, typeOf: gt, to: null, transform: null, transformOrigin: null, u1: null, u2: null, underlinePosition: $, underlineThickness: $, unicode: null, unicodeBidi: null, unicodeRange: null, unitsPerEm: $, values: null, vAlphabetic: $, vMathematical: $, vectorEffect: null, vHanging: $, vIdeographic: $, version: null, vertAdvY: $, vertOriginX: $, vertOriginY: $, viewBox: null, viewTarget: null, visibility: null, width: null, widths: null, wordSpacing: null, writingMode: null, x: null, x1: null, x2: null, xChannelSelector: null, xHeight: $, y: null, y1: null, y2: null, yChannelSelector: null, z: null, zoomAndPan: null }, space: "svg", transform: Z1 }), tE = Si({ properties: { xLinkActuate: null, xLinkArcRole: null, xLinkHref: null, xLinkRole: null, xLinkShow: null, xLinkTitle: null, xLinkType: null }, space: "xlink", transform(e, t) { return "xlink:" + t.slice(5).toLowerCase() } }), nE = Si({ attributes: { xmlnsxlink: "xmlns:xlink" }, properties: { xmlnsXLink: null, xmlns: null }, space: "xmlns", transform: eE }), rE = Si({ properties: { xmlBase: null, xmlLang: null, xmlSpace: null }, space: "xml", transform(e, t) { return "xml:" + t.slice(3).toLowerCase() } }), DC = { classId: "classID", dataType: "datatype", itemId: "itemID", strokeDashArray: "strokeDasharray", strokeDashOffset: "strokeDashoffset", strokeLineCap: "strokeLinecap", strokeLineJoin: "strokeLinejoin", strokeMiterLimit: "strokeMiterlimit", typeOf: "typeof", xLinkActuate: "xlinkActuate", xLinkArcRole: "xlinkArcrole", xLinkHref: "xlinkHref", xLinkRole: "xlinkRole", xLinkShow: "xlinkShow", xLinkTitle: "xlinkTitle", xLinkType: "xlinkType", xmlnsXLink: "xmlnsXlink" }, MC = /[A-Z]/g, N0 = /-[a-z]/g, FC = /^data[-\w.:]+$/i; function ro(e, t) { const n = Bu(t); let r = t, i = pt; if (n in e.normal) return e.property[e.normal[n]]; if (n.length > 4 && n.slice(0, 4) === "data" && FC.test(t)) { if (t.charAt(4) === "-") { const u = t.slice(5).replace(N0, UC); r = "data" + u.charAt(0).toUpperCase() + u.slice(1) } else { const u = t.slice(4); if (!N0.test(u)) { let s = u.replace(MC, BC); s.charAt(0) !== "-" && (s = "-" + s), t = "data" + s } } i = Qf } return new i(r, t) } function BC(e) { return "-" + e.toLowerCase() } function UC(e) { return e.charAt(1).toUpperCase() } const Zu = X1([J1, RC, tE, nE, rE], "html"), Qn = X1([J1, PC, tE, nE, rE], "svg"); function I0(e) { const t = String(e || "").trim(); return t ? t.split(/[ \t\n\r\f]+/g) : [] } function iE(e) { return e.join(" ").trim() } var Gf = {}, w0 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, HC = /\n/g, zC = /^\s*/, jC = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, $C = /^:\s*/, VC = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, YC = /^[;\s]*/, WC = /^\s+|\s+$/g, KC = `
`, v0 = "/", O0 = "*", rr = "", qC = "comment", QC = "declaration"; function GC(e, t) { if (typeof e != "string") throw new TypeError("First argument must be a string"); if (!e) return []; t = t || {}; var n = 1, r = 1; function i(m) { var T = m.match(HC); T && (n += T.length); var _ = m.lastIndexOf(KC); r = ~_ ? m.length - _ : r + m.length } function u() { var m = { line: n, column: r }; return function (T) { return T.position = new s(m), l(), T } } function s(m) { this.start = m, this.end = { line: n, column: r }, this.source = t.source } s.prototype.content = e; function a(m) { var T = new Error(t.source + ":" + n + ":" + r + ": " + m); if (T.reason = m, T.filename = t.source, T.line = n, T.column = r, T.source = e, !t.silent) throw T } function o(m) { var T = m.exec(e); if (T) { var _ = T[0]; return i(_), e = e.slice(_.length), T } } function l() { o(zC) } function f(m) { var T; for (m = m || []; T = d();)T !== !1 && m.push(T); return m } function d() { var m = u(); if (!(v0 != e.charAt(0) || O0 != e.charAt(1))) { for (var T = 2; rr != e.charAt(T) && (O0 != e.charAt(T) || v0 != e.charAt(T + 1));)++T; if (T += 2, rr === e.charAt(T - 1)) return a("End of comment missing"); var _ = e.slice(2, T - 2); return r += 2, i(_), e = e.slice(T), r += 2, m({ type: qC, comment: _ }) } } function p() { var m = u(), T = o(jC); if (T) { if (d(), !o($C)) return a("property missing ':'"); var _ = o(VC), g = m({ type: QC, property: L0(T[0].replace(w0, rr)), value: _ ? L0(_[0].replace(w0, rr)) : rr }); return o(YC), g } } function h() { var m = []; f(m); for (var T; T = p();)T !== !1 && (m.push(T), f(m)); return m } return l(), h() } function L0(e) { return e ? e.replace(WC, rr) : rr } var XC = GC, JC = Xs && Xs.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }; Object.defineProperty(Gf, "__esModule", { value: !0 }); Gf.default = e3; const ZC = JC(XC); function e3(e, t) { let n = null; if (!e || typeof e != "string") return n; const r = (0, ZC.default)(e), i = typeof t == "function"; return r.forEach(u => { if (u.type !== "declaration") return; const { property: s, value: a } = u; i ? t(s, a, u) : a && (n = n || {}, n[s] = a) }), n } var io = {}; Object.defineProperty(io, "__esModule", { value: !0 }); io.camelCase = void 0; var t3 = /^--[a-zA-Z0-9_-]+$/, n3 = /-([a-z])/g, r3 = /^[^-]+$/, i3 = /^-(webkit|moz|ms|o|khtml)-/, u3 = /^-(ms)-/, s3 = function (e) { return !e || r3.test(e) || t3.test(e) }, a3 = function (e, t) { return t.toUpperCase() }, R0 = function (e, t) { return "".concat(t, "-") }, o3 = function (e, t) { return t === void 0 && (t = {}), s3(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(u3, R0) : e = e.replace(i3, R0), e.replace(n3, a3)) }; io.camelCase = o3; var l3 = Xs && Xs.__importDefault || function (e) { return e && e.__esModule ? e : { default: e } }, c3 = l3(Gf), f3 = io; function wc(e, t) { var n = {}; return !e || typeof e != "string" || (0, c3.default)(e, function (r, i) { r && i && (n[(0, f3.camelCase)(r, t)] = i) }), n } wc.default = wc; var d3 = wc; const h3 = mi(d3), uo = uE("end"), nn = uE("start"); function uE(e) { return t; function t(n) { const r = n && n.position && n.position[e] || {}; if (typeof r.line == "number" && r.line > 0 && typeof r.column == "number" && r.column > 0) return { line: r.line, column: r.column, offset: typeof r.offset == "number" && r.offset > -1 ? r.offset : void 0 } } } function p3(e) { const t = nn(e), n = uo(e); if (t && n) return { start: t, end: n } } function cu(e) { return !e || typeof e != "object" ? "" : "position" in e || "type" in e ? P0(e.position) : "start" in e || "end" in e ? P0(e) : "line" in e || "column" in e ? vc(e) : "" } function vc(e) { return D0(e && e.line) + ":" + D0(e && e.column) } function P0(e) { return vc(e && e.start) + "-" + vc(e && e.end) } function D0(e) { return e && typeof e == "number" ? e : 1 } class Xe extends Error { constructor(t, n, r) { super(), typeof n == "string" && (r = n, n = void 0); let i = "", u = {}, s = !1; if (n && ("line" in n && "column" in n ? u = { place: n } : "start" in n && "end" in n ? u = { place: n } : "type" in n ? u = { ancestors: [n], place: n.position } : u = { ...n }), typeof t == "string" ? i = t : !u.cause && t && (s = !0, i = t.message, u.cause = t), !u.ruleId && !u.source && typeof r == "string") { const o = r.indexOf(":"); o === -1 ? u.ruleId = r : (u.source = r.slice(0, o), u.ruleId = r.slice(o + 1)) } if (!u.place && u.ancestors && u.ancestors) { const o = u.ancestors[u.ancestors.length - 1]; o && (u.place = o.position) } const a = u.place && "start" in u.place ? u.place.start : u.place; this.ancestors = u.ancestors || void 0, this.cause = u.cause || void 0, this.column = a ? a.column : void 0, this.fatal = void 0, this.file = "", this.message = i, this.line = a ? a.line : void 0, this.name = cu(u.place) || "1:1", this.place = u.place || void 0, this.reason = this.message, this.ruleId = u.ruleId || void 0, this.source = u.source || void 0, this.stack = s && u.cause && typeof u.cause.stack == "string" ? u.cause.stack : "", this.actual = void 0, this.expected = void 0, this.note = void 0, this.url = void 0 } } Xe.prototype.file = ""; Xe.prototype.name = ""; Xe.prototype.reason = ""; Xe.prototype.message = ""; Xe.prototype.stack = ""; Xe.prototype.column = void 0; Xe.prototype.line = void 0; Xe.prototype.ancestors = void 0; Xe.prototype.cause = void 0; Xe.prototype.fatal = void 0; Xe.prototype.place = void 0; Xe.prototype.ruleId = void 0; Xe.prototype.source = void 0; const Xf = {}.hasOwnProperty, m3 = new Map, g3 = /[A-Z]/g, E3 = new Set(["table", "tbody", "thead", "tfoot", "tr"]), T3 = new Set(["td", "th"]), sE = "https://github.com/syntax-tree/hast-util-to-jsx-runtime"; function y3(e, t) { if (!t || t.Fragment === void 0) throw new TypeError("Expected `Fragment` in options"); const n = t.filePath || void 0; let r; if (t.development) { if (typeof t.jsxDEV != "function") throw new TypeError("Expected `jsxDEV` in options when `development: true`"); r = N3(n, t.jsxDEV) } else { if (typeof t.jsx != "function") throw new TypeError("Expected `jsx` in production options"); if (typeof t.jsxs != "function") throw new TypeError("Expected `jsxs` in production options"); r = k3(n, t.jsx, t.jsxs) } const i = { Fragment: t.Fragment, ancestors: [], components: t.components || {}, create: r, elementAttributeNameCase: t.elementAttributeNameCase || "react", evaluater: t.createEvaluater ? t.createEvaluater() : void 0, filePath: n, ignoreInvalidStyle: t.ignoreInvalidStyle || !1, passKeys: t.passKeys !== !1, passNode: t.passNode || !1, schema: t.space === "svg" ? Qn : Zu, stylePropertyNameCase: t.stylePropertyNameCase || "dom", tableCellAlignToStyle: t.tableCellAlignToStyle !== !1 }, u = aE(i, e, void 0); return u && typeof u != "string" ? u : i.create(e, i.Fragment, { children: u || void 0 }, void 0) } function aE(e, t, n) { if (t.type === "element") return b3(e, t, n); if (t.type === "mdxFlowExpression" || t.type === "mdxTextExpression") return x3(e, t); if (t.type === "mdxJsxFlowElement" || t.type === "mdxJsxTextElement") return _3(e, t, n); if (t.type === "mdxjsEsm") return S3(e, t); if (t.type === "root") return C3(e, t, n); if (t.type === "text") return A3(e, t) } function b3(e, t, n) { const r = e.schema; let i = r; t.tagName.toLowerCase() === "svg" && r.space === "html" && (i = Qn, e.schema = i), e.ancestors.push(t); const u = lE(e, t.tagName, !1), s = I3(e, t); let a = Zf(e, t); return E3.has(t.tagName) && (a = a.filter(function (o) { return typeof o == "string" ? !OC(o) : !0 })), oE(e, s, u, t), Jf(s, a), e.ancestors.pop(), e.schema = r, e.create(t, u, s, n) } function x3(e, t) { if (t.data && t.data.estree && e.evaluater) { const r = t.data.estree.body[0]; return r.type, e.evaluater.evaluateExpression(r.expression) } Uu(e, t.position) } function S3(e, t) { if (t.data && t.data.estree && e.evaluater) return e.evaluater.evaluateProgram(t.data.estree); Uu(e, t.position) } function _3(e, t, n) { const r = e.schema; let i = r; t.name === "svg" && r.space === "html" && (i = Qn, e.schema = i), e.ancestors.push(t); const u = t.name === null ? e.Fragment : lE(e, t.name, !0), s = w3(e, t), a = Zf(e, t); return oE(e, s, u, t), Jf(s, a), e.ancestors.pop(), e.schema = r, e.create(t, u, s, n) } function C3(e, t, n) { const r = {}; return Jf(r, Zf(e, t)), e.create(t, e.Fragment, r, n) } function A3(e, t) { return t.value } function oE(e, t, n, r) { typeof n != "string" && n !== e.Fragment && e.passNode && (t.node = r) } function Jf(e, t) { if (t.length > 0) { const n = t.length > 1 ? t : t[0]; n && (e.children = n) } } function k3(e, t, n) { return r; function r(i, u, s, a) { const l = Array.isArray(s.children) ? n : t; return a ? l(u, s, a) : l(u, s) } } function N3(e, t) { return n; function n(r, i, u, s) { const a = Array.isArray(u.children), o = nn(r); return t(i, u, s, a, { columnNumber: o ? o.column - 1 : void 0, fileName: e, lineNumber: o ? o.line : void 0 }, void 0) } } function I3(e, t) { const n = {}; let r, i; for (i in t.properties) if (i !== "children" && Xf.call(t.properties, i)) { const u = v3(e, i, t.properties[i]); if (u) { const [s, a] = u; e.tableCellAlignToStyle && s === "align" && typeof a == "string" && T3.has(t.tagName) ? r = a : n[s] = a } } if (r) { const u = n.style || (n.style = {}); u[e.stylePropertyNameCase === "css" ? "text-align" : "textAlign"] = r } return n } function w3(e, t) { const n = {}; for (const r of t.attributes) if (r.type === "mdxJsxExpressionAttribute") if (r.data && r.data.estree && e.evaluater) { const u = r.data.estree.body[0]; u.type; const s = u.expression; s.type; const a = s.properties[0]; a.type, Object.assign(n, e.evaluater.evaluateExpression(a.argument)) } else Uu(e, t.position); else { const i = r.name; let u; if (r.value && typeof r.value == "object") if (r.value.data && r.value.data.estree && e.evaluater) { const a = r.value.data.estree.body[0]; a.type, u = e.evaluater.evaluateExpression(a.expression) } else Uu(e, t.position); else u = r.value === null ? !0 : r.value; n[i] = u } return n } function Zf(e, t) { const n = []; let r = -1; const i = e.passKeys ? new Map : m3; for (; ++r < t.children.length;) { const u = t.children[r]; let s; if (e.passKeys) { const o = u.type === "element" ? u.tagName : u.type === "mdxJsxFlowElement" || u.type === "mdxJsxTextElement" ? u.name : void 0; if (o) { const l = i.get(o) || 0; s = o + "-" + l, i.set(o, l + 1) } } const a = aE(e, u, s); a !== void 0 && n.push(a) } return n } function v3(e, t, n) { const r = ro(e.schema, t); if (!(n == null || typeof n == "number" && Number.isNaN(n))) { if (Array.isArray(n) && (n = r.commaSeparated ? G1(n) : iE(n)), r.property === "style") { let i = typeof n == "object" ? n : O3(e, String(n)); return e.stylePropertyNameCase === "css" && (i = L3(i)), ["style", i] } return [e.elementAttributeNameCase === "react" && r.space ? DC[r.property] || r.property : r.attribute, n] } } function O3(e, t) { try { return h3(t, { reactCompat: !0 }) } catch (n) { if (e.ignoreInvalidStyle) return {}; const r = n, i = new Xe("Cannot parse `style` attribute", { ancestors: e.ancestors, cause: r, ruleId: "style", source: "hast-util-to-jsx-runtime" }); throw i.file = e.filePath || void 0, i.url = sE + "#cannot-parse-style-attribute", i } } function lE(e, t, n) { let r; if (!n) r = { type: "Literal", value: t }; else if (t.includes(".")) { const i = t.split("."); let u = -1, s; for (; ++u < i.length;) { const a = C0(i[u]) ? { type: "Identifier", name: i[u] } : { type: "Literal", value: i[u] }; s = s ? { type: "MemberExpression", object: s, property: a, computed: !!(u && a.type === "Literal"), optional: !1 } : a } r = s } else r = C0(t) && !/^[a-z]/.test(t) ? { type: "Identifier", name: t } : { type: "Literal", value: t }; if (r.type === "Literal") { const i = r.value; return Xf.call(e.components, i) ? e.components[i] : i } if (e.evaluater) return e.evaluater.evaluateExpression(r); Uu(e) } function Uu(e, t) { const n = new Xe("Cannot handle MDX estrees without `createEvaluater`", { ancestors: e.ancestors, place: t, ruleId: "mdx-estree", source: "hast-util-to-jsx-runtime" }); throw n.file = e.filePath || void 0, n.url = sE + "#cannot-handle-mdx-estrees-without-createevaluater", n } function L3(e) { const t = {}; let n; for (n in e) Xf.call(e, n) && (t[R3(n)] = e[n]); return t } function R3(e) { let t = e.replace(g3, P3); return t.slice(0, 3) === "ms-" && (t = "-" + t), t } function P3(e) { return "-" + e.toLowerCase() } const el = { action: ["form"], cite: ["blockquote", "del", "ins", "q"], data: ["object"], formAction: ["button", "input"], href: ["a", "area", "base", "link"], icon: ["menuitem"], itemId: null, manifest: ["html"], ping: ["a", "area"], poster: ["video"], src: ["audio", "embed", "iframe", "img", "input", "script", "source", "track", "video"] }, D3 = {}; function ed(e, t) { const n = D3, r = typeof n.includeImageAlt == "boolean" ? n.includeImageAlt : !0, i = typeof n.includeHtml == "boolean" ? n.includeHtml : !0; return cE(e, r, i) } function cE(e, t, n) { if (M3(e)) { if ("value" in e) return e.type === "html" && !n ? "" : e.value; if (t && "alt" in e && e.alt) return e.alt; if ("children" in e) return M0(e.children, t, n) } return Array.isArray(e) ? M0(e, t, n) : "" } function M0(e, t, n) { const r = []; let i = -1; for (; ++i < e.length;)r[i] = cE(e[i], t, n); return r.join("") } function M3(e) { return !!(e && typeof e == "object") } const F0 = document.createElement("i"); function td(e) { const t = "&" + e + ";"; F0.innerHTML = t; const n = F0.textContent; return n.charCodeAt(n.length - 1) === 59 && e !== "semi" || n === t ? !1 : n } function bt(e, t, n, r) { const i = e.length; let u = 0, s; if (t < 0 ? t = -t > i ? 0 : i + t : t = t > i ? i : t, n = n > 0 ? n : 0, r.length < 1e4) s = Array.from(r), s.unshift(t, n), e.splice(...s); else for (n && e.splice(t, n); u < r.length;)s = r.slice(u, u + 1e4), s.unshift(t, 0), e.splice(...s), u += 1e4, t += 1e4 } function Nt(e, t) { return e.length > 0 ? (bt(e, e.length, 0, t), e) : t } const B0 = {}.hasOwnProperty; function fE(e) { const t = {}; let n = -1; for (; ++n < e.length;)F3(t, e[n]); return t } function F3(e, t) { let n; for (n in t) { const i = (B0.call(e, n) ? e[n] : void 0) || (e[n] = {}), u = t[n]; let s; if (u) for (s in u) { B0.call(i, s) || (i[s] = []); const a = u[s]; B3(i[s], Array.isArray(a) ? a : a ? [a] : []) } } } function B3(e, t) { let n = -1; const r = []; for (; ++n < t.length;)(t[n].add === "after" ? e : r).push(t[n]); bt(e, 0, 0, r) } function dE(e, t) { const n = Number.parseInt(e, t); return n < 9 || n === 11 || n > 13 && n < 32 || n > 126 && n < 160 || n > 55295 && n < 57344 || n > 64975 && n < 65008 || (n & 65535) === 65535 || (n & 65535) === 65534 || n > 1114111 ? "" : String.fromCodePoint(n) } function jt(e) { return e.replace(/[\t\n\r ]+/g, " ").replace(/^ | $/g, "").toLowerCase().toUpperCase() } const et = Gn(/[A-Za-z]/), Qe = Gn(/[\dA-Za-z]/), U3 = Gn(/[#-'*+\--9=?A-Z^-~]/); function Na(e) { return e !== null && (e < 32 || e === 127) } const Oc = Gn(/\d/), H3 = Gn(/[\dA-Fa-f]/), z3 = Gn(/[!-/:-@[-`{-~]/); function Z(e) { return e !== null && e < -2 } function ge(e) { return e !== null && (e < 0 || e === 32) } function oe(e) { return e === -2 || e === -1 || e === 32 } const so = Gn(new RegExp("\\p{P}|\\p{S}", "u")), xr = Gn(/\s/); function Gn(e) { return t; function t(n) { return n !== null && n > -1 && e.test(String.fromCharCode(n)) } } function _i(e) { const t = []; let n = -1, r = 0, i = 0; for (; ++n < e.length;) { const u = e.charCodeAt(n); let s = ""; if (u === 37 && Qe(e.charCodeAt(n + 1)) && Qe(e.charCodeAt(n + 2))) i = 2; else if (u < 128) /[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(u)) || (s = String.fromCharCode(u)); else if (u > 55295 && u < 57344) { const a = e.charCodeAt(n + 1); u < 56320 && a > 56319 && a < 57344 ? (s = String.fromCharCode(u, a), i = 1) : s = "" } else s = String.fromCharCode(u); s && (t.push(e.slice(r, n), encodeURIComponent(s)), r = n + i + 1, s = ""), i && (n += i, i = 0) } return t.join("") + e.slice(r) } function fe(e, t, n, r) { const i = r ? r - 1 : Number.POSITIVE_INFINITY; let u = 0; return s; function s(o) { return oe(o) ? (e.enter(n), a(o)) : t(o) } function a(o) { return oe(o) && u++ < i ? (e.consume(o), a) : (e.exit(n), t(o)) } } const j3 = { tokenize: $3 }; function $3(e) { const t = e.attempt(this.parser.constructs.contentInitial, r, i); let n; return t; function r(a) { if (a === null) { e.consume(a); return } return e.enter("lineEnding"), e.consume(a), e.exit("lineEnding"), fe(e, t, "linePrefix") } function i(a) { return e.enter("paragraph"), u(a) } function u(a) { const o = e.enter("chunkText", { contentType: "text", previous: n }); return n && (n.next = o), n = o, s(a) } function s(a) { if (a === null) { e.exit("chunkText"), e.exit("paragraph"), e.consume(a); return } return Z(a) ? (e.consume(a), e.exit("chunkText"), u) : (e.consume(a), s) } } const V3 = { tokenize: Y3 }, U0 = { tokenize: W3 }; function Y3(e) { const t = this, n = []; let r = 0, i, u, s; return a; function a(y) { if (r < n.length) { const I = n[r]; return t.containerState = I[1], e.attempt(I[0].continuation, o, l)(y) } return l(y) } function o(y) { if (r++, t.containerState._closeFlow) { t.containerState._closeFlow = void 0, i && E(); const I = t.events.length; let L = I, k; for (; L--;)if (t.events[L][0] === "exit" && t.events[L][1].type === "chunkFlow") { k = t.events[L][1].end; break } g(r); let P = I; for (; P < t.events.length;)t.events[P][1].end = { ...k }, P++; return bt(t.events, L + 1, 0, t.events.slice(I)), t.events.length = P, l(y) } return a(y) } function l(y) { if (r === n.length) { if (!i) return p(y); if (i.currentConstruct && i.currentConstruct.concrete) return m(y); t.interrupt = !!(i.currentConstruct && !i._gfmTableDynamicInterruptHack) } return t.containerState = {}, e.check(U0, f, d)(y) } function f(y) { return i && E(), g(r), p(y) } function d(y) { return t.parser.lazy[t.now().line] = r !== n.length, s = t.now().offset, m(y) } function p(y) { return t.containerState = {}, e.attempt(U0, h, m)(y) } function h(y) { return r++, n.push([t.currentConstruct, t.containerState]), p(y) } function m(y) { if (y === null) { i && E(), g(0), e.consume(y); return } return i = i || t.parser.flow(t.now()), e.enter("chunkFlow", { _tokenizer: i, contentType: "flow", previous: u }), T(y) } function T(y) { if (y === null) { _(e.exit("chunkFlow"), !0), g(0), e.consume(y); return } return Z(y) ? (e.consume(y), _(e.exit("chunkFlow")), r = 0, t.interrupt = void 0, a) : (e.consume(y), T) } function _(y, I) { const L = t.sliceStream(y); if (I && L.push(null), y.previous = u, u && (u.next = y), u = y, i.defineSkip(y.start), i.write(L), t.parser.lazy[y.start.line]) { let k = i.events.length; for (; k--;)if (i.events[k][1].start.offset < s && (!i.events[k][1].end || i.events[k][1].end.offset > s)) return; const P = t.events.length; let j = P, W, N; for (; j--;)if (t.events[j][0] === "exit" && t.events[j][1].type === "chunkFlow") { if (W) { N = t.events[j][1].end; break } W = !0 } for (g(r), k = P; k < t.events.length;)t.events[k][1].end = { ...N }, k++; bt(t.events, j + 1, 0, t.events.slice(P)), t.events.length = k } } function g(y) { let I = n.length; for (; I-- > y;) { const L = n[I]; t.containerState = L[1], L[0].exit.call(t, e) } n.length = y } function E() { i.write([null]), u = void 0, i = void 0, t.containerState._closeFlow = void 0 } } function W3(e, t, n) { return fe(e, e.attempt(this.parser.constructs.document, t, n), "linePrefix", this.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4) } function di(e) { if (e === null || ge(e) || xr(e)) return 1; if (so(e)) return 2 } function ao(e, t, n) { const r = []; let i = -1; for (; ++i < e.length;) { const u = e[i].resolveAll; u && !r.includes(u) && (t = u(t, n), r.push(u)) } return t } const Lc = { name: "attention", resolveAll: K3, tokenize: q3 }; function K3(e, t) { let n = -1, r, i, u, s, a, o, l, f; for (; ++n < e.length;)if (e[n][0] === "enter" && e[n][1].type === "attentionSequence" && e[n][1]._close) { for (r = n; r--;)if (e[r][0] === "exit" && e[r][1].type === "attentionSequence" && e[r][1]._open && t.sliceSerialize(e[r][1]).charCodeAt(0) === t.sliceSerialize(e[n][1]).charCodeAt(0)) { if ((e[r][1]._close || e[n][1]._open) && (e[n][1].end.offset - e[n][1].start.offset) % 3 && !((e[r][1].end.offset - e[r][1].start.offset + e[n][1].end.offset - e[n][1].start.offset) % 3)) continue; o = e[r][1].end.offset - e[r][1].start.offset > 1 && e[n][1].end.offset - e[n][1].start.offset > 1 ? 2 : 1; const d = { ...e[r][1].end }, p = { ...e[n][1].start }; H0(d, -o), H0(p, o), s = { type: o > 1 ? "strongSequence" : "emphasisSequence", start: d, end: { ...e[r][1].end } }, a = { type: o > 1 ? "strongSequence" : "emphasisSequence", start: { ...e[n][1].start }, end: p }, u = { type: o > 1 ? "strongText" : "emphasisText", start: { ...e[r][1].end }, end: { ...e[n][1].start } }, i = { type: o > 1 ? "strong" : "emphasis", start: { ...s.start }, end: { ...a.end } }, e[r][1].end = { ...s.start }, e[n][1].start = { ...a.end }, l = [], e[r][1].end.offset - e[r][1].start.offset && (l = Nt(l, [["enter", e[r][1], t], ["exit", e[r][1], t]])), l = Nt(l, [["enter", i, t], ["enter", s, t], ["exit", s, t], ["enter", u, t]]), l = Nt(l, ao(t.parser.constructs.insideSpan.null, e.slice(r + 1, n), t)), l = Nt(l, [["exit", u, t], ["enter", a, t], ["exit", a, t], ["exit", i, t]]), e[n][1].end.offset - e[n][1].start.offset ? (f = 2, l = Nt(l, [["enter", e[n][1], t], ["exit", e[n][1], t]])) : f = 0, bt(e, r - 1, n - r + 3, l), n = r + l.length - f - 2; break } } for (n = -1; ++n < e.length;)e[n][1].type === "attentionSequence" && (e[n][1].type = "data"); return e } function q3(e, t) { const n = this.parser.constructs.attentionMarkers.null, r = this.previous, i = di(r); let u; return s; function s(o) { return u = o, e.enter("attentionSequence"), a(o) } function a(o) { if (o === u) return e.consume(o), a; const l = e.exit("attentionSequence"), f = di(o), d = !f || f === 2 && i || n.includes(o), p = !i || i === 2 && f || n.includes(r); return l._open = !!(u === 42 ? d : d && (i || !p)), l._close = !!(u === 42 ? p : p && (f || !d)), t(o) } } function H0(e, t) { e.column += t, e.offset += t, e._bufferIndex += t } const Q3 = { name: "autolink", tokenize: G3 }; function G3(e, t, n) { let r = 0; return i; function i(h) { return e.enter("autolink"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.enter("autolinkProtocol"), u } function u(h) { return et(h) ? (e.consume(h), s) : h === 64 ? n(h) : l(h) } function s(h) { return h === 43 || h === 45 || h === 46 || Qe(h) ? (r = 1, a(h)) : l(h) } function a(h) { return h === 58 ? (e.consume(h), r = 0, o) : (h === 43 || h === 45 || h === 46 || Qe(h)) && r++ < 32 ? (e.consume(h), a) : (r = 0, l(h)) } function o(h) { return h === 62 ? (e.exit("autolinkProtocol"), e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : h === null || h === 32 || h === 60 || Na(h) ? n(h) : (e.consume(h), o) } function l(h) { return h === 64 ? (e.consume(h), f) : U3(h) ? (e.consume(h), l) : n(h) } function f(h) { return Qe(h) ? d(h) : n(h) } function d(h) { return h === 46 ? (e.consume(h), r = 0, f) : h === 62 ? (e.exit("autolinkProtocol").type = "autolinkEmail", e.enter("autolinkMarker"), e.consume(h), e.exit("autolinkMarker"), e.exit("autolink"), t) : p(h) } function p(h) { if ((h === 45 || Qe(h)) && r++ < 63) { const m = h === 45 ? p : d; return e.consume(h), m } return n(h) } } const es = { partial: !0, tokenize: X3 }; function X3(e, t, n) { return r; function r(u) { return oe(u) ? fe(e, i, "linePrefix")(u) : i(u) } function i(u) { return u === null || Z(u) ? t(u) : n(u) } } const hE = { continuation: { tokenize: Z3 }, exit: eA, name: "blockQuote", tokenize: J3 }; function J3(e, t, n) { const r = this; return i; function i(s) { if (s === 62) { const a = r.containerState; return a.open || (e.enter("blockQuote", { _container: !0 }), a.open = !0), e.enter("blockQuotePrefix"), e.enter("blockQuoteMarker"), e.consume(s), e.exit("blockQuoteMarker"), u } return n(s) } function u(s) { return oe(s) ? (e.enter("blockQuotePrefixWhitespace"), e.consume(s), e.exit("blockQuotePrefixWhitespace"), e.exit("blockQuotePrefix"), t) : (e.exit("blockQuotePrefix"), t(s)) } } function Z3(e, t, n) { const r = this; return i; function i(s) { return oe(s) ? fe(e, u, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(s) : u(s) } function u(s) { return e.attempt(hE, t, n)(s) } } function eA(e) { e.exit("blockQuote") } const pE = { name: "characterEscape", tokenize: tA }; function tA(e, t, n) { return r; function r(u) { return e.enter("characterEscape"), e.enter("escapeMarker"), e.consume(u), e.exit("escapeMarker"), i } function i(u) { return z3(u) ? (e.enter("characterEscapeValue"), e.consume(u), e.exit("characterEscapeValue"), e.exit("characterEscape"), t) : n(u) } } const mE = { name: "characterReference", tokenize: nA }; function nA(e, t, n) { const r = this; let i = 0, u, s; return a; function a(d) { return e.enter("characterReference"), e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), o } function o(d) { return d === 35 ? (e.enter("characterReferenceMarkerNumeric"), e.consume(d), e.exit("characterReferenceMarkerNumeric"), l) : (e.enter("characterReferenceValue"), u = 31, s = Qe, f(d)) } function l(d) { return d === 88 || d === 120 ? (e.enter("characterReferenceMarkerHexadecimal"), e.consume(d), e.exit("characterReferenceMarkerHexadecimal"), e.enter("characterReferenceValue"), u = 6, s = H3, f) : (e.enter("characterReferenceValue"), u = 7, s = Oc, f(d)) } function f(d) { if (d === 59 && i) { const p = e.exit("characterReferenceValue"); return s === Qe && !td(r.sliceSerialize(p)) ? n(d) : (e.enter("characterReferenceMarker"), e.consume(d), e.exit("characterReferenceMarker"), e.exit("characterReference"), t) } return s(d) && i++ < u ? (e.consume(d), f) : n(d) } } const z0 = { partial: !0, tokenize: iA }, j0 = { concrete: !0, name: "codeFenced", tokenize: rA }; function rA(e, t, n) { const r = this, i = { partial: !0, tokenize: L }; let u = 0, s = 0, a; return o; function o(k) { return l(k) } function l(k) { const P = r.events[r.events.length - 1]; return u = P && P[1].type === "linePrefix" ? P[2].sliceSerialize(P[1], !0).length : 0, a = k, e.enter("codeFenced"), e.enter("codeFencedFence"), e.enter("codeFencedFenceSequence"), f(k) } function f(k) { return k === a ? (s++, e.consume(k), f) : s < 3 ? n(k) : (e.exit("codeFencedFenceSequence"), oe(k) ? fe(e, d, "whitespace")(k) : d(k)) } function d(k) { return k === null || Z(k) ? (e.exit("codeFencedFence"), r.interrupt ? t(k) : e.check(z0, T, I)(k)) : (e.enter("codeFencedFenceInfo"), e.enter("chunkString", { contentType: "string" }), p(k)) } function p(k) { return k === null || Z(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), d(k)) : oe(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceInfo"), fe(e, h, "whitespace")(k)) : k === 96 && k === a ? n(k) : (e.consume(k), p) } function h(k) { return k === null || Z(k) ? d(k) : (e.enter("codeFencedFenceMeta"), e.enter("chunkString", { contentType: "string" }), m(k)) } function m(k) { return k === null || Z(k) ? (e.exit("chunkString"), e.exit("codeFencedFenceMeta"), d(k)) : k === 96 && k === a ? n(k) : (e.consume(k), m) } function T(k) { return e.attempt(i, I, _)(k) } function _(k) { return e.enter("lineEnding"), e.consume(k), e.exit("lineEnding"), g } function g(k) { return u > 0 && oe(k) ? fe(e, E, "linePrefix", u + 1)(k) : E(k) } function E(k) { return k === null || Z(k) ? e.check(z0, T, I)(k) : (e.enter("codeFlowValue"), y(k)) } function y(k) { return k === null || Z(k) ? (e.exit("codeFlowValue"), E(k)) : (e.consume(k), y) } function I(k) { return e.exit("codeFenced"), t(k) } function L(k, P, j) { let W = 0; return N; function N(G) { return k.enter("lineEnding"), k.consume(G), k.exit("lineEnding"), Y } function Y(G) { return k.enter("codeFencedFence"), oe(G) ? fe(k, U, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(G) : U(G) } function U(G) { return G === a ? (k.enter("codeFencedFenceSequence"), K(G)) : j(G) } function K(G) { return G === a ? (W++, k.consume(G), K) : W >= s ? (k.exit("codeFencedFenceSequence"), oe(G) ? fe(k, q, "whitespace")(G) : q(G)) : j(G) } function q(G) { return G === null || Z(G) ? (k.exit("codeFencedFence"), P(G)) : j(G) } } } function iA(e, t, n) { const r = this; return i; function i(s) { return s === null ? n(s) : (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), u) } function u(s) { return r.parser.lazy[r.now().line] ? n(s) : t(s) } } const tl = { name: "codeIndented", tokenize: sA }, uA = { partial: !0, tokenize: aA }; function sA(e, t, n) { const r = this; return i; function i(l) { return e.enter("codeIndented"), fe(e, u, "linePrefix", 5)(l) } function u(l) { const f = r.events[r.events.length - 1]; return f && f[1].type === "linePrefix" && f[2].sliceSerialize(f[1], !0).length >= 4 ? s(l) : n(l) } function s(l) { return l === null ? o(l) : Z(l) ? e.attempt(uA, s, o)(l) : (e.enter("codeFlowValue"), a(l)) } function a(l) { return l === null || Z(l) ? (e.exit("codeFlowValue"), s(l)) : (e.consume(l), a) } function o(l) { return e.exit("codeIndented"), t(l) } } function aA(e, t, n) { const r = this; return i; function i(s) { return r.parser.lazy[r.now().line] ? n(s) : Z(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), i) : fe(e, u, "linePrefix", 5)(s) } function u(s) { const a = r.events[r.events.length - 1]; return a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : Z(s) ? i(s) : n(s) } } const oA = { name: "codeText", previous: cA, resolve: lA, tokenize: fA }; function lA(e) { let t = e.length - 4, n = 3, r, i; if ((e[n][1].type === "lineEnding" || e[n][1].type === "space") && (e[t][1].type === "lineEnding" || e[t][1].type === "space")) { for (r = n; ++r < t;)if (e[r][1].type === "codeTextData") { e[n][1].type = "codeTextPadding", e[t][1].type = "codeTextPadding", n += 2, t -= 2; break } } for (r = n - 1, t++; ++r <= t;)i === void 0 ? r !== t && e[r][1].type !== "lineEnding" && (i = r) : (r === t || e[r][1].type === "lineEnding") && (e[i][1].type = "codeTextData", r !== i + 2 && (e[i][1].end = e[r - 1][1].end, e.splice(i + 2, r - i - 2), t -= r - i - 2, r = i + 2), i = void 0); return e } function cA(e) { return e !== 96 || this.events[this.events.length - 1][1].type === "characterEscape" } function fA(e, t, n) { let r = 0, i, u; return s; function s(d) { return e.enter("codeText"), e.enter("codeTextSequence"), a(d) } function a(d) { return d === 96 ? (e.consume(d), r++, a) : (e.exit("codeTextSequence"), o(d)) } function o(d) { return d === null ? n(d) : d === 32 ? (e.enter("space"), e.consume(d), e.exit("space"), o) : d === 96 ? (u = e.enter("codeTextSequence"), i = 0, f(d)) : Z(d) ? (e.enter("lineEnding"), e.consume(d), e.exit("lineEnding"), o) : (e.enter("codeTextData"), l(d)) } function l(d) { return d === null || d === 32 || d === 96 || Z(d) ? (e.exit("codeTextData"), o(d)) : (e.consume(d), l) } function f(d) { return d === 96 ? (e.consume(d), i++, f) : i === r ? (e.exit("codeTextSequence"), e.exit("codeText"), t(d)) : (u.type = "codeTextData", l(d)) } } class dA { constructor(t) { this.left = t ? [...t] : [], this.right = [] } get(t) { if (t < 0 || t >= this.left.length + this.right.length) throw new RangeError("Cannot access index `" + t + "` in a splice buffer of size `" + (this.left.length + this.right.length) + "`"); return t < this.left.length ? this.left[t] : this.right[this.right.length - t + this.left.length - 1] } get length() { return this.left.length + this.right.length } shift() { return this.setCursor(0), this.right.pop() } slice(t, n) { const r = n ?? Number.POSITIVE_INFINITY; return r < this.left.length ? this.left.slice(t, r) : t > this.left.length ? this.right.slice(this.right.length - r + this.left.length, this.right.length - t + this.left.length).reverse() : this.left.slice(t).concat(this.right.slice(this.right.length - r + this.left.length).reverse()) } splice(t, n, r) { const i = n || 0; this.setCursor(Math.trunc(t)); const u = this.right.splice(this.right.length - i, Number.POSITIVE_INFINITY); return r && zi(this.left, r), u.reverse() } pop() { return this.setCursor(Number.POSITIVE_INFINITY), this.left.pop() } push(t) { this.setCursor(Number.POSITIVE_INFINITY), this.left.push(t) } pushMany(t) { this.setCursor(Number.POSITIVE_INFINITY), zi(this.left, t) } unshift(t) { this.setCursor(0), this.right.push(t) } unshiftMany(t) { this.setCursor(0), zi(this.right, t.reverse()) } setCursor(t) { if (!(t === this.left.length || t > this.left.length && this.right.length === 0 || t < 0 && this.left.length === 0)) if (t < this.left.length) { const n = this.left.splice(t, Number.POSITIVE_INFINITY); zi(this.right, n.reverse()) } else { const n = this.right.splice(this.left.length + this.right.length - t, Number.POSITIVE_INFINITY); zi(this.left, n.reverse()) } } } function zi(e, t) { let n = 0; if (t.length < 1e4) e.push(...t); else for (; n < t.length;)e.push(...t.slice(n, n + 1e4)), n += 1e4 } function gE(e) { const t = {}; let n = -1, r, i, u, s, a, o, l; const f = new dA(e); for (; ++n < f.length;) { for (; n in t;)n = t[n]; if (r = f.get(n), n && r[1].type === "chunkFlow" && f.get(n - 1)[1].type === "listItemPrefix" && (o = r[1]._tokenizer.events, u = 0, u < o.length && o[u][1].type === "lineEndingBlank" && (u += 2), u < o.length && o[u][1].type === "content")) for (; ++u < o.length && o[u][1].type !== "content";)o[u][1].type === "chunkText" && (o[u][1]._isInFirstContentOfListItem = !0, u++); if (r[0] === "enter") r[1].contentType && (Object.assign(t, hA(f, n)), n = t[n], l = !0); else if (r[1]._container) { for (u = n, i = void 0; u--;)if (s = f.get(u), s[1].type === "lineEnding" || s[1].type === "lineEndingBlank") s[0] === "enter" && (i && (f.get(i)[1].type = "lineEndingBlank"), s[1].type = "lineEnding", i = u); else if (!(s[1].type === "linePrefix" || s[1].type === "listItemIndent")) break; i && (r[1].end = { ...f.get(i)[1].start }, a = f.slice(i, n), a.unshift(r), f.splice(i, n - i + 1, a)) } } return bt(e, 0, Number.POSITIVE_INFINITY, f.slice(0)), !l } function hA(e, t) { const n = e.get(t)[1], r = e.get(t)[2]; let i = t - 1; const u = []; let s = n._tokenizer; s || (s = r.parser[n.contentType](n.start), n._contentTypeTextTrailing && (s._contentTypeTextTrailing = !0)); const a = s.events, o = [], l = {}; let f, d, p = -1, h = n, m = 0, T = 0; const _ = [T]; for (; h;) { for (; e.get(++i)[1] !== h;); u.push(i), h._tokenizer || (f = r.sliceStream(h), h.next || f.push(null), d && s.defineSkip(h.start), h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = !0), s.write(f), h._isInFirstContentOfListItem && (s._gfmTasklistFirstContentOfListItem = void 0)), d = h, h = h.next } for (h = n; ++p < a.length;)a[p][0] === "exit" && a[p - 1][0] === "enter" && a[p][1].type === a[p - 1][1].type && a[p][1].start.line !== a[p][1].end.line && (T = p + 1, _.push(T), h._tokenizer = void 0, h.previous = void 0, h = h.next); for (s.events = [], h ? (h._tokenizer = void 0, h.previous = void 0) : _.pop(), p = _.length; p--;) { const g = a.slice(_[p], _[p + 1]), E = u.pop(); o.push([E, E + g.length - 1]), e.splice(E, 2, g) } for (o.reverse(), p = -1; ++p < o.length;)l[m + o[p][0]] = m + o[p][1], m += o[p][1] - o[p][0] - 1; return l } const pA = { resolve: gA, tokenize: EA }, mA = { partial: !0, tokenize: TA }; function gA(e) { return gE(e), e } function EA(e, t) { let n; return r; function r(a) { return e.enter("content"), n = e.enter("chunkContent", { contentType: "content" }), i(a) } function i(a) { return a === null ? u(a) : Z(a) ? e.check(mA, s, u)(a) : (e.consume(a), i) } function u(a) { return e.exit("chunkContent"), e.exit("content"), t(a) } function s(a) { return e.consume(a), e.exit("chunkContent"), n.next = e.enter("chunkContent", { contentType: "content", previous: n }), n = n.next, i } } function TA(e, t, n) { const r = this; return i; function i(s) { return e.exit("chunkContent"), e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), fe(e, u, "linePrefix") } function u(s) { if (s === null || Z(s)) return n(s); const a = r.events[r.events.length - 1]; return !r.parser.constructs.disable.null.includes("codeIndented") && a && a[1].type === "linePrefix" && a[2].sliceSerialize(a[1], !0).length >= 4 ? t(s) : e.interrupt(r.parser.constructs.flow, n, t)(s) } } function EE(e, t, n, r, i, u, s, a, o) { const l = o || Number.POSITIVE_INFINITY; let f = 0; return d; function d(g) { return g === 60 ? (e.enter(r), e.enter(i), e.enter(u), e.consume(g), e.exit(u), p) : g === null || g === 32 || g === 41 || Na(g) ? n(g) : (e.enter(r), e.enter(s), e.enter(a), e.enter("chunkString", { contentType: "string" }), T(g)) } function p(g) { return g === 62 ? (e.enter(u), e.consume(g), e.exit(u), e.exit(i), e.exit(r), t) : (e.enter(a), e.enter("chunkString", { contentType: "string" }), h(g)) } function h(g) { return g === 62 ? (e.exit("chunkString"), e.exit(a), p(g)) : g === null || g === 60 || Z(g) ? n(g) : (e.consume(g), g === 92 ? m : h) } function m(g) { return g === 60 || g === 62 || g === 92 ? (e.consume(g), h) : h(g) } function T(g) { return !f && (g === null || g === 41 || ge(g)) ? (e.exit("chunkString"), e.exit(a), e.exit(s), e.exit(r), t(g)) : f < l && g === 40 ? (e.consume(g), f++, T) : g === 41 ? (e.consume(g), f--, T) : g === null || g === 32 || g === 40 || Na(g) ? n(g) : (e.consume(g), g === 92 ? _ : T) } function _(g) { return g === 40 || g === 41 || g === 92 ? (e.consume(g), T) : T(g) } } function TE(e, t, n, r, i, u) { const s = this; let a = 0, o; return l; function l(h) { return e.enter(r), e.enter(i), e.consume(h), e.exit(i), e.enter(u), f } function f(h) { return a > 999 || h === null || h === 91 || h === 93 && !o || h === 94 && !a && "_hiddenFootnoteSupport" in s.parser.constructs ? n(h) : h === 93 ? (e.exit(u), e.enter(i), e.consume(h), e.exit(i), e.exit(r), t) : Z(h) ? (e.enter("lineEnding"), e.consume(h), e.exit("lineEnding"), f) : (e.enter("chunkString", { contentType: "string" }), d(h)) } function d(h) { return h === null || h === 91 || h === 93 || Z(h) || a++ > 999 ? (e.exit("chunkString"), f(h)) : (e.consume(h), o || (o = !oe(h)), h === 92 ? p : d) } function p(h) { return h === 91 || h === 92 || h === 93 ? (e.consume(h), a++, d) : d(h) } } function yE(e, t, n, r, i, u) { let s; return a; function a(p) { return p === 34 || p === 39 || p === 40 ? (e.enter(r), e.enter(i), e.consume(p), e.exit(i), s = p === 40 ? 41 : p, o) : n(p) } function o(p) { return p === s ? (e.enter(i), e.consume(p), e.exit(i), e.exit(r), t) : (e.enter(u), l(p)) } function l(p) { return p === s ? (e.exit(u), o(s)) : p === null ? n(p) : Z(p) ? (e.enter("lineEnding"), e.consume(p), e.exit("lineEnding"), fe(e, l, "linePrefix")) : (e.enter("chunkString", { contentType: "string" }), f(p)) } function f(p) { return p === s || p === null || Z(p) ? (e.exit("chunkString"), l(p)) : (e.consume(p), p === 92 ? d : f) } function d(p) { return p === s || p === 92 ? (e.consume(p), f) : f(p) } } function fu(e, t) { let n; return r; function r(i) { return Z(i) ? (e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), n = !0, r) : oe(i) ? fe(e, r, n ? "linePrefix" : "lineSuffix")(i) : t(i) } } const yA = { name: "definition", tokenize: xA }, bA = { partial: !0, tokenize: SA }; function xA(e, t, n) { const r = this; let i; return u; function u(h) { return e.enter("definition"), s(h) } function s(h) { return TE.call(r, e, a, n, "definitionLabel", "definitionLabelMarker", "definitionLabelString")(h) } function a(h) { return i = jt(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1)), h === 58 ? (e.enter("definitionMarker"), e.consume(h), e.exit("definitionMarker"), o) : n(h) } function o(h) { return ge(h) ? fu(e, l)(h) : l(h) } function l(h) { return EE(e, f, n, "definitionDestination", "definitionDestinationLiteral", "definitionDestinationLiteralMarker", "definitionDestinationRaw", "definitionDestinationString")(h) } function f(h) { return e.attempt(bA, d, d)(h) } function d(h) { return oe(h) ? fe(e, p, "whitespace")(h) : p(h) } function p(h) { return h === null || Z(h) ? (e.exit("definition"), r.parser.defined.push(i), t(h)) : n(h) } } function SA(e, t, n) { return r; function r(a) { return ge(a) ? fu(e, i)(a) : n(a) } function i(a) { return yE(e, u, n, "definitionTitle", "definitionTitleMarker", "definitionTitleString")(a) } function u(a) { return oe(a) ? fe(e, s, "whitespace")(a) : s(a) } function s(a) { return a === null || Z(a) ? t(a) : n(a) } } const _A = { name: "hardBreakEscape", tokenize: CA }; function CA(e, t, n) { return r; function r(u) { return e.enter("hardBreakEscape"), e.consume(u), i } function i(u) { return Z(u) ? (e.exit("hardBreakEscape"), t(u)) : n(u) } } const AA = { name: "headingAtx", resolve: kA, tokenize: NA }; function kA(e, t) { let n = e.length - 2, r = 3, i, u; return e[r][1].type === "whitespace" && (r += 2), n - 2 > r && e[n][1].type === "whitespace" && (n -= 2), e[n][1].type === "atxHeadingSequence" && (r === n - 1 || n - 4 > r && e[n - 2][1].type === "whitespace") && (n -= r + 1 === n ? 2 : 4), n > r && (i = { type: "atxHeadingText", start: e[r][1].start, end: e[n][1].end }, u = { type: "chunkText", start: e[r][1].start, end: e[n][1].end, contentType: "text" }, bt(e, r, n - r + 1, [["enter", i, t], ["enter", u, t], ["exit", u, t], ["exit", i, t]])), e } function NA(e, t, n) { let r = 0; return i; function i(f) { return e.enter("atxHeading"), u(f) } function u(f) { return e.enter("atxHeadingSequence"), s(f) } function s(f) { return f === 35 && r++ < 6 ? (e.consume(f), s) : f === null || ge(f) ? (e.exit("atxHeadingSequence"), a(f)) : n(f) } function a(f) { return f === 35 ? (e.enter("atxHeadingSequence"), o(f)) : f === null || Z(f) ? (e.exit("atxHeading"), t(f)) : oe(f) ? fe(e, a, "whitespace")(f) : (e.enter("atxHeadingText"), l(f)) } function o(f) { return f === 35 ? (e.consume(f), o) : (e.exit("atxHeadingSequence"), a(f)) } function l(f) { return f === null || f === 35 || ge(f) ? (e.exit("atxHeadingText"), a(f)) : (e.consume(f), l) } } const IA = ["address", "article", "aside", "base", "basefont", "blockquote", "body", "caption", "center", "col", "colgroup", "dd", "details", "dialog", "dir", "div", "dl", "dt", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hr", "html", "iframe", "legend", "li", "link", "main", "menu", "menuitem", "nav", "noframes", "ol", "optgroup", "option", "p", "param", "search", "section", "summary", "table", "tbody", "td", "tfoot", "th", "thead", "title", "tr", "track", "ul"], $0 = ["pre", "script", "style", "textarea"], wA = { concrete: !0, name: "htmlFlow", resolveTo: LA, tokenize: RA }, vA = { partial: !0, tokenize: DA }, OA = { partial: !0, tokenize: PA }; function LA(e) { let t = e.length; for (; t-- && !(e[t][0] === "enter" && e[t][1].type === "htmlFlow");); return t > 1 && e[t - 2][1].type === "linePrefix" && (e[t][1].start = e[t - 2][1].start, e[t + 1][1].start = e[t - 2][1].start, e.splice(t - 2, 2)), e } function RA(e, t, n) { const r = this; let i, u, s, a, o; return l; function l(A) { return f(A) } function f(A) { return e.enter("htmlFlow"), e.enter("htmlFlowData"), e.consume(A), d } function d(A) { return A === 33 ? (e.consume(A), p) : A === 47 ? (e.consume(A), u = !0, T) : A === 63 ? (e.consume(A), i = 3, r.interrupt ? t : S) : et(A) ? (e.consume(A), s = String.fromCharCode(A), _) : n(A) } function p(A) { return A === 45 ? (e.consume(A), i = 2, h) : A === 91 ? (e.consume(A), i = 5, a = 0, m) : et(A) ? (e.consume(A), i = 4, r.interrupt ? t : S) : n(A) } function h(A) { return A === 45 ? (e.consume(A), r.interrupt ? t : S) : n(A) } function m(A) { const pe = "CDATA["; return A === pe.charCodeAt(a++) ? (e.consume(A), a === pe.length ? r.interrupt ? t : U : m) : n(A) } function T(A) { return et(A) ? (e.consume(A), s = String.fromCharCode(A), _) : n(A) } function _(A) { if (A === null || A === 47 || A === 62 || ge(A)) { const pe = A === 47, ze = s.toLowerCase(); return !pe && !u && $0.includes(ze) ? (i = 1, r.interrupt ? t(A) : U(A)) : IA.includes(s.toLowerCase()) ? (i = 6, pe ? (e.consume(A), g) : r.interrupt ? t(A) : U(A)) : (i = 7, r.interrupt && !r.parser.lazy[r.now().line] ? n(A) : u ? E(A) : y(A)) } return A === 45 || Qe(A) ? (e.consume(A), s += String.fromCharCode(A), _) : n(A) } function g(A) { return A === 62 ? (e.consume(A), r.interrupt ? t : U) : n(A) } function E(A) { return oe(A) ? (e.consume(A), E) : N(A) } function y(A) { return A === 47 ? (e.consume(A), N) : A === 58 || A === 95 || et(A) ? (e.consume(A), I) : oe(A) ? (e.consume(A), y) : N(A) } function I(A) { return A === 45 || A === 46 || A === 58 || A === 95 || Qe(A) ? (e.consume(A), I) : L(A) } function L(A) { return A === 61 ? (e.consume(A), k) : oe(A) ? (e.consume(A), L) : y(A) } function k(A) { return A === null || A === 60 || A === 61 || A === 62 || A === 96 ? n(A) : A === 34 || A === 39 ? (e.consume(A), o = A, P) : oe(A) ? (e.consume(A), k) : j(A) } function P(A) { return A === o ? (e.consume(A), o = null, W) : A === null || Z(A) ? n(A) : (e.consume(A), P) } function j(A) { return A === null || A === 34 || A === 39 || A === 47 || A === 60 || A === 61 || A === 62 || A === 96 || ge(A) ? L(A) : (e.consume(A), j) } function W(A) { return A === 47 || A === 62 || oe(A) ? y(A) : n(A) } function N(A) { return A === 62 ? (e.consume(A), Y) : n(A) } function Y(A) { return A === null || Z(A) ? U(A) : oe(A) ? (e.consume(A), Y) : n(A) } function U(A) { return A === 45 && i === 2 ? (e.consume(A), ee) : A === 60 && i === 1 ? (e.consume(A), ae) : A === 62 && i === 4 ? (e.consume(A), J) : A === 63 && i === 3 ? (e.consume(A), S) : A === 93 && i === 5 ? (e.consume(A), X) : Z(A) && (i === 6 || i === 7) ? (e.exit("htmlFlowData"), e.check(vA, ne, K)(A)) : A === null || Z(A) ? (e.exit("htmlFlowData"), K(A)) : (e.consume(A), U) } function K(A) { return e.check(OA, q, ne)(A) } function q(A) { return e.enter("lineEnding"), e.consume(A), e.exit("lineEnding"), G } function G(A) { return A === null || Z(A) ? K(A) : (e.enter("htmlFlowData"), U(A)) } function ee(A) { return A === 45 ? (e.consume(A), S) : U(A) } function ae(A) { return A === 47 ? (e.consume(A), s = "", H) : U(A) } function H(A) { if (A === 62) { const pe = s.toLowerCase(); return $0.includes(pe) ? (e.consume(A), J) : U(A) } return et(A) && s.length < 8 ? (e.consume(A), s += String.fromCharCode(A), H) : U(A) } function X(A) { return A === 93 ? (e.consume(A), S) : U(A) } function S(A) { return A === 62 ? (e.consume(A), J) : A === 45 && i === 2 ? (e.consume(A), S) : U(A) } function J(A) { return A === null || Z(A) ? (e.exit("htmlFlowData"), ne(A)) : (e.consume(A), J) } function ne(A) { return e.exit("htmlFlow"), t(A) } } function PA(e, t, n) { const r = this; return i; function i(s) { return Z(s) ? (e.enter("lineEnding"), e.consume(s), e.exit("lineEnding"), u) : n(s) } function u(s) { return r.parser.lazy[r.now().line] ? n(s) : t(s) } } function DA(e, t, n) { return r; function r(i) { return e.enter("lineEnding"), e.consume(i), e.exit("lineEnding"), e.attempt(es, t, n) } } const MA = { name: "htmlText", tokenize: FA }; function FA(e, t, n) { const r = this; let i, u, s; return a; function a(S) { return e.enter("htmlText"), e.enter("htmlTextData"), e.consume(S), o } function o(S) { return S === 33 ? (e.consume(S), l) : S === 47 ? (e.consume(S), L) : S === 63 ? (e.consume(S), y) : et(S) ? (e.consume(S), j) : n(S) } function l(S) { return S === 45 ? (e.consume(S), f) : S === 91 ? (e.consume(S), u = 0, m) : et(S) ? (e.consume(S), E) : n(S) } function f(S) { return S === 45 ? (e.consume(S), h) : n(S) } function d(S) { return S === null ? n(S) : S === 45 ? (e.consume(S), p) : Z(S) ? (s = d, ae(S)) : (e.consume(S), d) } function p(S) { return S === 45 ? (e.consume(S), h) : d(S) } function h(S) { return S === 62 ? ee(S) : S === 45 ? p(S) : d(S) } function m(S) { const J = "CDATA["; return S === J.charCodeAt(u++) ? (e.consume(S), u === J.length ? T : m) : n(S) } function T(S) { return S === null ? n(S) : S === 93 ? (e.consume(S), _) : Z(S) ? (s = T, ae(S)) : (e.consume(S), T) } function _(S) { return S === 93 ? (e.consume(S), g) : T(S) } function g(S) { return S === 62 ? ee(S) : S === 93 ? (e.consume(S), g) : T(S) } function E(S) { return S === null || S === 62 ? ee(S) : Z(S) ? (s = E, ae(S)) : (e.consume(S), E) } function y(S) { return S === null ? n(S) : S === 63 ? (e.consume(S), I) : Z(S) ? (s = y, ae(S)) : (e.consume(S), y) } function I(S) { return S === 62 ? ee(S) : y(S) } function L(S) { return et(S) ? (e.consume(S), k) : n(S) } function k(S) { return S === 45 || Qe(S) ? (e.consume(S), k) : P(S) } function P(S) { return Z(S) ? (s = P, ae(S)) : oe(S) ? (e.consume(S), P) : ee(S) } function j(S) { return S === 45 || Qe(S) ? (e.consume(S), j) : S === 47 || S === 62 || ge(S) ? W(S) : n(S) } function W(S) { return S === 47 ? (e.consume(S), ee) : S === 58 || S === 95 || et(S) ? (e.consume(S), N) : Z(S) ? (s = W, ae(S)) : oe(S) ? (e.consume(S), W) : ee(S) } function N(S) { return S === 45 || S === 46 || S === 58 || S === 95 || Qe(S) ? (e.consume(S), N) : Y(S) } function Y(S) { return S === 61 ? (e.consume(S), U) : Z(S) ? (s = Y, ae(S)) : oe(S) ? (e.consume(S), Y) : W(S) } function U(S) { return S === null || S === 60 || S === 61 || S === 62 || S === 96 ? n(S) : S === 34 || S === 39 ? (e.consume(S), i = S, K) : Z(S) ? (s = U, ae(S)) : oe(S) ? (e.consume(S), U) : (e.consume(S), q) } function K(S) { return S === i ? (e.consume(S), i = void 0, G) : S === null ? n(S) : Z(S) ? (s = K, ae(S)) : (e.consume(S), K) } function q(S) { return S === null || S === 34 || S === 39 || S === 60 || S === 61 || S === 96 ? n(S) : S === 47 || S === 62 || ge(S) ? W(S) : (e.consume(S), q) } function G(S) { return S === 47 || S === 62 || ge(S) ? W(S) : n(S) } function ee(S) { return S === 62 ? (e.consume(S), e.exit("htmlTextData"), e.exit("htmlText"), t) : n(S) } function ae(S) { return e.exit("htmlTextData"), e.enter("lineEnding"), e.consume(S), e.exit("lineEnding"), H } function H(S) { return oe(S) ? fe(e, X, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(S) : X(S) } function X(S) { return e.enter("htmlTextData"), s(S) } } const nd = { name: "labelEnd", resolveAll: zA, resolveTo: jA, tokenize: $A }, BA = { tokenize: VA }, UA = { tokenize: YA }, HA = { tokenize: WA }; function zA(e) { let t = -1; const n = []; for (; ++t < e.length;) { const r = e[t][1]; if (n.push(e[t]), r.type === "labelImage" || r.type === "labelLink" || r.type === "labelEnd") { const i = r.type === "labelImage" ? 4 : 2; r.type = "data", t += i } } return e.length !== n.length && bt(e, 0, e.length, n), e } function jA(e, t) { let n = e.length, r = 0, i, u, s, a; for (; n--;)if (i = e[n][1], u) { if (i.type === "link" || i.type === "labelLink" && i._inactive) break; e[n][0] === "enter" && i.type === "labelLink" && (i._inactive = !0) } else if (s) { if (e[n][0] === "enter" && (i.type === "labelImage" || i.type === "labelLink") && !i._balanced && (u = n, i.type !== "labelLink")) { r = 2; break } } else i.type === "labelEnd" && (s = n); const o = { type: e[u][1].type === "labelLink" ? "link" : "image", start: { ...e[u][1].start }, end: { ...e[e.length - 1][1].end } }, l = { type: "label", start: { ...e[u][1].start }, end: { ...e[s][1].end } }, f = { type: "labelText", start: { ...e[u + r + 2][1].end }, end: { ...e[s - 2][1].start } }; return a = [["enter", o, t], ["enter", l, t]], a = Nt(a, e.slice(u + 1, u + r + 3)), a = Nt(a, [["enter", f, t]]), a = Nt(a, ao(t.parser.constructs.insideSpan.null, e.slice(u + r + 4, s - 3), t)), a = Nt(a, [["exit", f, t], e[s - 2], e[s - 1], ["exit", l, t]]), a = Nt(a, e.slice(s + 1)), a = Nt(a, [["exit", o, t]]), bt(e, u, e.length, a), e } function $A(e, t, n) { const r = this; let i = r.events.length, u, s; for (; i--;)if ((r.events[i][1].type === "labelImage" || r.events[i][1].type === "labelLink") && !r.events[i][1]._balanced) { u = r.events[i][1]; break } return a; function a(p) { return u ? u._inactive ? d(p) : (s = r.parser.defined.includes(jt(r.sliceSerialize({ start: u.end, end: r.now() }))), e.enter("labelEnd"), e.enter("labelMarker"), e.consume(p), e.exit("labelMarker"), e.exit("labelEnd"), o) : n(p) } function o(p) { return p === 40 ? e.attempt(BA, f, s ? f : d)(p) : p === 91 ? e.attempt(UA, f, s ? l : d)(p) : s ? f(p) : d(p) } function l(p) { return e.attempt(HA, f, d)(p) } function f(p) { return t(p) } function d(p) { return u._balanced = !0, n(p) } } function VA(e, t, n) { return r; function r(d) { return e.enter("resource"), e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), i } function i(d) { return ge(d) ? fu(e, u)(d) : u(d) } function u(d) { return d === 41 ? f(d) : EE(e, s, a, "resourceDestination", "resourceDestinationLiteral", "resourceDestinationLiteralMarker", "resourceDestinationRaw", "resourceDestinationString", 32)(d) } function s(d) { return ge(d) ? fu(e, o)(d) : f(d) } function a(d) { return n(d) } function o(d) { return d === 34 || d === 39 || d === 40 ? yE(e, l, n, "resourceTitle", "resourceTitleMarker", "resourceTitleString")(d) : f(d) } function l(d) { return ge(d) ? fu(e, f)(d) : f(d) } function f(d) { return d === 41 ? (e.enter("resourceMarker"), e.consume(d), e.exit("resourceMarker"), e.exit("resource"), t) : n(d) } } function YA(e, t, n) { const r = this; return i; function i(a) { return TE.call(r, e, u, s, "reference", "referenceMarker", "referenceString")(a) } function u(a) { return r.parser.defined.includes(jt(r.sliceSerialize(r.events[r.events.length - 1][1]).slice(1, -1))) ? t(a) : n(a) } function s(a) { return n(a) } } function WA(e, t, n) { return r; function r(u) { return e.enter("reference"), e.enter("referenceMarker"), e.consume(u), e.exit("referenceMarker"), i } function i(u) { return u === 93 ? (e.enter("referenceMarker"), e.consume(u), e.exit("referenceMarker"), e.exit("reference"), t) : n(u) } } const KA = { name: "labelStartImage", resolveAll: nd.resolveAll, tokenize: qA }; function qA(e, t, n) { const r = this; return i; function i(a) { return e.enter("labelImage"), e.enter("labelImageMarker"), e.consume(a), e.exit("labelImageMarker"), u } function u(a) { return a === 91 ? (e.enter("labelMarker"), e.consume(a), e.exit("labelMarker"), e.exit("labelImage"), s) : n(a) } function s(a) { return a === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(a) : t(a) } } const QA = { name: "labelStartLink", resolveAll: nd.resolveAll, tokenize: GA }; function GA(e, t, n) { const r = this; return i; function i(s) { return e.enter("labelLink"), e.enter("labelMarker"), e.consume(s), e.exit("labelMarker"), e.exit("labelLink"), u } function u(s) { return s === 94 && "_hiddenFootnoteSupport" in r.parser.constructs ? n(s) : t(s) } } const nl = { name: "lineEnding", tokenize: XA }; function XA(e, t) { return n; function n(r) { return e.enter("lineEnding"), e.consume(r), e.exit("lineEnding"), fe(e, t, "linePrefix") } } const Ks = { name: "thematicBreak", tokenize: JA }; function JA(e, t, n) { let r = 0, i; return u; function u(l) { return e.enter("thematicBreak"), s(l) } function s(l) { return i = l, a(l) } function a(l) { return l === i ? (e.enter("thematicBreakSequence"), o(l)) : r >= 3 && (l === null || Z(l)) ? (e.exit("thematicBreak"), t(l)) : n(l) } function o(l) { return l === i ? (e.consume(l), r++, o) : (e.exit("thematicBreakSequence"), oe(l) ? fe(e, a, "whitespace")(l) : a(l)) } } const st = { continuation: { tokenize: nk }, exit: ik, name: "list", tokenize: tk }, ZA = { partial: !0, tokenize: uk }, ek = { partial: !0, tokenize: rk }; function tk(e, t, n) { const r = this, i = r.events[r.events.length - 1]; let u = i && i[1].type === "linePrefix" ? i[2].sliceSerialize(i[1], !0).length : 0, s = 0; return a; function a(h) { const m = r.containerState.type || (h === 42 || h === 43 || h === 45 ? "listUnordered" : "listOrdered"); if (m === "listUnordered" ? !r.containerState.marker || h === r.containerState.marker : Oc(h)) { if (r.containerState.type || (r.containerState.type = m, e.enter(m, { _container: !0 })), m === "listUnordered") return e.enter("listItemPrefix"), h === 42 || h === 45 ? e.check(Ks, n, l)(h) : l(h); if (!r.interrupt || h === 49) return e.enter("listItemPrefix"), e.enter("listItemValue"), o(h) } return n(h) } function o(h) { return Oc(h) && ++s < 10 ? (e.consume(h), o) : (!r.interrupt || s < 2) && (r.containerState.marker ? h === r.containerState.marker : h === 41 || h === 46) ? (e.exit("listItemValue"), l(h)) : n(h) } function l(h) { return e.enter("listItemMarker"), e.consume(h), e.exit("listItemMarker"), r.containerState.marker = r.containerState.marker || h, e.check(es, r.interrupt ? n : f, e.attempt(ZA, p, d)) } function f(h) { return r.containerState.initialBlankLine = !0, u++, p(h) } function d(h) { return oe(h) ? (e.enter("listItemPrefixWhitespace"), e.consume(h), e.exit("listItemPrefixWhitespace"), p) : n(h) } function p(h) { return r.containerState.size = u + r.sliceSerialize(e.exit("listItemPrefix"), !0).length, t(h) } } function nk(e, t, n) { const r = this; return r.containerState._closeFlow = void 0, e.check(es, i, u); function i(a) { return r.containerState.furtherBlankLines = r.containerState.furtherBlankLines || r.containerState.initialBlankLine, fe(e, t, "listItemIndent", r.containerState.size + 1)(a) } function u(a) { return r.containerState.furtherBlankLines || !oe(a) ? (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, s(a)) : (r.containerState.furtherBlankLines = void 0, r.containerState.initialBlankLine = void 0, e.attempt(ek, t, s)(a)) } function s(a) { return r.containerState._closeFlow = !0, r.interrupt = void 0, fe(e, e.attempt(st, t, n), "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(a) } } function rk(e, t, n) { const r = this; return fe(e, i, "listItemIndent", r.containerState.size + 1); function i(u) { const s = r.events[r.events.length - 1]; return s && s[1].type === "listItemIndent" && s[2].sliceSerialize(s[1], !0).length === r.containerState.size ? t(u) : n(u) } } function ik(e) { e.exit(this.containerState.type) } function uk(e, t, n) { const r = this; return fe(e, i, "listItemPrefixWhitespace", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 5); function i(u) { const s = r.events[r.events.length - 1]; return !oe(u) && s && s[1].type === "listItemPrefixWhitespace" ? t(u) : n(u) } } const V0 = { name: "setextUnderline", resolveTo: sk, tokenize: ak }; function sk(e, t) { let n = e.length, r, i, u; for (; n--;)if (e[n][0] === "enter") { if (e[n][1].type === "content") { r = n; break } e[n][1].type === "paragraph" && (i = n) } else e[n][1].type === "content" && e.splice(n, 1), !u && e[n][1].type === "definition" && (u = n); const s = { type: "setextHeading", start: { ...e[r][1].start }, end: { ...e[e.length - 1][1].end } }; return e[i][1].type = "setextHeadingText", u ? (e.splice(i, 0, ["enter", s, t]), e.splice(u + 1, 0, ["exit", e[r][1], t]), e[r][1].end = { ...e[u][1].end }) : e[r][1] = s, e.push(["exit", s, t]), e } function ak(e, t, n) { const r = this; let i; return u; function u(l) { let f = r.events.length, d; for (; f--;)if (r.events[f][1].type !== "lineEnding" && r.events[f][1].type !== "linePrefix" && r.events[f][1].type !== "content") { d = r.events[f][1].type === "paragraph"; break } return !r.parser.lazy[r.now().line] && (r.interrupt || d) ? (e.enter("setextHeadingLine"), i = l, s(l)) : n(l) } function s(l) { return e.enter("setextHeadingLineSequence"), a(l) } function a(l) { return l === i ? (e.consume(l), a) : (e.exit("setextHeadingLineSequence"), oe(l) ? fe(e, o, "lineSuffix")(l) : o(l)) } function o(l) { return l === null || Z(l) ? (e.exit("setextHeadingLine"), t(l)) : n(l) } } const ok = { tokenize: lk }; function lk(e) { const t = this, n = e.attempt(es, r, e.attempt(this.parser.constructs.flowInitial, i, fe(e, e.attempt(this.parser.constructs.flow, i, e.attempt(pA, i)), "linePrefix"))); return n; function r(u) { if (u === null) { e.consume(u); return } return e.enter("lineEndingBlank"), e.consume(u), e.exit("lineEndingBlank"), t.currentConstruct = void 0, n } function i(u) { if (u === null) { e.consume(u); return } return e.enter("lineEnding"), e.consume(u), e.exit("lineEnding"), t.currentConstruct = void 0, n } } const ck = { resolveAll: xE() }, fk = bE("string"), dk = bE("text"); function bE(e) { return { resolveAll: xE(e === "text" ? hk : void 0), tokenize: t }; function t(n) { const r = this, i = this.parser.constructs[e], u = n.attempt(i, s, a); return s; function s(f) { return l(f) ? u(f) : a(f) } function a(f) { if (f === null) { n.consume(f); return } return n.enter("data"), n.consume(f), o } function o(f) { return l(f) ? (n.exit("data"), u(f)) : (n.consume(f), o) } function l(f) { if (f === null) return !0; const d = i[f]; let p = -1; if (d) for (; ++p < d.length;) { const h = d[p]; if (!h.previous || h.previous.call(r, r.previous)) return !0 } return !1 } } } function xE(e) { return t; function t(n, r) { let i = -1, u; for (; ++i <= n.length;)u === void 0 ? n[i] && n[i][1].type === "data" && (u = i, i++) : (!n[i] || n[i][1].type !== "data") && (i !== u + 2 && (n[u][1].end = n[i - 1][1].end, n.splice(u + 2, i - u - 2), i = u + 2), u = void 0); return e ? e(n, r) : n } } function hk(e, t) { let n = 0; for (; ++n <= e.length;)if ((n === e.length || e[n][1].type === "lineEnding") && e[n - 1][1].type === "data") { const r = e[n - 1][1], i = t.sliceStream(r); let u = i.length, s = -1, a = 0, o; for (; u--;) { const l = i[u]; if (typeof l == "string") { for (s = l.length; l.charCodeAt(s - 1) === 32;)a++, s--; if (s) break; s = -1 } else if (l === -2) o = !0, a++; else if (l !== -1) { u++; break } } if (t._contentTypeTextTrailing && n === e.length && (a = 0), a) { const l = { type: n === e.length || o || a < 2 ? "lineSuffix" : "hardBreakTrailing", start: { _bufferIndex: u ? s : r.start._bufferIndex + s, _index: r.start._index + u, line: r.end.line, column: r.end.column - a, offset: r.end.offset - a }, end: { ...r.end } }; r.end = { ...l.start }, r.start.offset === r.end.offset ? Object.assign(r, l) : (e.splice(n, 0, ["enter", l, t], ["exit", l, t]), n += 2) } n++ } return e } const pk = { 42: st, 43: st, 45: st, 48: st, 49: st, 50: st, 51: st, 52: st, 53: st, 54: st, 55: st, 56: st, 57: st, 62: hE }, mk = { 91: yA }, gk = { [-2]: tl, [-1]: tl, 32: tl }, Ek = { 35: AA, 42: Ks, 45: [V0, Ks], 60: wA, 61: V0, 95: Ks, 96: j0, 126: j0 }, Tk = { 38: mE, 92: pE }, yk = { [-5]: nl, [-4]: nl, [-3]: nl, 33: KA, 38: mE, 42: Lc, 60: [Q3, MA], 91: QA, 92: [_A, pE], 93: nd, 95: Lc, 96: oA }, bk = { null: [Lc, ck] }, xk = { null: [42, 95] }, Sk = { null: [] }, _k = Object.freeze(Object.defineProperty({ __proto__: null, attentionMarkers: xk, contentInitial: mk, disable: Sk, document: pk, flow: Ek, flowInitial: gk, insideSpan: bk, string: Tk, text: yk }, Symbol.toStringTag, { value: "Module" })); function Ck(e, t, n) { let r = { _bufferIndex: -1, _index: 0, line: n && n.line || 1, column: n && n.column || 1, offset: n && n.offset || 0 }; const i = {}, u = []; let s = [], a = []; const o = { attempt: P(L), check: P(k), consume: E, enter: y, exit: I, interrupt: P(k, { interrupt: !0 }) }, l = { code: null, containerState: {}, defineSkip: T, events: [], now: m, parser: e, previous: null, sliceSerialize: p, sliceStream: h, write: d }; let f = t.tokenize.call(l, o); return t.resolveAll && u.push(t), l; function d(Y) { return s = Nt(s, Y), _(), s[s.length - 1] !== null ? [] : (j(t, 0), l.events = ao(u, l.events, l), l.events) } function p(Y, U) { return kk(h(Y), U) } function h(Y) { return Ak(s, Y) } function m() { const { _bufferIndex: Y, _index: U, line: K, column: q, offset: G } = r; return { _bufferIndex: Y, _index: U, line: K, column: q, offset: G } } function T(Y) { i[Y.line] = Y.column, N() } function _() { let Y; for (; r._index < s.length;) { const U = s[r._index]; if (typeof U == "string") for (Y = r._index, r._bufferIndex < 0 && (r._bufferIndex = 0); r._index === Y && r._bufferIndex < U.length;)g(U.charCodeAt(r._bufferIndex)); else g(U) } } function g(Y) { f = f(Y) } function E(Y) { Z(Y) ? (r.line++, r.column = 1, r.offset += Y === -3 ? 2 : 1, N()) : Y !== -1 && (r.column++, r.offset++), r._bufferIndex < 0 ? r._index++ : (r._bufferIndex++, r._bufferIndex === s[r._index].length && (r._bufferIndex = -1, r._index++)), l.previous = Y } function y(Y, U) { const K = U || {}; return K.type = Y, K.start = m(), l.events.push(["enter", K, l]), a.push(K), K } function I(Y) { const U = a.pop(); return U.end = m(), l.events.push(["exit", U, l]), U } function L(Y, U) { j(Y, U.from) } function k(Y, U) { U.restore() } function P(Y, U) { return K; function K(q, G, ee) { let ae, H, X, S; return Array.isArray(q) ? ne(q) : "tokenize" in q ? ne([q]) : J(q); function J(ye) { return Wt; function Wt(xn) { const Nr = xn !== null && ye[xn], Ir = xn !== null && ye.null, is = [...Array.isArray(Nr) ? Nr : Nr ? [Nr] : [], ...Array.isArray(Ir) ? Ir : Ir ? [Ir] : []]; return ne(is)(xn) } } function ne(ye) { return ae = ye, H = 0, ye.length === 0 ? ee : A(ye[H]) } function A(ye) { return Wt; function Wt(xn) { return S = W(), X = ye, ye.partial || (l.currentConstruct = ye), ye.name && l.parser.constructs.disable.null.includes(ye.name) ? ze() : ye.tokenize.call(U ? Object.assign(Object.create(l), U) : l, o, pe, ze)(xn) } } function pe(ye) { return Y(X, S), G } function ze(ye) { return S.restore(), ++H < ae.length ? A(ae[H]) : ee } } } function j(Y, U) { Y.resolveAll && !u.includes(Y) && u.push(Y), Y.resolve && bt(l.events, U, l.events.length - U, Y.resolve(l.events.slice(U), l)), Y.resolveTo && (l.events = Y.resolveTo(l.events, l)) } function W() { const Y = m(), U = l.previous, K = l.currentConstruct, q = l.events.length, G = Array.from(a); return { from: q, restore: ee }; function ee() { r = Y, l.previous = U, l.currentConstruct = K, l.events.length = q, a = G, N() } } function N() { r.line in i && r.column < 2 && (r.column = i[r.line], r.offset += i[r.line] - 1) } } function Ak(e, t) { const n = t.start._index, r = t.start._bufferIndex, i = t.end._index, u = t.end._bufferIndex; let s; if (n === i) s = [e[n].slice(r, u)]; else { if (s = e.slice(n, i), r > -1) { const a = s[0]; typeof a == "string" ? s[0] = a.slice(r) : s.shift() } u > 0 && s.push(e[i].slice(0, u)) } return s } function kk(e, t) {
        let n = -1; const r = []; let i; for (; ++n < e.length;) {
          const u = e[n]; let s; if (typeof u == "string") s = u; else switch (u) {
            case -5: { s = "\r"; break } case -4: {
              s = `
`; break
            } case -3: {
              s = `\r
`; break
            } case -2: { s = t ? " " : "	"; break } case -1: { if (!t && i) continue; s = " "; break } default: s = String.fromCharCode(u)
          }i = u === -2, r.push(s)
        } return r.join("")
      } function Nk(e) { const r = { constructs: fE([_k, ...(e || {}).extensions || []]), content: i(j3), defined: [], document: i(V3), flow: i(ok), lazy: {}, string: i(fk), text: i(dk) }; return r; function i(u) { return s; function s(a) { return Ck(r, u, a) } } } function Ik(e) { for (; !gE(e);); return e } const Y0 = /[\0\t\n\r]/g; function wk() { let e = 1, t = "", n = !0, r; return i; function i(u, s, a) { const o = []; let l, f, d, p, h; for (u = t + (typeof u == "string" ? u.toString() : new TextDecoder(s || void 0).decode(u)), d = 0, t = "", n && (u.charCodeAt(0) === 65279 && d++, n = void 0); d < u.length;) { if (Y0.lastIndex = d, l = Y0.exec(u), p = l && l.index !== void 0 ? l.index : u.length, h = u.charCodeAt(p), !l) { t = u.slice(d); break } if (h === 10 && d === p && r) o.push(-3), r = void 0; else switch (r && (o.push(-5), r = void 0), d < p && (o.push(u.slice(d, p)), e += p - d), h) { case 0: { o.push(65533), e++; break } case 9: { for (f = Math.ceil(e / 4) * 4, o.push(-2); e++ < f;)o.push(-1); break } case 10: { o.push(-4), e = 1; break } default: r = !0, e = 1 }d = p + 1 } return a && (r && o.push(-5), t && o.push(t), o.push(null)), o } } const vk = /\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi; function Ok(e) { return e.replace(vk, Lk) } function Lk(e, t, n) { if (t) return t; if (n.charCodeAt(0) === 35) { const i = n.charCodeAt(1), u = i === 120 || i === 88; return dE(n.slice(u ? 2 : 1), u ? 16 : 10) } return td(n) || e } const SE = {}.hasOwnProperty; function Rk(e, t, n) { return typeof t != "string" && (n = t, t = void 0), Pk(n)(Ik(Nk(n).document().write(wk()(e, t, !0)))) } function Pk(e) { const t = { transforms: [], canContainEols: ["emphasis", "fragment", "heading", "paragraph", "strong"], enter: { autolink: u(bd), autolinkProtocol: W, autolinkEmail: W, atxHeading: u(Ed), blockQuote: u(Ir), characterEscape: W, characterReference: W, codeFenced: u(is), codeFencedFenceInfo: s, codeFencedFenceMeta: s, codeIndented: u(is, s), codeText: u(BT, s), codeTextData: W, data: W, codeFlowValue: W, definition: u(UT), definitionDestinationString: s, definitionLabelString: s, definitionTitleString: s, emphasis: u(HT), hardBreakEscape: u(Td), hardBreakTrailing: u(Td), htmlFlow: u(yd, s), htmlFlowData: W, htmlText: u(yd, s), htmlTextData: W, image: u(zT), label: s, link: u(bd), listItem: u(jT), listItemValue: p, listOrdered: u(xd, d), listUnordered: u(xd), paragraph: u($T), reference: A, referenceString: s, resourceDestinationString: s, resourceTitleString: s, setextHeading: u(Ed), strong: u(VT), thematicBreak: u(WT) }, exit: { atxHeading: o(), atxHeadingSequence: L, autolink: o(), autolinkEmail: Nr, autolinkProtocol: xn, blockQuote: o(), characterEscapeValue: N, characterReferenceMarkerHexadecimal: ze, characterReferenceMarkerNumeric: ze, characterReferenceValue: ye, characterReference: Wt, codeFenced: o(_), codeFencedFence: T, codeFencedFenceInfo: h, codeFencedFenceMeta: m, codeFlowValue: N, codeIndented: o(g), codeText: o(G), codeTextData: N, data: N, definition: o(), definitionDestinationString: I, definitionLabelString: E, definitionTitleString: y, emphasis: o(), hardBreakEscape: o(U), hardBreakTrailing: o(U), htmlFlow: o(K), htmlFlowData: N, htmlText: o(q), htmlTextData: N, image: o(ae), label: X, labelText: H, lineEnding: Y, link: o(ee), listItem: o(), listOrdered: o(), listUnordered: o(), paragraph: o(), referenceString: pe, resourceDestinationString: S, resourceTitleString: J, resource: ne, setextHeading: o(j), setextHeadingLineSequence: P, setextHeadingText: k, strong: o(), thematicBreak: o() } }; _E(t, (e || {}).mdastExtensions || []); const n = {}; return r; function r(D) { let V = { type: "root", children: [] }; const re = { stack: [V], tokenStack: [], config: t, enter: a, exit: l, buffer: s, resume: f, data: n }, ce = []; let me = -1; for (; ++me < D.length;)if (D[me][1].type === "listOrdered" || D[me][1].type === "listUnordered") if (D[me][0] === "enter") ce.push(me); else { const Rt = ce.pop(); me = i(D, Rt, me) } for (me = -1; ++me < D.length;) { const Rt = t[D[me][0]]; SE.call(Rt, D[me][1].type) && Rt[D[me][1].type].call(Object.assign({ sliceSerialize: D[me][2].sliceSerialize }, re), D[me][1]) } if (re.tokenStack.length > 0) { const Rt = re.tokenStack[re.tokenStack.length - 1]; (Rt[1] || W0).call(re, void 0, Rt[0]) } for (V.position = { start: _n(D.length > 0 ? D[0][1].start : { line: 1, column: 1, offset: 0 }), end: _n(D.length > 0 ? D[D.length - 2][1].end : { line: 1, column: 1, offset: 0 }) }, me = -1; ++me < t.transforms.length;)V = t.transforms[me](V) || V; return V } function i(D, V, re) { let ce = V - 1, me = -1, Rt = !1, Xn, un, Ni, Ii; for (; ++ce <= re;) { const mt = D[ce]; switch (mt[1].type) { case "listUnordered": case "listOrdered": case "blockQuote": { mt[0] === "enter" ? me++ : me--, Ii = void 0; break } case "lineEndingBlank": { mt[0] === "enter" && (Xn && !Ii && !me && !Ni && (Ni = ce), Ii = void 0); break } case "linePrefix": case "listItemValue": case "listItemMarker": case "listItemPrefix": case "listItemPrefixWhitespace": break; default: Ii = void 0 }if (!me && mt[0] === "enter" && mt[1].type === "listItemPrefix" || me === -1 && mt[0] === "exit" && (mt[1].type === "listUnordered" || mt[1].type === "listOrdered")) { if (Xn) { let wr = ce; for (un = void 0; wr--;) { const sn = D[wr]; if (sn[1].type === "lineEnding" || sn[1].type === "lineEndingBlank") { if (sn[0] === "exit") continue; un && (D[un][1].type = "lineEndingBlank", Rt = !0), sn[1].type = "lineEnding", un = wr } else if (!(sn[1].type === "linePrefix" || sn[1].type === "blockQuotePrefix" || sn[1].type === "blockQuotePrefixWhitespace" || sn[1].type === "blockQuoteMarker" || sn[1].type === "listItemIndent")) break } Ni && (!un || Ni < un) && (Xn._spread = !0), Xn.end = Object.assign({}, un ? D[un][1].start : mt[1].end), D.splice(un || ce, 0, ["exit", Xn, mt[2]]), ce++, re++ } if (mt[1].type === "listItemPrefix") { const wr = { type: "listItem", _spread: !1, start: Object.assign({}, mt[1].start), end: void 0 }; Xn = wr, D.splice(ce, 0, ["enter", wr, mt[2]]), ce++, re++, Ni = void 0, Ii = !0 } } } return D[V][1]._spread = Rt, re } function u(D, V) { return re; function re(ce) { a.call(this, D(ce), ce), V && V.call(this, ce) } } function s() { this.stack.push({ type: "fragment", children: [] }) } function a(D, V, re) { this.stack[this.stack.length - 1].children.push(D), this.stack.push(D), this.tokenStack.push([V, re || void 0]), D.position = { start: _n(V.start), end: void 0 } } function o(D) { return V; function V(re) { D && D.call(this, re), l.call(this, re) } } function l(D, V) { const re = this.stack.pop(), ce = this.tokenStack.pop(); if (ce) ce[0].type !== D.type && (V ? V.call(this, D, ce[0]) : (ce[1] || W0).call(this, D, ce[0])); else throw new Error("Cannot close `" + D.type + "` (" + cu({ start: D.start, end: D.end }) + "): its not open"); re.position.end = _n(D.end) } function f() { return ed(this.stack.pop()) } function d() { this.data.expectingFirstListItemValue = !0 } function p(D) { if (this.data.expectingFirstListItemValue) { const V = this.stack[this.stack.length - 2]; V.start = Number.parseInt(this.sliceSerialize(D), 10), this.data.expectingFirstListItemValue = void 0 } } function h() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.lang = D } function m() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.meta = D } function T() { this.data.flowCodeInside || (this.buffer(), this.data.flowCodeInside = !0) } function _() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.value = D.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, ""), this.data.flowCodeInside = void 0 } function g() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.value = D.replace(/(\r?\n|\r)$/g, "") } function E(D) { const V = this.resume(), re = this.stack[this.stack.length - 1]; re.label = V, re.identifier = jt(this.sliceSerialize(D)).toLowerCase() } function y() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.title = D } function I() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.url = D } function L(D) { const V = this.stack[this.stack.length - 1]; if (!V.depth) { const re = this.sliceSerialize(D).length; V.depth = re } } function k() { this.data.setextHeadingSlurpLineEnding = !0 } function P(D) { const V = this.stack[this.stack.length - 1]; V.depth = this.sliceSerialize(D).codePointAt(0) === 61 ? 1 : 2 } function j() { this.data.setextHeadingSlurpLineEnding = void 0 } function W(D) { const re = this.stack[this.stack.length - 1].children; let ce = re[re.length - 1]; (!ce || ce.type !== "text") && (ce = YT(), ce.position = { start: _n(D.start), end: void 0 }, re.push(ce)), this.stack.push(ce) } function N(D) { const V = this.stack.pop(); V.value += this.sliceSerialize(D), V.position.end = _n(D.end) } function Y(D) { const V = this.stack[this.stack.length - 1]; if (this.data.atHardBreak) { const re = V.children[V.children.length - 1]; re.position.end = _n(D.end), this.data.atHardBreak = void 0; return } !this.data.setextHeadingSlurpLineEnding && t.canContainEols.includes(V.type) && (W.call(this, D), N.call(this, D)) } function U() { this.data.atHardBreak = !0 } function K() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.value = D } function q() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.value = D } function G() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.value = D } function ee() { const D = this.stack[this.stack.length - 1]; if (this.data.inReference) { const V = this.data.referenceType || "shortcut"; D.type += "Reference", D.referenceType = V, delete D.url, delete D.title } else delete D.identifier, delete D.label; this.data.referenceType = void 0 } function ae() { const D = this.stack[this.stack.length - 1]; if (this.data.inReference) { const V = this.data.referenceType || "shortcut"; D.type += "Reference", D.referenceType = V, delete D.url, delete D.title } else delete D.identifier, delete D.label; this.data.referenceType = void 0 } function H(D) { const V = this.sliceSerialize(D), re = this.stack[this.stack.length - 2]; re.label = Ok(V), re.identifier = jt(V).toLowerCase() } function X() { const D = this.stack[this.stack.length - 1], V = this.resume(), re = this.stack[this.stack.length - 1]; if (this.data.inReference = !0, re.type === "link") { const ce = D.children; re.children = ce } else re.alt = V } function S() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.url = D } function J() { const D = this.resume(), V = this.stack[this.stack.length - 1]; V.title = D } function ne() { this.data.inReference = void 0 } function A() { this.data.referenceType = "collapsed" } function pe(D) { const V = this.resume(), re = this.stack[this.stack.length - 1]; re.label = V, re.identifier = jt(this.sliceSerialize(D)).toLowerCase(), this.data.referenceType = "full" } function ze(D) { this.data.characterReferenceType = D.type } function ye(D) { const V = this.sliceSerialize(D), re = this.data.characterReferenceType; let ce; re ? (ce = dE(V, re === "characterReferenceMarkerNumeric" ? 10 : 16), this.data.characterReferenceType = void 0) : ce = td(V); const me = this.stack[this.stack.length - 1]; me.value += ce } function Wt(D) { const V = this.stack.pop(); V.position.end = _n(D.end) } function xn(D) { N.call(this, D); const V = this.stack[this.stack.length - 1]; V.url = this.sliceSerialize(D) } function Nr(D) { N.call(this, D); const V = this.stack[this.stack.length - 1]; V.url = "mailto:" + this.sliceSerialize(D) } function Ir() { return { type: "blockquote", children: [] } } function is() { return { type: "code", lang: null, meta: null, value: "" } } function BT() { return { type: "inlineCode", value: "" } } function UT() { return { type: "definition", identifier: "", label: null, title: null, url: "" } } function HT() { return { type: "emphasis", children: [] } } function Ed() { return { type: "heading", depth: 0, children: [] } } function Td() { return { type: "break" } } function yd() { return { type: "html", value: "" } } function zT() { return { type: "image", title: null, url: "", alt: null } } function bd() { return { type: "link", title: null, url: "", children: [] } } function xd(D) { return { type: "list", ordered: D.type === "listOrdered", start: null, spread: D._spread, children: [] } } function jT(D) { return { type: "listItem", spread: D._spread, checked: null, children: [] } } function $T() { return { type: "paragraph", children: [] } } function VT() { return { type: "strong", children: [] } } function YT() { return { type: "text", value: "" } } function WT() { return { type: "thematicBreak" } } } function _n(e) { return { line: e.line, column: e.column, offset: e.offset } } function _E(e, t) { let n = -1; for (; ++n < t.length;) { const r = t[n]; Array.isArray(r) ? _E(e, r) : Dk(e, r) } } function Dk(e, t) { let n; for (n in t) if (SE.call(t, n)) switch (n) { case "canContainEols": { const r = t[n]; r && e[n].push(...r); break } case "transforms": { const r = t[n]; r && e[n].push(...r); break } case "enter": case "exit": { const r = t[n]; r && Object.assign(e[n], r); break } } } function W0(e, t) { throw e ? new Error("Cannot close `" + e.type + "` (" + cu({ start: e.start, end: e.end }) + "): a different token (`" + t.type + "`, " + cu({ start: t.start, end: t.end }) + ") is open") : new Error("Cannot close document, a token (`" + t.type + "`, " + cu({ start: t.start, end: t.end }) + ") is still open") } function Mk(e) { const t = this; t.parser = n; function n(r) { return Rk(r, { ...t.data("settings"), ...e, extensions: t.data("micromarkExtensions") || [], mdastExtensions: t.data("fromMarkdownExtensions") || [] }) } } function Fk(e, t) { const n = { type: "element", tagName: "blockquote", properties: {}, children: e.wrap(e.all(t), !0) }; return e.patch(t, n), e.applyData(t, n) } function Bk(e, t) {
        const n = { type: "element", tagName: "br", properties: {}, children: [] }; return e.patch(t, n), [e.applyData(t, n), {
          type: "text", value: `
`}]
      } function Uk(e, t) {
        const n = t.value ? t.value + `
`: "", r = {}, i = t.lang ? t.lang.split(/\s+/) : []; i.length > 0 && (r.className = ["language-" + i[0]]); let u = { type: "element", tagName: "code", properties: r, children: [{ type: "text", value: n }] }; return t.meta && (u.data = { meta: t.meta }), e.patch(t, u), u = e.applyData(t, u), u = { type: "element", tagName: "pre", properties: {}, children: [u] }, e.patch(t, u), u
      } function Hk(e, t) { const n = { type: "element", tagName: "del", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function zk(e, t) { const n = { type: "element", tagName: "em", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function jk(e, t) { const n = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", r = String(t.identifier).toUpperCase(), i = _i(r.toLowerCase()), u = e.footnoteOrder.indexOf(r); let s, a = e.footnoteCounts.get(r); a === void 0 ? (a = 0, e.footnoteOrder.push(r), s = e.footnoteOrder.length) : s = u + 1, a += 1, e.footnoteCounts.set(r, a); const o = { type: "element", tagName: "a", properties: { href: "#" + n + "fn-" + i, id: n + "fnref-" + i + (a > 1 ? "-" + a : ""), dataFootnoteRef: !0, ariaDescribedBy: ["footnote-label"] }, children: [{ type: "text", value: String(s) }] }; e.patch(t, o); const l = { type: "element", tagName: "sup", properties: {}, children: [o] }; return e.patch(t, l), e.applyData(t, l) } function $k(e, t) { const n = { type: "element", tagName: "h" + t.depth, properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function Vk(e, t) { if (e.options.allowDangerousHtml) { const n = { type: "raw", value: t.value }; return e.patch(t, n), e.applyData(t, n) } } function CE(e, t) { const n = t.referenceType; let r = "]"; if (n === "collapsed" ? r += "[]" : n === "full" && (r += "[" + (t.label || t.identifier) + "]"), t.type === "imageReference") return [{ type: "text", value: "![" + t.alt + r }]; const i = e.all(t), u = i[0]; u && u.type === "text" ? u.value = "[" + u.value : i.unshift({ type: "text", value: "[" }); const s = i[i.length - 1]; return s && s.type === "text" ? s.value += r : i.push({ type: "text", value: r }), i } function Yk(e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return CE(e, t); const i = { src: _i(r.url || ""), alt: t.alt }; r.title !== null && r.title !== void 0 && (i.title = r.title); const u = { type: "element", tagName: "img", properties: i, children: [] }; return e.patch(t, u), e.applyData(t, u) } function Wk(e, t) { const n = { src: _i(t.url) }; t.alt !== null && t.alt !== void 0 && (n.alt = t.alt), t.title !== null && t.title !== void 0 && (n.title = t.title); const r = { type: "element", tagName: "img", properties: n, children: [] }; return e.patch(t, r), e.applyData(t, r) } function Kk(e, t) { const n = { type: "text", value: t.value.replace(/\r?\n|\r/g, " ") }; e.patch(t, n); const r = { type: "element", tagName: "code", properties: {}, children: [n] }; return e.patch(t, r), e.applyData(t, r) } function qk(e, t) { const n = String(t.identifier).toUpperCase(), r = e.definitionById.get(n); if (!r) return CE(e, t); const i = { href: _i(r.url || "") }; r.title !== null && r.title !== void 0 && (i.title = r.title); const u = { type: "element", tagName: "a", properties: i, children: e.all(t) }; return e.patch(t, u), e.applyData(t, u) } function Qk(e, t) { const n = { href: _i(t.url) }; t.title !== null && t.title !== void 0 && (n.title = t.title); const r = { type: "element", tagName: "a", properties: n, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) } function Gk(e, t, n) {
        const r = e.all(t), i = n ? Xk(n) : AE(t), u = {}, s = []; if (typeof t.checked == "boolean") { const f = r[0]; let d; f && f.type === "element" && f.tagName === "p" ? d = f : (d = { type: "element", tagName: "p", properties: {}, children: [] }, r.unshift(d)), d.children.length > 0 && d.children.unshift({ type: "text", value: " " }), d.children.unshift({ type: "element", tagName: "input", properties: { type: "checkbox", checked: t.checked, disabled: !0 }, children: [] }), u.className = ["task-list-item"] } let a = -1; for (; ++a < r.length;) {
          const f = r[a]; (i || a !== 0 || f.type !== "element" || f.tagName !== "p") && s.push({
            type: "text", value: `
`}), f.type === "element" && f.tagName === "p" && !i ? s.push(...f.children) : s.push(f)
        } const o = r[r.length - 1]; o && (i || o.type !== "element" || o.tagName !== "p") && s.push({
          type: "text", value: `
`}); const l = { type: "element", tagName: "li", properties: u, children: s }; return e.patch(t, l), e.applyData(t, l)
      } function Xk(e) { let t = !1; if (e.type === "list") { t = e.spread || !1; const n = e.children; let r = -1; for (; !t && ++r < n.length;)t = AE(n[r]) } return t } function AE(e) { const t = e.spread; return t ?? e.children.length > 1 } function Jk(e, t) { const n = {}, r = e.all(t); let i = -1; for (typeof t.start == "number" && t.start !== 1 && (n.start = t.start); ++i < r.length;) { const s = r[i]; if (s.type === "element" && s.tagName === "li" && s.properties && Array.isArray(s.properties.className) && s.properties.className.includes("task-list-item")) { n.className = ["contains-task-list"]; break } } const u = { type: "element", tagName: t.ordered ? "ol" : "ul", properties: n, children: e.wrap(r, !0) }; return e.patch(t, u), e.applyData(t, u) } function Zk(e, t) { const n = { type: "element", tagName: "p", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function eN(e, t) { const n = { type: "root", children: e.wrap(e.all(t)) }; return e.patch(t, n), e.applyData(t, n) } function tN(e, t) { const n = { type: "element", tagName: "strong", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } function nN(e, t) { const n = e.all(t), r = n.shift(), i = []; if (r) { const s = { type: "element", tagName: "thead", properties: {}, children: e.wrap([r], !0) }; e.patch(t.children[0], s), i.push(s) } if (n.length > 0) { const s = { type: "element", tagName: "tbody", properties: {}, children: e.wrap(n, !0) }, a = nn(t.children[1]), o = uo(t.children[t.children.length - 1]); a && o && (s.position = { start: a, end: o }), i.push(s) } const u = { type: "element", tagName: "table", properties: {}, children: e.wrap(i, !0) }; return e.patch(t, u), e.applyData(t, u) } function rN(e, t, n) { const r = n ? n.children : void 0, u = (r ? r.indexOf(t) : 1) === 0 ? "th" : "td", s = n && n.type === "table" ? n.align : void 0, a = s ? s.length : t.children.length; let o = -1; const l = []; for (; ++o < a;) { const d = t.children[o], p = {}, h = s ? s[o] : void 0; h && (p.align = h); let m = { type: "element", tagName: u, properties: p, children: [] }; d && (m.children = e.all(d), e.patch(d, m), m = e.applyData(d, m)), l.push(m) } const f = { type: "element", tagName: "tr", properties: {}, children: e.wrap(l, !0) }; return e.patch(t, f), e.applyData(t, f) } function iN(e, t) { const n = { type: "element", tagName: "td", properties: {}, children: e.all(t) }; return e.patch(t, n), e.applyData(t, n) } const K0 = 9, q0 = 32; function uN(e) { const t = String(e), n = /\r?\n|\r/g; let r = n.exec(t), i = 0; const u = []; for (; r;)u.push(Q0(t.slice(i, r.index), i > 0, !0), r[0]), i = r.index + r[0].length, r = n.exec(t); return u.push(Q0(t.slice(i), i > 0, !1)), u.join("") } function Q0(e, t, n) { let r = 0, i = e.length; if (t) { let u = e.codePointAt(r); for (; u === K0 || u === q0;)r++, u = e.codePointAt(r) } if (n) { let u = e.codePointAt(i - 1); for (; u === K0 || u === q0;)i--, u = e.codePointAt(i - 1) } return i > r ? e.slice(r, i) : "" } function sN(e, t) { const n = { type: "text", value: uN(String(t.value)) }; return e.patch(t, n), e.applyData(t, n) } function aN(e, t) { const n = { type: "element", tagName: "hr", properties: {}, children: [] }; return e.patch(t, n), e.applyData(t, n) } const oN = { blockquote: Fk, break: Bk, code: Uk, delete: Hk, emphasis: zk, footnoteReference: jk, heading: $k, html: Vk, imageReference: Yk, image: Wk, inlineCode: Kk, linkReference: qk, link: Qk, listItem: Gk, list: Jk, paragraph: Zk, root: eN, strong: tN, table: nN, tableCell: iN, tableRow: rN, text: sN, thematicBreak: aN, toml: As, yaml: As, definition: As, footnoteDefinition: As }; function As() { } const kE = -1, oo = 0, du = 1, Ia = 2, rd = 3, id = 4, ud = 5, sd = 6, NE = 7, IE = 8, G0 = typeof self == "object" ? self : globalThis, lN = (e, t) => { const n = (i, u) => (e.set(u, i), i), r = i => { if (e.has(i)) return e.get(i); const [u, s] = t[i]; switch (u) { case oo: case kE: return n(s, i); case du: { const a = n([], i); for (const o of s) a.push(r(o)); return a } case Ia: { const a = n({}, i); for (const [o, l] of s) a[r(o)] = r(l); return a } case rd: return n(new Date(s), i); case id: { const { source: a, flags: o } = s; return n(new RegExp(a, o), i) } case ud: { const a = n(new Map, i); for (const [o, l] of s) a.set(r(o), r(l)); return a } case sd: { const a = n(new Set, i); for (const o of s) a.add(r(o)); return a } case NE: { const { name: a, message: o } = s; return n(new G0[a](o), i) } case IE: return n(BigInt(s), i); case "BigInt": return n(Object(BigInt(s)), i); case "ArrayBuffer": return n(new Uint8Array(s).buffer, s); case "DataView": { const { buffer: a } = new Uint8Array(s); return n(new DataView(a), s) } }return n(new G0[u](s), i) }; return r }, X0 = e => lN(new Map, e)(0), Rr = "", { toString: cN } = {}, { keys: fN } = Object, ji = e => { const t = typeof e; if (t !== "object" || !e) return [oo, t]; const n = cN.call(e).slice(8, -1); switch (n) { case "Array": return [du, Rr]; case "Object": return [Ia, Rr]; case "Date": return [rd, Rr]; case "RegExp": return [id, Rr]; case "Map": return [ud, Rr]; case "Set": return [sd, Rr]; case "DataView": return [du, n] }return n.includes("Array") ? [du, n] : n.includes("Error") ? [NE, n] : [Ia, n] }, ks = ([e, t]) => e === oo && (t === "function" || t === "symbol"), dN = (e, t, n, r) => { const i = (s, a) => { const o = r.push(s) - 1; return n.set(a, o), o }, u = s => { if (n.has(s)) return n.get(s); let [a, o] = ji(s); switch (a) { case oo: { let f = s; switch (o) { case "bigint": a = IE, f = s.toString(); break; case "function": case "symbol": if (e) throw new TypeError("unable to serialize " + o); f = null; break; case "undefined": return i([kE], s) }return i([a, f], s) } case du: { if (o) { let p = s; return o === "DataView" ? p = new Uint8Array(s.buffer) : o === "ArrayBuffer" && (p = new Uint8Array(s)), i([o, [...p]], s) } const f = [], d = i([a, f], s); for (const p of s) f.push(u(p)); return d } case Ia: { if (o) switch (o) { case "BigInt": return i([o, s.toString()], s); case "Boolean": case "Number": case "String": return i([o, s.valueOf()], s) }if (t && "toJSON" in s) return u(s.toJSON()); const f = [], d = i([a, f], s); for (const p of fN(s)) (e || !ks(ji(s[p]))) && f.push([u(p), u(s[p])]); return d } case rd: return i([a, s.toISOString()], s); case id: { const { source: f, flags: d } = s; return i([a, { source: f, flags: d }], s) } case ud: { const f = [], d = i([a, f], s); for (const [p, h] of s) (e || !(ks(ji(p)) || ks(ji(h)))) && f.push([u(p), u(h)]); return d } case sd: { const f = [], d = i([a, f], s); for (const p of s) (e || !ks(ji(p))) && f.push(u(p)); return d } }const { message: l } = s; return i([a, { name: o, message: l }], s) }; return u }, J0 = (e, { json: t, lossy: n } = {}) => { const r = []; return dN(!(t || n), !!t, new Map, r)(e), r }, hi = typeof structuredClone == "function" ? (e, t) => t && ("json" in t || "lossy" in t) ? X0(J0(e, t)) : structuredClone(e) : (e, t) => X0(J0(e, t)); function hN(e, t) { const n = [{ type: "text", value: "" }]; return t > 1 && n.push({ type: "element", tagName: "sup", properties: {}, children: [{ type: "text", value: String(t) }] }), n } function pN(e, t) { return "Back to reference " + (e + 1) + (t > 1 ? "-" + t : "") } function mN(e) {
        const t = typeof e.options.clobberPrefix == "string" ? e.options.clobberPrefix : "user-content-", n = e.options.footnoteBackContent || hN, r = e.options.footnoteBackLabel || pN, i = e.options.footnoteLabel || "Footnotes", u = e.options.footnoteLabelTagName || "h2", s = e.options.footnoteLabelProperties || { className: ["sr-only"] }, a = []; let o = -1; for (; ++o < e.footnoteOrder.length;) { const l = e.footnoteById.get(e.footnoteOrder[o]); if (!l) continue; const f = e.all(l), d = String(l.identifier).toUpperCase(), p = _i(d.toLowerCase()); let h = 0; const m = [], T = e.footnoteCounts.get(d); for (; T !== void 0 && ++h <= T;) { m.length > 0 && m.push({ type: "text", value: " " }); let E = typeof n == "string" ? n : n(o, h); typeof E == "string" && (E = { type: "text", value: E }), m.push({ type: "element", tagName: "a", properties: { href: "#" + t + "fnref-" + p + (h > 1 ? "-" + h : ""), dataFootnoteBackref: "", ariaLabel: typeof r == "string" ? r : r(o, h), className: ["data-footnote-backref"] }, children: Array.isArray(E) ? E : [E] }) } const _ = f[f.length - 1]; if (_ && _.type === "element" && _.tagName === "p") { const E = _.children[_.children.length - 1]; E && E.type === "text" ? E.value += " " : _.children.push({ type: "text", value: " " }), _.children.push(...m) } else f.push(...m); const g = { type: "element", tagName: "li", properties: { id: t + "fn-" + p }, children: e.wrap(f, !0) }; e.patch(l, g), a.push(g) } if (a.length !== 0) return {
          type: "element", tagName: "section", properties: { dataFootnotes: !0, className: ["footnotes"] }, children: [{ type: "element", tagName: u, properties: { ...hi(s), id: "footnote-label" }, children: [{ type: "text", value: i }] }, {
            type: "text", value: `
`}, { type: "element", tagName: "ol", properties: {}, children: e.wrap(a, !0) }, {
            type: "text", value: `
`}]
        }
      } const lo = function (e) { if (e == null) return yN; if (typeof e == "function") return co(e); if (typeof e == "object") return Array.isArray(e) ? gN(e) : EN(e); if (typeof e == "string") return TN(e); throw new Error("Expected function, string, or object as test") }; function gN(e) { const t = []; let n = -1; for (; ++n < e.length;)t[n] = lo(e[n]); return co(r); function r(...i) { let u = -1; for (; ++u < t.length;)if (t[u].apply(this, i)) return !0; return !1 } } function EN(e) { const t = e; return co(n); function n(r) { const i = r; let u; for (u in e) if (i[u] !== t[u]) return !1; return !0 } } function TN(e) { return co(t); function t(n) { return n && n.type === e } } function co(e) { return t; function t(n, r, i) { return !!(bN(n) && e.call(this, n, typeof r == "number" ? r : void 0, i || void 0)) } } function yN() { return !0 } function bN(e) { return e !== null && typeof e == "object" && "type" in e } const wE = [], xN = !0, Rc = !1, SN = "skip"; function vE(e, t, n, r) { let i; typeof t == "function" && typeof n != "function" ? (r = n, n = t) : i = t; const u = lo(i), s = r ? -1 : 1; a(e, void 0, [])(); function a(o, l, f) { const d = o && typeof o == "object" ? o : {}; if (typeof d.type == "string") { const h = typeof d.tagName == "string" ? d.tagName : typeof d.name == "string" ? d.name : void 0; Object.defineProperty(p, "name", { value: "node (" + (o.type + (h ? "<" + h + ">" : "")) + ")" }) } return p; function p() { let h = wE, m, T, _; if ((!t || u(o, l, f[f.length - 1] || void 0)) && (h = _N(n(o, f)), h[0] === Rc)) return h; if ("children" in o && o.children) { const g = o; if (g.children && h[0] !== SN) for (T = (r ? g.children.length : -1) + s, _ = f.concat(g); T > -1 && T < g.children.length;) { const E = g.children[T]; if (m = a(E, T, _)(), m[0] === Rc) return m; T = typeof m[1] == "number" ? m[1] : T + s } } return h } } } function _N(e) { return Array.isArray(e) ? e : typeof e == "number" ? [xN, e] : e == null ? wE : [e] } function fo(e, t, n, r) { let i, u, s; typeof t == "function" && typeof n != "function" ? (u = void 0, s = t, i = n) : (u = t, s = n, i = r), vE(e, u, a, i); function a(o, l) { const f = l[l.length - 1], d = f ? f.children.indexOf(o) : void 0; return s(o, d, f) } } const Pc = {}.hasOwnProperty, CN = {}; function AN(e, t) { const n = t || CN, r = new Map, i = new Map, u = new Map, s = { ...oN, ...n.handlers }, a = { all: l, applyData: NN, definitionById: r, footnoteById: i, footnoteCounts: u, footnoteOrder: [], handlers: s, one: o, options: n, patch: kN, wrap: wN }; return fo(e, function (f) { if (f.type === "definition" || f.type === "footnoteDefinition") { const d = f.type === "definition" ? r : i, p = String(f.identifier).toUpperCase(); d.has(p) || d.set(p, f) } }), a; function o(f, d) { const p = f.type, h = a.handlers[p]; if (Pc.call(a.handlers, p) && h) return h(a, f, d); if (a.options.passThrough && a.options.passThrough.includes(p)) { if ("children" in f) { const { children: T, ..._ } = f, g = hi(_); return g.children = a.all(f), g } return hi(f) } return (a.options.unknownHandler || IN)(a, f, d) } function l(f) { const d = []; if ("children" in f) { const p = f.children; let h = -1; for (; ++h < p.length;) { const m = a.one(p[h], f); if (m) { if (h && p[h - 1].type === "break" && (!Array.isArray(m) && m.type === "text" && (m.value = Z0(m.value)), !Array.isArray(m) && m.type === "element")) { const T = m.children[0]; T && T.type === "text" && (T.value = Z0(T.value)) } Array.isArray(m) ? d.push(...m) : d.push(m) } } } return d } } function kN(e, t) { e.position && (t.position = p3(e)) } function NN(e, t) { let n = t; if (e && e.data) { const r = e.data.hName, i = e.data.hChildren, u = e.data.hProperties; if (typeof r == "string") if (n.type === "element") n.tagName = r; else { const s = "children" in n ? n.children : [n]; n = { type: "element", tagName: r, properties: {}, children: s } } n.type === "element" && u && Object.assign(n.properties, hi(u)), "children" in n && n.children && i !== null && i !== void 0 && (n.children = i) } return n } function IN(e, t) { const n = t.data || {}, r = "value" in t && !(Pc.call(n, "hProperties") || Pc.call(n, "hChildren")) ? { type: "text", value: t.value } : { type: "element", tagName: "div", properties: {}, children: e.all(t) }; return e.patch(t, r), e.applyData(t, r) } function wN(e, t) {
        const n = []; let r = -1; for (t && n.push({
          type: "text", value: `
`}); ++r < e.length;)r && n.push({
            type: "text", value: `
`}), n.push(e[r]); return t && e.length > 0 && n.push({
              type: "text", value: `
`}), n
      } function Z0(e) { let t = 0, n = e.charCodeAt(t); for (; n === 9 || n === 32;)t++, n = e.charCodeAt(t); return e.slice(t) } function ep(e, t) {
        const n = AN(e, t), r = n.one(e, void 0), i = mN(n), u = Array.isArray(r) ? { type: "root", children: r } : r || { type: "root", children: [] }; return i && u.children.push({
          type: "text", value: `
`}, i), u
      } function vN(e, t) { return e && "run" in e ? async function (n, r) { const i = ep(n, { file: r, ...t }); await e.run(i, r) } : function (n, r) { return ep(n, { file: r, ...e || t }) } } function tp(e) { if (e) throw e } var qs = Object.prototype.hasOwnProperty, OE = Object.prototype.toString, np = Object.defineProperty, rp = Object.getOwnPropertyDescriptor, ip = function (t) { return typeof Array.isArray == "function" ? Array.isArray(t) : OE.call(t) === "[object Array]" }, up = function (t) { if (!t || OE.call(t) !== "[object Object]") return !1; var n = qs.call(t, "constructor"), r = t.constructor && t.constructor.prototype && qs.call(t.constructor.prototype, "isPrototypeOf"); if (t.constructor && !n && !r) return !1; var i; for (i in t); return typeof i > "u" || qs.call(t, i) }, sp = function (t, n) { np && n.name === "__proto__" ? np(t, n.name, { enumerable: !0, configurable: !0, value: n.newValue, writable: !0 }) : t[n.name] = n.newValue }, ap = function (t, n) { if (n === "__proto__") if (qs.call(t, n)) { if (rp) return rp(t, n).value } else return; return t[n] }, ON = function e() { var t, n, r, i, u, s, a = arguments[0], o = 1, l = arguments.length, f = !1; for (typeof a == "boolean" && (f = a, a = arguments[1] || {}, o = 2), (a == null || typeof a != "object" && typeof a != "function") && (a = {}); o < l; ++o)if (t = arguments[o], t != null) for (n in t) r = ap(a, n), i = ap(t, n), a !== i && (f && i && (up(i) || (u = ip(i))) ? (u ? (u = !1, s = r && ip(r) ? r : []) : s = r && up(r) ? r : {}, sp(a, { name: n, newValue: e(f, s, i) })) : typeof i < "u" && sp(a, { name: n, newValue: i })); return a }; const rl = mi(ON); function Dc(e) { if (typeof e != "object" || e === null) return !1; const t = Object.getPrototypeOf(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) } function LN() { const e = [], t = { run: n, use: r }; return t; function n(...i) { let u = -1; const s = i.pop(); if (typeof s != "function") throw new TypeError("Expected function as last argument, not " + s); a(null, ...i); function a(o, ...l) { const f = e[++u]; let d = -1; if (o) { s(o); return } for (; ++d < i.length;)(l[d] === null || l[d] === void 0) && (l[d] = i[d]); i = l, f ? RN(f, a)(...l) : s(null, ...l) } } function r(i) { if (typeof i != "function") throw new TypeError("Expected `middelware` to be a function, not " + i); return e.push(i), t } } function RN(e, t) { let n; return r; function r(...s) { const a = e.length > s.length; let o; a && s.push(i); try { o = e.apply(this, s) } catch (l) { const f = l; if (a && n) throw f; return i(f) } a || (o && o.then && typeof o.then == "function" ? o.then(u, i) : o instanceof Error ? i(o) : u(o)) } function i(s, ...a) { n || (n = !0, t(s, ...a)) } function u(s) { i(null, s) } } const Gt = { basename: PN, dirname: DN, extname: MN, join: FN, sep: "/" }; function PN(e, t) { if (t !== void 0 && typeof t != "string") throw new TypeError('"ext" argument must be a string'); ts(e); let n = 0, r = -1, i = e.length, u; if (t === void 0 || t.length === 0 || t.length > e.length) { for (; i--;)if (e.codePointAt(i) === 47) { if (u) { n = i + 1; break } } else r < 0 && (u = !0, r = i + 1); return r < 0 ? "" : e.slice(n, r) } if (t === e) return ""; let s = -1, a = t.length - 1; for (; i--;)if (e.codePointAt(i) === 47) { if (u) { n = i + 1; break } } else s < 0 && (u = !0, s = i + 1), a > -1 && (e.codePointAt(i) === t.codePointAt(a--) ? a < 0 && (r = i) : (a = -1, r = s)); return n === r ? r = s : r < 0 && (r = e.length), e.slice(n, r) } function DN(e) { if (ts(e), e.length === 0) return "."; let t = -1, n = e.length, r; for (; --n;)if (e.codePointAt(n) === 47) { if (r) { t = n; break } } else r || (r = !0); return t < 0 ? e.codePointAt(0) === 47 ? "/" : "." : t === 1 && e.codePointAt(0) === 47 ? "//" : e.slice(0, t) } function MN(e) { ts(e); let t = e.length, n = -1, r = 0, i = -1, u = 0, s; for (; t--;) { const a = e.codePointAt(t); if (a === 47) { if (s) { r = t + 1; break } continue } n < 0 && (s = !0, n = t + 1), a === 46 ? i < 0 ? i = t : u !== 1 && (u = 1) : i > -1 && (u = -1) } return i < 0 || n < 0 || u === 0 || u === 1 && i === n - 1 && i === r + 1 ? "" : e.slice(i, n) } function FN(...e) { let t = -1, n; for (; ++t < e.length;)ts(e[t]), e[t] && (n = n === void 0 ? e[t] : n + "/" + e[t]); return n === void 0 ? "." : BN(n) } function BN(e) { ts(e); const t = e.codePointAt(0) === 47; let n = UN(e, !t); return n.length === 0 && !t && (n = "."), n.length > 0 && e.codePointAt(e.length - 1) === 47 && (n += "/"), t ? "/" + n : n } function UN(e, t) { let n = "", r = 0, i = -1, u = 0, s = -1, a, o; for (; ++s <= e.length;) { if (s < e.length) a = e.codePointAt(s); else { if (a === 47) break; a = 47 } if (a === 47) { if (!(i === s - 1 || u === 1)) if (i !== s - 1 && u === 2) { if (n.length < 2 || r !== 2 || n.codePointAt(n.length - 1) !== 46 || n.codePointAt(n.length - 2) !== 46) { if (n.length > 2) { if (o = n.lastIndexOf("/"), o !== n.length - 1) { o < 0 ? (n = "", r = 0) : (n = n.slice(0, o), r = n.length - 1 - n.lastIndexOf("/")), i = s, u = 0; continue } } else if (n.length > 0) { n = "", r = 0, i = s, u = 0; continue } } t && (n = n.length > 0 ? n + "/.." : "..", r = 2) } else n.length > 0 ? n += "/" + e.slice(i + 1, s) : n = e.slice(i + 1, s), r = s - i - 1; i = s, u = 0 } else a === 46 && u > -1 ? u++ : u = -1 } return n } function ts(e) { if (typeof e != "string") throw new TypeError("Path must be a string. Received " + JSON.stringify(e)) } const HN = { cwd: zN }; function zN() { return "/" } function Mc(e) { return !!(e !== null && typeof e == "object" && "href" in e && e.href && "protocol" in e && e.protocol && e.auth === void 0) } function jN(e) { if (typeof e == "string") e = new URL(e); else if (!Mc(e)) { const t = new TypeError('The "path" argument must be of type string or an instance of URL. Received `' + e + "`"); throw t.code = "ERR_INVALID_ARG_TYPE", t } if (e.protocol !== "file:") { const t = new TypeError("The URL must be of scheme file"); throw t.code = "ERR_INVALID_URL_SCHEME", t } return $N(e) } function $N(e) { if (e.hostname !== "") { const r = new TypeError('File URL host must be "localhost" or empty on darwin'); throw r.code = "ERR_INVALID_FILE_URL_HOST", r } const t = e.pathname; let n = -1; for (; ++n < t.length;)if (t.codePointAt(n) === 37 && t.codePointAt(n + 1) === 50) { const r = t.codePointAt(n + 2); if (r === 70 || r === 102) { const i = new TypeError("File URL path must not include encoded / characters"); throw i.code = "ERR_INVALID_FILE_URL_PATH", i } } return decodeURIComponent(t) } const il = ["history", "path", "basename", "stem", "extname", "dirname"]; class LE { constructor(t) { let n; t ? Mc(t) ? n = { path: t } : typeof t == "string" || VN(t) ? n = { value: t } : n = t : n = {}, this.cwd = "cwd" in n ? "" : HN.cwd(), this.data = {}, this.history = [], this.messages = [], this.value, this.map, this.result, this.stored; let r = -1; for (; ++r < il.length;) { const u = il[r]; u in n && n[u] !== void 0 && n[u] !== null && (this[u] = u === "history" ? [...n[u]] : n[u]) } let i; for (i in n) il.includes(i) || (this[i] = n[i]) } get basename() { return typeof this.path == "string" ? Gt.basename(this.path) : void 0 } set basename(t) { sl(t, "basename"), ul(t, "basename"), this.path = Gt.join(this.dirname || "", t) } get dirname() { return typeof this.path == "string" ? Gt.dirname(this.path) : void 0 } set dirname(t) { op(this.basename, "dirname"), this.path = Gt.join(t || "", this.basename) } get extname() { return typeof this.path == "string" ? Gt.extname(this.path) : void 0 } set extname(t) { if (ul(t, "extname"), op(this.dirname, "extname"), t) { if (t.codePointAt(0) !== 46) throw new Error("`extname` must start with `.`"); if (t.includes(".", 1)) throw new Error("`extname` cannot contain multiple dots") } this.path = Gt.join(this.dirname, this.stem + (t || "")) } get path() { return this.history[this.history.length - 1] } set path(t) { Mc(t) && (t = jN(t)), sl(t, "path"), this.path !== t && this.history.push(t) } get stem() { return typeof this.path == "string" ? Gt.basename(this.path, this.extname) : void 0 } set stem(t) { sl(t, "stem"), ul(t, "stem"), this.path = Gt.join(this.dirname || "", t + (this.extname || "")) } fail(t, n, r) { const i = this.message(t, n, r); throw i.fatal = !0, i } info(t, n, r) { const i = this.message(t, n, r); return i.fatal = void 0, i } message(t, n, r) { const i = new Xe(t, n, r); return this.path && (i.name = this.path + ":" + i.name, i.file = this.path), i.fatal = !1, this.messages.push(i), i } toString(t) { return this.value === void 0 ? "" : typeof this.value == "string" ? this.value : new TextDecoder(t || void 0).decode(this.value) } } function ul(e, t) { if (e && e.includes(Gt.sep)) throw new Error("`" + t + "` cannot be a path: did not expect `" + Gt.sep + "`") } function sl(e, t) { if (!e) throw new Error("`" + t + "` cannot be empty") } function op(e, t) { if (!e) throw new Error("Setting `" + t + "` requires `path` to be set too") } function VN(e) { return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e) } const YN = function (e) { const r = this.constructor.prototype, i = r[e], u = function () { return i.apply(u, arguments) }; return Object.setPrototypeOf(u, r), u }, WN = {}.hasOwnProperty; class ad extends YN { constructor() { super("copy"), this.Compiler = void 0, this.Parser = void 0, this.attachers = [], this.compiler = void 0, this.freezeIndex = -1, this.frozen = void 0, this.namespace = {}, this.parser = void 0, this.transformers = LN() } copy() { const t = new ad; let n = -1; for (; ++n < this.attachers.length;) { const r = this.attachers[n]; t.use(...r) } return t.data(rl(!0, {}, this.namespace)), t } data(t, n) { return typeof t == "string" ? arguments.length === 2 ? (ll("data", this.frozen), this.namespace[t] = n, this) : WN.call(this.namespace, t) && this.namespace[t] || void 0 : t ? (ll("data", this.frozen), this.namespace = t, this) : this.namespace } freeze() { if (this.frozen) return this; const t = this; for (; ++this.freezeIndex < this.attachers.length;) { const [n, ...r] = this.attachers[this.freezeIndex]; if (r[0] === !1) continue; r[0] === !0 && (r[0] = void 0); const i = n.call(t, ...r); typeof i == "function" && this.transformers.use(i) } return this.frozen = !0, this.freezeIndex = Number.POSITIVE_INFINITY, this } parse(t) { this.freeze(); const n = Ns(t), r = this.parser || this.Parser; return al("parse", r), r(String(n), n) } process(t, n) { const r = this; return this.freeze(), al("process", this.parser || this.Parser), ol("process", this.compiler || this.Compiler), n ? i(void 0, n) : new Promise(i); function i(u, s) { const a = Ns(t), o = r.parse(a); r.run(o, a, function (f, d, p) { if (f || !d || !p) return l(f); const h = d, m = r.stringify(h, p); QN(m) ? p.value = m : p.result = m, l(f, p) }); function l(f, d) { f || !d ? s(f) : u ? u(d) : n(void 0, d) } } } processSync(t) { let n = !1, r; return this.freeze(), al("processSync", this.parser || this.Parser), ol("processSync", this.compiler || this.Compiler), this.process(t, i), cp("processSync", "process", n), r; function i(u, s) { n = !0, tp(u), r = s } } run(t, n, r) { lp(t), this.freeze(); const i = this.transformers; return !r && typeof n == "function" && (r = n, n = void 0), r ? u(void 0, r) : new Promise(u); function u(s, a) { const o = Ns(n); i.run(t, o, l); function l(f, d, p) { const h = d || t; f ? a(f) : s ? s(h) : r(void 0, h, p) } } } runSync(t, n) { let r = !1, i; return this.run(t, n, u), cp("runSync", "run", r), i; function u(s, a) { tp(s), i = a, r = !0 } } stringify(t, n) { this.freeze(); const r = Ns(n), i = this.compiler || this.Compiler; return ol("stringify", i), lp(t), i(t, r) } use(t, ...n) { const r = this.attachers, i = this.namespace; if (ll("use", this.frozen), t != null) if (typeof t == "function") o(t, n); else if (typeof t == "object") Array.isArray(t) ? a(t) : s(t); else throw new TypeError("Expected usable value, not `" + t + "`"); return this; function u(l) { if (typeof l == "function") o(l, []); else if (typeof l == "object") if (Array.isArray(l)) { const [f, ...d] = l; o(f, d) } else s(l); else throw new TypeError("Expected usable value, not `" + l + "`") } function s(l) { if (!("plugins" in l) && !("settings" in l)) throw new Error("Expected usable value but received an empty preset, which is probably a mistake: presets typically come with `plugins` and sometimes with `settings`, but this has neither"); a(l.plugins), l.settings && (i.settings = rl(!0, i.settings, l.settings)) } function a(l) { let f = -1; if (l != null) if (Array.isArray(l)) for (; ++f < l.length;) { const d = l[f]; u(d) } else throw new TypeError("Expected a list of plugins, not `" + l + "`") } function o(l, f) { let d = -1, p = -1; for (; ++d < r.length;)if (r[d][0] === l) { p = d; break } if (p === -1) r.push([l, ...f]); else if (f.length > 0) { let [h, ...m] = f; const T = r[p][1]; Dc(T) && Dc(h) && (h = rl(!0, T, h)), r[p] = [l, h, ...m] } } } } const KN = new ad().freeze(); function al(e, t) { if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `parser`") } function ol(e, t) { if (typeof t != "function") throw new TypeError("Cannot `" + e + "` without `compiler`") } function ll(e, t) { if (t) throw new Error("Cannot call `" + e + "` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.") } function lp(e) { if (!Dc(e) || typeof e.type != "string") throw new TypeError("Expected node, got `" + e + "`") } function cp(e, t, n) { if (!n) throw new Error("`" + e + "` finished async. Use `" + t + "` instead") } function Ns(e) { return qN(e) ? e : new LE(e) } function qN(e) { return !!(e && typeof e == "object" && "message" in e && "messages" in e) } function QN(e) { return typeof e == "string" || GN(e) } function GN(e) { return !!(e && typeof e == "object" && "byteLength" in e && "byteOffset" in e) } const XN = "https://github.com/remarkjs/react-markdown/blob/main/changelog.md", fp = [], dp = { allowDangerousHtml: !0 }, JN = /^(https?|ircs?|mailto|xmpp)$/i, ZN = [{ from: "astPlugins", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowDangerousHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "allowNode", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowElement" }, { from: "allowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "allowedElements" }, { from: "disallowedTypes", id: "replace-allownode-allowedtypes-and-disallowedtypes", to: "disallowedElements" }, { from: "escapeHtml", id: "remove-buggy-html-in-markdown-parser" }, { from: "includeElementIndex", id: "#remove-includeelementindex" }, { from: "includeNodeIndex", id: "change-includenodeindex-to-includeelementindex" }, { from: "linkTarget", id: "remove-linktarget" }, { from: "plugins", id: "change-plugins-to-remarkplugins", to: "remarkPlugins" }, { from: "rawSourcePos", id: "#remove-rawsourcepos" }, { from: "renderers", id: "change-renderers-to-components", to: "components" }, { from: "source", id: "change-source-to-children", to: "children" }, { from: "sourcePos", id: "#remove-sourcepos" }, { from: "transformImageUri", id: "#add-urltransform", to: "urlTransform" }, { from: "transformLinkUri", id: "#add-urltransform", to: "urlTransform" }]; function eI(e) { const t = tI(e), n = nI(e); return rI(t.runSync(t.parse(n), n), e) } function tI(e) { const t = e.rehypePlugins || fp, n = e.remarkPlugins || fp, r = e.remarkRehypeOptions ? { ...e.remarkRehypeOptions, ...dp } : dp; return KN().use(Mk).use(n).use(vN, r).use(t) } function nI(e) { const t = e.children || "", n = new LE; return typeof t == "string" && (n.value = t), n } function rI(e, t) { const n = t.allowedElements, r = t.allowElement, i = t.components, u = t.disallowedElements, s = t.skipHtml, a = t.unwrapDisallowed, o = t.urlTransform || iI; for (const f of ZN) Object.hasOwn(t, f.from) && ("" + f.from + (f.to ? "use `" + f.to + "` instead" : "remove it") + XN + f.id, void 0); return t.className && (e = { type: "element", tagName: "div", properties: { className: t.className }, children: e.type === "root" ? e.children : [e] }), fo(e, l), y3(e, { Fragment: w.Fragment, components: i, ignoreInvalidStyle: !0, jsx: w.jsx, jsxs: w.jsxs, passKeys: !0, passNode: !0 }); function l(f, d, p) { if (f.type === "raw" && p && typeof d == "number") return s ? p.children.splice(d, 1) : p.children[d] = { type: "text", value: f.value }, d; if (f.type === "element") { let h; for (h in el) if (Object.hasOwn(el, h) && Object.hasOwn(f.properties, h)) { const m = f.properties[h], T = el[h]; (T === null || T.includes(f.tagName)) && (f.properties[h] = o(String(m || ""), h, f)) } } if (f.type === "element") { let h = n ? !n.includes(f.tagName) : u ? u.includes(f.tagName) : !1; if (!h && r && typeof d == "number" && (h = !r(f, d, p)), h && p && typeof d == "number") return a && f.children ? p.children.splice(d, 1, ...f.children) : p.children.splice(d, 1), d } } } function iI(e) { const t = e.indexOf(":"), n = e.indexOf("?"), r = e.indexOf("#"), i = e.indexOf("/"); return t === -1 || i !== -1 && t > i || n !== -1 && t > n || r !== -1 && t > r || JN.test(e.slice(0, t)) ? e : "" } function hp(e, t) { const n = String(e); if (typeof t != "string") throw new TypeError("Expected character"); let r = 0, i = n.indexOf(t); for (; i !== -1;)r++, i = n.indexOf(t, i + t.length); return r } function uI(e) { if (typeof e != "string") throw new TypeError("Expected a string"); return e.replace(/[|\\{}()[\]^$+*?.]/g, "\\$&").replace(/-/g, "\\x2d") } function sI(e, t, n) { const i = lo((n || {}).ignore || []), u = aI(t); let s = -1; for (; ++s < u.length;)vE(e, "text", a); function a(l, f) { let d = -1, p; for (; ++d < f.length;) { const h = f[d], m = p ? p.children : void 0; if (i(h, m ? m.indexOf(h) : void 0, p)) return; p = h } if (p) return o(l, f) } function o(l, f) { const d = f[f.length - 1], p = u[s][0], h = u[s][1]; let m = 0; const _ = d.children.indexOf(l); let g = !1, E = []; p.lastIndex = 0; let y = p.exec(l.value); for (; y;) { const I = y.index, L = { index: y.index, input: y.input, stack: [...f, l] }; let k = h(...y, L); if (typeof k == "string" && (k = k.length > 0 ? { type: "text", value: k } : void 0), k === !1 ? p.lastIndex = I + 1 : (m !== I && E.push({ type: "text", value: l.value.slice(m, I) }), Array.isArray(k) ? E.push(...k) : k && E.push(k), m = I + y[0].length, g = !0), !p.global) break; y = p.exec(l.value) } return g ? (m < l.value.length && E.push({ type: "text", value: l.value.slice(m) }), d.children.splice(_, 1, ...E)) : E = [l], _ + E.length } } function aI(e) { const t = []; if (!Array.isArray(e)) throw new TypeError("Expected find and replace tuple or list of tuples"); const n = !e[0] || Array.isArray(e[0]) ? e : [e]; let r = -1; for (; ++r < n.length;) { const i = n[r]; t.push([oI(i[0]), lI(i[1])]) } return t } function oI(e) { return typeof e == "string" ? new RegExp(uI(e), "g") : e } function lI(e) { return typeof e == "function" ? e : function () { return e } } const cl = "phrasing", fl = ["autolink", "link", "image", "label"]; function cI() { return { transforms: [EI], enter: { literalAutolink: dI, literalAutolinkEmail: dl, literalAutolinkHttp: dl, literalAutolinkWww: dl }, exit: { literalAutolink: gI, literalAutolinkEmail: mI, literalAutolinkHttp: hI, literalAutolinkWww: pI } } } function fI() { return { unsafe: [{ character: "@", before: "[+\\-.\\w]", after: "[\\-.\\w]", inConstruct: cl, notInConstruct: fl }, { character: ".", before: "[Ww]", after: "[\\-.\\w]", inConstruct: cl, notInConstruct: fl }, { character: ":", before: "[ps]", after: "\\/", inConstruct: cl, notInConstruct: fl }] } } function dI(e) { this.enter({ type: "link", title: null, url: "", children: [] }, e) } function dl(e) { this.config.enter.autolinkProtocol.call(this, e) } function hI(e) { this.config.exit.autolinkProtocol.call(this, e) } function pI(e) { this.config.exit.data.call(this, e); const t = this.stack[this.stack.length - 1]; t.type, t.url = "http://" + this.sliceSerialize(e) } function mI(e) { this.config.exit.autolinkEmail.call(this, e) } function gI(e) { this.exit(e) } function EI(e) { sI(e, [[/(https?:\/\/|www(?=\.))([-.\w]+)([^ \t\r\n]*)/gi, TI], [new RegExp("(?<=^|\\s|\\p{P}|\\p{S})([-.\\w+]+)@([-\\w]+(?:\\.[-\\w]+)+)", "gu"), yI]], { ignore: ["link", "linkReference"] }) } function TI(e, t, n, r, i) { let u = ""; if (!RE(i) || (/^w/i.test(t) && (n = t + n, t = "", u = "http://"), !bI(n))) return !1; const s = xI(n + r); if (!s[0]) return !1; const a = { type: "link", title: null, url: u + t + s[0], children: [{ type: "text", value: t + s[0] }] }; return s[1] ? [a, { type: "text", value: s[1] }] : a } function yI(e, t, n, r) { return !RE(r, !0) || /[-\d_]$/.test(n) ? !1 : { type: "link", title: null, url: "mailto:" + t + "@" + n, children: [{ type: "text", value: t + "@" + n }] } } function bI(e) { const t = e.split("."); return !(t.length < 2 || t[t.length - 1] && (/_/.test(t[t.length - 1]) || !/[a-zA-Z\d]/.test(t[t.length - 1])) || t[t.length - 2] && (/_/.test(t[t.length - 2]) || !/[a-zA-Z\d]/.test(t[t.length - 2]))) } function xI(e) { const t = /[!"&'),.:;<>?\]}]+$/.exec(e); if (!t) return [e, void 0]; e = e.slice(0, t.index); let n = t[0], r = n.indexOf(")"); const i = hp(e, "("); let u = hp(e, ")"); for (; r !== -1 && i > u;)e += n.slice(0, r + 1), n = n.slice(r + 1), r = n.indexOf(")"), u++; return [e, n] } function RE(e, t) { const n = e.input.charCodeAt(e.index - 1); return (e.index === 0 || xr(n) || so(n)) && (!t || n !== 47) } PE.peek = vI; function SI() { this.buffer() } function _I(e) { this.enter({ type: "footnoteReference", identifier: "", label: "" }, e) } function CI() { this.buffer() } function AI(e) { this.enter({ type: "footnoteDefinition", identifier: "", label: "", children: [] }, e) } function kI(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = jt(this.sliceSerialize(e)).toLowerCase(), n.label = t } function NI(e) { this.exit(e) } function II(e) { const t = this.resume(), n = this.stack[this.stack.length - 1]; n.type, n.identifier = jt(this.sliceSerialize(e)).toLowerCase(), n.label = t } function wI(e) { this.exit(e) } function vI() { return "[" } function PE(e, t, n, r) { const i = n.createTracker(r); let u = i.move("[^"); const s = n.enter("footnoteReference"), a = n.enter("reference"); return u += i.move(n.safe(n.associationId(e), { after: "]", before: u })), a(), s(), u += i.move("]"), u } function OI() { return { enter: { gfmFootnoteCallString: SI, gfmFootnoteCall: _I, gfmFootnoteDefinitionLabelString: CI, gfmFootnoteDefinition: AI }, exit: { gfmFootnoteCallString: kI, gfmFootnoteCall: NI, gfmFootnoteDefinitionLabelString: II, gfmFootnoteDefinition: wI } } } function LI(e) {
        let t = !1; return e && e.firstLineBlank && (t = !0), { handlers: { footnoteDefinition: n, footnoteReference: PE }, unsafe: [{ character: "[", inConstruct: ["label", "phrasing", "reference"] }] }; function n(r, i, u, s) {
          const a = u.createTracker(s); let o = a.move("[^"); const l = u.enter("footnoteDefinition"), f = u.enter("label"); return o += a.move(u.safe(u.associationId(r), { before: o, after: "]" })), f(), o += a.move("]:"), r.children && r.children.length > 0 && (a.shift(4), o += a.move((t ? `
`: " ") + u.indentLines(u.containerFlow(r, a.current()), t ? DE : RI))), l(), o
        }
      } function RI(e, t, n) { return t === 0 ? e : DE(e, t, n) } function DE(e, t, n) { return (n ? "" : "    ") + e } const PI = ["autolink", "destinationLiteral", "destinationRaw", "reference", "titleQuote", "titleApostrophe"]; ME.peek = UI; function DI() { return { canContainEols: ["delete"], enter: { strikethrough: FI }, exit: { strikethrough: BI } } } function MI() { return { unsafe: [{ character: "~", inConstruct: "phrasing", notInConstruct: PI }], handlers: { delete: ME } } } function FI(e) { this.enter({ type: "delete", children: [] }, e) } function BI(e) { this.exit(e) } function ME(e, t, n, r) { const i = n.createTracker(r), u = n.enter("strikethrough"); let s = i.move("~~"); return s += n.containerPhrasing(e, { ...i.current(), before: s, after: "~" }), s += i.move("~~"), u(), s } function UI() { return "~" } function HI(e) { return e.length } function zI(e, t) {
        const n = t || {}, r = (n.align || []).concat(), i = n.stringLength || HI, u = [], s = [], a = [], o = []; let l = 0, f = -1; for (; ++f < e.length;) { const T = [], _ = []; let g = -1; for (e[f].length > l && (l = e[f].length); ++g < e[f].length;) { const E = jI(e[f][g]); if (n.alignDelimiters !== !1) { const y = i(E); _[g] = y, (o[g] === void 0 || y > o[g]) && (o[g] = y) } T.push(E) } s[f] = T, a[f] = _ } let d = -1; if (typeof r == "object" && "length" in r) for (; ++d < l;)u[d] = pp(r[d]); else { const T = pp(r); for (; ++d < l;)u[d] = T } d = -1; const p = [], h = []; for (; ++d < l;) { const T = u[d]; let _ = "", g = ""; T === 99 ? (_ = ":", g = ":") : T === 108 ? _ = ":" : T === 114 && (g = ":"); let E = n.alignDelimiters === !1 ? 1 : Math.max(1, o[d] - _.length - g.length); const y = _ + "-".repeat(E) + g; n.alignDelimiters !== !1 && (E = _.length + E + g.length, E > o[d] && (o[d] = E), h[d] = E), p[d] = y } s.splice(1, 0, p), a.splice(1, 0, h), f = -1; const m = []; for (; ++f < s.length;) { const T = s[f], _ = a[f]; d = -1; const g = []; for (; ++d < l;) { const E = T[d] || ""; let y = "", I = ""; if (n.alignDelimiters !== !1) { const L = o[d] - (_[d] || 0), k = u[d]; k === 114 ? y = " ".repeat(L) : k === 99 ? L % 2 ? (y = " ".repeat(L / 2 + .5), I = " ".repeat(L / 2 - .5)) : (y = " ".repeat(L / 2), I = y) : I = " ".repeat(L) } n.delimiterStart !== !1 && !d && g.push("|"), n.padding !== !1 && !(n.alignDelimiters === !1 && E === "") && (n.delimiterStart !== !1 || d) && g.push(" "), n.alignDelimiters !== !1 && g.push(y), g.push(E), n.alignDelimiters !== !1 && g.push(I), n.padding !== !1 && g.push(" "), (n.delimiterEnd !== !1 || d !== l - 1) && g.push("|") } m.push(n.delimiterEnd === !1 ? g.join("").replace(/ +$/, "") : g.join("")) } return m.join(`
`)
      } function jI(e) { return e == null ? "" : String(e) } function pp(e) { const t = typeof e == "string" ? e.codePointAt(0) : 0; return t === 67 || t === 99 ? 99 : t === 76 || t === 108 ? 108 : t === 82 || t === 114 ? 114 : 0 } const mp = {}.hasOwnProperty; function FE(e, t) { const n = t || {}; function r(i, ...u) { let s = r.invalid; const a = r.handlers; if (i && mp.call(i, e)) { const o = String(i[e]); s = mp.call(a, o) ? a[o] : r.unknown } if (s) return s.call(this, i, ...u) } return r.handlers = n.handlers || {}, r.invalid = n.invalid, r.unknown = n.unknown, r } function $I(e, t, n, r) { const i = n.enter("blockquote"), u = n.createTracker(r); u.move("> "), u.shift(2); const s = n.indentLines(n.containerFlow(e, u.current()), VI); return i(), s } function VI(e, t, n) { return ">" + (n ? "" : " ") + e } function YI(e, t) { return gp(e, t.inConstruct, !0) && !gp(e, t.notInConstruct, !1) } function gp(e, t, n) { if (typeof t == "string" && (t = [t]), !t || t.length === 0) return n; let r = -1; for (; ++r < t.length;)if (e.includes(t[r])) return !0; return !1 } function Ep(e, t, n, r) {
        let i = -1; for (; ++i < n.unsafe.length;)if (n.unsafe[i].character === `
`&& YI(n.stack, n.unsafe[i])) return /[ \t]/.test(r.before) ? "" : " "; return `\\
`} function WI(e, t) { const n = String(e); let r = n.indexOf(t), i = r, u = 0, s = 0; if (typeof t != "string") throw new TypeError("Expected substring"); for (; r !== -1;)r === i ? ++u > s && (s = u) : u = 1, i = r + t.length, r = n.indexOf(t, i); return s } function KI(e, t) { return !!(t.options.fences === !1 && e.value && !e.lang && /[^ \r\n]/.test(e.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(e.value)) } function qI(e) { const t = e.options.fence || "`"; if (t !== "`" && t !== "~") throw new Error("Cannot serialize code with `" + t + "` for `options.fence`, expected `` ` `` or `~`"); return t } function QI(e, t, n, r) {
        const i = qI(n), u = e.value || "", s = i === "`" ? "GraveAccent" : "Tilde"; if (KI(e, n)) { const d = n.enter("codeIndented"), p = n.indentLines(u, GI); return d(), p } const a = n.createTracker(r), o = i.repeat(Math.max(WI(u, i) + 1, 3)), l = n.enter("codeFenced"); let f = a.move(o); if (e.lang) { const d = n.enter(`codeFencedLang${s}`); f += a.move(n.safe(e.lang, { before: f, after: " ", encode: ["`"], ...a.current() })), d() } if (e.lang && e.meta) {
          const d = n.enter(`codeFencedMeta${s}`); f += a.move(" "), f += a.move(n.safe(e.meta, {
            before: f, after: `
`, encode: ["`"], ...a.current()
          })), d()
        } return f += a.move(`
`), u && (f += a.move(u + `
`)), f += a.move(o), l(), f
      } function GI(e, t, n) { return (n ? "" : "    ") + e } function od(e) { const t = e.options.quote || '"'; if (t !== '"' && t !== "'") throw new Error("Cannot serialize title with `" + t + "` for `options.quote`, expected `\"`, or `'`"); return t } function XI(e, t, n, r) {
        const i = od(n), u = i === '"' ? "Quote" : "Apostrophe", s = n.enter("definition"); let a = n.enter("label"); const o = n.createTracker(r); let l = o.move("["); return l += o.move(n.safe(n.associationId(e), { before: l, after: "]", ...o.current() })), l += o.move("]: "), a(), !e.url || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), l += o.move("<"), l += o.move(n.safe(e.url, { before: l, after: ">", ...o.current() })), l += o.move(">")) : (a = n.enter("destinationRaw"), l += o.move(n.safe(e.url, {
          before: l, after: e.title ? " " : `
`, ...o.current()
        }))), a(), e.title && (a = n.enter(`title${u}`), l += o.move(" " + i), l += o.move(n.safe(e.title, { before: l, after: i, ...o.current() })), l += o.move(i), a()), s(), l
      } function JI(e) { const t = e.options.emphasis || "*"; if (t !== "*" && t !== "_") throw new Error("Cannot serialize emphasis with `" + t + "` for `options.emphasis`, expected `*`, or `_`"); return t } function Hu(e) { return "&#x" + e.toString(16).toUpperCase() + ";" } function wa(e, t, n) { const r = di(e), i = di(t); return r === void 0 ? i === void 0 ? n === "_" ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : i === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !0 } : r === 1 ? i === void 0 ? { inside: !1, outside: !1 } : i === 1 ? { inside: !0, outside: !0 } : { inside: !1, outside: !1 } : i === void 0 ? { inside: !1, outside: !1 } : i === 1 ? { inside: !0, outside: !1 } : { inside: !1, outside: !1 } } BE.peek = ZI; function BE(e, t, n, r) { const i = JI(n), u = n.enter("emphasis"), s = n.createTracker(r), a = s.move(i); let o = s.move(n.containerPhrasing(e, { after: i, before: a, ...s.current() })); const l = o.charCodeAt(0), f = wa(r.before.charCodeAt(r.before.length - 1), l, i); f.inside && (o = Hu(l) + o.slice(1)); const d = o.charCodeAt(o.length - 1), p = wa(r.after.charCodeAt(0), d, i); p.inside && (o = o.slice(0, -1) + Hu(d)); const h = s.move(i); return u(), n.attentionEncodeSurroundingInfo = { after: p.outside, before: f.outside }, a + o + h } function ZI(e, t, n) { return n.options.emphasis || "*" } function ew(e, t) { let n = !1; return fo(e, function (r) { if ("value" in r && /\r?\n|\r/.test(r.value) || r.type === "break") return n = !0, Rc }), !!((!e.depth || e.depth < 3) && ed(e) && (t.options.setext || n)) } function tw(e, t, n, r) {
        const i = Math.max(Math.min(6, e.depth || 1), 1), u = n.createTracker(r); if (ew(e, n)) {
          const f = n.enter("headingSetext"), d = n.enter("phrasing"), p = n.containerPhrasing(e, {
            ...u.current(), before: `
`, after: `
`}); return d(), f(), p + `
`+ (i === 1 ? "=" : "-").repeat(p.length - (Math.max(p.lastIndexOf("\r"), p.lastIndexOf(`
`)) + 1))
        } const s = "#".repeat(i), a = n.enter("headingAtx"), o = n.enter("phrasing"); u.move(s + " "); let l = n.containerPhrasing(e, {
          before: "# ", after: `
`, ...u.current()
        }); return /^[\t ]/.test(l) && (l = Hu(l.charCodeAt(0)) + l.slice(1)), l = l ? s + " " + l : s, n.options.closeAtx && (l += " " + s), o(), a(), l
      } UE.peek = nw; function UE(e) { return e.value || "" } function nw() { return "<" } HE.peek = rw; function HE(e, t, n, r) { const i = od(n), u = i === '"' ? "Quote" : "Apostrophe", s = n.enter("image"); let a = n.enter("label"); const o = n.createTracker(r); let l = o.move("!["); return l += o.move(n.safe(e.alt, { before: l, after: "]", ...o.current() })), l += o.move("]("), a(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (a = n.enter("destinationLiteral"), l += o.move("<"), l += o.move(n.safe(e.url, { before: l, after: ">", ...o.current() })), l += o.move(">")) : (a = n.enter("destinationRaw"), l += o.move(n.safe(e.url, { before: l, after: e.title ? " " : ")", ...o.current() }))), a(), e.title && (a = n.enter(`title${u}`), l += o.move(" " + i), l += o.move(n.safe(e.title, { before: l, after: i, ...o.current() })), l += o.move(i), a()), l += o.move(")"), s(), l } function rw() { return "!" } zE.peek = iw; function zE(e, t, n, r) { const i = e.referenceType, u = n.enter("imageReference"); let s = n.enter("label"); const a = n.createTracker(r); let o = a.move("!["); const l = n.safe(e.alt, { before: o, after: "]", ...a.current() }); o += a.move(l + "]["), s(); const f = n.stack; n.stack = [], s = n.enter("reference"); const d = n.safe(n.associationId(e), { before: o, after: "]", ...a.current() }); return s(), n.stack = f, u(), i === "full" || !l || l !== d ? o += a.move(d + "]") : i === "shortcut" ? o = o.slice(0, -1) : o += a.move("]"), o } function iw() { return "!" } jE.peek = uw; function jE(e, t, n) { let r = e.value || "", i = "`", u = -1; for (; new RegExp("(^|[^`])" + i + "([^`]|$)").test(r);)i += "`"; for (/[^ \r\n]/.test(r) && (/^[ \r\n]/.test(r) && /[ \r\n]$/.test(r) || /^`|`$/.test(r)) && (r = " " + r + " "); ++u < n.unsafe.length;) { const s = n.unsafe[u], a = n.compilePattern(s); let o; if (s.atBreak) for (; o = a.exec(r);) { let l = o.index; r.charCodeAt(l) === 10 && r.charCodeAt(l - 1) === 13 && l--, r = r.slice(0, l) + " " + r.slice(o.index + 1) } } return i + r + i } function uw() { return "`" } function $E(e, t) { const n = ed(e); return !!(!t.options.resourceLink && e.url && !e.title && e.children && e.children.length === 1 && e.children[0].type === "text" && (n === e.url || "mailto:" + n === e.url) && /^[a-z][a-z+.-]+:/i.test(e.url) && !/[\0- <>\u007F]/.test(e.url)) } VE.peek = sw; function VE(e, t, n, r) { const i = od(n), u = i === '"' ? "Quote" : "Apostrophe", s = n.createTracker(r); let a, o; if ($E(e, n)) { const f = n.stack; n.stack = [], a = n.enter("autolink"); let d = s.move("<"); return d += s.move(n.containerPhrasing(e, { before: d, after: ">", ...s.current() })), d += s.move(">"), a(), n.stack = f, d } a = n.enter("link"), o = n.enter("label"); let l = s.move("["); return l += s.move(n.containerPhrasing(e, { before: l, after: "](", ...s.current() })), l += s.move("]("), o(), !e.url && e.title || /[\0- \u007F]/.test(e.url) ? (o = n.enter("destinationLiteral"), l += s.move("<"), l += s.move(n.safe(e.url, { before: l, after: ">", ...s.current() })), l += s.move(">")) : (o = n.enter("destinationRaw"), l += s.move(n.safe(e.url, { before: l, after: e.title ? " " : ")", ...s.current() }))), o(), e.title && (o = n.enter(`title${u}`), l += s.move(" " + i), l += s.move(n.safe(e.title, { before: l, after: i, ...s.current() })), l += s.move(i), o()), l += s.move(")"), a(), l } function sw(e, t, n) { return $E(e, n) ? "<" : "[" } YE.peek = aw; function YE(e, t, n, r) { const i = e.referenceType, u = n.enter("linkReference"); let s = n.enter("label"); const a = n.createTracker(r); let o = a.move("["); const l = n.containerPhrasing(e, { before: o, after: "]", ...a.current() }); o += a.move(l + "]["), s(); const f = n.stack; n.stack = [], s = n.enter("reference"); const d = n.safe(n.associationId(e), { before: o, after: "]", ...a.current() }); return s(), n.stack = f, u(), i === "full" || !l || l !== d ? o += a.move(d + "]") : i === "shortcut" ? o = o.slice(0, -1) : o += a.move("]"), o } function aw() { return "[" } function ld(e) { const t = e.options.bullet || "*"; if (t !== "*" && t !== "+" && t !== "-") throw new Error("Cannot serialize items with `" + t + "` for `options.bullet`, expected `*`, `+`, or `-`"); return t } function ow(e) { const t = ld(e), n = e.options.bulletOther; if (!n) return t === "*" ? "-" : "*"; if (n !== "*" && n !== "+" && n !== "-") throw new Error("Cannot serialize items with `" + n + "` for `options.bulletOther`, expected `*`, `+`, or `-`"); if (n === t) throw new Error("Expected `bullet` (`" + t + "`) and `bulletOther` (`" + n + "`) to be different"); return n } function lw(e) { const t = e.options.bulletOrdered || "."; if (t !== "." && t !== ")") throw new Error("Cannot serialize items with `" + t + "` for `options.bulletOrdered`, expected `.` or `)`"); return t } function WE(e) { const t = e.options.rule || "*"; if (t !== "*" && t !== "-" && t !== "_") throw new Error("Cannot serialize rules with `" + t + "` for `options.rule`, expected `*`, `-`, or `_`"); return t } function cw(e, t, n, r) { const i = n.enter("list"), u = n.bulletCurrent; let s = e.ordered ? lw(n) : ld(n); const a = e.ordered ? s === "." ? ")" : "." : ow(n); let o = t && n.bulletLastUsed ? s === n.bulletLastUsed : !1; if (!e.ordered) { const f = e.children ? e.children[0] : void 0; if ((s === "*" || s === "-") && f && (!f.children || !f.children[0]) && n.stack[n.stack.length - 1] === "list" && n.stack[n.stack.length - 2] === "listItem" && n.stack[n.stack.length - 3] === "list" && n.stack[n.stack.length - 4] === "listItem" && n.indexStack[n.indexStack.length - 1] === 0 && n.indexStack[n.indexStack.length - 2] === 0 && n.indexStack[n.indexStack.length - 3] === 0 && (o = !0), WE(n) === s && f) { let d = -1; for (; ++d < e.children.length;) { const p = e.children[d]; if (p && p.type === "listItem" && p.children && p.children[0] && p.children[0].type === "thematicBreak") { o = !0; break } } } } o && (s = a), n.bulletCurrent = s; const l = n.containerFlow(e, r); return n.bulletLastUsed = s, n.bulletCurrent = u, i(), l } function fw(e) { const t = e.options.listItemIndent || "one"; if (t !== "tab" && t !== "one" && t !== "mixed") throw new Error("Cannot serialize items with `" + t + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`"); return t } function dw(e, t, n, r) { const i = fw(n); let u = n.bulletCurrent || ld(n); t && t.type === "list" && t.ordered && (u = (typeof t.start == "number" && t.start > -1 ? t.start : 1) + (n.options.incrementListMarker === !1 ? 0 : t.children.indexOf(e)) + u); let s = u.length + 1; (i === "tab" || i === "mixed" && (t && t.type === "list" && t.spread || e.spread)) && (s = Math.ceil(s / 4) * 4); const a = n.createTracker(r); a.move(u + " ".repeat(s - u.length)), a.shift(s); const o = n.enter("listItem"), l = n.indentLines(n.containerFlow(e, a.current()), f); return o(), l; function f(d, p, h) { return p ? (h ? "" : " ".repeat(s)) + d : (h ? u : u + " ".repeat(s - u.length)) + d } } function hw(e, t, n, r) { const i = n.enter("paragraph"), u = n.enter("phrasing"), s = n.containerPhrasing(e, r); return u(), i(), s } const pw = lo(["break", "delete", "emphasis", "footnote", "footnoteReference", "image", "imageReference", "inlineCode", "inlineMath", "link", "linkReference", "mdxJsxTextElement", "mdxTextExpression", "strong", "text", "textDirective"]); function mw(e, t, n, r) { return (e.children.some(function (s) { return pw(s) }) ? n.containerPhrasing : n.containerFlow).call(n, e, r) } function gw(e) { const t = e.options.strong || "*"; if (t !== "*" && t !== "_") throw new Error("Cannot serialize strong with `" + t + "` for `options.strong`, expected `*`, or `_`"); return t } KE.peek = Ew; function KE(e, t, n, r) { const i = gw(n), u = n.enter("strong"), s = n.createTracker(r), a = s.move(i + i); let o = s.move(n.containerPhrasing(e, { after: i, before: a, ...s.current() })); const l = o.charCodeAt(0), f = wa(r.before.charCodeAt(r.before.length - 1), l, i); f.inside && (o = Hu(l) + o.slice(1)); const d = o.charCodeAt(o.length - 1), p = wa(r.after.charCodeAt(0), d, i); p.inside && (o = o.slice(0, -1) + Hu(d)); const h = s.move(i + i); return u(), n.attentionEncodeSurroundingInfo = { after: p.outside, before: f.outside }, a + o + h } function Ew(e, t, n) { return n.options.strong || "*" } function Tw(e, t, n, r) { return n.safe(e.value, r) } function yw(e) { const t = e.options.ruleRepetition || 3; if (t < 3) throw new Error("Cannot serialize rules with repetition `" + t + "` for `options.ruleRepetition`, expected `3` or more"); return t } function bw(e, t, n) { const r = (WE(n) + (n.options.ruleSpaces ? " " : "")).repeat(yw(n)); return n.options.ruleSpaces ? r.slice(0, -1) : r } const qE = { blockquote: $I, break: Ep, code: QI, definition: XI, emphasis: BE, hardBreak: Ep, heading: tw, html: UE, image: HE, imageReference: zE, inlineCode: jE, link: VE, linkReference: YE, list: cw, listItem: dw, paragraph: hw, root: mw, strong: KE, text: Tw, thematicBreak: bw }; function xw() { return { enter: { table: Sw, tableData: Tp, tableHeader: Tp, tableRow: Cw }, exit: { codeText: Aw, table: _w, tableData: hl, tableHeader: hl, tableRow: hl } } } function Sw(e) { const t = e._align; this.enter({ type: "table", align: t.map(function (n) { return n === "none" ? null : n }), children: [] }, e), this.data.inTable = !0 } function _w(e) { this.exit(e), this.data.inTable = void 0 } function Cw(e) { this.enter({ type: "tableRow", children: [] }, e) } function hl(e) { this.exit(e) } function Tp(e) { this.enter({ type: "tableCell", children: [] }, e) } function Aw(e) { let t = this.resume(); this.data.inTable && (t = t.replace(/\\([\\|])/g, kw)); const n = this.stack[this.stack.length - 1]; n.type, n.value = t, this.exit(e) } function kw(e, t) { return t === "|" ? t : e } function Nw(e) {
        const t = e || {}, n = t.tableCellPadding, r = t.tablePipeAlign, i = t.stringLength, u = n ? " " : "|"; return {
          unsafe: [{ character: "\r", inConstruct: "tableCell" }, {
            character: `
`, inConstruct: "tableCell"
          }, { atBreak: !0, character: "|", after: "[	 :-]" }, { character: "|", inConstruct: "tableCell" }, { atBreak: !0, character: ":", after: "-" }, { atBreak: !0, character: "-", after: "[:|-]" }], handlers: { inlineCode: p, table: s, tableCell: o, tableRow: a }
        }; function s(h, m, T, _) { return l(f(h, T, _), h.align) } function a(h, m, T, _) {
          const g = d(h, T, _), E = l([g]); return E.slice(0, E.indexOf(`
`))
        } function o(h, m, T, _) { const g = T.enter("tableCell"), E = T.enter("phrasing"), y = T.containerPhrasing(h, { ..._, before: u, after: u }); return E(), g(), y } function l(h, m) { return zI(h, { align: m, alignDelimiters: r, padding: n, stringLength: i }) } function f(h, m, T) { const _ = h.children; let g = -1; const E = [], y = m.enter("table"); for (; ++g < _.length;)E[g] = d(_[g], m, T); return y(), E } function d(h, m, T) { const _ = h.children; let g = -1; const E = [], y = m.enter("tableRow"); for (; ++g < _.length;)E[g] = o(_[g], h, m, T); return y(), E } function p(h, m, T) { let _ = qE.inlineCode(h, m, T); return T.stack.includes("tableCell") && (_ = _.replace(/\|/g, "\\$&")), _ }
      } function Iw() { return { exit: { taskListCheckValueChecked: yp, taskListCheckValueUnchecked: yp, paragraph: vw } } } function ww() { return { unsafe: [{ atBreak: !0, character: "-", after: "[:|-]" }], handlers: { listItem: Ow } } } function yp(e) { const t = this.stack[this.stack.length - 2]; t.type, t.checked = e.type === "taskListCheckValueChecked" } function vw(e) { const t = this.stack[this.stack.length - 2]; if (t && t.type === "listItem" && typeof t.checked == "boolean") { const n = this.stack[this.stack.length - 1]; n.type; const r = n.children[0]; if (r && r.type === "text") { const i = t.children; let u = -1, s; for (; ++u < i.length;) { const a = i[u]; if (a.type === "paragraph") { s = a; break } } s === n && (r.value = r.value.slice(1), r.value.length === 0 ? n.children.shift() : n.position && r.position && typeof r.position.start.offset == "number" && (r.position.start.column++, r.position.start.offset++, n.position.start = Object.assign({}, r.position.start))) } } this.exit(e) } function Ow(e, t, n, r) { const i = e.children[0], u = typeof e.checked == "boolean" && i && i.type === "paragraph", s = "[" + (e.checked ? "x" : " ") + "] ", a = n.createTracker(r); u && a.move(s); let o = qE.listItem(e, t, n, { ...r, ...a.current() }); return u && (o = o.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, l)), o; function l(f) { return f + s } } function Lw() { return [cI(), OI(), DI(), xw(), Iw()] } function Rw(e) { return { extensions: [fI(), LI(e), MI(), Nw(e), ww()] } } const Pw = { tokenize: Hw, partial: !0 }, QE = { tokenize: zw, partial: !0 }, GE = { tokenize: jw, partial: !0 }, XE = { tokenize: $w, partial: !0 }, Dw = { tokenize: Vw, partial: !0 }, JE = { name: "wwwAutolink", tokenize: Bw, previous: eT }, ZE = { name: "protocolAutolink", tokenize: Uw, previous: tT }, bn = { name: "emailAutolink", tokenize: Fw, previous: nT }, rn = {}; function Mw() { return { text: rn } } let Jn = 48; for (; Jn < 123;)rn[Jn] = bn, Jn++, Jn === 58 ? Jn = 65 : Jn === 91 && (Jn = 97); rn[43] = bn; rn[45] = bn; rn[46] = bn; rn[95] = bn; rn[72] = [bn, ZE]; rn[104] = [bn, ZE]; rn[87] = [bn, JE]; rn[119] = [bn, JE]; function Fw(e, t, n) { const r = this; let i, u; return s; function s(d) { return !Fc(d) || !nT.call(r, r.previous) || cd(r.events) ? n(d) : (e.enter("literalAutolink"), e.enter("literalAutolinkEmail"), a(d)) } function a(d) { return Fc(d) ? (e.consume(d), a) : d === 64 ? (e.consume(d), o) : n(d) } function o(d) { return d === 46 ? e.check(Dw, f, l)(d) : d === 45 || d === 95 || Qe(d) ? (u = !0, e.consume(d), o) : f(d) } function l(d) { return e.consume(d), i = !0, o } function f(d) { return u && i && et(r.previous) ? (e.exit("literalAutolinkEmail"), e.exit("literalAutolink"), t(d)) : n(d) } } function Bw(e, t, n) { const r = this; return i; function i(s) { return s !== 87 && s !== 119 || !eT.call(r, r.previous) || cd(r.events) ? n(s) : (e.enter("literalAutolink"), e.enter("literalAutolinkWww"), e.check(Pw, e.attempt(QE, e.attempt(GE, u), n), n)(s)) } function u(s) { return e.exit("literalAutolinkWww"), e.exit("literalAutolink"), t(s) } } function Uw(e, t, n) { const r = this; let i = "", u = !1; return s; function s(d) { return (d === 72 || d === 104) && tT.call(r, r.previous) && !cd(r.events) ? (e.enter("literalAutolink"), e.enter("literalAutolinkHttp"), i += String.fromCodePoint(d), e.consume(d), a) : n(d) } function a(d) { if (et(d) && i.length < 5) return i += String.fromCodePoint(d), e.consume(d), a; if (d === 58) { const p = i.toLowerCase(); if (p === "http" || p === "https") return e.consume(d), o } return n(d) } function o(d) { return d === 47 ? (e.consume(d), u ? l : (u = !0, o)) : n(d) } function l(d) { return d === null || Na(d) || ge(d) || xr(d) || so(d) ? n(d) : e.attempt(QE, e.attempt(GE, f), n)(d) } function f(d) { return e.exit("literalAutolinkHttp"), e.exit("literalAutolink"), t(d) } } function Hw(e, t, n) { let r = 0; return i; function i(s) { return (s === 87 || s === 119) && r < 3 ? (r++, e.consume(s), i) : s === 46 && r === 3 ? (e.consume(s), u) : n(s) } function u(s) { return s === null ? n(s) : t(s) } } function zw(e, t, n) { let r, i, u; return s; function s(l) { return l === 46 || l === 95 ? e.check(XE, o, a)(l) : l === null || ge(l) || xr(l) || l !== 45 && so(l) ? o(l) : (u = !0, e.consume(l), s) } function a(l) { return l === 95 ? r = !0 : (i = r, r = void 0), e.consume(l), s } function o(l) { return i || r || !u ? n(l) : t(l) } } function jw(e, t) { let n = 0, r = 0; return i; function i(s) { return s === 40 ? (n++, e.consume(s), i) : s === 41 && r < n ? u(s) : s === 33 || s === 34 || s === 38 || s === 39 || s === 41 || s === 42 || s === 44 || s === 46 || s === 58 || s === 59 || s === 60 || s === 63 || s === 93 || s === 95 || s === 126 ? e.check(XE, t, u)(s) : s === null || ge(s) || xr(s) ? t(s) : (e.consume(s), i) } function u(s) { return s === 41 && r++, e.consume(s), i } } function $w(e, t, n) { return r; function r(a) { return a === 33 || a === 34 || a === 39 || a === 41 || a === 42 || a === 44 || a === 46 || a === 58 || a === 59 || a === 63 || a === 95 || a === 126 ? (e.consume(a), r) : a === 38 ? (e.consume(a), u) : a === 93 ? (e.consume(a), i) : a === 60 || a === null || ge(a) || xr(a) ? t(a) : n(a) } function i(a) { return a === null || a === 40 || a === 91 || ge(a) || xr(a) ? t(a) : r(a) } function u(a) { return et(a) ? s(a) : n(a) } function s(a) { return a === 59 ? (e.consume(a), r) : et(a) ? (e.consume(a), s) : n(a) } } function Vw(e, t, n) { return r; function r(u) { return e.consume(u), i } function i(u) { return Qe(u) ? n(u) : t(u) } } function eT(e) { return e === null || e === 40 || e === 42 || e === 95 || e === 91 || e === 93 || e === 126 || ge(e) } function tT(e) { return !et(e) } function nT(e) { return !(e === 47 || Fc(e)) } function Fc(e) { return e === 43 || e === 45 || e === 46 || e === 95 || Qe(e) } function cd(e) { let t = e.length, n = !1; for (; t--;) { const r = e[t][1]; if ((r.type === "labelLink" || r.type === "labelImage") && !r._balanced) { n = !0; break } if (r._gfmAutolinkLiteralWalkedInto) { n = !1; break } } return e.length > 0 && !n && (e[e.length - 1][1]._gfmAutolinkLiteralWalkedInto = !0), n } const Yw = { tokenize: Zw, partial: !0 }; function Ww() { return { document: { 91: { name: "gfmFootnoteDefinition", tokenize: Gw, continuation: { tokenize: Xw }, exit: Jw } }, text: { 91: { name: "gfmFootnoteCall", tokenize: Qw }, 93: { name: "gfmPotentialFootnoteCall", add: "after", tokenize: Kw, resolveTo: qw } } } } function Kw(e, t, n) { const r = this; let i = r.events.length; const u = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let s; for (; i--;) { const o = r.events[i][1]; if (o.type === "labelImage") { s = o; break } if (o.type === "gfmFootnoteCall" || o.type === "labelLink" || o.type === "label" || o.type === "image" || o.type === "link") break } return a; function a(o) { if (!s || !s._balanced) return n(o); const l = jt(r.sliceSerialize({ start: s.end, end: r.now() })); return l.codePointAt(0) !== 94 || !u.includes(l.slice(1)) ? n(o) : (e.enter("gfmFootnoteCallLabelMarker"), e.consume(o), e.exit("gfmFootnoteCallLabelMarker"), t(o)) } } function qw(e, t) { let n = e.length; for (; n--;)if (e[n][1].type === "labelImage" && e[n][0] === "enter") { e[n][1]; break } e[n + 1][1].type = "data", e[n + 3][1].type = "gfmFootnoteCallLabelMarker"; const r = { type: "gfmFootnoteCall", start: Object.assign({}, e[n + 3][1].start), end: Object.assign({}, e[e.length - 1][1].end) }, i = { type: "gfmFootnoteCallMarker", start: Object.assign({}, e[n + 3][1].end), end: Object.assign({}, e[n + 3][1].end) }; i.end.column++, i.end.offset++, i.end._bufferIndex++; const u = { type: "gfmFootnoteCallString", start: Object.assign({}, i.end), end: Object.assign({}, e[e.length - 1][1].start) }, s = { type: "chunkString", contentType: "string", start: Object.assign({}, u.start), end: Object.assign({}, u.end) }, a = [e[n + 1], e[n + 2], ["enter", r, t], e[n + 3], e[n + 4], ["enter", i, t], ["exit", i, t], ["enter", u, t], ["enter", s, t], ["exit", s, t], ["exit", u, t], e[e.length - 2], e[e.length - 1], ["exit", r, t]]; return e.splice(n, e.length - n + 1, ...a), e } function Qw(e, t, n) { const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let u = 0, s; return a; function a(d) { return e.enter("gfmFootnoteCall"), e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), o } function o(d) { return d !== 94 ? n(d) : (e.enter("gfmFootnoteCallMarker"), e.consume(d), e.exit("gfmFootnoteCallMarker"), e.enter("gfmFootnoteCallString"), e.enter("chunkString").contentType = "string", l) } function l(d) { if (u > 999 || d === 93 && !s || d === null || d === 91 || ge(d)) return n(d); if (d === 93) { e.exit("chunkString"); const p = e.exit("gfmFootnoteCallString"); return i.includes(jt(r.sliceSerialize(p))) ? (e.enter("gfmFootnoteCallLabelMarker"), e.consume(d), e.exit("gfmFootnoteCallLabelMarker"), e.exit("gfmFootnoteCall"), t) : n(d) } return ge(d) || (s = !0), u++, e.consume(d), d === 92 ? f : l } function f(d) { return d === 91 || d === 92 || d === 93 ? (e.consume(d), u++, l) : l(d) } } function Gw(e, t, n) { const r = this, i = r.parser.gfmFootnotes || (r.parser.gfmFootnotes = []); let u, s = 0, a; return o; function o(m) { return e.enter("gfmFootnoteDefinition")._container = !0, e.enter("gfmFootnoteDefinitionLabel"), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(m), e.exit("gfmFootnoteDefinitionLabelMarker"), l } function l(m) { return m === 94 ? (e.enter("gfmFootnoteDefinitionMarker"), e.consume(m), e.exit("gfmFootnoteDefinitionMarker"), e.enter("gfmFootnoteDefinitionLabelString"), e.enter("chunkString").contentType = "string", f) : n(m) } function f(m) { if (s > 999 || m === 93 && !a || m === null || m === 91 || ge(m)) return n(m); if (m === 93) { e.exit("chunkString"); const T = e.exit("gfmFootnoteDefinitionLabelString"); return u = jt(r.sliceSerialize(T)), e.enter("gfmFootnoteDefinitionLabelMarker"), e.consume(m), e.exit("gfmFootnoteDefinitionLabelMarker"), e.exit("gfmFootnoteDefinitionLabel"), p } return ge(m) || (a = !0), s++, e.consume(m), m === 92 ? d : f } function d(m) { return m === 91 || m === 92 || m === 93 ? (e.consume(m), s++, f) : f(m) } function p(m) { return m === 58 ? (e.enter("definitionMarker"), e.consume(m), e.exit("definitionMarker"), i.includes(u) || i.push(u), fe(e, h, "gfmFootnoteDefinitionWhitespace")) : n(m) } function h(m) { return t(m) } } function Xw(e, t, n) { return e.check(es, t, e.attempt(Yw, t, n)) } function Jw(e) { e.exit("gfmFootnoteDefinition") } function Zw(e, t, n) { const r = this; return fe(e, i, "gfmFootnoteDefinitionIndent", 5); function i(u) { const s = r.events[r.events.length - 1]; return s && s[1].type === "gfmFootnoteDefinitionIndent" && s[2].sliceSerialize(s[1], !0).length === 4 ? t(u) : n(u) } } function e6(e) { let n = (e || {}).singleTilde; const r = { name: "strikethrough", tokenize: u, resolveAll: i }; return n == null && (n = !0), { text: { 126: r }, insideSpan: { null: [r] }, attentionMarkers: { null: [126] } }; function i(s, a) { let o = -1; for (; ++o < s.length;)if (s[o][0] === "enter" && s[o][1].type === "strikethroughSequenceTemporary" && s[o][1]._close) { let l = o; for (; l--;)if (s[l][0] === "exit" && s[l][1].type === "strikethroughSequenceTemporary" && s[l][1]._open && s[o][1].end.offset - s[o][1].start.offset === s[l][1].end.offset - s[l][1].start.offset) { s[o][1].type = "strikethroughSequence", s[l][1].type = "strikethroughSequence"; const f = { type: "strikethrough", start: Object.assign({}, s[l][1].start), end: Object.assign({}, s[o][1].end) }, d = { type: "strikethroughText", start: Object.assign({}, s[l][1].end), end: Object.assign({}, s[o][1].start) }, p = [["enter", f, a], ["enter", s[l][1], a], ["exit", s[l][1], a], ["enter", d, a]], h = a.parser.constructs.insideSpan.null; h && bt(p, p.length, 0, ao(h, s.slice(l + 1, o), a)), bt(p, p.length, 0, [["exit", d, a], ["enter", s[o][1], a], ["exit", s[o][1], a], ["exit", f, a]]), bt(s, l - 1, o - l + 3, p), o = l + p.length - 2; break } } for (o = -1; ++o < s.length;)s[o][1].type === "strikethroughSequenceTemporary" && (s[o][1].type = "data"); return s } function u(s, a, o) { const l = this.previous, f = this.events; let d = 0; return p; function p(m) { return l === 126 && f[f.length - 1][1].type !== "characterEscape" ? o(m) : (s.enter("strikethroughSequenceTemporary"), h(m)) } function h(m) { const T = di(l); if (m === 126) return d > 1 ? o(m) : (s.consume(m), d++, h); if (d < 2 && !n) return o(m); const _ = s.exit("strikethroughSequenceTemporary"), g = di(m); return _._open = !g || g === 2 && !!T, _._close = !T || T === 2 && !!g, a(m) } } } class t6 { constructor() { this.map = [] } add(t, n, r) { n6(this, t, n, r) } consume(t) { if (this.map.sort(function (u, s) { return u[0] - s[0] }), this.map.length === 0) return; let n = this.map.length; const r = []; for (; n > 0;)n -= 1, r.push(t.slice(this.map[n][0] + this.map[n][1]), this.map[n][2]), t.length = this.map[n][0]; r.push(t.slice()), t.length = 0; let i = r.pop(); for (; i;) { for (const u of i) t.push(u); i = r.pop() } this.map.length = 0 } } function n6(e, t, n, r) { let i = 0; if (!(n === 0 && r.length === 0)) { for (; i < e.map.length;) { if (e.map[i][0] === t) { e.map[i][1] += n, e.map[i][2].push(...r); return } i += 1 } e.map.push([t, n, r]) } } function r6(e, t) { let n = !1; const r = []; for (; t < e.length;) { const i = e[t]; if (n) { if (i[0] === "enter") i[1].type === "tableContent" && r.push(e[t + 1][1].type === "tableDelimiterMarker" ? "left" : "none"); else if (i[1].type === "tableContent") { if (e[t - 1][1].type === "tableDelimiterMarker") { const u = r.length - 1; r[u] = r[u] === "left" ? "center" : "right" } } else if (i[1].type === "tableDelimiterRow") break } else i[0] === "enter" && i[1].type === "tableDelimiterRow" && (n = !0); t += 1 } return r } function i6() { return { flow: { null: { name: "table", tokenize: u6, resolveAll: s6 } } } } function u6(e, t, n) { const r = this; let i = 0, u = 0, s; return a; function a(N) { let Y = r.events.length - 1; for (; Y > -1;) { const q = r.events[Y][1].type; if (q === "lineEnding" || q === "linePrefix") Y--; else break } const U = Y > -1 ? r.events[Y][1].type : null, K = U === "tableHead" || U === "tableRow" ? k : o; return K === k && r.parser.lazy[r.now().line] ? n(N) : K(N) } function o(N) { return e.enter("tableHead"), e.enter("tableRow"), l(N) } function l(N) { return N === 124 || (s = !0, u += 1), f(N) } function f(N) { return N === null ? n(N) : Z(N) ? u > 1 ? (u = 0, r.interrupt = !0, e.exit("tableRow"), e.enter("lineEnding"), e.consume(N), e.exit("lineEnding"), h) : n(N) : oe(N) ? fe(e, f, "whitespace")(N) : (u += 1, s && (s = !1, i += 1), N === 124 ? (e.enter("tableCellDivider"), e.consume(N), e.exit("tableCellDivider"), s = !0, f) : (e.enter("data"), d(N))) } function d(N) { return N === null || N === 124 || ge(N) ? (e.exit("data"), f(N)) : (e.consume(N), N === 92 ? p : d) } function p(N) { return N === 92 || N === 124 ? (e.consume(N), d) : d(N) } function h(N) { return r.interrupt = !1, r.parser.lazy[r.now().line] ? n(N) : (e.enter("tableDelimiterRow"), s = !1, oe(N) ? fe(e, m, "linePrefix", r.parser.constructs.disable.null.includes("codeIndented") ? void 0 : 4)(N) : m(N)) } function m(N) { return N === 45 || N === 58 ? _(N) : N === 124 ? (s = !0, e.enter("tableCellDivider"), e.consume(N), e.exit("tableCellDivider"), T) : L(N) } function T(N) { return oe(N) ? fe(e, _, "whitespace")(N) : _(N) } function _(N) { return N === 58 ? (u += 1, s = !0, e.enter("tableDelimiterMarker"), e.consume(N), e.exit("tableDelimiterMarker"), g) : N === 45 ? (u += 1, g(N)) : N === null || Z(N) ? I(N) : L(N) } function g(N) { return N === 45 ? (e.enter("tableDelimiterFiller"), E(N)) : L(N) } function E(N) { return N === 45 ? (e.consume(N), E) : N === 58 ? (s = !0, e.exit("tableDelimiterFiller"), e.enter("tableDelimiterMarker"), e.consume(N), e.exit("tableDelimiterMarker"), y) : (e.exit("tableDelimiterFiller"), y(N)) } function y(N) { return oe(N) ? fe(e, I, "whitespace")(N) : I(N) } function I(N) { return N === 124 ? m(N) : N === null || Z(N) ? !s || i !== u ? L(N) : (e.exit("tableDelimiterRow"), e.exit("tableHead"), t(N)) : L(N) } function L(N) { return n(N) } function k(N) { return e.enter("tableRow"), P(N) } function P(N) { return N === 124 ? (e.enter("tableCellDivider"), e.consume(N), e.exit("tableCellDivider"), P) : N === null || Z(N) ? (e.exit("tableRow"), t(N)) : oe(N) ? fe(e, P, "whitespace")(N) : (e.enter("data"), j(N)) } function j(N) { return N === null || N === 124 || ge(N) ? (e.exit("data"), P(N)) : (e.consume(N), N === 92 ? W : j) } function W(N) { return N === 92 || N === 124 ? (e.consume(N), j) : j(N) } } function s6(e, t) { let n = -1, r = !0, i = 0, u = [0, 0, 0, 0], s = [0, 0, 0, 0], a = !1, o = 0, l, f, d; const p = new t6; for (; ++n < e.length;) { const h = e[n], m = h[1]; h[0] === "enter" ? m.type === "tableHead" ? (a = !1, o !== 0 && (bp(p, t, o, l, f), f = void 0, o = 0), l = { type: "table", start: Object.assign({}, m.start), end: Object.assign({}, m.end) }, p.add(n, 0, [["enter", l, t]])) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (r = !0, d = void 0, u = [0, 0, 0, 0], s = [0, n + 1, 0, 0], a && (a = !1, f = { type: "tableBody", start: Object.assign({}, m.start), end: Object.assign({}, m.end) }, p.add(n, 0, [["enter", f, t]])), i = m.type === "tableDelimiterRow" ? 2 : f ? 3 : 1) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") ? (r = !1, s[2] === 0 && (u[1] !== 0 && (s[0] = s[1], d = Is(p, t, u, i, void 0, d), u = [0, 0, 0, 0]), s[2] = n)) : m.type === "tableCellDivider" && (r ? r = !1 : (u[1] !== 0 && (s[0] = s[1], d = Is(p, t, u, i, void 0, d)), u = s, s = [u[1], n, 0, 0])) : m.type === "tableHead" ? (a = !0, o = n) : m.type === "tableRow" || m.type === "tableDelimiterRow" ? (o = n, u[1] !== 0 ? (s[0] = s[1], d = Is(p, t, u, i, n, d)) : s[1] !== 0 && (d = Is(p, t, s, i, n, d)), i = 0) : i && (m.type === "data" || m.type === "tableDelimiterMarker" || m.type === "tableDelimiterFiller") && (s[3] = n) } for (o !== 0 && bp(p, t, o, l, f), p.consume(t.events), n = -1; ++n < t.events.length;) { const h = t.events[n]; h[0] === "enter" && h[1].type === "table" && (h[1]._align = r6(t.events, n)) } return e } function Is(e, t, n, r, i, u) { const s = r === 1 ? "tableHeader" : r === 2 ? "tableDelimiter" : "tableData", a = "tableContent"; n[0] !== 0 && (u.end = Object.assign({}, Pr(t.events, n[0])), e.add(n[0], 0, [["exit", u, t]])); const o = Pr(t.events, n[1]); if (u = { type: s, start: Object.assign({}, o), end: Object.assign({}, o) }, e.add(n[1], 0, [["enter", u, t]]), n[2] !== 0) { const l = Pr(t.events, n[2]), f = Pr(t.events, n[3]), d = { type: a, start: Object.assign({}, l), end: Object.assign({}, f) }; if (e.add(n[2], 0, [["enter", d, t]]), r !== 2) { const p = t.events[n[2]], h = t.events[n[3]]; if (p[1].end = Object.assign({}, h[1].end), p[1].type = "chunkText", p[1].contentType = "text", n[3] > n[2] + 1) { const m = n[2] + 1, T = n[3] - n[2] - 1; e.add(m, T, []) } } e.add(n[3] + 1, 0, [["exit", d, t]]) } return i !== void 0 && (u.end = Object.assign({}, Pr(t.events, i)), e.add(i, 0, [["exit", u, t]]), u = void 0), u } function bp(e, t, n, r, i) { const u = [], s = Pr(t.events, n); i && (i.end = Object.assign({}, s), u.push(["exit", i, t])), r.end = Object.assign({}, s), u.push(["exit", r, t]), e.add(n + 1, 0, u) } function Pr(e, t) { const n = e[t], r = n[0] === "enter" ? "start" : "end"; return n[1][r] } const a6 = { name: "tasklistCheck", tokenize: l6 }; function o6() { return { text: { 91: a6 } } } function l6(e, t, n) { const r = this; return i; function i(o) { return r.previous !== null || !r._gfmTasklistFirstContentOfListItem ? n(o) : (e.enter("taskListCheck"), e.enter("taskListCheckMarker"), e.consume(o), e.exit("taskListCheckMarker"), u) } function u(o) { return ge(o) ? (e.enter("taskListCheckValueUnchecked"), e.consume(o), e.exit("taskListCheckValueUnchecked"), s) : o === 88 || o === 120 ? (e.enter("taskListCheckValueChecked"), e.consume(o), e.exit("taskListCheckValueChecked"), s) : n(o) } function s(o) { return o === 93 ? (e.enter("taskListCheckMarker"), e.consume(o), e.exit("taskListCheckMarker"), e.exit("taskListCheck"), a) : n(o) } function a(o) { return Z(o) ? t(o) : oe(o) ? e.check({ tokenize: c6 }, t, n)(o) : n(o) } } function c6(e, t, n) { return fe(e, r, "whitespace"); function r(i) { return i === null ? n(i) : t(i) } } function f6(e) { return fE([Mw(), Ww(), e6(e), i6(), o6()]) } const d6 = {}; function h6(e) { const t = this, n = e || d6, r = t.data(), i = r.micromarkExtensions || (r.micromarkExtensions = []), u = r.fromMarkdownExtensions || (r.fromMarkdownExtensions = []), s = r.toMarkdownExtensions || (r.toMarkdownExtensions = []); i.push(f6(n)), u.push(Lw()), s.push(Rw(n)) } const xp = /[#.]/g; function p6(e, t) { const n = e || "", r = {}; let i = 0, u, s; for (; i < n.length;) { xp.lastIndex = i; const a = xp.exec(n), o = n.slice(i, a ? a.index : n.length); o && (u ? u === "#" ? r.id = o : Array.isArray(r.className) ? r.className.push(o) : r.className = [o] : s = o, i += o.length), a && (u = a[0], i++) } return { type: "element", tagName: s || t || "div", properties: r, children: [] } } function rT(e, t, n) { const r = n ? T6(n) : void 0; function i(u, s, ...a) { let o; if (u == null) { o = { type: "root", children: [] }; const l = s; a.unshift(l) } else { o = p6(u, t); const l = o.tagName.toLowerCase(), f = r ? r.get(l) : void 0; if (o.tagName = f || l, m6(s)) a.unshift(s); else for (const [d, p] of Object.entries(s)) g6(e, o.properties, d, p) } for (const l of a) Bc(o.children, l); return o.type === "element" && o.tagName === "template" && (o.content = { type: "root", children: o.children }, o.children = []), o } return i } function m6(e) { if (e === null || typeof e != "object" || Array.isArray(e)) return !0; if (typeof e.type != "string") return !1; const t = e, n = Object.keys(e); for (const r of n) { const i = t[r]; if (i && typeof i == "object") { if (!Array.isArray(i)) return !0; const u = i; for (const s of u) if (typeof s != "number" && typeof s != "string") return !0 } } return !!("children" in e && Array.isArray(e.children)) } function g6(e, t, n, r) { const i = ro(e, n); let u; if (r != null) { if (typeof r == "number") { if (Number.isNaN(r)) return; u = r } else typeof r == "boolean" ? u = r : typeof r == "string" ? i.spaceSeparated ? u = I0(r) : i.commaSeparated ? u = _0(r) : i.commaOrSpaceSeparated ? u = I0(_0(r).join(" ")) : u = Sp(i, i.property, r) : Array.isArray(r) ? u = [...r] : u = i.property === "style" ? E6(r) : String(r); if (Array.isArray(u)) { const s = []; for (const a of u) s.push(Sp(i, i.property, a)); u = s } i.property === "className" && Array.isArray(t.className) && (u = t.className.concat(u)), t[i.property] = u } } function Bc(e, t) { if (t != null) if (typeof t == "number" || typeof t == "string") e.push({ type: "text", value: String(t) }); else if (Array.isArray(t)) for (const n of t) Bc(e, n); else if (typeof t == "object" && "type" in t) t.type === "root" ? Bc(e, t.children) : e.push(t); else throw new Error("Expected node, nodes, or string, got `" + t + "`") } function Sp(e, t, n) { if (typeof n == "string") { if (e.number && n && !Number.isNaN(Number(n))) return Number(n); if ((e.boolean || e.overloadedBoolean) && (n === "" || Bu(n) === Bu(t))) return !0 } return n } function E6(e) { const t = []; for (const [n, r] of Object.entries(e)) t.push([n, r].join(": ")); return t.join("; ") } function T6(e) { const t = new Map; for (const n of e) t.set(n.toLowerCase(), n); return t } const y6 = ["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feDropShadow", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "solidColor", "textArea", "textPath"], b6 = rT(Zu, "div"), x6 = rT(Qn, "g", y6); function S6(e) { const t = String(e), n = []; return { toOffset: i, toPoint: r }; function r(u) { if (typeof u == "number" && u > -1 && u <= t.length) { let s = 0; for (; ;) { let a = n[s]; if (a === void 0) { const o = _p(t, n[s - 1]); a = o === -1 ? t.length + 1 : o + 1, n[s] = a } if (a > u) return { line: s + 1, column: u - (s > 0 ? n[s - 1] : 0) + 1, offset: u }; s++ } } } function i(u) { if (u && typeof u.line == "number" && typeof u.column == "number" && !Number.isNaN(u.line) && !Number.isNaN(u.column)) { for (; n.length < u.line;) { const a = n[n.length - 1], o = _p(t, a), l = o === -1 ? t.length + 1 : o + 1; if (a === l) break; n.push(l) } const s = (u.line > 1 ? n[u.line - 2] : 0) + u.column - 1; if (s < n[u.line - 1]) return s } } } function _p(e, t) {
        const n = e.indexOf("\r", t), r = e.indexOf(`
`, t); return r === -1 ? n : n === -1 || n + 1 === r ? r : n < r ? n : r
      } const or = { html: "http://www.w3.org/1999/xhtml", mathml: "http://www.w3.org/1998/Math/MathML", svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink", xml: "http://www.w3.org/XML/1998/namespace", xmlns: "http://www.w3.org/2000/xmlns/" }, iT = {}.hasOwnProperty, _6 = Object.prototype; function C6(e, t) { const n = t || {}; return fd({ file: n.file || void 0, location: !1, schema: n.space === "svg" ? Qn : Zu, verbose: n.verbose || !1 }, e) } function fd(e, t) { let n; switch (t.nodeName) { case "#comment": { const r = t; return n = { type: "comment", value: r.data }, Qs(e, r, n), n } case "#document": case "#document-fragment": { const r = t, i = "mode" in r ? r.mode === "quirks" || r.mode === "limited-quirks" : !1; if (n = { type: "root", children: uT(e, t.childNodes), data: { quirksMode: i } }, e.file && e.location) { const u = String(e.file), s = S6(u), a = s.toPoint(0), o = s.toPoint(u.length); n.position = { start: a, end: o } } return n } case "#documentType": { const r = t; return n = { type: "doctype" }, Qs(e, r, n), n } case "#text": { const r = t; return n = { type: "text", value: r.value }, Qs(e, r, n), n } default: return n = A6(e, t), n } } function uT(e, t) { let n = -1; const r = []; for (; ++n < t.length;) { const i = fd(e, t[n]); r.push(i) } return r } function A6(e, t) { const n = e.schema; e.schema = t.namespaceURI === or.svg ? Qn : Zu; let r = -1; const i = {}; for (; ++r < t.attrs.length;) { const a = t.attrs[r], o = (a.prefix ? a.prefix + ":" : "") + a.name; iT.call(_6, o) || (i[o] = a.value) } const s = (e.schema.space === "svg" ? x6 : b6)(t.tagName, i, uT(e, t.childNodes)); if (Qs(e, t, s), s.tagName === "template") { const a = t, o = a.sourceCodeLocation, l = o && o.startTag && Kr(o.startTag), f = o && o.endTag && Kr(o.endTag), d = fd(e, a.content); l && f && e.file && (d.position = { start: l.end, end: f.start }), s.content = d } return e.schema = n, s } function Qs(e, t, n) { if ("sourceCodeLocation" in t && t.sourceCodeLocation && e.file) { const r = k6(e, n, t.sourceCodeLocation); r && (e.location = !0, n.position = r) } } function k6(e, t, n) { const r = Kr(n); if (t.type === "element") { const i = t.children[t.children.length - 1]; if (r && !n.endTag && i && i.position && i.position.end && (r.end = Object.assign({}, i.position.end)), e.verbose) { const u = {}; let s; if (n.attrs) for (s in n.attrs) iT.call(n.attrs, s) && (u[ro(e.schema, s).property] = Kr(n.attrs[s])); n.startTag; const a = Kr(n.startTag), o = n.endTag ? Kr(n.endTag) : void 0, l = { opening: a }; o && (l.closing = o), l.properties = u, t.data = { position: l } } } return r } function Kr(e) { const t = Cp({ line: e.startLine, column: e.startCol, offset: e.startOffset }), n = Cp({ line: e.endLine, column: e.endCol, offset: e.endOffset }); return t || n ? { start: t, end: n } : void 0 } function Cp(e) { return e.line && e.column ? e : void 0 } const N6 = {}, I6 = {}.hasOwnProperty, sT = FE("type", { handlers: { root: v6, element: D6, text: R6, comment: P6, doctype: L6 } }); function w6(e, t) { const r = (t || N6).space; return sT(e, r === "svg" ? Qn : Zu) } function v6(e, t) { const n = { nodeName: "#document", mode: (e.data || {}).quirksMode ? "quirks" : "no-quirks", childNodes: [] }; return n.childNodes = dd(e.children, n, t), Ci(e, n), n } function O6(e, t) { const n = { nodeName: "#document-fragment", childNodes: [] }; return n.childNodes = dd(e.children, n, t), Ci(e, n), n } function L6(e) { const t = { nodeName: "#documentType", name: "html", publicId: "", systemId: "", parentNode: null }; return Ci(e, t), t } function R6(e) { const t = { nodeName: "#text", value: e.value, parentNode: null }; return Ci(e, t), t } function P6(e) { const t = { nodeName: "#comment", data: e.value, parentNode: null }; return Ci(e, t), t } function D6(e, t) { const n = t; let r = n; e.type === "element" && e.tagName.toLowerCase() === "svg" && n.space === "html" && (r = Qn); const i = []; let u; if (e.properties) { for (u in e.properties) if (u !== "children" && I6.call(e.properties, u)) { const o = M6(r, u, e.properties[u]); o && i.push(o) } } const s = r.space, a = { nodeName: e.tagName, tagName: e.tagName, attrs: i, namespaceURI: or[s], childNodes: [], parentNode: null }; return a.childNodes = dd(e.children, a, r), Ci(e, a), e.tagName === "template" && e.content && (a.content = O6(e.content, r)), a } function M6(e, t, n) { const r = ro(e, t); if (n === !1 || n === null || n === void 0 || typeof n == "number" && Number.isNaN(n) || !n && r.boolean) return; Array.isArray(n) && (n = r.commaSeparated ? G1(n) : iE(n)); const i = { name: r.attribute, value: n === !0 ? "" : String(n) }; if (r.space && r.space !== "html" && r.space !== "svg") { const u = i.name.indexOf(":"); u < 0 ? i.prefix = "" : (i.name = i.name.slice(u + 1), i.prefix = r.attribute.slice(0, u)), i.namespace = or[r.space] } return i } function dd(e, t, n) { let r = -1; const i = []; if (e) for (; ++r < e.length;) { const u = sT(e[r], n); u.parentNode = t, i.push(u) } return i } function Ci(e, t) { const n = e.position; n && n.start && n.end && (n.start.offset, n.end.offset, t.sourceCodeLocation = { startLine: n.start.line, startCol: n.start.column, startOffset: n.start.offset, endLine: n.end.line, endCol: n.end.column, endOffset: n.end.offset }) } const F6 = ["area", "base", "basefont", "bgsound", "br", "col", "command", "embed", "frame", "hr", "image", "img", "input", "keygen", "link", "meta", "param", "source", "track", "wbr"], B6 = new Set([65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111]), Se = ""; var b; (function (e) { e[e.EOF = -1] = "EOF", e[e.NULL = 0] = "NULL", e[e.TABULATION = 9] = "TABULATION", e[e.CARRIAGE_RETURN = 13] = "CARRIAGE_RETURN", e[e.LINE_FEED = 10] = "LINE_FEED", e[e.FORM_FEED = 12] = "FORM_FEED", e[e.SPACE = 32] = "SPACE", e[e.EXCLAMATION_MARK = 33] = "EXCLAMATION_MARK", e[e.QUOTATION_MARK = 34] = "QUOTATION_MARK", e[e.AMPERSAND = 38] = "AMPERSAND", e[e.APOSTROPHE = 39] = "APOSTROPHE", e[e.HYPHEN_MINUS = 45] = "HYPHEN_MINUS", e[e.SOLIDUS = 47] = "SOLIDUS", e[e.DIGIT_0 = 48] = "DIGIT_0", e[e.DIGIT_9 = 57] = "DIGIT_9", e[e.SEMICOLON = 59] = "SEMICOLON", e[e.LESS_THAN_SIGN = 60] = "LESS_THAN_SIGN", e[e.EQUALS_SIGN = 61] = "EQUALS_SIGN", e[e.GREATER_THAN_SIGN = 62] = "GREATER_THAN_SIGN", e[e.QUESTION_MARK = 63] = "QUESTION_MARK", e[e.LATIN_CAPITAL_A = 65] = "LATIN_CAPITAL_A", e[e.LATIN_CAPITAL_Z = 90] = "LATIN_CAPITAL_Z", e[e.RIGHT_SQUARE_BRACKET = 93] = "RIGHT_SQUARE_BRACKET", e[e.GRAVE_ACCENT = 96] = "GRAVE_ACCENT", e[e.LATIN_SMALL_A = 97] = "LATIN_SMALL_A", e[e.LATIN_SMALL_Z = 122] = "LATIN_SMALL_Z" })(b || (b = {})); const ut = { DASH_DASH: "--", CDATA_START: "[CDATA[", DOCTYPE: "doctype", SCRIPT: "script", PUBLIC: "public", SYSTEM: "system" }; function aT(e) { return e >= 55296 && e <= 57343 } function U6(e) { return e >= 56320 && e <= 57343 } function H6(e, t) { return (e - 55296) * 1024 + 9216 + t } function oT(e) { return e !== 32 && e !== 10 && e !== 13 && e !== 9 && e !== 12 && e >= 1 && e <= 31 || e >= 127 && e <= 159 } function lT(e) { return e >= 64976 && e <= 65007 || B6.has(e) } var R; (function (e) { e.controlCharacterInInputStream = "control-character-in-input-stream", e.noncharacterInInputStream = "noncharacter-in-input-stream", e.surrogateInInputStream = "surrogate-in-input-stream", e.nonVoidHtmlElementStartTagWithTrailingSolidus = "non-void-html-element-start-tag-with-trailing-solidus", e.endTagWithAttributes = "end-tag-with-attributes", e.endTagWithTrailingSolidus = "end-tag-with-trailing-solidus", e.unexpectedSolidusInTag = "unexpected-solidus-in-tag", e.unexpectedNullCharacter = "unexpected-null-character", e.unexpectedQuestionMarkInsteadOfTagName = "unexpected-question-mark-instead-of-tag-name", e.invalidFirstCharacterOfTagName = "invalid-first-character-of-tag-name", e.unexpectedEqualsSignBeforeAttributeName = "unexpected-equals-sign-before-attribute-name", e.missingEndTagName = "missing-end-tag-name", e.unexpectedCharacterInAttributeName = "unexpected-character-in-attribute-name", e.unknownNamedCharacterReference = "unknown-named-character-reference", e.missingSemicolonAfterCharacterReference = "missing-semicolon-after-character-reference", e.unexpectedCharacterAfterDoctypeSystemIdentifier = "unexpected-character-after-doctype-system-identifier", e.unexpectedCharacterInUnquotedAttributeValue = "unexpected-character-in-unquoted-attribute-value", e.eofBeforeTagName = "eof-before-tag-name", e.eofInTag = "eof-in-tag", e.missingAttributeValue = "missing-attribute-value", e.missingWhitespaceBetweenAttributes = "missing-whitespace-between-attributes", e.missingWhitespaceAfterDoctypePublicKeyword = "missing-whitespace-after-doctype-public-keyword", e.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers = "missing-whitespace-between-doctype-public-and-system-identifiers", e.missingWhitespaceAfterDoctypeSystemKeyword = "missing-whitespace-after-doctype-system-keyword", e.missingQuoteBeforeDoctypePublicIdentifier = "missing-quote-before-doctype-public-identifier", e.missingQuoteBeforeDoctypeSystemIdentifier = "missing-quote-before-doctype-system-identifier", e.missingDoctypePublicIdentifier = "missing-doctype-public-identifier", e.missingDoctypeSystemIdentifier = "missing-doctype-system-identifier", e.abruptDoctypePublicIdentifier = "abrupt-doctype-public-identifier", e.abruptDoctypeSystemIdentifier = "abrupt-doctype-system-identifier", e.cdataInHtmlContent = "cdata-in-html-content", e.incorrectlyOpenedComment = "incorrectly-opened-comment", e.eofInScriptHtmlCommentLikeText = "eof-in-script-html-comment-like-text", e.eofInDoctype = "eof-in-doctype", e.nestedComment = "nested-comment", e.abruptClosingOfEmptyComment = "abrupt-closing-of-empty-comment", e.eofInComment = "eof-in-comment", e.incorrectlyClosedComment = "incorrectly-closed-comment", e.eofInCdata = "eof-in-cdata", e.absenceOfDigitsInNumericCharacterReference = "absence-of-digits-in-numeric-character-reference", e.nullCharacterReference = "null-character-reference", e.surrogateCharacterReference = "surrogate-character-reference", e.characterReferenceOutsideUnicodeRange = "character-reference-outside-unicode-range", e.controlCharacterReference = "control-character-reference", e.noncharacterCharacterReference = "noncharacter-character-reference", e.missingWhitespaceBeforeDoctypeName = "missing-whitespace-before-doctype-name", e.missingDoctypeName = "missing-doctype-name", e.invalidCharacterSequenceAfterDoctypeName = "invalid-character-sequence-after-doctype-name", e.duplicateAttribute = "duplicate-attribute", e.nonConformingDoctype = "non-conforming-doctype", e.missingDoctype = "missing-doctype", e.misplacedDoctype = "misplaced-doctype", e.endTagWithoutMatchingOpenElement = "end-tag-without-matching-open-element", e.closingOfElementWithOpenChildElements = "closing-of-element-with-open-child-elements", e.disallowedContentInNoscriptInHead = "disallowed-content-in-noscript-in-head", e.openElementsLeftAfterEof = "open-elements-left-after-eof", e.abandonedHeadElementChild = "abandoned-head-element-child", e.misplacedStartTagForHeadElement = "misplaced-start-tag-for-head-element", e.nestedNoscriptInHead = "nested-noscript-in-head", e.eofInElementThatCanContainOnlyText = "eof-in-element-that-can-contain-only-text" })(R || (R = {})); const z6 = 65536; class j6 { constructor(t) { this.handler = t, this.html = "", this.pos = -1, this.lastGapPos = -2, this.gapStack = [], this.skipNextNewLine = !1, this.lastChunkWritten = !1, this.endOfChunkHit = !1, this.bufferWaterline = z6, this.isEol = !1, this.lineStartPos = 0, this.droppedBufferSize = 0, this.line = 1, this.lastErrOffset = -1 } get col() { return this.pos - this.lineStartPos + +(this.lastGapPos !== this.pos) } get offset() { return this.droppedBufferSize + this.pos } getError(t, n) { const { line: r, col: i, offset: u } = this, s = i + n, a = u + n; return { code: t, startLine: r, endLine: r, startCol: s, endCol: s, startOffset: a, endOffset: a } } _err(t) { this.handler.onParseError && this.lastErrOffset !== this.offset && (this.lastErrOffset = this.offset, this.handler.onParseError(this.getError(t, 0))) } _addGap() { this.gapStack.push(this.lastGapPos), this.lastGapPos = this.pos } _processSurrogate(t) { if (this.pos !== this.html.length - 1) { const n = this.html.charCodeAt(this.pos + 1); if (U6(n)) return this.pos++, this._addGap(), H6(t, n) } else if (!this.lastChunkWritten) return this.endOfChunkHit = !0, b.EOF; return this._err(R.surrogateInInputStream), t } willDropParsedChunk() { return this.pos > this.bufferWaterline } dropParsedChunk() { this.willDropParsedChunk() && (this.html = this.html.substring(this.pos), this.lineStartPos -= this.pos, this.droppedBufferSize += this.pos, this.pos = 0, this.lastGapPos = -2, this.gapStack.length = 0) } write(t, n) { this.html.length > 0 ? this.html += t : this.html = t, this.endOfChunkHit = !1, this.lastChunkWritten = n } insertHtmlAtCurrentPos(t) { this.html = this.html.substring(0, this.pos + 1) + t + this.html.substring(this.pos + 1), this.endOfChunkHit = !1 } startsWith(t, n) { if (this.pos + t.length > this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, !1; if (n) return this.html.startsWith(t, this.pos); for (let r = 0; r < t.length; r++)if ((this.html.charCodeAt(this.pos + r) | 32) !== t.charCodeAt(r)) return !1; return !0 } peek(t) { const n = this.pos + t; if (n >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, b.EOF; const r = this.html.charCodeAt(n); return r === b.CARRIAGE_RETURN ? b.LINE_FEED : r } advance() { if (this.pos++, this.isEol && (this.isEol = !1, this.line++, this.lineStartPos = this.pos), this.pos >= this.html.length) return this.endOfChunkHit = !this.lastChunkWritten, b.EOF; let t = this.html.charCodeAt(this.pos); return t === b.CARRIAGE_RETURN ? (this.isEol = !0, this.skipNextNewLine = !0, b.LINE_FEED) : t === b.LINE_FEED && (this.isEol = !0, this.skipNextNewLine) ? (this.line--, this.skipNextNewLine = !1, this._addGap(), this.advance()) : (this.skipNextNewLine = !1, aT(t) && (t = this._processSurrogate(t)), this.handler.onParseError === null || t > 31 && t < 127 || t === b.LINE_FEED || t === b.CARRIAGE_RETURN || t > 159 && t < 64976 || this._checkForProblematicCharacters(t), t) } _checkForProblematicCharacters(t) { oT(t) ? this._err(R.controlCharacterInInputStream) : lT(t) && this._err(R.noncharacterInInputStream) } retreat(t) { for (this.pos -= t; this.pos < this.lastGapPos;)this.lastGapPos = this.gapStack.pop(), this.pos--; this.isEol = !1 } } var se; (function (e) { e[e.CHARACTER = 0] = "CHARACTER", e[e.NULL_CHARACTER = 1] = "NULL_CHARACTER", e[e.WHITESPACE_CHARACTER = 2] = "WHITESPACE_CHARACTER", e[e.START_TAG = 3] = "START_TAG", e[e.END_TAG = 4] = "END_TAG", e[e.COMMENT = 5] = "COMMENT", e[e.DOCTYPE = 6] = "DOCTYPE", e[e.EOF = 7] = "EOF", e[e.HIBERNATION = 8] = "HIBERNATION" })(se || (se = {})); function cT(e, t) { for (let n = e.attrs.length - 1; n >= 0; n--)if (e.attrs[n].name === t) return e.attrs[n].value; return null } const $6 = new Uint16Array('<\0\0\0\0\0\0EMabcfglmnoprstu\\bfmsligP&cutereve;iyx}rc;r;ravepha;acr;d;gpon;f;plyFunction;ingcsr;ign;ildemlaceforsucrkslash;;ed;y;crtause;noullis;a;r;pf;eve;cmpeq;HOacdefhilorsucy;PYcpyute;;italDifferentialD;leys;aeioron;dilrc;nint;ot;dnilla;terDot;i;rcleDMPTot;inus;lus;imes;ocskwiseContourIntegral;eCurlyDQoubleQuote;uote;lnpuon;e;gitruent;nt;ourIntegral;fr;oduct;nterClockwiseContourIntegral;oss;cr;p;Cap;DJSZacefios;otrahd;cy;cy;cy;grsger;r;hv;ayron;;l;ta;r;afcmriticalADGTcute;o;bleAcute;rave;ilde;ond;ferentialD;\0\0\0\0f;;DEot;qual;bleCDLRUVontourIntegrao\0\0nArrow;eoftARTrrow;ightArrow;engLReftARrrow;ightArrow;ightArrow;ightATrrow;ee;p\0\0rrow;ownArrow;erticalBar;nABLRTarrow;BUar;pArrow;reve;eft\0\0ightVector;eeVector;ector;Bar;ight\0eeVector;ector;Bar;ee;Arrow;ctr;rok;NTacdfglmopqstuxG;Hcuteaiyron;rc;ot;r;raveement;apcr;ty\0\0mallSquare;erySmallSquare;gpon;f;silon;uail;Tilde;librium;cir;m;a;mlipsts;onentialE;cfiosy;r;lled\0\0mallSquare;erySmallSquare;\0\0\0f;All;riertrf;cJTabcdfgorstcy;>mma;d;reve;eiydil;rc;;ot;r;;pf;eaterEFGLSTqual;Less;ullEqual;reater;ess;lantEqual;ilde;cr;;AacfiosuRDcy;ctek;;irc;r;lbertSpace;\0f;izontalLine;ctrok;mpownHumqual;EJOacdfgmnostucy;lig;cy;cuteiyrc;ot;r;rave;apcgr;inaryI;lie\0;egrral;section;isibleCTomma;imes;gpton;f;a;cr;ilde;\0cy;lcfosuiyrc;;r;pf;\0r;rcy;kcy;HJacfoscy;cy;ppa;eydil;;r;pf;cr;JTaceflmostcy;<cmnprute;bda;g;lacetrf;r;aeyron;dil;;fstACDFRTUVarnrgleBracket;row;BRar;ightArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ightAVrrow;ector;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;ightsEFGLSTqualGreater;ullEqual;reater;ess;lantEqual;ilde;r;;eftarrow;idot;npwgLRlreftARrrow;ightArrow;ightArrow;eftarightightf;erLReftArrow;ightArrow;cht;rok;;acefiosup;y;dliumSpace;lintrf;r;nusPlus;pf;c;Jacefostucy;cute;aeyron;dil;;gswativeMTVediumSpace;hicneryThitedGLreaterGreateessLesLine;r;Bnptreak;BreakingSpace;f;;CDEGHLNPRSTVoungruent;pCap;oubleVerticalBar;lqxement;ual;Tilde;ists;reater;EFGLSTqual;ullEqual;reater;ess;lantEqual;ilde;umpownHump;qual;efstTriangle;BEar;qual;s;EGLSTqual;reater;ess;lantEqual;ilde;estedGLreaterGreater;essLess;recedes;ESqual;lantEqual;eiverseElement;ghtTriangle;BEar;qual;quuareSubpset;Equal;erset;Equal;bcpset;Equal;ceeds;ESTqual;lantEqual;ilde;erset;Equal;ilde;EFTqual;ullEqual;ilde;erticalBar;cr;ilde;Eacdfgmoprstuvlig;cuteiyrc;blac;r;raveaeicr;ga;cron;pf;enCurlyDQoubleQuote;uote;;clr;ashidees;mlerBParr;acek;et;arenthesis;acfhilorsrtialD;y;r;i;;usMinus;ipncareplanf;;eiocedes;ESTqual;lantEqual;ilde;me;dpuct;ortion;al;cir;;UfosOT"r;pf;cr;BEacefhiorsuarr;Gcnrute;g;r;tl;aeyron;dil;;;verseEUlqement;uilibrium;pEquilibrium;ro;ghtACDFTUVanrgleBracket;row;BLar;eftArrow;eiling;o\0bleBracket;n\0eeVector;ector;Bar;loor;ere;AVrrow;ector;iangle;BEar;qual;pDTVownVector;eeVector;ector;Bar;ector;Bar;puf;ndImplies;ightarrow;chr;;leDelayed;HOacfhimoqstuCcHcy;y;FTcy;cute;;aeiyron;dil;rc;;r;ortDLRUownArroweftArrowightArrowpArrow;gma;allCircle;pf;\0\0t;are;ISUntersection;ubpset;Equal;erset;Equal;nion;cr;ar;bcmp;set;Equal;cheeds;ESTqual;lantEqual;ilde;Th;;esrset;Equal;etHRSacfhiorsORNADE;Hccy;y;bu;;aeyron;dil;;r;ei\0efore;a;cnkSpace;Space;lde;EFTqual;ullEqual;ilde;pf;ipleDot;ctr;rok;\0\0\0\0\0\0\0cruter;ocir;r\0y;ve;iyrc;blac;r;raveacr;dierBParr;acek;et;arenthesis;on;Plus;gpon;f;ADETadpsrrow;BDar;ownArrow;ownArrow;quilibrium;ee;Arrow;ownerLReftArrow;ightArrow;i;lon;ing;cr;ilde;mlDbcdefosvash;ar;y;ash;l;er;btyar;;icalBLSTar;ine;eparator;ilde;ThinSpace;r;pf;cr;dash;cefosirc;dge;r;pf;cr;fiosr;;pf;cr;AIUacfosucy;cy;cy;cuteiyrc;;r;pf;cr;ml;Hacdefoscy;cute;ayron;;ot;\0oWidta;r;pf;cr;\0\0\0\0\0\0\0cutereve;;Ediuy;;rcte;lig;r;raveepfpsym;ha;apcclr;g;\0\0;adsvnd;;lope;;;elmrsz;esd;a;;;;;;;;t;vb;d;pth;arr;gpon;f;;Eaeiop;cir;;d;s;rox;eingctyr;;mp;eildemlcioninnt;Nabcdefiklnoprsuot;crkcepsong;psilon;rime;im;eq;ee;ed;gerk;tbrk;oy;quo;cmprtaus;eptyv;snoahw;;een;r;gcostuvwaiurc;pdptot;lus;imes;\0\0cup;ar;riangleduown;p;plus;earow;akocnklstozenge;riangle;dlrown;eft;ight;k;\0\0;;4;ck;eo;q=uiv;t;ptwxf;;tomtie;DHUVbdhmptuvLRlr;;;;;DUdu;;;;LRlr;;;;;HLRhlr;;;;;;ox;LRlr;;;;;DUdu;;;;inus;lus;imes;LRlr;;;;;HLRhlr;;;;;;evbarceior;mi;m;el;bh;sub;l;etp;Ee;;q\0\0\0\0\0\0\0\0\0\0cprute;;abcdsnd;rcup;aup;p;ot;;eot;aeiu\0s;on;dilrc;ps;sm;ot;dmnilptyv;t;err;ceiy;ck;mark;r;Ecefms;;elq;e\0\0rrowlreft;ight;RSacd;st;irc;ash;nint;id;cir;ubs;uit\0on;e;q\0\0a;t;;flemxente\0;dot;nfry;o;sr;aorr;ss;cur;bp;e;;e;dot;delprvwarrlr;;\0\0r;c;arr;p;;bcdosrcap;aup;p;ot;r;;alrvrr;m;yevwq\0\0reuee;edge;enearrowlreftightecioninnt;lcty;AHabcdefhijlorstuwzrar;glrsger;eth;h;varow;aayron;;;aogrr;tseq;glmta;ptyv;irsht;;arlraegsvm;osnd;suit;amma;in;;iode;ontimes;ncy;c\0\0rn;op;lptuwlar;f;;empsq;dot;inus;lus;quare;blebarwedgnadhownarrowarpoonlrefighkaro\0\0rn;op;cotry;;l;rok;drot;i;fahraangle;ciy;grarr;DacdefglmnopqrstuxDoocsuteter;aioyron;r;clon;;ot;Drot;;;rsave;dot;;ilsnters;;;dot;apscr;ty;svetp1;;;gs;p;gpon;f;alsr;sl;us;i;lvon;csuviorc\0\0antgltressaeils;st;v;DD;parsl;Daot;rr;cdir;oah;mrlo;cipl;seoctationential\0\0\0\0\0\0\0llingdotsey;male;ilrlig;\0\0g;ig;;lig;lig;fjaltt;ig;ns;of;\0f;ak;v;artint;aocs\0\0;;;;\0;;\0\0;;5;\0;;8;l;wn;cr;Eabcdefgijlnorstv;l;cmpute;ma;d;reve;iyrc;;ot;;lqs;qslan;cdlc;ot;o;l;;es;r;;gmel;cy;;Eaj;;;Eaes;p;prox;q;qim;pf;cir;m;el;;>;cdlqrci;r;ot;Par;uest;adels\0pror;qlqlesienrtneqq;Aabcefkosyrilmrrsfildrcy;;cwir;;ar;irc;alrrts;uitlip;con;r;sewarow;arow;amoprrr;tht;klreftarrow;ightarrow;f;bar;cltr;asrok;bpull;hen\0\0\0\0\0\0cute;iyrc;cxy;clfr;rave;inoinnt;t;fin;ta;lig;aopcgtr;elpinarh;f;ed;;cfotare;in;tie;do;celpal;grerarhk;rod;cgpty;on;f;a;uestcir;n;Edsv;ot;;v;;ilde;\0cy;lcfmosuiyrc;;r;ath;pf;\0r;rcy;kcy;acfghjosppa;v;eydil;;r;reen;cy;cy;pf;cr;ABEHabcdefghjlmnoprstuvartrail;arr;;g;ar;\0\0\0\0\0\0\0\0\0ute;mptyv;rabda;g;dl;;uor;bfhlpst;fs;s;p;l;im;l;;aeil;;s;abrrr;rk;akcek;;es;ldu;;aeuyron;diil;;cqrsa;uo;rduhar;shar;h;;fgqstahlrtrrow;taarpoonduownpeftarrows;ightahsrrow;sarpoonquigarrohreetimes;;qslan;cdgsc;ot;o;r;;es;adegspproot;qgqgtiilrsht;;;E;rdu;l;lk;cy;;achtrorneard;ri;iodot;ust;acheEaes;p;prox;q;qim;abnoptwznrg;r;rglmreftarightapsto;ightparrowlrefight;aflr;;us;imes;st;;efngear;lt;achmtrornear;d;;ri;achiqtquo;r;m;eg;;buo;r;rok;<;cdhilqrci;r;remes;arr;uest;Piar;;efrdushar;har;enrtneqq;DacdefhilnopsuDot;clprret;;ese;sto;dluowefker;oymma;;ash;asuredangler;o;cdnro;acdsir;otus;bd;u;p;dpels;f;ctr;pos;lmtimap;GLRVabcdefghijlmoprstuvwgt;;veltftarrrow;ightarrow;;;vightarrow;Ddash;ash;bcnptlaute;g;;Eiop;d;s;rour;al;s\0pmp;eaeouy\0;on;dil;ng;dot;p;;ash;;Aadqsxrr;rhrk;;oot;uieiar;ist;sr;Eest;qs;qslani;rAaprrr;ar;;sv;d;cy;AEadestr;rr;r;;fqstarrroightarro;qslan;si;ri;eiptf;;inn;Edv;ot;;;i;v;;aorr;astllel;;lint;;ceu;c;eAaitrrr;cw;;ghtarrowri;echimpqu;ceru;ort\0\0arm;e;qsubpbcp;Ees;et;eq;qc;e;Ees;et;eq;qgilrldeianglelreft;eight;e;m;esro;p;DHadgilrsash;arr;p;ash;et;;>nfin;Aetrr;;;r<ie;Atrr;rie;im;Aanrr;rhrk;;oear;\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0csuteiyr;c;abioslac;v;old;lig;crir;;\0\0\0n;ave;bmar;acitrirr;oss;n;aeicr;ga;cdnron;;pf;aelr;rp;;adiosvr;efmr;ofgof;r;lope;;cloashl;idees;as;mlbar;\0\0\0\0\0\0\0\0\0r;ast;lle\0\0m;;y;rcimptnt;od;il;enk;r;imo;v;mane;;tvchfork;aunckk;h;s;abcdemstcir;ir;ou;;nim;wo;ipuntint;f;nd;Eaceinosu;p;u;c;acenspprourlyeaespprox;qq;im;ime;sEasdfpalslar;ine;urf;;trel;cir;;ncsp;fiopsur;pf;rime;cr;aeoteirnionnt;st;eABHabcdefhilmnoprstuxartrail;arar;cdenqrteu;te;imptyv;g;del;;uor;abcfhlpstwp;;fs;;s;l;im;l;;aiil;o;nalabrrrk;akcek;;es;ldu;;aeuyron;diil;;clqsa;dhar;uo;rh;acgl;ipsnart;ilrsht;;aordu;l;;v;gnshtahlrstrrow;taarpoonduowpeftahrrowarpoonightarrows;quigarrohreetimes;g;ingdotseahmra;oust;achemid;abptnrg;r;raflr;;us;imes;apr;gt;olint;arachqquo;r;buo;rhirremes;i;efltri;luhar;;\0\0\0\0\0\0\0cute;qu;Eaceinpsy;\0;on;u;dil;rc;Eas;p;im;olint;i;ot;be;Aacmstxrr;rhr;oti;war;minnut;r;oacoyrp;hycy;;rt\0\0iaragmma;fv;;deglnprot;;q;E;;E;e;lus;arr;araeitlslsetmhp;parsl;dle;;e;s;flptcy;;b;ar;f;adres;uitcsuaup;s;p;s;ubp;eset;e;eset;e;afrarcemtr;tmiararr;fanighteppsilohsbcmnp;Edemnprs;ot;;dot;ult;Ee;;lus;arr;eiut;enq;qeq;qm;bp;;c;acenspprourlyeaespproqg;123;Edehlmnps;ost;ub;;dot;soul;b;arr;ult;Ee;;lus;eiut;enq;qeq;qm;bp;;Aanrr;rhr;owar;lig\0\0\0\0\0\0\0\0\0\0\0\0get;;raeyron;dil;;lrec;r;eiko\0e4fa;svym;cnkaspproimsasrnes;bd;ar;;eps;bcfot;ir;;ork;rime;aipdadempstngle;dlqrowneft;e;ight;eot;inus;lus;b;ime;ezium;chtry;;cy;rok;ioxheadlreftarroightarrowAHabcdfghlmoprstuwrar;cruter\0y;ve;iyrc;abhrlac;airsht;;raverlrlk;ct\0\0rn;erop;ri;alcr;gpon;f;adhlsuownarpoonlrefighi;hlonparrows;cit\0\0rn;erop;ng;ri;cr;dirot;lde;i;famrlangle;ABDacdeflnoprszrar;v;asnrgrt;eknprstappothinhirop;hiugmbpsetneq;q;setneq;q;hretianglelreftighty;ashelr;bear;q;lip;btar;trsubppf;rotrcur;bpnEenEeigzag;cefoprsirc;dibgar;e;q;erp;r;pf;;eatcr;\0\0\0\0\0\0\0trr;Aarr;Aarrais;dptfl;imAarrcqr;ptracefiosucuyte;iyrc;;nr;cy;pf;cr;cmy;lacdefhioswcute;ayron;;ot;ettra;r;cy;grarr;pf;cr;jn;j;'.split("").map(e => e.charCodeAt(0))), V6 = new Map([[0, 65533], [128, 8364], [130, 8218], [131, 402], [132, 8222], [133, 8230], [134, 8224], [135, 8225], [136, 710], [137, 8240], [138, 352], [139, 8249], [140, 338], [142, 381], [145, 8216], [146, 8217], [147, 8220], [148, 8221], [149, 8226], [150, 8211], [151, 8212], [152, 732], [153, 8482], [154, 353], [155, 8250], [156, 339], [158, 382], [159, 376]]); function Y6(e) { var t; return e >= 55296 && e <= 57343 || e > 1114111 ? 65533 : (t = V6.get(e)) !== null && t !== void 0 ? t : e } var Ue; (function (e) { e[e.NUM = 35] = "NUM", e[e.SEMI = 59] = "SEMI", e[e.EQUALS = 61] = "EQUALS", e[e.ZERO = 48] = "ZERO", e[e.NINE = 57] = "NINE", e[e.LOWER_A = 97] = "LOWER_A", e[e.LOWER_F = 102] = "LOWER_F", e[e.LOWER_X = 120] = "LOWER_X", e[e.LOWER_Z = 122] = "LOWER_Z", e[e.UPPER_A = 65] = "UPPER_A", e[e.UPPER_F = 70] = "UPPER_F", e[e.UPPER_Z = 90] = "UPPER_Z" })(Ue || (Ue = {})); const W6 = 32; var Rn; (function (e) { e[e.VALUE_LENGTH = 49152] = "VALUE_LENGTH", e[e.BRANCH_LENGTH = 16256] = "BRANCH_LENGTH", e[e.JUMP_TABLE = 127] = "JUMP_TABLE" })(Rn || (Rn = {})); function Uc(e) { return e >= Ue.ZERO && e <= Ue.NINE } function K6(e) { return e >= Ue.UPPER_A && e <= Ue.UPPER_F || e >= Ue.LOWER_A && e <= Ue.LOWER_F } function q6(e) { return e >= Ue.UPPER_A && e <= Ue.UPPER_Z || e >= Ue.LOWER_A && e <= Ue.LOWER_Z || Uc(e) } function Q6(e) { return e === Ue.EQUALS || q6(e) } var Fe; (function (e) { e[e.EntityStart = 0] = "EntityStart", e[e.NumericStart = 1] = "NumericStart", e[e.NumericDecimal = 2] = "NumericDecimal", e[e.NumericHex = 3] = "NumericHex", e[e.NamedEntity = 4] = "NamedEntity" })(Fe || (Fe = {})); var cn; (function (e) { e[e.Legacy = 0] = "Legacy", e[e.Strict = 1] = "Strict", e[e.Attribute = 2] = "Attribute" })(cn || (cn = {})); class G6 { constructor(t, n, r) { this.decodeTree = t, this.emitCodePoint = n, this.errors = r, this.state = Fe.EntityStart, this.consumed = 1, this.result = 0, this.treeIndex = 0, this.excess = 1, this.decodeMode = cn.Strict } startEntity(t) { this.decodeMode = t, this.state = Fe.EntityStart, this.result = 0, this.treeIndex = 0, this.excess = 1, this.consumed = 1 } write(t, n) { switch (this.state) { case Fe.EntityStart: return t.charCodeAt(n) === Ue.NUM ? (this.state = Fe.NumericStart, this.consumed += 1, this.stateNumericStart(t, n + 1)) : (this.state = Fe.NamedEntity, this.stateNamedEntity(t, n)); case Fe.NumericStart: return this.stateNumericStart(t, n); case Fe.NumericDecimal: return this.stateNumericDecimal(t, n); case Fe.NumericHex: return this.stateNumericHex(t, n); case Fe.NamedEntity: return this.stateNamedEntity(t, n) } } stateNumericStart(t, n) { return n >= t.length ? -1 : (t.charCodeAt(n) | W6) === Ue.LOWER_X ? (this.state = Fe.NumericHex, this.consumed += 1, this.stateNumericHex(t, n + 1)) : (this.state = Fe.NumericDecimal, this.stateNumericDecimal(t, n)) } addToNumericResult(t, n, r, i) { if (n !== r) { const u = r - n; this.result = this.result * Math.pow(i, u) + Number.parseInt(t.substr(n, u), i), this.consumed += u } } stateNumericHex(t, n) { const r = n; for (; n < t.length;) { const i = t.charCodeAt(n); if (Uc(i) || K6(i)) n += 1; else return this.addToNumericResult(t, r, n, 16), this.emitNumericEntity(i, 3) } return this.addToNumericResult(t, r, n, 16), -1 } stateNumericDecimal(t, n) { const r = n; for (; n < t.length;) { const i = t.charCodeAt(n); if (Uc(i)) n += 1; else return this.addToNumericResult(t, r, n, 10), this.emitNumericEntity(i, 2) } return this.addToNumericResult(t, r, n, 10), -1 } emitNumericEntity(t, n) { var r; if (this.consumed <= n) return (r = this.errors) === null || r === void 0 || r.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; if (t === Ue.SEMI) this.consumed += 1; else if (this.decodeMode === cn.Strict) return 0; return this.emitCodePoint(Y6(this.result), this.consumed), this.errors && (t !== Ue.SEMI && this.errors.missingSemicolonAfterCharacterReference(), this.errors.validateNumericCharacterReference(this.result)), this.consumed } stateNamedEntity(t, n) { const { decodeTree: r } = this; let i = r[this.treeIndex], u = (i & Rn.VALUE_LENGTH) >> 14; for (; n < t.length; n++, this.excess++) { const s = t.charCodeAt(n); if (this.treeIndex = X6(r, i, this.treeIndex + Math.max(1, u), s), this.treeIndex < 0) return this.result === 0 || this.decodeMode === cn.Attribute && (u === 0 || Q6(s)) ? 0 : this.emitNotTerminatedNamedEntity(); if (i = r[this.treeIndex], u = (i & Rn.VALUE_LENGTH) >> 14, u !== 0) { if (s === Ue.SEMI) return this.emitNamedEntityData(this.treeIndex, u, this.consumed + this.excess); this.decodeMode !== cn.Strict && (this.result = this.treeIndex, this.consumed += this.excess, this.excess = 0) } } return -1 } emitNotTerminatedNamedEntity() { var t; const { result: n, decodeTree: r } = this, i = (r[n] & Rn.VALUE_LENGTH) >> 14; return this.emitNamedEntityData(n, i, this.consumed), (t = this.errors) === null || t === void 0 || t.missingSemicolonAfterCharacterReference(), this.consumed } emitNamedEntityData(t, n, r) { const { decodeTree: i } = this; return this.emitCodePoint(n === 1 ? i[t] & ~Rn.VALUE_LENGTH : i[t + 1], r), n === 3 && this.emitCodePoint(i[t + 2], r), r } end() { var t; switch (this.state) { case Fe.NamedEntity: return this.result !== 0 && (this.decodeMode !== cn.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0; case Fe.NumericDecimal: return this.emitNumericEntity(0, 2); case Fe.NumericHex: return this.emitNumericEntity(0, 3); case Fe.NumericStart: return (t = this.errors) === null || t === void 0 || t.absenceOfDigitsInNumericCharacterReference(this.consumed), 0; case Fe.EntityStart: return 0 } } } function X6(e, t, n, r) { const i = (t & Rn.BRANCH_LENGTH) >> 7, u = t & Rn.JUMP_TABLE; if (i === 0) return u !== 0 && r === u ? n : -1; if (u) { const o = r - u; return o < 0 || o >= i ? -1 : e[n + o] - 1 } let s = n, a = s + i - 1; for (; s <= a;) { const o = s + a >>> 1, l = e[o]; if (l < r) s = o + 1; else if (l > r) a = o - 1; else return e[o + i] } return -1 } var F; (function (e) { e.HTML = "http://www.w3.org/1999/xhtml", e.MATHML = "http://www.w3.org/1998/Math/MathML", e.SVG = "http://www.w3.org/2000/svg", e.XLINK = "http://www.w3.org/1999/xlink", e.XML = "http://www.w3.org/XML/1998/namespace", e.XMLNS = "http://www.w3.org/2000/xmlns/" })(F || (F = {})); var hr; (function (e) { e.TYPE = "type", e.ACTION = "action", e.ENCODING = "encoding", e.PROMPT = "prompt", e.NAME = "name", e.COLOR = "color", e.FACE = "face", e.SIZE = "size" })(hr || (hr = {})); var It; (function (e) { e.NO_QUIRKS = "no-quirks", e.QUIRKS = "quirks", e.LIMITED_QUIRKS = "limited-quirks" })(It || (It = {})); var v; (function (e) { e.A = "a", e.ADDRESS = "address", e.ANNOTATION_XML = "annotation-xml", e.APPLET = "applet", e.AREA = "area", e.ARTICLE = "article", e.ASIDE = "aside", e.B = "b", e.BASE = "base", e.BASEFONT = "basefont", e.BGSOUND = "bgsound", e.BIG = "big", e.BLOCKQUOTE = "blockquote", e.BODY = "body", e.BR = "br", e.BUTTON = "button", e.CAPTION = "caption", e.CENTER = "center", e.CODE = "code", e.COL = "col", e.COLGROUP = "colgroup", e.DD = "dd", e.DESC = "desc", e.DETAILS = "details", e.DIALOG = "dialog", e.DIR = "dir", e.DIV = "div", e.DL = "dl", e.DT = "dt", e.EM = "em", e.EMBED = "embed", e.FIELDSET = "fieldset", e.FIGCAPTION = "figcaption", e.FIGURE = "figure", e.FONT = "font", e.FOOTER = "footer", e.FOREIGN_OBJECT = "foreignObject", e.FORM = "form", e.FRAME = "frame", e.FRAMESET = "frameset", e.H1 = "h1", e.H2 = "h2", e.H3 = "h3", e.H4 = "h4", e.H5 = "h5", e.H6 = "h6", e.HEAD = "head", e.HEADER = "header", e.HGROUP = "hgroup", e.HR = "hr", e.HTML = "html", e.I = "i", e.IMG = "img", e.IMAGE = "image", e.INPUT = "input", e.IFRAME = "iframe", e.KEYGEN = "keygen", e.LABEL = "label", e.LI = "li", e.LINK = "link", e.LISTING = "listing", e.MAIN = "main", e.MALIGNMARK = "malignmark", e.MARQUEE = "marquee", e.MATH = "math", e.MENU = "menu", e.META = "meta", e.MGLYPH = "mglyph", e.MI = "mi", e.MO = "mo", e.MN = "mn", e.MS = "ms", e.MTEXT = "mtext", e.NAV = "nav", e.NOBR = "nobr", e.NOFRAMES = "noframes", e.NOEMBED = "noembed", e.NOSCRIPT = "noscript", e.OBJECT = "object", e.OL = "ol", e.OPTGROUP = "optgroup", e.OPTION = "option", e.P = "p", e.PARAM = "param", e.PLAINTEXT = "plaintext", e.PRE = "pre", e.RB = "rb", e.RP = "rp", e.RT = "rt", e.RTC = "rtc", e.RUBY = "ruby", e.S = "s", e.SCRIPT = "script", e.SEARCH = "search", e.SECTION = "section", e.SELECT = "select", e.SOURCE = "source", e.SMALL = "small", e.SPAN = "span", e.STRIKE = "strike", e.STRONG = "strong", e.STYLE = "style", e.SUB = "sub", e.SUMMARY = "summary", e.SUP = "sup", e.TABLE = "table", e.TBODY = "tbody", e.TEMPLATE = "template", e.TEXTAREA = "textarea", e.TFOOT = "tfoot", e.TD = "td", e.TH = "th", e.THEAD = "thead", e.TITLE = "title", e.TR = "tr", e.TRACK = "track", e.TT = "tt", e.U = "u", e.UL = "ul", e.SVG = "svg", e.VAR = "var", e.WBR = "wbr", e.XMP = "xmp" })(v || (v = {})); var c; (function (e) { e[e.UNKNOWN = 0] = "UNKNOWN", e[e.A = 1] = "A", e[e.ADDRESS = 2] = "ADDRESS", e[e.ANNOTATION_XML = 3] = "ANNOTATION_XML", e[e.APPLET = 4] = "APPLET", e[e.AREA = 5] = "AREA", e[e.ARTICLE = 6] = "ARTICLE", e[e.ASIDE = 7] = "ASIDE", e[e.B = 8] = "B", e[e.BASE = 9] = "BASE", e[e.BASEFONT = 10] = "BASEFONT", e[e.BGSOUND = 11] = "BGSOUND", e[e.BIG = 12] = "BIG", e[e.BLOCKQUOTE = 13] = "BLOCKQUOTE", e[e.BODY = 14] = "BODY", e[e.BR = 15] = "BR", e[e.BUTTON = 16] = "BUTTON", e[e.CAPTION = 17] = "CAPTION", e[e.CENTER = 18] = "CENTER", e[e.CODE = 19] = "CODE", e[e.COL = 20] = "COL", e[e.COLGROUP = 21] = "COLGROUP", e[e.DD = 22] = "DD", e[e.DESC = 23] = "DESC", e[e.DETAILS = 24] = "DETAILS", e[e.DIALOG = 25] = "DIALOG", e[e.DIR = 26] = "DIR", e[e.DIV = 27] = "DIV", e[e.DL = 28] = "DL", e[e.DT = 29] = "DT", e[e.EM = 30] = "EM", e[e.EMBED = 31] = "EMBED", e[e.FIELDSET = 32] = "FIELDSET", e[e.FIGCAPTION = 33] = "FIGCAPTION", e[e.FIGURE = 34] = "FIGURE", e[e.FONT = 35] = "FONT", e[e.FOOTER = 36] = "FOOTER", e[e.FOREIGN_OBJECT = 37] = "FOREIGN_OBJECT", e[e.FORM = 38] = "FORM", e[e.FRAME = 39] = "FRAME", e[e.FRAMESET = 40] = "FRAMESET", e[e.H1 = 41] = "H1", e[e.H2 = 42] = "H2", e[e.H3 = 43] = "H3", e[e.H4 = 44] = "H4", e[e.H5 = 45] = "H5", e[e.H6 = 46] = "H6", e[e.HEAD = 47] = "HEAD", e[e.HEADER = 48] = "HEADER", e[e.HGROUP = 49] = "HGROUP", e[e.HR = 50] = "HR", e[e.HTML = 51] = "HTML", e[e.I = 52] = "I", e[e.IMG = 53] = "IMG", e[e.IMAGE = 54] = "IMAGE", e[e.INPUT = 55] = "INPUT", e[e.IFRAME = 56] = "IFRAME", e[e.KEYGEN = 57] = "KEYGEN", e[e.LABEL = 58] = "LABEL", e[e.LI = 59] = "LI", e[e.LINK = 60] = "LINK", e[e.LISTING = 61] = "LISTING", e[e.MAIN = 62] = "MAIN", e[e.MALIGNMARK = 63] = "MALIGNMARK", e[e.MARQUEE = 64] = "MARQUEE", e[e.MATH = 65] = "MATH", e[e.MENU = 66] = "MENU", e[e.META = 67] = "META", e[e.MGLYPH = 68] = "MGLYPH", e[e.MI = 69] = "MI", e[e.MO = 70] = "MO", e[e.MN = 71] = "MN", e[e.MS = 72] = "MS", e[e.MTEXT = 73] = "MTEXT", e[e.NAV = 74] = "NAV", e[e.NOBR = 75] = "NOBR", e[e.NOFRAMES = 76] = "NOFRAMES", e[e.NOEMBED = 77] = "NOEMBED", e[e.NOSCRIPT = 78] = "NOSCRIPT", e[e.OBJECT = 79] = "OBJECT", e[e.OL = 80] = "OL", e[e.OPTGROUP = 81] = "OPTGROUP", e[e.OPTION = 82] = "OPTION", e[e.P = 83] = "P", e[e.PARAM = 84] = "PARAM", e[e.PLAINTEXT = 85] = "PLAINTEXT", e[e.PRE = 86] = "PRE", e[e.RB = 87] = "RB", e[e.RP = 88] = "RP", e[e.RT = 89] = "RT", e[e.RTC = 90] = "RTC", e[e.RUBY = 91] = "RUBY", e[e.S = 92] = "S", e[e.SCRIPT = 93] = "SCRIPT", e[e.SEARCH = 94] = "SEARCH", e[e.SECTION = 95] = "SECTION", e[e.SELECT = 96] = "SELECT", e[e.SOURCE = 97] = "SOURCE", e[e.SMALL = 98] = "SMALL", e[e.SPAN = 99] = "SPAN", e[e.STRIKE = 100] = "STRIKE", e[e.STRONG = 101] = "STRONG", e[e.STYLE = 102] = "STYLE", e[e.SUB = 103] = "SUB", e[e.SUMMARY = 104] = "SUMMARY", e[e.SUP = 105] = "SUP", e[e.TABLE = 106] = "TABLE", e[e.TBODY = 107] = "TBODY", e[e.TEMPLATE = 108] = "TEMPLATE", e[e.TEXTAREA = 109] = "TEXTAREA", e[e.TFOOT = 110] = "TFOOT", e[e.TD = 111] = "TD", e[e.TH = 112] = "TH", e[e.THEAD = 113] = "THEAD", e[e.TITLE = 114] = "TITLE", e[e.TR = 115] = "TR", e[e.TRACK = 116] = "TRACK", e[e.TT = 117] = "TT", e[e.U = 118] = "U", e[e.UL = 119] = "UL", e[e.SVG = 120] = "SVG", e[e.VAR = 121] = "VAR", e[e.WBR = 122] = "WBR", e[e.XMP = 123] = "XMP" })(c || (c = {})); const J6 = new Map([[v.A, c.A], [v.ADDRESS, c.ADDRESS], [v.ANNOTATION_XML, c.ANNOTATION_XML], [v.APPLET, c.APPLET], [v.AREA, c.AREA], [v.ARTICLE, c.ARTICLE], [v.ASIDE, c.ASIDE], [v.B, c.B], [v.BASE, c.BASE], [v.BASEFONT, c.BASEFONT], [v.BGSOUND, c.BGSOUND], [v.BIG, c.BIG], [v.BLOCKQUOTE, c.BLOCKQUOTE], [v.BODY, c.BODY], [v.BR, c.BR], [v.BUTTON, c.BUTTON], [v.CAPTION, c.CAPTION], [v.CENTER, c.CENTER], [v.CODE, c.CODE], [v.COL, c.COL], [v.COLGROUP, c.COLGROUP], [v.DD, c.DD], [v.DESC, c.DESC], [v.DETAILS, c.DETAILS], [v.DIALOG, c.DIALOG], [v.DIR, c.DIR], [v.DIV, c.DIV], [v.DL, c.DL], [v.DT, c.DT], [v.EM, c.EM], [v.EMBED, c.EMBED], [v.FIELDSET, c.FIELDSET], [v.FIGCAPTION, c.FIGCAPTION], [v.FIGURE, c.FIGURE], [v.FONT, c.FONT], [v.FOOTER, c.FOOTER], [v.FOREIGN_OBJECT, c.FOREIGN_OBJECT], [v.FORM, c.FORM], [v.FRAME, c.FRAME], [v.FRAMESET, c.FRAMESET], [v.H1, c.H1], [v.H2, c.H2], [v.H3, c.H3], [v.H4, c.H4], [v.H5, c.H5], [v.H6, c.H6], [v.HEAD, c.HEAD], [v.HEADER, c.HEADER], [v.HGROUP, c.HGROUP], [v.HR, c.HR], [v.HTML, c.HTML], [v.I, c.I], [v.IMG, c.IMG], [v.IMAGE, c.IMAGE], [v.INPUT, c.INPUT], [v.IFRAME, c.IFRAME], [v.KEYGEN, c.KEYGEN], [v.LABEL, c.LABEL], [v.LI, c.LI], [v.LINK, c.LINK], [v.LISTING, c.LISTING], [v.MAIN, c.MAIN], [v.MALIGNMARK, c.MALIGNMARK], [v.MARQUEE, c.MARQUEE], [v.MATH, c.MATH], [v.MENU, c.MENU], [v.META, c.META], [v.MGLYPH, c.MGLYPH], [v.MI, c.MI], [v.MO, c.MO], [v.MN, c.MN], [v.MS, c.MS], [v.MTEXT, c.MTEXT], [v.NAV, c.NAV], [v.NOBR, c.NOBR], [v.NOFRAMES, c.NOFRAMES], [v.NOEMBED, c.NOEMBED], [v.NOSCRIPT, c.NOSCRIPT], [v.OBJECT, c.OBJECT], [v.OL, c.OL], [v.OPTGROUP, c.OPTGROUP], [v.OPTION, c.OPTION], [v.P, c.P], [v.PARAM, c.PARAM], [v.PLAINTEXT, c.PLAINTEXT], [v.PRE, c.PRE], [v.RB, c.RB], [v.RP, c.RP], [v.RT, c.RT], [v.RTC, c.RTC], [v.RUBY, c.RUBY], [v.S, c.S], [v.SCRIPT, c.SCRIPT], [v.SEARCH, c.SEARCH], [v.SECTION, c.SECTION], [v.SELECT, c.SELECT], [v.SOURCE, c.SOURCE], [v.SMALL, c.SMALL], [v.SPAN, c.SPAN], [v.STRIKE, c.STRIKE], [v.STRONG, c.STRONG], [v.STYLE, c.STYLE], [v.SUB, c.SUB], [v.SUMMARY, c.SUMMARY], [v.SUP, c.SUP], [v.TABLE, c.TABLE], [v.TBODY, c.TBODY], [v.TEMPLATE, c.TEMPLATE], [v.TEXTAREA, c.TEXTAREA], [v.TFOOT, c.TFOOT], [v.TD, c.TD], [v.TH, c.TH], [v.THEAD, c.THEAD], [v.TITLE, c.TITLE], [v.TR, c.TR], [v.TRACK, c.TRACK], [v.TT, c.TT], [v.U, c.U], [v.UL, c.UL], [v.SVG, c.SVG], [v.VAR, c.VAR], [v.WBR, c.WBR], [v.XMP, c.XMP]]); function Ai(e) { var t; return (t = J6.get(e)) !== null && t !== void 0 ? t : c.UNKNOWN } const B = c, Z6 = { [F.HTML]: new Set([B.ADDRESS, B.APPLET, B.AREA, B.ARTICLE, B.ASIDE, B.BASE, B.BASEFONT, B.BGSOUND, B.BLOCKQUOTE, B.BODY, B.BR, B.BUTTON, B.CAPTION, B.CENTER, B.COL, B.COLGROUP, B.DD, B.DETAILS, B.DIR, B.DIV, B.DL, B.DT, B.EMBED, B.FIELDSET, B.FIGCAPTION, B.FIGURE, B.FOOTER, B.FORM, B.FRAME, B.FRAMESET, B.H1, B.H2, B.H3, B.H4, B.H5, B.H6, B.HEAD, B.HEADER, B.HGROUP, B.HR, B.HTML, B.IFRAME, B.IMG, B.INPUT, B.LI, B.LINK, B.LISTING, B.MAIN, B.MARQUEE, B.MENU, B.META, B.NAV, B.NOEMBED, B.NOFRAMES, B.NOSCRIPT, B.OBJECT, B.OL, B.P, B.PARAM, B.PLAINTEXT, B.PRE, B.SCRIPT, B.SECTION, B.SELECT, B.SOURCE, B.STYLE, B.SUMMARY, B.TABLE, B.TBODY, B.TD, B.TEMPLATE, B.TEXTAREA, B.TFOOT, B.TH, B.THEAD, B.TITLE, B.TR, B.TRACK, B.UL, B.WBR, B.XMP]), [F.MATHML]: new Set([B.MI, B.MO, B.MN, B.MS, B.MTEXT, B.ANNOTATION_XML]), [F.SVG]: new Set([B.TITLE, B.FOREIGN_OBJECT, B.DESC]), [F.XLINK]: new Set, [F.XML]: new Set, [F.XMLNS]: new Set }, Hc = new Set([B.H1, B.H2, B.H3, B.H4, B.H5, B.H6]); v.STYLE, v.SCRIPT, v.XMP, v.IFRAME, v.NOEMBED, v.NOFRAMES, v.PLAINTEXT; var x; (function (e) { e[e.DATA = 0] = "DATA", e[e.RCDATA = 1] = "RCDATA", e[e.RAWTEXT = 2] = "RAWTEXT", e[e.SCRIPT_DATA = 3] = "SCRIPT_DATA", e[e.PLAINTEXT = 4] = "PLAINTEXT", e[e.TAG_OPEN = 5] = "TAG_OPEN", e[e.END_TAG_OPEN = 6] = "END_TAG_OPEN", e[e.TAG_NAME = 7] = "TAG_NAME", e[e.RCDATA_LESS_THAN_SIGN = 8] = "RCDATA_LESS_THAN_SIGN", e[e.RCDATA_END_TAG_OPEN = 9] = "RCDATA_END_TAG_OPEN", e[e.RCDATA_END_TAG_NAME = 10] = "RCDATA_END_TAG_NAME", e[e.RAWTEXT_LESS_THAN_SIGN = 11] = "RAWTEXT_LESS_THAN_SIGN", e[e.RAWTEXT_END_TAG_OPEN = 12] = "RAWTEXT_END_TAG_OPEN", e[e.RAWTEXT_END_TAG_NAME = 13] = "RAWTEXT_END_TAG_NAME", e[e.SCRIPT_DATA_LESS_THAN_SIGN = 14] = "SCRIPT_DATA_LESS_THAN_SIGN", e[e.SCRIPT_DATA_END_TAG_OPEN = 15] = "SCRIPT_DATA_END_TAG_OPEN", e[e.SCRIPT_DATA_END_TAG_NAME = 16] = "SCRIPT_DATA_END_TAG_NAME", e[e.SCRIPT_DATA_ESCAPE_START = 17] = "SCRIPT_DATA_ESCAPE_START", e[e.SCRIPT_DATA_ESCAPE_START_DASH = 18] = "SCRIPT_DATA_ESCAPE_START_DASH", e[e.SCRIPT_DATA_ESCAPED = 19] = "SCRIPT_DATA_ESCAPED", e[e.SCRIPT_DATA_ESCAPED_DASH = 20] = "SCRIPT_DATA_ESCAPED_DASH", e[e.SCRIPT_DATA_ESCAPED_DASH_DASH = 21] = "SCRIPT_DATA_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN = 22] = "SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_OPEN = 23] = "SCRIPT_DATA_ESCAPED_END_TAG_OPEN", e[e.SCRIPT_DATA_ESCAPED_END_TAG_NAME = 24] = "SCRIPT_DATA_ESCAPED_END_TAG_NAME", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_START = 25] = "SCRIPT_DATA_DOUBLE_ESCAPE_START", e[e.SCRIPT_DATA_DOUBLE_ESCAPED = 26] = "SCRIPT_DATA_DOUBLE_ESCAPED", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH = 27] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH = 28] = "SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH", e[e.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN = 29] = "SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN", e[e.SCRIPT_DATA_DOUBLE_ESCAPE_END = 30] = "SCRIPT_DATA_DOUBLE_ESCAPE_END", e[e.BEFORE_ATTRIBUTE_NAME = 31] = "BEFORE_ATTRIBUTE_NAME", e[e.ATTRIBUTE_NAME = 32] = "ATTRIBUTE_NAME", e[e.AFTER_ATTRIBUTE_NAME = 33] = "AFTER_ATTRIBUTE_NAME", e[e.BEFORE_ATTRIBUTE_VALUE = 34] = "BEFORE_ATTRIBUTE_VALUE", e[e.ATTRIBUTE_VALUE_DOUBLE_QUOTED = 35] = "ATTRIBUTE_VALUE_DOUBLE_QUOTED", e[e.ATTRIBUTE_VALUE_SINGLE_QUOTED = 36] = "ATTRIBUTE_VALUE_SINGLE_QUOTED", e[e.ATTRIBUTE_VALUE_UNQUOTED = 37] = "ATTRIBUTE_VALUE_UNQUOTED", e[e.AFTER_ATTRIBUTE_VALUE_QUOTED = 38] = "AFTER_ATTRIBUTE_VALUE_QUOTED", e[e.SELF_CLOSING_START_TAG = 39] = "SELF_CLOSING_START_TAG", e[e.BOGUS_COMMENT = 40] = "BOGUS_COMMENT", e[e.MARKUP_DECLARATION_OPEN = 41] = "MARKUP_DECLARATION_OPEN", e[e.COMMENT_START = 42] = "COMMENT_START", e[e.COMMENT_START_DASH = 43] = "COMMENT_START_DASH", e[e.COMMENT = 44] = "COMMENT", e[e.COMMENT_LESS_THAN_SIGN = 45] = "COMMENT_LESS_THAN_SIGN", e[e.COMMENT_LESS_THAN_SIGN_BANG = 46] = "COMMENT_LESS_THAN_SIGN_BANG", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH = 47] = "COMMENT_LESS_THAN_SIGN_BANG_DASH", e[e.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH = 48] = "COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH", e[e.COMMENT_END_DASH = 49] = "COMMENT_END_DASH", e[e.COMMENT_END = 50] = "COMMENT_END", e[e.COMMENT_END_BANG = 51] = "COMMENT_END_BANG", e[e.DOCTYPE = 52] = "DOCTYPE", e[e.BEFORE_DOCTYPE_NAME = 53] = "BEFORE_DOCTYPE_NAME", e[e.DOCTYPE_NAME = 54] = "DOCTYPE_NAME", e[e.AFTER_DOCTYPE_NAME = 55] = "AFTER_DOCTYPE_NAME", e[e.AFTER_DOCTYPE_PUBLIC_KEYWORD = 56] = "AFTER_DOCTYPE_PUBLIC_KEYWORD", e[e.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER = 57] = "BEFORE_DOCTYPE_PUBLIC_IDENTIFIER", e[e.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED = 58] = "DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED = 59] = "DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_PUBLIC_IDENTIFIER = 60] = "AFTER_DOCTYPE_PUBLIC_IDENTIFIER", e[e.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS = 61] = "BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS", e[e.AFTER_DOCTYPE_SYSTEM_KEYWORD = 62] = "AFTER_DOCTYPE_SYSTEM_KEYWORD", e[e.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER = 63] = "BEFORE_DOCTYPE_SYSTEM_IDENTIFIER", e[e.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED = 64] = "DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED", e[e.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED = 65] = "DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED", e[e.AFTER_DOCTYPE_SYSTEM_IDENTIFIER = 66] = "AFTER_DOCTYPE_SYSTEM_IDENTIFIER", e[e.BOGUS_DOCTYPE = 67] = "BOGUS_DOCTYPE", e[e.CDATA_SECTION = 68] = "CDATA_SECTION", e[e.CDATA_SECTION_BRACKET = 69] = "CDATA_SECTION_BRACKET", e[e.CDATA_SECTION_END = 70] = "CDATA_SECTION_END", e[e.CHARACTER_REFERENCE = 71] = "CHARACTER_REFERENCE", e[e.AMBIGUOUS_AMPERSAND = 72] = "AMBIGUOUS_AMPERSAND" })(x || (x = {})); const ve = { DATA: x.DATA, RCDATA: x.RCDATA, RAWTEXT: x.RAWTEXT, SCRIPT_DATA: x.SCRIPT_DATA, PLAINTEXT: x.PLAINTEXT, CDATA_SECTION: x.CDATA_SECTION }; function ev(e) { return e >= b.DIGIT_0 && e <= b.DIGIT_9 } function Gi(e) { return e >= b.LATIN_CAPITAL_A && e <= b.LATIN_CAPITAL_Z } function tv(e) { return e >= b.LATIN_SMALL_A && e <= b.LATIN_SMALL_Z } function Cn(e) { return tv(e) || Gi(e) } function Ap(e) { return Cn(e) || ev(e) } function ws(e) { return e + 32 } function fT(e) { return e === b.SPACE || e === b.LINE_FEED || e === b.TABULATION || e === b.FORM_FEED } function kp(e) { return fT(e) || e === b.SOLIDUS || e === b.GREATER_THAN_SIGN } function nv(e) { return e === b.NULL ? R.nullCharacterReference : e > 1114111 ? R.characterReferenceOutsideUnicodeRange : aT(e) ? R.surrogateCharacterReference : lT(e) ? R.noncharacterCharacterReference : oT(e) || e === b.CARRIAGE_RETURN ? R.controlCharacterReference : null } class rv { constructor(t, n) { this.options = t, this.handler = n, this.paused = !1, this.inLoop = !1, this.inForeignNode = !1, this.lastStartTagName = "", this.active = !1, this.state = x.DATA, this.returnState = x.DATA, this.entityStartPos = 0, this.consumedAfterSnapshot = -1, this.currentCharacterToken = null, this.currentToken = null, this.currentAttr = { name: "", value: "" }, this.preprocessor = new j6(n), this.currentLocation = this.getCurrentLocation(-1), this.entityDecoder = new G6($6, (r, i) => { this.preprocessor.pos = this.entityStartPos + i - 1, this._flushCodePointConsumedAsCharacterReference(r) }, n.onParseError ? { missingSemicolonAfterCharacterReference: () => { this._err(R.missingSemicolonAfterCharacterReference, 1) }, absenceOfDigitsInNumericCharacterReference: r => { this._err(R.absenceOfDigitsInNumericCharacterReference, this.entityStartPos - this.preprocessor.pos + r) }, validateNumericCharacterReference: r => { const i = nv(r); i && this._err(i, 1) } } : void 0) } _err(t, n = 0) { var r, i; (i = (r = this.handler).onParseError) === null || i === void 0 || i.call(r, this.preprocessor.getError(t, n)) } getCurrentLocation(t) { return this.options.sourceCodeLocationInfo ? { startLine: this.preprocessor.line, startCol: this.preprocessor.col - t, startOffset: this.preprocessor.offset - t, endLine: -1, endCol: -1, endOffset: -1 } : null } _runParsingLoop() { if (!this.inLoop) { for (this.inLoop = !0; this.active && !this.paused;) { this.consumedAfterSnapshot = 0; const t = this._consume(); this._ensureHibernation() || this._callState(t) } this.inLoop = !1 } } pause() { this.paused = !0 } resume(t) { if (!this.paused) throw new Error("Parser was already resumed"); this.paused = !1, !this.inLoop && (this._runParsingLoop(), this.paused || t == null || t()) } write(t, n, r) { this.active = !0, this.preprocessor.write(t, n), this._runParsingLoop(), this.paused || r == null || r() } insertHtmlAtCurrentPos(t) { this.active = !0, this.preprocessor.insertHtmlAtCurrentPos(t), this._runParsingLoop() } _ensureHibernation() { return this.preprocessor.endOfChunkHit ? (this.preprocessor.retreat(this.consumedAfterSnapshot), this.consumedAfterSnapshot = 0, this.active = !1, !0) : !1 } _consume() { return this.consumedAfterSnapshot++, this.preprocessor.advance() } _advanceBy(t) { this.consumedAfterSnapshot += t; for (let n = 0; n < t; n++)this.preprocessor.advance() } _consumeSequenceIfMatch(t, n) { return this.preprocessor.startsWith(t, n) ? (this._advanceBy(t.length - 1), !0) : !1 } _createStartTagToken() { this.currentToken = { type: se.START_TAG, tagName: "", tagID: c.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(1) } } _createEndTagToken() { this.currentToken = { type: se.END_TAG, tagName: "", tagID: c.UNKNOWN, selfClosing: !1, ackSelfClosing: !1, attrs: [], location: this.getCurrentLocation(2) } } _createCommentToken(t) { this.currentToken = { type: se.COMMENT, data: "", location: this.getCurrentLocation(t) } } _createDoctypeToken(t) { this.currentToken = { type: se.DOCTYPE, name: t, forceQuirks: !1, publicId: null, systemId: null, location: this.currentLocation } } _createCharacterToken(t, n) { this.currentCharacterToken = { type: t, chars: n, location: this.currentLocation } } _createAttr(t) { this.currentAttr = { name: t, value: "" }, this.currentLocation = this.getCurrentLocation(0) } _leaveAttrName() { var t, n; const r = this.currentToken; if (cT(r, this.currentAttr.name) === null) { if (r.attrs.push(this.currentAttr), r.location && this.currentLocation) { const i = (t = (n = r.location).attrs) !== null && t !== void 0 ? t : n.attrs = Object.create(null); i[this.currentAttr.name] = this.currentLocation, this._leaveAttrValue() } } else this._err(R.duplicateAttribute) } _leaveAttrValue() { this.currentLocation && (this.currentLocation.endLine = this.preprocessor.line, this.currentLocation.endCol = this.preprocessor.col, this.currentLocation.endOffset = this.preprocessor.offset) } prepareToken(t) { this._emitCurrentCharacterToken(t.location), this.currentToken = null, t.location && (t.location.endLine = this.preprocessor.line, t.location.endCol = this.preprocessor.col + 1, t.location.endOffset = this.preprocessor.offset + 1), this.currentLocation = this.getCurrentLocation(-1) } emitCurrentTagToken() { const t = this.currentToken; this.prepareToken(t), t.tagID = Ai(t.tagName), t.type === se.START_TAG ? (this.lastStartTagName = t.tagName, this.handler.onStartTag(t)) : (t.attrs.length > 0 && this._err(R.endTagWithAttributes), t.selfClosing && this._err(R.endTagWithTrailingSolidus), this.handler.onEndTag(t)), this.preprocessor.dropParsedChunk() } emitCurrentComment(t) { this.prepareToken(t), this.handler.onComment(t), this.preprocessor.dropParsedChunk() } emitCurrentDoctype(t) { this.prepareToken(t), this.handler.onDoctype(t), this.preprocessor.dropParsedChunk() } _emitCurrentCharacterToken(t) { if (this.currentCharacterToken) { switch (t && this.currentCharacterToken.location && (this.currentCharacterToken.location.endLine = t.startLine, this.currentCharacterToken.location.endCol = t.startCol, this.currentCharacterToken.location.endOffset = t.startOffset), this.currentCharacterToken.type) { case se.CHARACTER: { this.handler.onCharacter(this.currentCharacterToken); break } case se.NULL_CHARACTER: { this.handler.onNullCharacter(this.currentCharacterToken); break } case se.WHITESPACE_CHARACTER: { this.handler.onWhitespaceCharacter(this.currentCharacterToken); break } }this.currentCharacterToken = null } } _emitEOFToken() { const t = this.getCurrentLocation(0); t && (t.endLine = t.startLine, t.endCol = t.startCol, t.endOffset = t.startOffset), this._emitCurrentCharacterToken(t), this.handler.onEof({ type: se.EOF, location: t }), this.active = !1 } _appendCharToCurrentCharacterToken(t, n) { if (this.currentCharacterToken) if (this.currentCharacterToken.type === t) { this.currentCharacterToken.chars += n; return } else this.currentLocation = this.getCurrentLocation(0), this._emitCurrentCharacterToken(this.currentLocation), this.preprocessor.dropParsedChunk(); this._createCharacterToken(t, n) } _emitCodePoint(t) { const n = fT(t) ? se.WHITESPACE_CHARACTER : t === b.NULL ? se.NULL_CHARACTER : se.CHARACTER; this._appendCharToCurrentCharacterToken(n, String.fromCodePoint(t)) } _emitChars(t) { this._appendCharToCurrentCharacterToken(se.CHARACTER, t) } _startCharacterReference() { this.returnState = this.state, this.state = x.CHARACTER_REFERENCE, this.entityStartPos = this.preprocessor.pos, this.entityDecoder.startEntity(this._isCharacterReferenceInAttribute() ? cn.Attribute : cn.Legacy) } _isCharacterReferenceInAttribute() { return this.returnState === x.ATTRIBUTE_VALUE_DOUBLE_QUOTED || this.returnState === x.ATTRIBUTE_VALUE_SINGLE_QUOTED || this.returnState === x.ATTRIBUTE_VALUE_UNQUOTED } _flushCodePointConsumedAsCharacterReference(t) { this._isCharacterReferenceInAttribute() ? this.currentAttr.value += String.fromCodePoint(t) : this._emitCodePoint(t) } _callState(t) { switch (this.state) { case x.DATA: { this._stateData(t); break } case x.RCDATA: { this._stateRcdata(t); break } case x.RAWTEXT: { this._stateRawtext(t); break } case x.SCRIPT_DATA: { this._stateScriptData(t); break } case x.PLAINTEXT: { this._statePlaintext(t); break } case x.TAG_OPEN: { this._stateTagOpen(t); break } case x.END_TAG_OPEN: { this._stateEndTagOpen(t); break } case x.TAG_NAME: { this._stateTagName(t); break } case x.RCDATA_LESS_THAN_SIGN: { this._stateRcdataLessThanSign(t); break } case x.RCDATA_END_TAG_OPEN: { this._stateRcdataEndTagOpen(t); break } case x.RCDATA_END_TAG_NAME: { this._stateRcdataEndTagName(t); break } case x.RAWTEXT_LESS_THAN_SIGN: { this._stateRawtextLessThanSign(t); break } case x.RAWTEXT_END_TAG_OPEN: { this._stateRawtextEndTagOpen(t); break } case x.RAWTEXT_END_TAG_NAME: { this._stateRawtextEndTagName(t); break } case x.SCRIPT_DATA_LESS_THAN_SIGN: { this._stateScriptDataLessThanSign(t); break } case x.SCRIPT_DATA_END_TAG_OPEN: { this._stateScriptDataEndTagOpen(t); break } case x.SCRIPT_DATA_END_TAG_NAME: { this._stateScriptDataEndTagName(t); break } case x.SCRIPT_DATA_ESCAPE_START: { this._stateScriptDataEscapeStart(t); break } case x.SCRIPT_DATA_ESCAPE_START_DASH: { this._stateScriptDataEscapeStartDash(t); break } case x.SCRIPT_DATA_ESCAPED: { this._stateScriptDataEscaped(t); break } case x.SCRIPT_DATA_ESCAPED_DASH: { this._stateScriptDataEscapedDash(t); break } case x.SCRIPT_DATA_ESCAPED_DASH_DASH: { this._stateScriptDataEscapedDashDash(t); break } case x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN: { this._stateScriptDataEscapedLessThanSign(t); break } case x.SCRIPT_DATA_ESCAPED_END_TAG_OPEN: { this._stateScriptDataEscapedEndTagOpen(t); break } case x.SCRIPT_DATA_ESCAPED_END_TAG_NAME: { this._stateScriptDataEscapedEndTagName(t); break } case x.SCRIPT_DATA_DOUBLE_ESCAPE_START: { this._stateScriptDataDoubleEscapeStart(t); break } case x.SCRIPT_DATA_DOUBLE_ESCAPED: { this._stateScriptDataDoubleEscaped(t); break } case x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH: { this._stateScriptDataDoubleEscapedDash(t); break } case x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH: { this._stateScriptDataDoubleEscapedDashDash(t); break } case x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN: { this._stateScriptDataDoubleEscapedLessThanSign(t); break } case x.SCRIPT_DATA_DOUBLE_ESCAPE_END: { this._stateScriptDataDoubleEscapeEnd(t); break } case x.BEFORE_ATTRIBUTE_NAME: { this._stateBeforeAttributeName(t); break } case x.ATTRIBUTE_NAME: { this._stateAttributeName(t); break } case x.AFTER_ATTRIBUTE_NAME: { this._stateAfterAttributeName(t); break } case x.BEFORE_ATTRIBUTE_VALUE: { this._stateBeforeAttributeValue(t); break } case x.ATTRIBUTE_VALUE_DOUBLE_QUOTED: { this._stateAttributeValueDoubleQuoted(t); break } case x.ATTRIBUTE_VALUE_SINGLE_QUOTED: { this._stateAttributeValueSingleQuoted(t); break } case x.ATTRIBUTE_VALUE_UNQUOTED: { this._stateAttributeValueUnquoted(t); break } case x.AFTER_ATTRIBUTE_VALUE_QUOTED: { this._stateAfterAttributeValueQuoted(t); break } case x.SELF_CLOSING_START_TAG: { this._stateSelfClosingStartTag(t); break } case x.BOGUS_COMMENT: { this._stateBogusComment(t); break } case x.MARKUP_DECLARATION_OPEN: { this._stateMarkupDeclarationOpen(t); break } case x.COMMENT_START: { this._stateCommentStart(t); break } case x.COMMENT_START_DASH: { this._stateCommentStartDash(t); break } case x.COMMENT: { this._stateComment(t); break } case x.COMMENT_LESS_THAN_SIGN: { this._stateCommentLessThanSign(t); break } case x.COMMENT_LESS_THAN_SIGN_BANG: { this._stateCommentLessThanSignBang(t); break } case x.COMMENT_LESS_THAN_SIGN_BANG_DASH: { this._stateCommentLessThanSignBangDash(t); break } case x.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH: { this._stateCommentLessThanSignBangDashDash(t); break } case x.COMMENT_END_DASH: { this._stateCommentEndDash(t); break } case x.COMMENT_END: { this._stateCommentEnd(t); break } case x.COMMENT_END_BANG: { this._stateCommentEndBang(t); break } case x.DOCTYPE: { this._stateDoctype(t); break } case x.BEFORE_DOCTYPE_NAME: { this._stateBeforeDoctypeName(t); break } case x.DOCTYPE_NAME: { this._stateDoctypeName(t); break } case x.AFTER_DOCTYPE_NAME: { this._stateAfterDoctypeName(t); break } case x.AFTER_DOCTYPE_PUBLIC_KEYWORD: { this._stateAfterDoctypePublicKeyword(t); break } case x.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER: { this._stateBeforeDoctypePublicIdentifier(t); break } case x.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED: { this._stateDoctypePublicIdentifierDoubleQuoted(t); break } case x.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED: { this._stateDoctypePublicIdentifierSingleQuoted(t); break } case x.AFTER_DOCTYPE_PUBLIC_IDENTIFIER: { this._stateAfterDoctypePublicIdentifier(t); break } case x.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS: { this._stateBetweenDoctypePublicAndSystemIdentifiers(t); break } case x.AFTER_DOCTYPE_SYSTEM_KEYWORD: { this._stateAfterDoctypeSystemKeyword(t); break } case x.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER: { this._stateBeforeDoctypeSystemIdentifier(t); break } case x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED: { this._stateDoctypeSystemIdentifierDoubleQuoted(t); break } case x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED: { this._stateDoctypeSystemIdentifierSingleQuoted(t); break } case x.AFTER_DOCTYPE_SYSTEM_IDENTIFIER: { this._stateAfterDoctypeSystemIdentifier(t); break } case x.BOGUS_DOCTYPE: { this._stateBogusDoctype(t); break } case x.CDATA_SECTION: { this._stateCdataSection(t); break } case x.CDATA_SECTION_BRACKET: { this._stateCdataSectionBracket(t); break } case x.CDATA_SECTION_END: { this._stateCdataSectionEnd(t); break } case x.CHARACTER_REFERENCE: { this._stateCharacterReference(); break } case x.AMBIGUOUS_AMPERSAND: { this._stateAmbiguousAmpersand(t); break } default: throw new Error("Unknown state") } } _stateData(t) { switch (t) { case b.LESS_THAN_SIGN: { this.state = x.TAG_OPEN; break } case b.AMPERSAND: { this._startCharacterReference(); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitCodePoint(t); break } case b.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateRcdata(t) { switch (t) { case b.AMPERSAND: { this._startCharacterReference(); break } case b.LESS_THAN_SIGN: { this.state = x.RCDATA_LESS_THAN_SIGN; break } case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitChars(Se); break } case b.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateRawtext(t) { switch (t) { case b.LESS_THAN_SIGN: { this.state = x.RAWTEXT_LESS_THAN_SIGN; break } case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitChars(Se); break } case b.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateScriptData(t) { switch (t) { case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_LESS_THAN_SIGN; break } case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitChars(Se); break } case b.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _statePlaintext(t) { switch (t) { case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitChars(Se); break } case b.EOF: { this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateTagOpen(t) { if (Cn(t)) this._createStartTagToken(), this.state = x.TAG_NAME, this._stateTagName(t); else switch (t) { case b.EXCLAMATION_MARK: { this.state = x.MARKUP_DECLARATION_OPEN; break } case b.SOLIDUS: { this.state = x.END_TAG_OPEN; break } case b.QUESTION_MARK: { this._err(R.unexpectedQuestionMarkInsteadOfTagName), this._createCommentToken(1), this.state = x.BOGUS_COMMENT, this._stateBogusComment(t); break } case b.EOF: { this._err(R.eofBeforeTagName), this._emitChars("<"), this._emitEOFToken(); break } default: this._err(R.invalidFirstCharacterOfTagName), this._emitChars("<"), this.state = x.DATA, this._stateData(t) } } _stateEndTagOpen(t) { if (Cn(t)) this._createEndTagToken(), this.state = x.TAG_NAME, this._stateTagName(t); else switch (t) { case b.GREATER_THAN_SIGN: { this._err(R.missingEndTagName), this.state = x.DATA; break } case b.EOF: { this._err(R.eofBeforeTagName), this._emitChars("</"), this._emitEOFToken(); break } default: this._err(R.invalidFirstCharacterOfTagName), this._createCommentToken(2), this.state = x.BOGUS_COMMENT, this._stateBogusComment(t) } } _stateTagName(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this.state = x.BEFORE_ATTRIBUTE_NAME; break } case b.SOLIDUS: { this.state = x.SELF_CLOSING_START_TAG; break } case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentTagToken(); break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.tagName += Se; break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: n.tagName += String.fromCodePoint(Gi(t) ? ws(t) : t) } } _stateRcdataLessThanSign(t) { t === b.SOLIDUS ? this.state = x.RCDATA_END_TAG_OPEN : (this._emitChars("<"), this.state = x.RCDATA, this._stateRcdata(t)) } _stateRcdataEndTagOpen(t) { Cn(t) ? (this.state = x.RCDATA_END_TAG_NAME, this._stateRcdataEndTagName(t)) : (this._emitChars("</"), this.state = x.RCDATA, this._stateRcdata(t)) } handleSpecialEndTag(t) { if (!this.preprocessor.startsWith(this.lastStartTagName, !1)) return !this._ensureHibernation(); this._createEndTagToken(); const n = this.currentToken; switch (n.tagName = this.lastStartTagName, this.preprocessor.peek(this.lastStartTagName.length)) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: return this._advanceBy(this.lastStartTagName.length), this.state = x.BEFORE_ATTRIBUTE_NAME, !1; case b.SOLIDUS: return this._advanceBy(this.lastStartTagName.length), this.state = x.SELF_CLOSING_START_TAG, !1; case b.GREATER_THAN_SIGN: return this._advanceBy(this.lastStartTagName.length), this.emitCurrentTagToken(), this.state = x.DATA, !1; default: return !this._ensureHibernation() } } _stateRcdataEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.RCDATA, this._stateRcdata(t)) } _stateRawtextLessThanSign(t) { t === b.SOLIDUS ? this.state = x.RAWTEXT_END_TAG_OPEN : (this._emitChars("<"), this.state = x.RAWTEXT, this._stateRawtext(t)) } _stateRawtextEndTagOpen(t) { Cn(t) ? (this.state = x.RAWTEXT_END_TAG_NAME, this._stateRawtextEndTagName(t)) : (this._emitChars("</"), this.state = x.RAWTEXT, this._stateRawtext(t)) } _stateRawtextEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.RAWTEXT, this._stateRawtext(t)) } _stateScriptDataLessThanSign(t) { switch (t) { case b.SOLIDUS: { this.state = x.SCRIPT_DATA_END_TAG_OPEN; break } case b.EXCLAMATION_MARK: { this.state = x.SCRIPT_DATA_ESCAPE_START, this._emitChars("<!"); break } default: this._emitChars("<"), this.state = x.SCRIPT_DATA, this._stateScriptData(t) } } _stateScriptDataEndTagOpen(t) { Cn(t) ? (this.state = x.SCRIPT_DATA_END_TAG_NAME, this._stateScriptDataEndTagName(t)) : (this._emitChars("</"), this.state = x.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEscapeStart(t) { t === b.HYPHEN_MINUS ? (this.state = x.SCRIPT_DATA_ESCAPE_START_DASH, this._emitChars("-")) : (this.state = x.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEscapeStartDash(t) { t === b.HYPHEN_MINUS ? (this.state = x.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-")) : (this.state = x.SCRIPT_DATA, this._stateScriptData(t)) } _stateScriptDataEscaped(t) { switch (t) { case b.HYPHEN_MINUS: { this.state = x.SCRIPT_DATA_ESCAPED_DASH, this._emitChars("-"); break } case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break } case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitChars(Se); break } case b.EOF: { this._err(R.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateScriptDataEscapedDash(t) { switch (t) { case b.HYPHEN_MINUS: { this.state = x.SCRIPT_DATA_ESCAPED_DASH_DASH, this._emitChars("-"); break } case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_ESCAPED, this._emitChars(Se); break } case b.EOF: { this._err(R.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = x.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataEscapedDashDash(t) { switch (t) { case b.HYPHEN_MINUS: { this._emitChars("-"); break } case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN; break } case b.GREATER_THAN_SIGN: { this.state = x.SCRIPT_DATA, this._emitChars(">"); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_ESCAPED, this._emitChars(Se); break } case b.EOF: { this._err(R.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = x.SCRIPT_DATA_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataEscapedLessThanSign(t) { t === b.SOLIDUS ? this.state = x.SCRIPT_DATA_ESCAPED_END_TAG_OPEN : Cn(t) ? (this._emitChars("<"), this.state = x.SCRIPT_DATA_DOUBLE_ESCAPE_START, this._stateScriptDataDoubleEscapeStart(t)) : (this._emitChars("<"), this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataEscapedEndTagOpen(t) { Cn(t) ? (this.state = x.SCRIPT_DATA_ESCAPED_END_TAG_NAME, this._stateScriptDataEscapedEndTagName(t)) : (this._emitChars("</"), this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataEscapedEndTagName(t) { this.handleSpecialEndTag(t) && (this._emitChars("</"), this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataDoubleEscapeStart(t) { if (this.preprocessor.startsWith(ut.SCRIPT, !1) && kp(this.preprocessor.peek(ut.SCRIPT.length))) { this._emitCodePoint(t); for (let n = 0; n < ut.SCRIPT.length; n++)this._emitCodePoint(this._consume()); this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED } else this._ensureHibernation() || (this.state = x.SCRIPT_DATA_ESCAPED, this._stateScriptDataEscaped(t)) } _stateScriptDataDoubleEscaped(t) { switch (t) { case b.HYPHEN_MINUS: { this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH, this._emitChars("-"); break } case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this._emitChars(Se); break } case b.EOF: { this._err(R.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateScriptDataDoubleEscapedDash(t) { switch (t) { case b.HYPHEN_MINUS: { this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH, this._emitChars("-"); break } case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Se); break } case b.EOF: { this._err(R.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataDoubleEscapedDashDash(t) { switch (t) { case b.HYPHEN_MINUS: { this._emitChars("-"); break } case b.LESS_THAN_SIGN: { this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN, this._emitChars("<"); break } case b.GREATER_THAN_SIGN: { this.state = x.SCRIPT_DATA, this._emitChars(">"); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitChars(Se); break } case b.EOF: { this._err(R.eofInScriptHtmlCommentLikeText), this._emitEOFToken(); break } default: this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._emitCodePoint(t) } } _stateScriptDataDoubleEscapedLessThanSign(t) { t === b.SOLIDUS ? (this.state = x.SCRIPT_DATA_DOUBLE_ESCAPE_END, this._emitChars("/")) : (this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t)) } _stateScriptDataDoubleEscapeEnd(t) { if (this.preprocessor.startsWith(ut.SCRIPT, !1) && kp(this.preprocessor.peek(ut.SCRIPT.length))) { this._emitCodePoint(t); for (let n = 0; n < ut.SCRIPT.length; n++)this._emitCodePoint(this._consume()); this.state = x.SCRIPT_DATA_ESCAPED } else this._ensureHibernation() || (this.state = x.SCRIPT_DATA_DOUBLE_ESCAPED, this._stateScriptDataDoubleEscaped(t)) } _stateBeforeAttributeName(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.SOLIDUS: case b.GREATER_THAN_SIGN: case b.EOF: { this.state = x.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t); break } case b.EQUALS_SIGN: { this._err(R.unexpectedEqualsSignBeforeAttributeName), this._createAttr("="), this.state = x.ATTRIBUTE_NAME; break } default: this._createAttr(""), this.state = x.ATTRIBUTE_NAME, this._stateAttributeName(t) } } _stateAttributeName(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: case b.SOLIDUS: case b.GREATER_THAN_SIGN: case b.EOF: { this._leaveAttrName(), this.state = x.AFTER_ATTRIBUTE_NAME, this._stateAfterAttributeName(t); break } case b.EQUALS_SIGN: { this._leaveAttrName(), this.state = x.BEFORE_ATTRIBUTE_VALUE; break } case b.QUOTATION_MARK: case b.APOSTROPHE: case b.LESS_THAN_SIGN: { this._err(R.unexpectedCharacterInAttributeName), this.currentAttr.name += String.fromCodePoint(t); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.currentAttr.name += Se; break } default: this.currentAttr.name += String.fromCodePoint(Gi(t) ? ws(t) : t) } } _stateAfterAttributeName(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.SOLIDUS: { this.state = x.SELF_CLOSING_START_TAG; break } case b.EQUALS_SIGN: { this.state = x.BEFORE_ATTRIBUTE_VALUE; break } case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentTagToken(); break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: this._createAttr(""), this.state = x.ATTRIBUTE_NAME, this._stateAttributeName(t) } } _stateBeforeAttributeValue(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.QUOTATION_MARK: { this.state = x.ATTRIBUTE_VALUE_DOUBLE_QUOTED; break } case b.APOSTROPHE: { this.state = x.ATTRIBUTE_VALUE_SINGLE_QUOTED; break } case b.GREATER_THAN_SIGN: { this._err(R.missingAttributeValue), this.state = x.DATA, this.emitCurrentTagToken(); break } default: this.state = x.ATTRIBUTE_VALUE_UNQUOTED, this._stateAttributeValueUnquoted(t) } } _stateAttributeValueDoubleQuoted(t) { switch (t) { case b.QUOTATION_MARK: { this.state = x.AFTER_ATTRIBUTE_VALUE_QUOTED; break } case b.AMPERSAND: { this._startCharacterReference(); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.currentAttr.value += Se; break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: this.currentAttr.value += String.fromCodePoint(t) } } _stateAttributeValueSingleQuoted(t) { switch (t) { case b.APOSTROPHE: { this.state = x.AFTER_ATTRIBUTE_VALUE_QUOTED; break } case b.AMPERSAND: { this._startCharacterReference(); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.currentAttr.value += Se; break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: this.currentAttr.value += String.fromCodePoint(t) } } _stateAttributeValueUnquoted(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this._leaveAttrValue(), this.state = x.BEFORE_ATTRIBUTE_NAME; break } case b.AMPERSAND: { this._startCharacterReference(); break } case b.GREATER_THAN_SIGN: { this._leaveAttrValue(), this.state = x.DATA, this.emitCurrentTagToken(); break } case b.NULL: { this._err(R.unexpectedNullCharacter), this.currentAttr.value += Se; break } case b.QUOTATION_MARK: case b.APOSTROPHE: case b.LESS_THAN_SIGN: case b.EQUALS_SIGN: case b.GRAVE_ACCENT: { this._err(R.unexpectedCharacterInUnquotedAttributeValue), this.currentAttr.value += String.fromCodePoint(t); break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: this.currentAttr.value += String.fromCodePoint(t) } } _stateAfterAttributeValueQuoted(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this._leaveAttrValue(), this.state = x.BEFORE_ATTRIBUTE_NAME; break } case b.SOLIDUS: { this._leaveAttrValue(), this.state = x.SELF_CLOSING_START_TAG; break } case b.GREATER_THAN_SIGN: { this._leaveAttrValue(), this.state = x.DATA, this.emitCurrentTagToken(); break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: this._err(R.missingWhitespaceBetweenAttributes), this.state = x.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t) } } _stateSelfClosingStartTag(t) { switch (t) { case b.GREATER_THAN_SIGN: { const n = this.currentToken; n.selfClosing = !0, this.state = x.DATA, this.emitCurrentTagToken(); break } case b.EOF: { this._err(R.eofInTag), this._emitEOFToken(); break } default: this._err(R.unexpectedSolidusInTag), this.state = x.BEFORE_ATTRIBUTE_NAME, this._stateBeforeAttributeName(t) } } _stateBogusComment(t) { const n = this.currentToken; switch (t) { case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentComment(n); break } case b.EOF: { this.emitCurrentComment(n), this._emitEOFToken(); break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.data += Se; break } default: n.data += String.fromCodePoint(t) } } _stateMarkupDeclarationOpen(t) { this._consumeSequenceIfMatch(ut.DASH_DASH, !0) ? (this._createCommentToken(ut.DASH_DASH.length + 1), this.state = x.COMMENT_START) : this._consumeSequenceIfMatch(ut.DOCTYPE, !1) ? (this.currentLocation = this.getCurrentLocation(ut.DOCTYPE.length + 1), this.state = x.DOCTYPE) : this._consumeSequenceIfMatch(ut.CDATA_START, !0) ? this.inForeignNode ? this.state = x.CDATA_SECTION : (this._err(R.cdataInHtmlContent), this._createCommentToken(ut.CDATA_START.length + 1), this.currentToken.data = "[CDATA[", this.state = x.BOGUS_COMMENT) : this._ensureHibernation() || (this._err(R.incorrectlyOpenedComment), this._createCommentToken(2), this.state = x.BOGUS_COMMENT, this._stateBogusComment(t)) } _stateCommentStart(t) { switch (t) { case b.HYPHEN_MINUS: { this.state = x.COMMENT_START_DASH; break } case b.GREATER_THAN_SIGN: { this._err(R.abruptClosingOfEmptyComment), this.state = x.DATA; const n = this.currentToken; this.emitCurrentComment(n); break } default: this.state = x.COMMENT, this._stateComment(t) } } _stateCommentStartDash(t) { const n = this.currentToken; switch (t) { case b.HYPHEN_MINUS: { this.state = x.COMMENT_END; break } case b.GREATER_THAN_SIGN: { this._err(R.abruptClosingOfEmptyComment), this.state = x.DATA, this.emitCurrentComment(n); break } case b.EOF: { this._err(R.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "-", this.state = x.COMMENT, this._stateComment(t) } } _stateComment(t) { const n = this.currentToken; switch (t) { case b.HYPHEN_MINUS: { this.state = x.COMMENT_END_DASH; break } case b.LESS_THAN_SIGN: { n.data += "<", this.state = x.COMMENT_LESS_THAN_SIGN; break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.data += Se; break } case b.EOF: { this._err(R.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += String.fromCodePoint(t) } } _stateCommentLessThanSign(t) { const n = this.currentToken; switch (t) { case b.EXCLAMATION_MARK: { n.data += "!", this.state = x.COMMENT_LESS_THAN_SIGN_BANG; break } case b.LESS_THAN_SIGN: { n.data += "<"; break } default: this.state = x.COMMENT, this._stateComment(t) } } _stateCommentLessThanSignBang(t) { t === b.HYPHEN_MINUS ? this.state = x.COMMENT_LESS_THAN_SIGN_BANG_DASH : (this.state = x.COMMENT, this._stateComment(t)) } _stateCommentLessThanSignBangDash(t) { t === b.HYPHEN_MINUS ? this.state = x.COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH : (this.state = x.COMMENT_END_DASH, this._stateCommentEndDash(t)) } _stateCommentLessThanSignBangDashDash(t) { t !== b.GREATER_THAN_SIGN && t !== b.EOF && this._err(R.nestedComment), this.state = x.COMMENT_END, this._stateCommentEnd(t) } _stateCommentEndDash(t) { const n = this.currentToken; switch (t) { case b.HYPHEN_MINUS: { this.state = x.COMMENT_END; break } case b.EOF: { this._err(R.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "-", this.state = x.COMMENT, this._stateComment(t) } } _stateCommentEnd(t) { const n = this.currentToken; switch (t) { case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentComment(n); break } case b.EXCLAMATION_MARK: { this.state = x.COMMENT_END_BANG; break } case b.HYPHEN_MINUS: { n.data += "-"; break } case b.EOF: { this._err(R.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "--", this.state = x.COMMENT, this._stateComment(t) } } _stateCommentEndBang(t) { const n = this.currentToken; switch (t) { case b.HYPHEN_MINUS: { n.data += "--!", this.state = x.COMMENT_END_DASH; break } case b.GREATER_THAN_SIGN: { this._err(R.incorrectlyClosedComment), this.state = x.DATA, this.emitCurrentComment(n); break } case b.EOF: { this._err(R.eofInComment), this.emitCurrentComment(n), this._emitEOFToken(); break } default: n.data += "--!", this.state = x.COMMENT, this._stateComment(t) } } _stateDoctype(t) { switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this.state = x.BEFORE_DOCTYPE_NAME; break } case b.GREATER_THAN_SIGN: { this.state = x.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t); break } case b.EOF: { this._err(R.eofInDoctype), this._createDoctypeToken(null); const n = this.currentToken; n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingWhitespaceBeforeDoctypeName), this.state = x.BEFORE_DOCTYPE_NAME, this._stateBeforeDoctypeName(t) } } _stateBeforeDoctypeName(t) { if (Gi(t)) this._createDoctypeToken(String.fromCharCode(ws(t))), this.state = x.DOCTYPE_NAME; else switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.NULL: { this._err(R.unexpectedNullCharacter), this._createDoctypeToken(Se), this.state = x.DOCTYPE_NAME; break } case b.GREATER_THAN_SIGN: { this._err(R.missingDoctypeName), this._createDoctypeToken(null); const n = this.currentToken; n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.EOF: { this._err(R.eofInDoctype), this._createDoctypeToken(null); const n = this.currentToken; n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._createDoctypeToken(String.fromCodePoint(t)), this.state = x.DOCTYPE_NAME } } _stateDoctypeName(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this.state = x.AFTER_DOCTYPE_NAME; break } case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.name += Se; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.name += String.fromCodePoint(Gi(t) ? ws(t) : t) } } _stateAfterDoctypeName(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._consumeSequenceIfMatch(ut.PUBLIC, !1) ? this.state = x.AFTER_DOCTYPE_PUBLIC_KEYWORD : this._consumeSequenceIfMatch(ut.SYSTEM, !1) ? this.state = x.AFTER_DOCTYPE_SYSTEM_KEYWORD : this._ensureHibernation() || (this._err(R.invalidCharacterSequenceAfterDoctypeName), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t)) } } _stateAfterDoctypePublicKeyword(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this.state = x.BEFORE_DOCTYPE_PUBLIC_IDENTIFIER; break } case b.QUOTATION_MARK: { this._err(R.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break } case b.APOSTROPHE: { this._err(R.missingWhitespaceAfterDoctypePublicKeyword), n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break } case b.GREATER_THAN_SIGN: { this._err(R.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBeforeDoctypePublicIdentifier(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.QUOTATION_MARK: { n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED; break } case b.APOSTROPHE: { n.publicId = "", this.state = x.DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED; break } case b.GREATER_THAN_SIGN: { this._err(R.missingDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingQuoteBeforeDoctypePublicIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateDoctypePublicIdentifierDoubleQuoted(t) { const n = this.currentToken; switch (t) { case b.QUOTATION_MARK: { this.state = x.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.publicId += Se; break } case b.GREATER_THAN_SIGN: { this._err(R.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.publicId += String.fromCodePoint(t) } } _stateDoctypePublicIdentifierSingleQuoted(t) { const n = this.currentToken; switch (t) { case b.APOSTROPHE: { this.state = x.AFTER_DOCTYPE_PUBLIC_IDENTIFIER; break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.publicId += Se; break } case b.GREATER_THAN_SIGN: { this._err(R.abruptDoctypePublicIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.publicId += String.fromCodePoint(t) } } _stateAfterDoctypePublicIdentifier(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this.state = x.BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS; break } case b.GREATER_THAN_SIGN: { this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.QUOTATION_MARK: { this._err(R.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case b.APOSTROPHE: { this._err(R.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBetweenDoctypePublicAndSystemIdentifiers(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.GREATER_THAN_SIGN: { this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.QUOTATION_MARK: { n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case b.APOSTROPHE: { n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateAfterDoctypeSystemKeyword(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: { this.state = x.BEFORE_DOCTYPE_SYSTEM_IDENTIFIER; break } case b.QUOTATION_MARK: { this._err(R.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case b.APOSTROPHE: { this._err(R.missingWhitespaceAfterDoctypeSystemKeyword), n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case b.GREATER_THAN_SIGN: { this._err(R.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBeforeDoctypeSystemIdentifier(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.QUOTATION_MARK: { n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED; break } case b.APOSTROPHE: { n.systemId = "", this.state = x.DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED; break } case b.GREATER_THAN_SIGN: { this._err(R.missingDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.DATA, this.emitCurrentDoctype(n); break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.missingQuoteBeforeDoctypeSystemIdentifier), n.forceQuirks = !0, this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateDoctypeSystemIdentifierDoubleQuoted(t) { const n = this.currentToken; switch (t) { case b.QUOTATION_MARK: { this.state = x.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.systemId += Se; break } case b.GREATER_THAN_SIGN: { this._err(R.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.systemId += String.fromCodePoint(t) } } _stateDoctypeSystemIdentifierSingleQuoted(t) { const n = this.currentToken; switch (t) { case b.APOSTROPHE: { this.state = x.AFTER_DOCTYPE_SYSTEM_IDENTIFIER; break } case b.NULL: { this._err(R.unexpectedNullCharacter), n.systemId += Se; break } case b.GREATER_THAN_SIGN: { this._err(R.abruptDoctypeSystemIdentifier), n.forceQuirks = !0, this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: n.systemId += String.fromCodePoint(t) } } _stateAfterDoctypeSystemIdentifier(t) { const n = this.currentToken; switch (t) { case b.SPACE: case b.LINE_FEED: case b.TABULATION: case b.FORM_FEED: break; case b.GREATER_THAN_SIGN: { this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.EOF: { this._err(R.eofInDoctype), n.forceQuirks = !0, this.emitCurrentDoctype(n), this._emitEOFToken(); break } default: this._err(R.unexpectedCharacterAfterDoctypeSystemIdentifier), this.state = x.BOGUS_DOCTYPE, this._stateBogusDoctype(t) } } _stateBogusDoctype(t) { const n = this.currentToken; switch (t) { case b.GREATER_THAN_SIGN: { this.emitCurrentDoctype(n), this.state = x.DATA; break } case b.NULL: { this._err(R.unexpectedNullCharacter); break } case b.EOF: { this.emitCurrentDoctype(n), this._emitEOFToken(); break } } } _stateCdataSection(t) { switch (t) { case b.RIGHT_SQUARE_BRACKET: { this.state = x.CDATA_SECTION_BRACKET; break } case b.EOF: { this._err(R.eofInCdata), this._emitEOFToken(); break } default: this._emitCodePoint(t) } } _stateCdataSectionBracket(t) { t === b.RIGHT_SQUARE_BRACKET ? this.state = x.CDATA_SECTION_END : (this._emitChars("]"), this.state = x.CDATA_SECTION, this._stateCdataSection(t)) } _stateCdataSectionEnd(t) { switch (t) { case b.GREATER_THAN_SIGN: { this.state = x.DATA; break } case b.RIGHT_SQUARE_BRACKET: { this._emitChars("]"); break } default: this._emitChars("]]"), this.state = x.CDATA_SECTION, this._stateCdataSection(t) } } _stateCharacterReference() { let t = this.entityDecoder.write(this.preprocessor.html, this.preprocessor.pos); if (t < 0) if (this.preprocessor.lastChunkWritten) t = this.entityDecoder.end(); else { this.active = !1, this.preprocessor.pos = this.preprocessor.html.length - 1, this.consumedAfterSnapshot = 0, this.preprocessor.endOfChunkHit = !0; return } t === 0 ? (this.preprocessor.pos = this.entityStartPos, this._flushCodePointConsumedAsCharacterReference(b.AMPERSAND), this.state = !this._isCharacterReferenceInAttribute() && Ap(this.preprocessor.peek(1)) ? x.AMBIGUOUS_AMPERSAND : this.returnState) : this.state = this.returnState } _stateAmbiguousAmpersand(t) { Ap(t) ? this._flushCodePointConsumedAsCharacterReference(t) : (t === b.SEMICOLON && this._err(R.unknownNamedCharacterReference), this.state = this.returnState, this._callState(t)) } } const dT = new Set([c.DD, c.DT, c.LI, c.OPTGROUP, c.OPTION, c.P, c.RB, c.RP, c.RT, c.RTC]), Np = new Set([...dT, c.CAPTION, c.COLGROUP, c.TBODY, c.TD, c.TFOOT, c.TH, c.THEAD, c.TR]), va = new Set([c.APPLET, c.CAPTION, c.HTML, c.MARQUEE, c.OBJECT, c.TABLE, c.TD, c.TEMPLATE, c.TH]), iv = new Set([...va, c.OL, c.UL]), uv = new Set([...va, c.BUTTON]), Ip = new Set([c.ANNOTATION_XML, c.MI, c.MN, c.MO, c.MS, c.MTEXT]), wp = new Set([c.DESC, c.FOREIGN_OBJECT, c.TITLE]), sv = new Set([c.TR, c.TEMPLATE, c.HTML]), av = new Set([c.TBODY, c.TFOOT, c.THEAD, c.TEMPLATE, c.HTML]), ov = new Set([c.TABLE, c.TEMPLATE, c.HTML]), lv = new Set([c.TD, c.TH]); class cv { get currentTmplContentOrNode() { return this._isInTemplate() ? this.treeAdapter.getTemplateContent(this.current) : this.current } constructor(t, n, r) { this.treeAdapter = n, this.handler = r, this.items = [], this.tagIDs = [], this.stackTop = -1, this.tmplCount = 0, this.currentTagId = c.UNKNOWN, this.current = t } _indexOf(t) { return this.items.lastIndexOf(t, this.stackTop) } _isInTemplate() { return this.currentTagId === c.TEMPLATE && this.treeAdapter.getNamespaceURI(this.current) === F.HTML } _updateCurrentElement() { this.current = this.items[this.stackTop], this.currentTagId = this.tagIDs[this.stackTop] } push(t, n) { this.stackTop++, this.items[this.stackTop] = t, this.current = t, this.tagIDs[this.stackTop] = n, this.currentTagId = n, this._isInTemplate() && this.tmplCount++, this.handler.onItemPush(t, n, !0) } pop() { const t = this.current; this.tmplCount > 0 && this._isInTemplate() && this.tmplCount--, this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !0) } replace(t, n) { const r = this._indexOf(t); this.items[r] = n, r === this.stackTop && (this.current = n) } insertAfter(t, n, r) { const i = this._indexOf(t) + 1; this.items.splice(i, 0, n), this.tagIDs.splice(i, 0, r), this.stackTop++, i === this.stackTop && this._updateCurrentElement(), this.current && this.currentTagId !== void 0 && this.handler.onItemPush(this.current, this.currentTagId, i === this.stackTop) } popUntilTagNamePopped(t) { let n = this.stackTop + 1; do n = this.tagIDs.lastIndexOf(t, n - 1); while (n > 0 && this.treeAdapter.getNamespaceURI(this.items[n]) !== F.HTML); this.shortenToLength(Math.max(n, 0)) } shortenToLength(t) { for (; this.stackTop >= t;) { const n = this.current; this.tmplCount > 0 && this._isInTemplate() && (this.tmplCount -= 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(n, this.stackTop < t) } } popUntilElementPopped(t) { const n = this._indexOf(t); this.shortenToLength(Math.max(n, 0)) } popUntilPopped(t, n) { const r = this._indexOfTagNames(t, n); this.shortenToLength(Math.max(r, 0)) } popUntilNumberedHeaderPopped() { this.popUntilPopped(Hc, F.HTML) } popUntilTableCellPopped() { this.popUntilPopped(lv, F.HTML) } popAllUpToHtmlElement() { this.tmplCount = 0, this.shortenToLength(1) } _indexOfTagNames(t, n) { for (let r = this.stackTop; r >= 0; r--)if (t.has(this.tagIDs[r]) && this.treeAdapter.getNamespaceURI(this.items[r]) === n) return r; return -1 } clearBackTo(t, n) { const r = this._indexOfTagNames(t, n); this.shortenToLength(r + 1) } clearBackToTableContext() { this.clearBackTo(ov, F.HTML) } clearBackToTableBodyContext() { this.clearBackTo(av, F.HTML) } clearBackToTableRowContext() { this.clearBackTo(sv, F.HTML) } remove(t) { const n = this._indexOf(t); n >= 0 && (n === this.stackTop ? this.pop() : (this.items.splice(n, 1), this.tagIDs.splice(n, 1), this.stackTop--, this._updateCurrentElement(), this.handler.onItemPop(t, !1))) } tryPeekProperlyNestedBodyElement() { return this.stackTop >= 1 && this.tagIDs[1] === c.BODY ? this.items[1] : null } contains(t) { return this._indexOf(t) > -1 } getCommonAncestor(t) { const n = this._indexOf(t) - 1; return n >= 0 ? this.items[n] : null } isRootHtmlElementCurrent() { return this.stackTop === 0 && this.tagIDs[0] === c.HTML } hasInDynamicScope(t, n) { for (let r = this.stackTop; r >= 0; r--) { const i = this.tagIDs[r]; switch (this.treeAdapter.getNamespaceURI(this.items[r])) { case F.HTML: { if (i === t) return !0; if (n.has(i)) return !1; break } case F.SVG: { if (wp.has(i)) return !1; break } case F.MATHML: { if (Ip.has(i)) return !1; break } } } return !0 } hasInScope(t) { return this.hasInDynamicScope(t, va) } hasInListItemScope(t) { return this.hasInDynamicScope(t, iv) } hasInButtonScope(t) { return this.hasInDynamicScope(t, uv) } hasNumberedHeaderInScope() { for (let t = this.stackTop; t >= 0; t--) { const n = this.tagIDs[t]; switch (this.treeAdapter.getNamespaceURI(this.items[t])) { case F.HTML: { if (Hc.has(n)) return !0; if (va.has(n)) return !1; break } case F.SVG: { if (wp.has(n)) return !1; break } case F.MATHML: { if (Ip.has(n)) return !1; break } } } return !0 } hasInTableScope(t) { for (let n = this.stackTop; n >= 0; n--)if (this.treeAdapter.getNamespaceURI(this.items[n]) === F.HTML) switch (this.tagIDs[n]) { case t: return !0; case c.TABLE: case c.HTML: return !1 }return !0 } hasTableBodyContextInTableScope() { for (let t = this.stackTop; t >= 0; t--)if (this.treeAdapter.getNamespaceURI(this.items[t]) === F.HTML) switch (this.tagIDs[t]) { case c.TBODY: case c.THEAD: case c.TFOOT: return !0; case c.TABLE: case c.HTML: return !1 }return !0 } hasInSelectScope(t) { for (let n = this.stackTop; n >= 0; n--)if (this.treeAdapter.getNamespaceURI(this.items[n]) === F.HTML) switch (this.tagIDs[n]) { case t: return !0; case c.OPTION: case c.OPTGROUP: break; default: return !1 }return !0 } generateImpliedEndTags() { for (; this.currentTagId !== void 0 && dT.has(this.currentTagId);)this.pop() } generateImpliedEndTagsThoroughly() { for (; this.currentTagId !== void 0 && Np.has(this.currentTagId);)this.pop() } generateImpliedEndTagsWithExclusion(t) { for (; this.currentTagId !== void 0 && this.currentTagId !== t && Np.has(this.currentTagId);)this.pop() } } const pl = 3; var Xt; (function (e) { e[e.Marker = 0] = "Marker", e[e.Element = 1] = "Element" })(Xt || (Xt = {})); const vp = { type: Xt.Marker }; class fv { constructor(t) { this.treeAdapter = t, this.entries = [], this.bookmark = null } _getNoahArkConditionCandidates(t, n) { const r = [], i = n.length, u = this.treeAdapter.getTagName(t), s = this.treeAdapter.getNamespaceURI(t); for (let a = 0; a < this.entries.length; a++) { const o = this.entries[a]; if (o.type === Xt.Marker) break; const { element: l } = o; if (this.treeAdapter.getTagName(l) === u && this.treeAdapter.getNamespaceURI(l) === s) { const f = this.treeAdapter.getAttrList(l); f.length === i && r.push({ idx: a, attrs: f }) } } return r } _ensureNoahArkCondition(t) { if (this.entries.length < pl) return; const n = this.treeAdapter.getAttrList(t), r = this._getNoahArkConditionCandidates(t, n); if (r.length < pl) return; const i = new Map(n.map(s => [s.name, s.value])); let u = 0; for (let s = 0; s < r.length; s++) { const a = r[s]; a.attrs.every(o => i.get(o.name) === o.value) && (u += 1, u >= pl && this.entries.splice(a.idx, 1)) } } insertMarker() { this.entries.unshift(vp) } pushElement(t, n) { this._ensureNoahArkCondition(t), this.entries.unshift({ type: Xt.Element, element: t, token: n }) } insertElementAfterBookmark(t, n) { const r = this.entries.indexOf(this.bookmark); this.entries.splice(r, 0, { type: Xt.Element, element: t, token: n }) } removeEntry(t) { const n = this.entries.indexOf(t); n !== -1 && this.entries.splice(n, 1) } clearToLastMarker() { const t = this.entries.indexOf(vp); t === -1 ? this.entries.length = 0 : this.entries.splice(0, t + 1) } getElementEntryInScopeWithTagName(t) { const n = this.entries.find(r => r.type === Xt.Marker || this.treeAdapter.getTagName(r.element) === t); return n && n.type === Xt.Element ? n : null } getElementEntry(t) { return this.entries.find(n => n.type === Xt.Element && n.element === t) } } const An = { createDocument() { return { nodeName: "#document", mode: It.NO_QUIRKS, childNodes: [] } }, createDocumentFragment() { return { nodeName: "#document-fragment", childNodes: [] } }, createElement(e, t, n) { return { nodeName: e, tagName: e, attrs: n, namespaceURI: t, childNodes: [], parentNode: null } }, createCommentNode(e) { return { nodeName: "#comment", data: e, parentNode: null } }, createTextNode(e) { return { nodeName: "#text", value: e, parentNode: null } }, appendChild(e, t) { e.childNodes.push(t), t.parentNode = e }, insertBefore(e, t, n) { const r = e.childNodes.indexOf(n); e.childNodes.splice(r, 0, t), t.parentNode = e }, setTemplateContent(e, t) { e.content = t }, getTemplateContent(e) { return e.content }, setDocumentType(e, t, n, r) { const i = e.childNodes.find(u => u.nodeName === "#documentType"); if (i) i.name = t, i.publicId = n, i.systemId = r; else { const u = { nodeName: "#documentType", name: t, publicId: n, systemId: r, parentNode: null }; An.appendChild(e, u) } }, setDocumentMode(e, t) { e.mode = t }, getDocumentMode(e) { return e.mode }, detachNode(e) { if (e.parentNode) { const t = e.parentNode.childNodes.indexOf(e); e.parentNode.childNodes.splice(t, 1), e.parentNode = null } }, insertText(e, t) { if (e.childNodes.length > 0) { const n = e.childNodes[e.childNodes.length - 1]; if (An.isTextNode(n)) { n.value += t; return } } An.appendChild(e, An.createTextNode(t)) }, insertTextBefore(e, t, n) { const r = e.childNodes[e.childNodes.indexOf(n) - 1]; r && An.isTextNode(r) ? r.value += t : An.insertBefore(e, An.createTextNode(t), n) }, adoptAttributes(e, t) { const n = new Set(e.attrs.map(r => r.name)); for (let r = 0; r < t.length; r++)n.has(t[r].name) || e.attrs.push(t[r]) }, getFirstChild(e) { return e.childNodes[0] }, getChildNodes(e) { return e.childNodes }, getParentNode(e) { return e.parentNode }, getAttrList(e) { return e.attrs }, getTagName(e) { return e.tagName }, getNamespaceURI(e) { return e.namespaceURI }, getTextNodeContent(e) { return e.value }, getCommentNodeContent(e) { return e.data }, getDocumentTypeNodeName(e) { return e.name }, getDocumentTypeNodePublicId(e) { return e.publicId }, getDocumentTypeNodeSystemId(e) { return e.systemId }, isTextNode(e) { return e.nodeName === "#text" }, isCommentNode(e) { return e.nodeName === "#comment" }, isDocumentTypeNode(e) { return e.nodeName === "#documentType" }, isElementNode(e) { return Object.prototype.hasOwnProperty.call(e, "tagName") }, setNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = t }, getNodeSourceCodeLocation(e) { return e.sourceCodeLocation }, updateNodeSourceCodeLocation(e, t) { e.sourceCodeLocation = { ...e.sourceCodeLocation, ...t } } }, hT = "html", dv = "about:legacy-compat", hv = "http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd", pT = ["+//silmaril//dtd html pro v0r11 19970101//", "-//as//dtd html 3.0 aswedit + extensions//", "-//advasoft ltd//dtd html 3.0 aswedit + extensions//", "-//ietf//dtd html 2.0 level 1//", "-//ietf//dtd html 2.0 level 2//", "-//ietf//dtd html 2.0 strict level 1//", "-//ietf//dtd html 2.0 strict level 2//", "-//ietf//dtd html 2.0 strict//", "-//ietf//dtd html 2.0//", "-//ietf//dtd html 2.1e//", "-//ietf//dtd html 3.0//", "-//ietf//dtd html 3.2 final//", "-//ietf//dtd html 3.2//", "-//ietf//dtd html 3//", "-//ietf//dtd html level 0//", "-//ietf//dtd html level 1//", "-//ietf//dtd html level 2//", "-//ietf//dtd html level 3//", "-//ietf//dtd html strict level 0//", "-//ietf//dtd html strict level 1//", "-//ietf//dtd html strict level 2//", "-//ietf//dtd html strict level 3//", "-//ietf//dtd html strict//", "-//ietf//dtd html//", "-//metrius//dtd metrius presentational//", "-//microsoft//dtd internet explorer 2.0 html strict//", "-//microsoft//dtd internet explorer 2.0 html//", "-//microsoft//dtd internet explorer 2.0 tables//", "-//microsoft//dtd internet explorer 3.0 html strict//", "-//microsoft//dtd internet explorer 3.0 html//", "-//microsoft//dtd internet explorer 3.0 tables//", "-//netscape comm. corp.//dtd html//", "-//netscape comm. corp.//dtd strict html//", "-//o'reilly and associates//dtd html 2.0//", "-//o'reilly and associates//dtd html extended 1.0//", "-//o'reilly and associates//dtd html extended relaxed 1.0//", "-//sq//dtd html 2.0 hotmetal + extensions//", "-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//", "-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//", "-//spyglass//dtd html 2.0 extended//", "-//sun microsystems corp.//dtd hotjava html//", "-//sun microsystems corp.//dtd hotjava strict html//", "-//w3c//dtd html 3 1995-03-24//", "-//w3c//dtd html 3.2 draft//", "-//w3c//dtd html 3.2 final//", "-//w3c//dtd html 3.2//", "-//w3c//dtd html 3.2s draft//", "-//w3c//dtd html 4.0 frameset//", "-//w3c//dtd html 4.0 transitional//", "-//w3c//dtd html experimental 19960712//", "-//w3c//dtd html experimental 970421//", "-//w3c//dtd w3 html//", "-//w3o//dtd w3 html 3.0//", "-//webtechs//dtd mozilla html 2.0//", "-//webtechs//dtd mozilla html//"], pv = [...pT, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"], mv = new Set(["-//w3o//dtd w3 html strict 3.0//en//", "-/w3c/dtd html 4.0 transitional/en", "html"]), mT = ["-//w3c//dtd xhtml 1.0 frameset//", "-//w3c//dtd xhtml 1.0 transitional//"], gv = [...mT, "-//w3c//dtd html 4.01 frameset//", "-//w3c//dtd html 4.01 transitional//"]; function Op(e, t) { return t.some(n => e.startsWith(n)) } function Ev(e) { return e.name === hT && e.publicId === null && (e.systemId === null || e.systemId === dv) } function Tv(e) { if (e.name !== hT) return It.QUIRKS; const { systemId: t } = e; if (t && t.toLowerCase() === hv) return It.QUIRKS; let { publicId: n } = e; if (n !== null) { if (n = n.toLowerCase(), mv.has(n)) return It.QUIRKS; let r = t === null ? pv : pT; if (Op(n, r)) return It.QUIRKS; if (r = t === null ? mT : gv, Op(n, r)) return It.LIMITED_QUIRKS } return It.NO_QUIRKS } const Lp = { TEXT_HTML: "text/html", APPLICATION_XML: "application/xhtml+xml" }, yv = "definitionurl", bv = "definitionURL", xv = new Map(["attributeName", "attributeType", "baseFrequency", "baseProfile", "calcMode", "clipPathUnits", "diffuseConstant", "edgeMode", "filterUnits", "glyphRef", "gradientTransform", "gradientUnits", "kernelMatrix", "kernelUnitLength", "keyPoints", "keySplines", "keyTimes", "lengthAdjust", "limitingConeAngle", "markerHeight", "markerUnits", "markerWidth", "maskContentUnits", "maskUnits", "numOctaves", "pathLength", "patternContentUnits", "patternTransform", "patternUnits", "pointsAtX", "pointsAtY", "pointsAtZ", "preserveAlpha", "preserveAspectRatio", "primitiveUnits", "refX", "refY", "repeatCount", "repeatDur", "requiredExtensions", "requiredFeatures", "specularConstant", "specularExponent", "spreadMethod", "startOffset", "stdDeviation", "stitchTiles", "surfaceScale", "systemLanguage", "tableValues", "targetX", "targetY", "textLength", "viewBox", "viewTarget", "xChannelSelector", "yChannelSelector", "zoomAndPan"].map(e => [e.toLowerCase(), e])), Sv = new Map([["xlink:actuate", { prefix: "xlink", name: "actuate", namespace: F.XLINK }], ["xlink:arcrole", { prefix: "xlink", name: "arcrole", namespace: F.XLINK }], ["xlink:href", { prefix: "xlink", name: "href", namespace: F.XLINK }], ["xlink:role", { prefix: "xlink", name: "role", namespace: F.XLINK }], ["xlink:show", { prefix: "xlink", name: "show", namespace: F.XLINK }], ["xlink:title", { prefix: "xlink", name: "title", namespace: F.XLINK }], ["xlink:type", { prefix: "xlink", name: "type", namespace: F.XLINK }], ["xml:lang", { prefix: "xml", name: "lang", namespace: F.XML }], ["xml:space", { prefix: "xml", name: "space", namespace: F.XML }], ["xmlns", { prefix: "", name: "xmlns", namespace: F.XMLNS }], ["xmlns:xlink", { prefix: "xmlns", name: "xlink", namespace: F.XMLNS }]]), _v = new Map(["altGlyph", "altGlyphDef", "altGlyphItem", "animateColor", "animateMotion", "animateTransform", "clipPath", "feBlend", "feColorMatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "foreignObject", "glyphRef", "linearGradient", "radialGradient", "textPath"].map(e => [e.toLowerCase(), e])), Cv = new Set([c.B, c.BIG, c.BLOCKQUOTE, c.BODY, c.BR, c.CENTER, c.CODE, c.DD, c.DIV, c.DL, c.DT, c.EM, c.EMBED, c.H1, c.H2, c.H3, c.H4, c.H5, c.H6, c.HEAD, c.HR, c.I, c.IMG, c.LI, c.LISTING, c.MENU, c.META, c.NOBR, c.OL, c.P, c.PRE, c.RUBY, c.S, c.SMALL, c.SPAN, c.STRONG, c.STRIKE, c.SUB, c.SUP, c.TABLE, c.TT, c.U, c.UL, c.VAR]); function Av(e) { const t = e.tagID; return t === c.FONT && e.attrs.some(({ name: r }) => r === hr.COLOR || r === hr.SIZE || r === hr.FACE) || Cv.has(t) } function gT(e) { for (let t = 0; t < e.attrs.length; t++)if (e.attrs[t].name === yv) { e.attrs[t].name = bv; break } } function ET(e) { for (let t = 0; t < e.attrs.length; t++) { const n = xv.get(e.attrs[t].name); n != null && (e.attrs[t].name = n) } } function hd(e) { for (let t = 0; t < e.attrs.length; t++) { const n = Sv.get(e.attrs[t].name); n && (e.attrs[t].prefix = n.prefix, e.attrs[t].name = n.name, e.attrs[t].namespace = n.namespace) } } function kv(e) { const t = _v.get(e.tagName); t != null && (e.tagName = t, e.tagID = Ai(e.tagName)) } function Nv(e, t) { return t === F.MATHML && (e === c.MI || e === c.MO || e === c.MN || e === c.MS || e === c.MTEXT) } function Iv(e, t, n) { if (t === F.MATHML && e === c.ANNOTATION_XML) { for (let r = 0; r < n.length; r++)if (n[r].name === hr.ENCODING) { const i = n[r].value.toLowerCase(); return i === Lp.TEXT_HTML || i === Lp.APPLICATION_XML } } return t === F.SVG && (e === c.FOREIGN_OBJECT || e === c.DESC || e === c.TITLE) } function wv(e, t, n, r) { return (!r || r === F.HTML) && Iv(e, t, n) || (!r || r === F.MATHML) && Nv(e, t) } const vv = "hidden", Ov = 8, Lv = 3; var C; (function (e) { e[e.INITIAL = 0] = "INITIAL", e[e.BEFORE_HTML = 1] = "BEFORE_HTML", e[e.BEFORE_HEAD = 2] = "BEFORE_HEAD", e[e.IN_HEAD = 3] = "IN_HEAD", e[e.IN_HEAD_NO_SCRIPT = 4] = "IN_HEAD_NO_SCRIPT", e[e.AFTER_HEAD = 5] = "AFTER_HEAD", e[e.IN_BODY = 6] = "IN_BODY", e[e.TEXT = 7] = "TEXT", e[e.IN_TABLE = 8] = "IN_TABLE", e[e.IN_TABLE_TEXT = 9] = "IN_TABLE_TEXT", e[e.IN_CAPTION = 10] = "IN_CAPTION", e[e.IN_COLUMN_GROUP = 11] = "IN_COLUMN_GROUP", e[e.IN_TABLE_BODY = 12] = "IN_TABLE_BODY", e[e.IN_ROW = 13] = "IN_ROW", e[e.IN_CELL = 14] = "IN_CELL", e[e.IN_SELECT = 15] = "IN_SELECT", e[e.IN_SELECT_IN_TABLE = 16] = "IN_SELECT_IN_TABLE", e[e.IN_TEMPLATE = 17] = "IN_TEMPLATE", e[e.AFTER_BODY = 18] = "AFTER_BODY", e[e.IN_FRAMESET = 19] = "IN_FRAMESET", e[e.AFTER_FRAMESET = 20] = "AFTER_FRAMESET", e[e.AFTER_AFTER_BODY = 21] = "AFTER_AFTER_BODY", e[e.AFTER_AFTER_FRAMESET = 22] = "AFTER_AFTER_FRAMESET" })(C || (C = {})); const Rv = { startLine: -1, startCol: -1, startOffset: -1, endLine: -1, endCol: -1, endOffset: -1 }, TT = new Set([c.TABLE, c.TBODY, c.TFOOT, c.THEAD, c.TR]), Rp = { scriptingEnabled: !0, sourceCodeLocationInfo: !1, treeAdapter: An, onParseError: null }; class Pp { constructor(t, n, r = null, i = null) { this.fragmentContext = r, this.scriptHandler = i, this.currentToken = null, this.stopped = !1, this.insertionMode = C.INITIAL, this.originalInsertionMode = C.INITIAL, this.headElement = null, this.formElement = null, this.currentNotInHTML = !1, this.tmplInsertionModeStack = [], this.pendingCharacterTokens = [], this.hasNonWhitespacePendingCharacterToken = !1, this.framesetOk = !0, this.skipNextNewLine = !1, this.fosterParentingEnabled = !1, this.options = { ...Rp, ...t }, this.treeAdapter = this.options.treeAdapter, this.onParseError = this.options.onParseError, this.onParseError && (this.options.sourceCodeLocationInfo = !0), this.document = n ?? this.treeAdapter.createDocument(), this.tokenizer = new rv(this.options, this), this.activeFormattingElements = new fv(this.treeAdapter), this.fragmentContextID = r ? Ai(this.treeAdapter.getTagName(r)) : c.UNKNOWN, this._setContextModes(r ?? this.document, this.fragmentContextID), this.openElements = new cv(this.document, this.treeAdapter, this) } static parse(t, n) { const r = new this(n); return r.tokenizer.write(t, !0), r.document } static getFragmentParser(t, n) { const r = { ...Rp, ...n }; t ?? (t = r.treeAdapter.createElement(v.TEMPLATE, F.HTML, [])); const i = r.treeAdapter.createElement("documentmock", F.HTML, []), u = new this(r, i, t); return u.fragmentContextID === c.TEMPLATE && u.tmplInsertionModeStack.unshift(C.IN_TEMPLATE), u._initTokenizerForFragmentParsing(), u._insertFakeRootElement(), u._resetInsertionMode(), u._findFormInFragmentContext(), u } getFragment() { const t = this.treeAdapter.getFirstChild(this.document), n = this.treeAdapter.createDocumentFragment(); return this._adoptNodes(t, n), n } _err(t, n, r) { var i; if (!this.onParseError) return; const u = (i = t.location) !== null && i !== void 0 ? i : Rv, s = { code: n, startLine: u.startLine, startCol: u.startCol, startOffset: u.startOffset, endLine: r ? u.startLine : u.endLine, endCol: r ? u.startCol : u.endCol, endOffset: r ? u.startOffset : u.endOffset }; this.onParseError(s) } onItemPush(t, n, r) { var i, u; (u = (i = this.treeAdapter).onItemPush) === null || u === void 0 || u.call(i, t), r && this.openElements.stackTop > 0 && this._setContextModes(t, n) } onItemPop(t, n) { var r, i; if (this.options.sourceCodeLocationInfo && this._setEndLocation(t, this.currentToken), (i = (r = this.treeAdapter).onItemPop) === null || i === void 0 || i.call(r, t, this.openElements.current), n) { let u, s; this.openElements.stackTop === 0 && this.fragmentContext ? (u = this.fragmentContext, s = this.fragmentContextID) : { current: u, currentTagId: s } = this.openElements, this._setContextModes(u, s) } } _setContextModes(t, n) { const r = t === this.document || t && this.treeAdapter.getNamespaceURI(t) === F.HTML; this.currentNotInHTML = !r, this.tokenizer.inForeignNode = !r && t !== void 0 && n !== void 0 && !this._isIntegrationPoint(n, t) } _switchToTextParsing(t, n) { this._insertElement(t, F.HTML), this.tokenizer.state = n, this.originalInsertionMode = this.insertionMode, this.insertionMode = C.TEXT } switchToPlaintextParsing() { this.insertionMode = C.TEXT, this.originalInsertionMode = C.IN_BODY, this.tokenizer.state = ve.PLAINTEXT } _getAdjustedCurrentElement() { return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current } _findFormInFragmentContext() { let t = this.fragmentContext; for (; t;) { if (this.treeAdapter.getTagName(t) === v.FORM) { this.formElement = t; break } t = this.treeAdapter.getParentNode(t) } } _initTokenizerForFragmentParsing() { if (!(!this.fragmentContext || this.treeAdapter.getNamespaceURI(this.fragmentContext) !== F.HTML)) switch (this.fragmentContextID) { case c.TITLE: case c.TEXTAREA: { this.tokenizer.state = ve.RCDATA; break } case c.STYLE: case c.XMP: case c.IFRAME: case c.NOEMBED: case c.NOFRAMES: case c.NOSCRIPT: { this.tokenizer.state = ve.RAWTEXT; break } case c.SCRIPT: { this.tokenizer.state = ve.SCRIPT_DATA; break } case c.PLAINTEXT: { this.tokenizer.state = ve.PLAINTEXT; break } } } _setDocumentType(t) { const n = t.name || "", r = t.publicId || "", i = t.systemId || ""; if (this.treeAdapter.setDocumentType(this.document, n, r, i), t.location) { const s = this.treeAdapter.getChildNodes(this.document).find(a => this.treeAdapter.isDocumentTypeNode(a)); s && this.treeAdapter.setNodeSourceCodeLocation(s, t.location) } } _attachElementToTree(t, n) { if (this.options.sourceCodeLocationInfo) { const r = n && { ...n, startTag: n }; this.treeAdapter.setNodeSourceCodeLocation(t, r) } if (this._shouldFosterParentOnInsertion()) this._fosterParentElement(t); else { const r = this.openElements.currentTmplContentOrNode; this.treeAdapter.appendChild(r ?? this.document, t) } } _appendElement(t, n) { const r = this.treeAdapter.createElement(t.tagName, n, t.attrs); this._attachElementToTree(r, t.location) } _insertElement(t, n) { const r = this.treeAdapter.createElement(t.tagName, n, t.attrs); this._attachElementToTree(r, t.location), this.openElements.push(r, t.tagID) } _insertFakeElement(t, n) { const r = this.treeAdapter.createElement(t, F.HTML, []); this._attachElementToTree(r, null), this.openElements.push(r, n) } _insertTemplate(t) { const n = this.treeAdapter.createElement(t.tagName, F.HTML, t.attrs), r = this.treeAdapter.createDocumentFragment(); this.treeAdapter.setTemplateContent(n, r), this._attachElementToTree(n, t.location), this.openElements.push(n, t.tagID), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, null) } _insertFakeRootElement() { const t = this.treeAdapter.createElement(v.HTML, F.HTML, []); this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(t, null), this.treeAdapter.appendChild(this.openElements.current, t), this.openElements.push(t, c.HTML) } _appendCommentNode(t, n) { const r = this.treeAdapter.createCommentNode(t.data); this.treeAdapter.appendChild(n, r), this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(r, t.location) } _insertCharacters(t) { let n, r; if (this._shouldFosterParentOnInsertion() ? ({ parent: n, beforeElement: r } = this._findFosterParentingLocation(), r ? this.treeAdapter.insertTextBefore(n, t.chars, r) : this.treeAdapter.insertText(n, t.chars)) : (n = this.openElements.currentTmplContentOrNode, this.treeAdapter.insertText(n, t.chars)), !t.location) return; const i = this.treeAdapter.getChildNodes(n), u = r ? i.lastIndexOf(r) : i.length, s = i[u - 1]; if (this.treeAdapter.getNodeSourceCodeLocation(s)) { const { endLine: o, endCol: l, endOffset: f } = t.location; this.treeAdapter.updateNodeSourceCodeLocation(s, { endLine: o, endCol: l, endOffset: f }) } else this.options.sourceCodeLocationInfo && this.treeAdapter.setNodeSourceCodeLocation(s, t.location) } _adoptNodes(t, n) { for (let r = this.treeAdapter.getFirstChild(t); r; r = this.treeAdapter.getFirstChild(t))this.treeAdapter.detachNode(r), this.treeAdapter.appendChild(n, r) } _setEndLocation(t, n) { if (this.treeAdapter.getNodeSourceCodeLocation(t) && n.location) { const r = n.location, i = this.treeAdapter.getTagName(t), u = n.type === se.END_TAG && i === n.tagName ? { endTag: { ...r }, endLine: r.endLine, endCol: r.endCol, endOffset: r.endOffset } : { endLine: r.startLine, endCol: r.startCol, endOffset: r.startOffset }; this.treeAdapter.updateNodeSourceCodeLocation(t, u) } } shouldProcessStartTagTokenInForeignContent(t) { if (!this.currentNotInHTML) return !1; let n, r; return this.openElements.stackTop === 0 && this.fragmentContext ? (n = this.fragmentContext, r = this.fragmentContextID) : { current: n, currentTagId: r } = this.openElements, t.tagID === c.SVG && this.treeAdapter.getTagName(n) === v.ANNOTATION_XML && this.treeAdapter.getNamespaceURI(n) === F.MATHML ? !1 : this.tokenizer.inForeignNode || (t.tagID === c.MGLYPH || t.tagID === c.MALIGNMARK) && r !== void 0 && !this._isIntegrationPoint(r, n, F.HTML) } _processToken(t) { switch (t.type) { case se.CHARACTER: { this.onCharacter(t); break } case se.NULL_CHARACTER: { this.onNullCharacter(t); break } case se.COMMENT: { this.onComment(t); break } case se.DOCTYPE: { this.onDoctype(t); break } case se.START_TAG: { this._processStartTag(t); break } case se.END_TAG: { this.onEndTag(t); break } case se.EOF: { this.onEof(t); break } case se.WHITESPACE_CHARACTER: { this.onWhitespaceCharacter(t); break } } } _isIntegrationPoint(t, n, r) { const i = this.treeAdapter.getNamespaceURI(n), u = this.treeAdapter.getAttrList(n); return wv(t, i, u, r) } _reconstructActiveFormattingElements() { const t = this.activeFormattingElements.entries.length; if (t) { const n = this.activeFormattingElements.entries.findIndex(i => i.type === Xt.Marker || this.openElements.contains(i.element)), r = n === -1 ? t - 1 : n - 1; for (let i = r; i >= 0; i--) { const u = this.activeFormattingElements.entries[i]; this._insertElement(u.token, this.treeAdapter.getNamespaceURI(u.element)), u.element = this.openElements.current } } } _closeTableCell() { this.openElements.generateImpliedEndTags(), this.openElements.popUntilTableCellPopped(), this.activeFormattingElements.clearToLastMarker(), this.insertionMode = C.IN_ROW } _closePElement() { this.openElements.generateImpliedEndTagsWithExclusion(c.P), this.openElements.popUntilTagNamePopped(c.P) } _resetInsertionMode() { for (let t = this.openElements.stackTop; t >= 0; t--)switch (t === 0 && this.fragmentContext ? this.fragmentContextID : this.openElements.tagIDs[t]) { case c.TR: { this.insertionMode = C.IN_ROW; return } case c.TBODY: case c.THEAD: case c.TFOOT: { this.insertionMode = C.IN_TABLE_BODY; return } case c.CAPTION: { this.insertionMode = C.IN_CAPTION; return } case c.COLGROUP: { this.insertionMode = C.IN_COLUMN_GROUP; return } case c.TABLE: { this.insertionMode = C.IN_TABLE; return } case c.BODY: { this.insertionMode = C.IN_BODY; return } case c.FRAMESET: { this.insertionMode = C.IN_FRAMESET; return } case c.SELECT: { this._resetInsertionModeForSelect(t); return } case c.TEMPLATE: { this.insertionMode = this.tmplInsertionModeStack[0]; return } case c.HTML: { this.insertionMode = this.headElement ? C.AFTER_HEAD : C.BEFORE_HEAD; return } case c.TD: case c.TH: { if (t > 0) { this.insertionMode = C.IN_CELL; return } break } case c.HEAD: { if (t > 0) { this.insertionMode = C.IN_HEAD; return } break } }this.insertionMode = C.IN_BODY } _resetInsertionModeForSelect(t) { if (t > 0) for (let n = t - 1; n > 0; n--) { const r = this.openElements.tagIDs[n]; if (r === c.TEMPLATE) break; if (r === c.TABLE) { this.insertionMode = C.IN_SELECT_IN_TABLE; return } } this.insertionMode = C.IN_SELECT } _isElementCausesFosterParenting(t) { return TT.has(t) } _shouldFosterParentOnInsertion() { return this.fosterParentingEnabled && this.openElements.currentTagId !== void 0 && this._isElementCausesFosterParenting(this.openElements.currentTagId) } _findFosterParentingLocation() { for (let t = this.openElements.stackTop; t >= 0; t--) { const n = this.openElements.items[t]; switch (this.openElements.tagIDs[t]) { case c.TEMPLATE: { if (this.treeAdapter.getNamespaceURI(n) === F.HTML) return { parent: this.treeAdapter.getTemplateContent(n), beforeElement: null }; break } case c.TABLE: { const r = this.treeAdapter.getParentNode(n); return r ? { parent: r, beforeElement: n } : { parent: this.openElements.items[t - 1], beforeElement: null } } } } return { parent: this.openElements.items[0], beforeElement: null } } _fosterParentElement(t) { const n = this._findFosterParentingLocation(); n.beforeElement ? this.treeAdapter.insertBefore(n.parent, t, n.beforeElement) : this.treeAdapter.appendChild(n.parent, t) } _isSpecialElement(t, n) { const r = this.treeAdapter.getNamespaceURI(t); return Z6[r].has(n) } onCharacter(t) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) { lL(this, t); return } switch (this.insertionMode) { case C.INITIAL: { $i(this, t); break } case C.BEFORE_HTML: { hu(this, t); break } case C.BEFORE_HEAD: { pu(this, t); break } case C.IN_HEAD: { mu(this, t); break } case C.IN_HEAD_NO_SCRIPT: { gu(this, t); break } case C.AFTER_HEAD: { Eu(this, t); break } case C.IN_BODY: case C.IN_CAPTION: case C.IN_CELL: case C.IN_TEMPLATE: { bT(this, t); break } case C.TEXT: case C.IN_SELECT: case C.IN_SELECT_IN_TABLE: { this._insertCharacters(t); break } case C.IN_TABLE: case C.IN_TABLE_BODY: case C.IN_ROW: { ml(this, t); break } case C.IN_TABLE_TEXT: { kT(this, t); break } case C.IN_COLUMN_GROUP: { Oa(this, t); break } case C.AFTER_BODY: { La(this, t); break } case C.AFTER_AFTER_BODY: { Gs(this, t); break } } } onNullCharacter(t) { if (this.skipNextNewLine = !1, this.tokenizer.inForeignNode) { oL(this, t); return } switch (this.insertionMode) { case C.INITIAL: { $i(this, t); break } case C.BEFORE_HTML: { hu(this, t); break } case C.BEFORE_HEAD: { pu(this, t); break } case C.IN_HEAD: { mu(this, t); break } case C.IN_HEAD_NO_SCRIPT: { gu(this, t); break } case C.AFTER_HEAD: { Eu(this, t); break } case C.TEXT: { this._insertCharacters(t); break } case C.IN_TABLE: case C.IN_TABLE_BODY: case C.IN_ROW: { ml(this, t); break } case C.IN_COLUMN_GROUP: { Oa(this, t); break } case C.AFTER_BODY: { La(this, t); break } case C.AFTER_AFTER_BODY: { Gs(this, t); break } } } onComment(t) { if (this.skipNextNewLine = !1, this.currentNotInHTML) { zc(this, t); return } switch (this.insertionMode) { case C.INITIAL: case C.BEFORE_HTML: case C.BEFORE_HEAD: case C.IN_HEAD: case C.IN_HEAD_NO_SCRIPT: case C.AFTER_HEAD: case C.IN_BODY: case C.IN_TABLE: case C.IN_CAPTION: case C.IN_COLUMN_GROUP: case C.IN_TABLE_BODY: case C.IN_ROW: case C.IN_CELL: case C.IN_SELECT: case C.IN_SELECT_IN_TABLE: case C.IN_TEMPLATE: case C.IN_FRAMESET: case C.AFTER_FRAMESET: { zc(this, t); break } case C.IN_TABLE_TEXT: { Vi(this, t); break } case C.AFTER_BODY: { Hv(this, t); break } case C.AFTER_AFTER_BODY: case C.AFTER_AFTER_FRAMESET: { zv(this, t); break } } } onDoctype(t) { switch (this.skipNextNewLine = !1, this.insertionMode) { case C.INITIAL: { jv(this, t); break } case C.BEFORE_HEAD: case C.IN_HEAD: case C.IN_HEAD_NO_SCRIPT: case C.AFTER_HEAD: { this._err(t, R.misplacedDoctype); break } case C.IN_TABLE_TEXT: { Vi(this, t); break } } } onStartTag(t) { this.skipNextNewLine = !1, this.currentToken = t, this._processStartTag(t), t.selfClosing && !t.ackSelfClosing && this._err(t, R.nonVoidHtmlElementStartTagWithTrailingSolidus) } _processStartTag(t) { this.shouldProcessStartTagTokenInForeignContent(t) ? cL(this, t) : this._startTagOutsideForeignContent(t) } _startTagOutsideForeignContent(t) { switch (this.insertionMode) { case C.INITIAL: { $i(this, t); break } case C.BEFORE_HTML: { $v(this, t); break } case C.BEFORE_HEAD: { Yv(this, t); break } case C.IN_HEAD: { Yt(this, t); break } case C.IN_HEAD_NO_SCRIPT: { qv(this, t); break } case C.AFTER_HEAD: { Gv(this, t); break } case C.IN_BODY: { Je(this, t); break } case C.IN_TABLE: { pi(this, t); break } case C.IN_TABLE_TEXT: { Vi(this, t); break } case C.IN_CAPTION: { WO(this, t); break } case C.IN_COLUMN_GROUP: { gd(this, t); break } case C.IN_TABLE_BODY: { mo(this, t); break } case C.IN_ROW: { go(this, t); break } case C.IN_CELL: { QO(this, t); break } case C.IN_SELECT: { wT(this, t); break } case C.IN_SELECT_IN_TABLE: { XO(this, t); break } case C.IN_TEMPLATE: { ZO(this, t); break } case C.AFTER_BODY: { tL(this, t); break } case C.IN_FRAMESET: { nL(this, t); break } case C.AFTER_FRAMESET: { iL(this, t); break } case C.AFTER_AFTER_BODY: { sL(this, t); break } case C.AFTER_AFTER_FRAMESET: { aL(this, t); break } } } onEndTag(t) { this.skipNextNewLine = !1, this.currentToken = t, this.currentNotInHTML ? fL(this, t) : this._endTagOutsideForeignContent(t) } _endTagOutsideForeignContent(t) { switch (this.insertionMode) { case C.INITIAL: { $i(this, t); break } case C.BEFORE_HTML: { Vv(this, t); break } case C.BEFORE_HEAD: { Wv(this, t); break } case C.IN_HEAD: { Kv(this, t); break } case C.IN_HEAD_NO_SCRIPT: { Qv(this, t); break } case C.AFTER_HEAD: { Xv(this, t); break } case C.IN_BODY: { po(this, t); break } case C.TEXT: { MO(this, t); break } case C.IN_TABLE: { zu(this, t); break } case C.IN_TABLE_TEXT: { Vi(this, t); break } case C.IN_CAPTION: { KO(this, t); break } case C.IN_COLUMN_GROUP: { qO(this, t); break } case C.IN_TABLE_BODY: { jc(this, t); break } case C.IN_ROW: { IT(this, t); break } case C.IN_CELL: { GO(this, t); break } case C.IN_SELECT: { vT(this, t); break } case C.IN_SELECT_IN_TABLE: { JO(this, t); break } case C.IN_TEMPLATE: { eL(this, t); break } case C.AFTER_BODY: { LT(this, t); break } case C.IN_FRAMESET: { rL(this, t); break } case C.AFTER_FRAMESET: { uL(this, t); break } case C.AFTER_AFTER_BODY: { Gs(this, t); break } } } onEof(t) { switch (this.insertionMode) { case C.INITIAL: { $i(this, t); break } case C.BEFORE_HTML: { hu(this, t); break } case C.BEFORE_HEAD: { pu(this, t); break } case C.IN_HEAD: { mu(this, t); break } case C.IN_HEAD_NO_SCRIPT: { gu(this, t); break } case C.AFTER_HEAD: { Eu(this, t); break } case C.IN_BODY: case C.IN_TABLE: case C.IN_CAPTION: case C.IN_COLUMN_GROUP: case C.IN_TABLE_BODY: case C.IN_ROW: case C.IN_CELL: case C.IN_SELECT: case C.IN_SELECT_IN_TABLE: { CT(this, t); break } case C.TEXT: { FO(this, t); break } case C.IN_TABLE_TEXT: { Vi(this, t); break } case C.IN_TEMPLATE: { OT(this, t); break } case C.AFTER_BODY: case C.IN_FRAMESET: case C.AFTER_FRAMESET: case C.AFTER_AFTER_BODY: case C.AFTER_AFTER_FRAMESET: { md(this, t); break } } } onWhitespaceCharacter(t) { if (this.skipNextNewLine && (this.skipNextNewLine = !1, t.chars.charCodeAt(0) === b.LINE_FEED)) { if (t.chars.length === 1) return; t.chars = t.chars.substr(1) } if (this.tokenizer.inForeignNode) { this._insertCharacters(t); return } switch (this.insertionMode) { case C.IN_HEAD: case C.IN_HEAD_NO_SCRIPT: case C.AFTER_HEAD: case C.TEXT: case C.IN_COLUMN_GROUP: case C.IN_SELECT: case C.IN_SELECT_IN_TABLE: case C.IN_FRAMESET: case C.AFTER_FRAMESET: { this._insertCharacters(t); break } case C.IN_BODY: case C.IN_CAPTION: case C.IN_CELL: case C.IN_TEMPLATE: case C.AFTER_BODY: case C.AFTER_AFTER_BODY: case C.AFTER_AFTER_FRAMESET: { yT(this, t); break } case C.IN_TABLE: case C.IN_TABLE_BODY: case C.IN_ROW: { ml(this, t); break } case C.IN_TABLE_TEXT: { AT(this, t); break } } } } function Pv(e, t) { let n = e.activeFormattingElements.getElementEntryInScopeWithTagName(t.tagName); return n ? e.openElements.contains(n.element) ? e.openElements.hasInScope(t.tagID) || (n = null) : (e.activeFormattingElements.removeEntry(n), n = null) : _T(e, t), n } function Dv(e, t) { let n = null, r = e.openElements.stackTop; for (; r >= 0; r--) { const i = e.openElements.items[r]; if (i === t.element) break; e._isSpecialElement(i, e.openElements.tagIDs[r]) && (n = i) } return n || (e.openElements.shortenToLength(Math.max(r, 0)), e.activeFormattingElements.removeEntry(t)), n } function Mv(e, t, n) { let r = t, i = e.openElements.getCommonAncestor(t); for (let u = 0, s = i; s !== n; u++, s = i) { i = e.openElements.getCommonAncestor(s); const a = e.activeFormattingElements.getElementEntry(s), o = a && u >= Lv; !a || o ? (o && e.activeFormattingElements.removeEntry(a), e.openElements.remove(s)) : (s = Fv(e, a), r === t && (e.activeFormattingElements.bookmark = a), e.treeAdapter.detachNode(r), e.treeAdapter.appendChild(s, r), r = s) } return r } function Fv(e, t) { const n = e.treeAdapter.getNamespaceURI(t.element), r = e.treeAdapter.createElement(t.token.tagName, n, t.token.attrs); return e.openElements.replace(t.element, r), t.element = r, r } function Bv(e, t, n) { const r = e.treeAdapter.getTagName(t), i = Ai(r); if (e._isElementCausesFosterParenting(i)) e._fosterParentElement(n); else { const u = e.treeAdapter.getNamespaceURI(t); i === c.TEMPLATE && u === F.HTML && (t = e.treeAdapter.getTemplateContent(t)), e.treeAdapter.appendChild(t, n) } } function Uv(e, t, n) { const r = e.treeAdapter.getNamespaceURI(n.element), { token: i } = n, u = e.treeAdapter.createElement(i.tagName, r, i.attrs); e._adoptNodes(t, u), e.treeAdapter.appendChild(t, u), e.activeFormattingElements.insertElementAfterBookmark(u, i), e.activeFormattingElements.removeEntry(n), e.openElements.remove(n.element), e.openElements.insertAfter(t, u, i.tagID) } function pd(e, t) { for (let n = 0; n < Ov; n++) { const r = Pv(e, t); if (!r) break; const i = Dv(e, r); if (!i) break; e.activeFormattingElements.bookmark = r; const u = Mv(e, i, r.element), s = e.openElements.getCommonAncestor(r.element); e.treeAdapter.detachNode(u), s && Bv(e, s, u), Uv(e, i, r) } } function zc(e, t) { e._appendCommentNode(t, e.openElements.currentTmplContentOrNode) } function Hv(e, t) { e._appendCommentNode(t, e.openElements.items[0]) } function zv(e, t) { e._appendCommentNode(t, e.document) } function md(e, t) { if (e.stopped = !0, t.location) { const n = e.fragmentContext ? 0 : 2; for (let r = e.openElements.stackTop; r >= n; r--)e._setEndLocation(e.openElements.items[r], t); if (!e.fragmentContext && e.openElements.stackTop >= 0) { const r = e.openElements.items[0], i = e.treeAdapter.getNodeSourceCodeLocation(r); if (i && !i.endTag && (e._setEndLocation(r, t), e.openElements.stackTop >= 1)) { const u = e.openElements.items[1], s = e.treeAdapter.getNodeSourceCodeLocation(u); s && !s.endTag && e._setEndLocation(u, t) } } } } function jv(e, t) { e._setDocumentType(t); const n = t.forceQuirks ? It.QUIRKS : Tv(t); Ev(t) || e._err(t, R.nonConformingDoctype), e.treeAdapter.setDocumentMode(e.document, n), e.insertionMode = C.BEFORE_HTML } function $i(e, t) { e._err(t, R.missingDoctype, !0), e.treeAdapter.setDocumentMode(e.document, It.QUIRKS), e.insertionMode = C.BEFORE_HTML, e._processToken(t) } function $v(e, t) { t.tagID === c.HTML ? (e._insertElement(t, F.HTML), e.insertionMode = C.BEFORE_HEAD) : hu(e, t) } function Vv(e, t) { const n = t.tagID; (n === c.HTML || n === c.HEAD || n === c.BODY || n === c.BR) && hu(e, t) } function hu(e, t) { e._insertFakeRootElement(), e.insertionMode = C.BEFORE_HEAD, e._processToken(t) } function Yv(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.HEAD: { e._insertElement(t, F.HTML), e.headElement = e.openElements.current, e.insertionMode = C.IN_HEAD; break } default: pu(e, t) } } function Wv(e, t) { const n = t.tagID; n === c.HEAD || n === c.BODY || n === c.HTML || n === c.BR ? pu(e, t) : e._err(t, R.endTagWithoutMatchingOpenElement) } function pu(e, t) { e._insertFakeElement(v.HEAD, c.HEAD), e.headElement = e.openElements.current, e.insertionMode = C.IN_HEAD, e._processToken(t) } function Yt(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.BASE: case c.BASEFONT: case c.BGSOUND: case c.LINK: case c.META: { e._appendElement(t, F.HTML), t.ackSelfClosing = !0; break } case c.TITLE: { e._switchToTextParsing(t, ve.RCDATA); break } case c.NOSCRIPT: { e.options.scriptingEnabled ? e._switchToTextParsing(t, ve.RAWTEXT) : (e._insertElement(t, F.HTML), e.insertionMode = C.IN_HEAD_NO_SCRIPT); break } case c.NOFRAMES: case c.STYLE: { e._switchToTextParsing(t, ve.RAWTEXT); break } case c.SCRIPT: { e._switchToTextParsing(t, ve.SCRIPT_DATA); break } case c.TEMPLATE: { e._insertTemplate(t), e.activeFormattingElements.insertMarker(), e.framesetOk = !1, e.insertionMode = C.IN_TEMPLATE, e.tmplInsertionModeStack.unshift(C.IN_TEMPLATE); break } case c.HEAD: { e._err(t, R.misplacedStartTagForHeadElement); break } default: mu(e, t) } } function Kv(e, t) { switch (t.tagID) { case c.HEAD: { e.openElements.pop(), e.insertionMode = C.AFTER_HEAD; break } case c.BODY: case c.BR: case c.HTML: { mu(e, t); break } case c.TEMPLATE: { kr(e, t); break } default: e._err(t, R.endTagWithoutMatchingOpenElement) } } function kr(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.generateImpliedEndTagsThoroughly(), e.openElements.currentTagId !== c.TEMPLATE && e._err(t, R.closingOfElementWithOpenChildElements), e.openElements.popUntilTagNamePopped(c.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode()) : e._err(t, R.endTagWithoutMatchingOpenElement) } function mu(e, t) { e.openElements.pop(), e.insertionMode = C.AFTER_HEAD, e._processToken(t) } function qv(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.BASEFONT: case c.BGSOUND: case c.HEAD: case c.LINK: case c.META: case c.NOFRAMES: case c.STYLE: { Yt(e, t); break } case c.NOSCRIPT: { e._err(t, R.nestedNoscriptInHead); break } default: gu(e, t) } } function Qv(e, t) { switch (t.tagID) { case c.NOSCRIPT: { e.openElements.pop(), e.insertionMode = C.IN_HEAD; break } case c.BR: { gu(e, t); break } default: e._err(t, R.endTagWithoutMatchingOpenElement) } } function gu(e, t) { const n = t.type === se.EOF ? R.openElementsLeftAfterEof : R.disallowedContentInNoscriptInHead; e._err(t, n), e.openElements.pop(), e.insertionMode = C.IN_HEAD, e._processToken(t) } function Gv(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.BODY: { e._insertElement(t, F.HTML), e.framesetOk = !1, e.insertionMode = C.IN_BODY; break } case c.FRAMESET: { e._insertElement(t, F.HTML), e.insertionMode = C.IN_FRAMESET; break } case c.BASE: case c.BASEFONT: case c.BGSOUND: case c.LINK: case c.META: case c.NOFRAMES: case c.SCRIPT: case c.STYLE: case c.TEMPLATE: case c.TITLE: { e._err(t, R.abandonedHeadElementChild), e.openElements.push(e.headElement, c.HEAD), Yt(e, t), e.openElements.remove(e.headElement); break } case c.HEAD: { e._err(t, R.misplacedStartTagForHeadElement); break } default: Eu(e, t) } } function Xv(e, t) { switch (t.tagID) { case c.BODY: case c.HTML: case c.BR: { Eu(e, t); break } case c.TEMPLATE: { kr(e, t); break } default: e._err(t, R.endTagWithoutMatchingOpenElement) } } function Eu(e, t) { e._insertFakeElement(v.BODY, c.BODY), e.insertionMode = C.IN_BODY, ho(e, t) } function ho(e, t) { switch (t.type) { case se.CHARACTER: { bT(e, t); break } case se.WHITESPACE_CHARACTER: { yT(e, t); break } case se.COMMENT: { zc(e, t); break } case se.START_TAG: { Je(e, t); break } case se.END_TAG: { po(e, t); break } case se.EOF: { CT(e, t); break } } } function yT(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t) } function bT(e, t) { e._reconstructActiveFormattingElements(), e._insertCharacters(t), e.framesetOk = !1 } function Jv(e, t) { e.openElements.tmplCount === 0 && e.treeAdapter.adoptAttributes(e.openElements.items[0], t.attrs) } function Zv(e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e.openElements.tmplCount === 0 && (e.framesetOk = !1, e.treeAdapter.adoptAttributes(n, t.attrs)) } function eO(e, t) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); e.framesetOk && n && (e.treeAdapter.detachNode(n), e.openElements.popAllUpToHtmlElement(), e._insertElement(t, F.HTML), e.insertionMode = C.IN_FRAMESET) } function tO(e, t) { e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, F.HTML) } function nO(e, t) { e.openElements.hasInButtonScope(c.P) && e._closePElement(), e.openElements.currentTagId !== void 0 && Hc.has(e.openElements.currentTagId) && e.openElements.pop(), e._insertElement(t, F.HTML) } function rO(e, t) { e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, F.HTML), e.skipNextNewLine = !0, e.framesetOk = !1 } function iO(e, t) { const n = e.openElements.tmplCount > 0; (!e.formElement || n) && (e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, F.HTML), n || (e.formElement = e.openElements.current)) } function uO(e, t) { e.framesetOk = !1; const n = t.tagID; for (let r = e.openElements.stackTop; r >= 0; r--) { const i = e.openElements.tagIDs[r]; if (n === c.LI && i === c.LI || (n === c.DD || n === c.DT) && (i === c.DD || i === c.DT)) { e.openElements.generateImpliedEndTagsWithExclusion(i), e.openElements.popUntilTagNamePopped(i); break } if (i !== c.ADDRESS && i !== c.DIV && i !== c.P && e._isSpecialElement(e.openElements.items[r], i)) break } e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, F.HTML) } function sO(e, t) { e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, F.HTML), e.tokenizer.state = ve.PLAINTEXT } function aO(e, t) { e.openElements.hasInScope(c.BUTTON) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(c.BUTTON)), e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML), e.framesetOk = !1 } function oO(e, t) { const n = e.activeFormattingElements.getElementEntryInScopeWithTagName(v.A); n && (pd(e, t), e.openElements.remove(n.element), e.activeFormattingElements.removeEntry(n)), e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) } function lO(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) } function cO(e, t) { e._reconstructActiveFormattingElements(), e.openElements.hasInScope(c.NOBR) && (pd(e, t), e._reconstructActiveFormattingElements()), e._insertElement(t, F.HTML), e.activeFormattingElements.pushElement(e.openElements.current, t) } function fO(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML), e.activeFormattingElements.insertMarker(), e.framesetOk = !1 } function dO(e, t) { e.treeAdapter.getDocumentMode(e.document) !== It.QUIRKS && e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._insertElement(t, F.HTML), e.framesetOk = !1, e.insertionMode = C.IN_TABLE } function xT(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, F.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function ST(e) { const t = cT(e, hr.TYPE); return t != null && t.toLowerCase() === vv } function hO(e, t) { e._reconstructActiveFormattingElements(), e._appendElement(t, F.HTML), ST(t) || (e.framesetOk = !1), t.ackSelfClosing = !0 } function pO(e, t) { e._appendElement(t, F.HTML), t.ackSelfClosing = !0 } function mO(e, t) { e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._appendElement(t, F.HTML), e.framesetOk = !1, t.ackSelfClosing = !0 } function gO(e, t) { t.tagName = v.IMG, t.tagID = c.IMG, xT(e, t) } function EO(e, t) { e._insertElement(t, F.HTML), e.skipNextNewLine = !0, e.tokenizer.state = ve.RCDATA, e.originalInsertionMode = e.insertionMode, e.framesetOk = !1, e.insertionMode = C.TEXT } function TO(e, t) { e.openElements.hasInButtonScope(c.P) && e._closePElement(), e._reconstructActiveFormattingElements(), e.framesetOk = !1, e._switchToTextParsing(t, ve.RAWTEXT) } function yO(e, t) { e.framesetOk = !1, e._switchToTextParsing(t, ve.RAWTEXT) } function Dp(e, t) { e._switchToTextParsing(t, ve.RAWTEXT) } function bO(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML), e.framesetOk = !1, e.insertionMode = e.insertionMode === C.IN_TABLE || e.insertionMode === C.IN_CAPTION || e.insertionMode === C.IN_TABLE_BODY || e.insertionMode === C.IN_ROW || e.insertionMode === C.IN_CELL ? C.IN_SELECT_IN_TABLE : C.IN_SELECT } function xO(e, t) { e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML) } function SO(e, t) { e.openElements.hasInScope(c.RUBY) && e.openElements.generateImpliedEndTags(), e._insertElement(t, F.HTML) } function _O(e, t) { e.openElements.hasInScope(c.RUBY) && e.openElements.generateImpliedEndTagsWithExclusion(c.RTC), e._insertElement(t, F.HTML) } function CO(e, t) { e._reconstructActiveFormattingElements(), gT(t), hd(t), t.selfClosing ? e._appendElement(t, F.MATHML) : e._insertElement(t, F.MATHML), t.ackSelfClosing = !0 } function AO(e, t) { e._reconstructActiveFormattingElements(), ET(t), hd(t), t.selfClosing ? e._appendElement(t, F.SVG) : e._insertElement(t, F.SVG), t.ackSelfClosing = !0 } function Mp(e, t) { e._reconstructActiveFormattingElements(), e._insertElement(t, F.HTML) } function Je(e, t) { switch (t.tagID) { case c.I: case c.S: case c.B: case c.U: case c.EM: case c.TT: case c.BIG: case c.CODE: case c.FONT: case c.SMALL: case c.STRIKE: case c.STRONG: { lO(e, t); break } case c.A: { oO(e, t); break } case c.H1: case c.H2: case c.H3: case c.H4: case c.H5: case c.H6: { nO(e, t); break } case c.P: case c.DL: case c.OL: case c.UL: case c.DIV: case c.DIR: case c.NAV: case c.MAIN: case c.MENU: case c.ASIDE: case c.CENTER: case c.FIGURE: case c.FOOTER: case c.HEADER: case c.HGROUP: case c.DIALOG: case c.DETAILS: case c.ADDRESS: case c.ARTICLE: case c.SEARCH: case c.SECTION: case c.SUMMARY: case c.FIELDSET: case c.BLOCKQUOTE: case c.FIGCAPTION: { tO(e, t); break } case c.LI: case c.DD: case c.DT: { uO(e, t); break } case c.BR: case c.IMG: case c.WBR: case c.AREA: case c.EMBED: case c.KEYGEN: { xT(e, t); break } case c.HR: { mO(e, t); break } case c.RB: case c.RTC: { SO(e, t); break } case c.RT: case c.RP: { _O(e, t); break } case c.PRE: case c.LISTING: { rO(e, t); break } case c.XMP: { TO(e, t); break } case c.SVG: { AO(e, t); break } case c.HTML: { Jv(e, t); break } case c.BASE: case c.LINK: case c.META: case c.STYLE: case c.TITLE: case c.SCRIPT: case c.BGSOUND: case c.BASEFONT: case c.TEMPLATE: { Yt(e, t); break } case c.BODY: { Zv(e, t); break } case c.FORM: { iO(e, t); break } case c.NOBR: { cO(e, t); break } case c.MATH: { CO(e, t); break } case c.TABLE: { dO(e, t); break } case c.INPUT: { hO(e, t); break } case c.PARAM: case c.TRACK: case c.SOURCE: { pO(e, t); break } case c.IMAGE: { gO(e, t); break } case c.BUTTON: { aO(e, t); break } case c.APPLET: case c.OBJECT: case c.MARQUEE: { fO(e, t); break } case c.IFRAME: { yO(e, t); break } case c.SELECT: { bO(e, t); break } case c.OPTION: case c.OPTGROUP: { xO(e, t); break } case c.NOEMBED: case c.NOFRAMES: { Dp(e, t); break } case c.FRAMESET: { eO(e, t); break } case c.TEXTAREA: { EO(e, t); break } case c.NOSCRIPT: { e.options.scriptingEnabled ? Dp(e, t) : Mp(e, t); break } case c.PLAINTEXT: { sO(e, t); break } case c.COL: case c.TH: case c.TD: case c.TR: case c.HEAD: case c.FRAME: case c.TBODY: case c.TFOOT: case c.THEAD: case c.CAPTION: case c.COLGROUP: break; default: Mp(e, t) } } function kO(e, t) { if (e.openElements.hasInScope(c.BODY) && (e.insertionMode = C.AFTER_BODY, e.options.sourceCodeLocationInfo)) { const n = e.openElements.tryPeekProperlyNestedBodyElement(); n && e._setEndLocation(n, t) } } function NO(e, t) { e.openElements.hasInScope(c.BODY) && (e.insertionMode = C.AFTER_BODY, LT(e, t)) } function IO(e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n)) } function wO(e) { const t = e.openElements.tmplCount > 0, { formElement: n } = e; t || (e.formElement = null), (n || t) && e.openElements.hasInScope(c.FORM) && (e.openElements.generateImpliedEndTags(), t ? e.openElements.popUntilTagNamePopped(c.FORM) : n && e.openElements.remove(n)) } function vO(e) { e.openElements.hasInButtonScope(c.P) || e._insertFakeElement(v.P, c.P), e._closePElement() } function OO(e) { e.openElements.hasInListItemScope(c.LI) && (e.openElements.generateImpliedEndTagsWithExclusion(c.LI), e.openElements.popUntilTagNamePopped(c.LI)) } function LO(e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTagsWithExclusion(n), e.openElements.popUntilTagNamePopped(n)) } function RO(e) { e.openElements.hasNumberedHeaderInScope() && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilNumberedHeaderPopped()) } function PO(e, t) { const n = t.tagID; e.openElements.hasInScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker()) } function DO(e) { e._reconstructActiveFormattingElements(), e._insertFakeElement(v.BR, c.BR), e.openElements.pop(), e.framesetOk = !1 } function _T(e, t) { const n = t.tagName, r = t.tagID; for (let i = e.openElements.stackTop; i > 0; i--) { const u = e.openElements.items[i], s = e.openElements.tagIDs[i]; if (r === s && (r !== c.UNKNOWN || e.treeAdapter.getTagName(u) === n)) { e.openElements.generateImpliedEndTagsWithExclusion(r), e.openElements.stackTop >= i && e.openElements.shortenToLength(i); break } if (e._isSpecialElement(u, s)) break } } function po(e, t) { switch (t.tagID) { case c.A: case c.B: case c.I: case c.S: case c.U: case c.EM: case c.TT: case c.BIG: case c.CODE: case c.FONT: case c.NOBR: case c.SMALL: case c.STRIKE: case c.STRONG: { pd(e, t); break } case c.P: { vO(e); break } case c.DL: case c.UL: case c.OL: case c.DIR: case c.DIV: case c.NAV: case c.PRE: case c.MAIN: case c.MENU: case c.ASIDE: case c.BUTTON: case c.CENTER: case c.FIGURE: case c.FOOTER: case c.HEADER: case c.HGROUP: case c.DIALOG: case c.ADDRESS: case c.ARTICLE: case c.DETAILS: case c.SEARCH: case c.SECTION: case c.SUMMARY: case c.LISTING: case c.FIELDSET: case c.BLOCKQUOTE: case c.FIGCAPTION: { IO(e, t); break } case c.LI: { OO(e); break } case c.DD: case c.DT: { LO(e, t); break } case c.H1: case c.H2: case c.H3: case c.H4: case c.H5: case c.H6: { RO(e); break } case c.BR: { DO(e); break } case c.BODY: { kO(e, t); break } case c.HTML: { NO(e, t); break } case c.FORM: { wO(e); break } case c.APPLET: case c.OBJECT: case c.MARQUEE: { PO(e, t); break } case c.TEMPLATE: { kr(e, t); break } default: _T(e, t) } } function CT(e, t) { e.tmplInsertionModeStack.length > 0 ? OT(e, t) : md(e, t) } function MO(e, t) { var n; t.tagID === c.SCRIPT && ((n = e.scriptHandler) === null || n === void 0 || n.call(e, e.openElements.current)), e.openElements.pop(), e.insertionMode = e.originalInsertionMode } function FO(e, t) { e._err(t, R.eofInElementThatCanContainOnlyText), e.openElements.pop(), e.insertionMode = e.originalInsertionMode, e.onEof(t) } function ml(e, t) { if (e.openElements.currentTagId !== void 0 && TT.has(e.openElements.currentTagId)) switch (e.pendingCharacterTokens.length = 0, e.hasNonWhitespacePendingCharacterToken = !1, e.originalInsertionMode = e.insertionMode, e.insertionMode = C.IN_TABLE_TEXT, t.type) { case se.CHARACTER: { kT(e, t); break } case se.WHITESPACE_CHARACTER: { AT(e, t); break } } else ns(e, t) } function BO(e, t) { e.openElements.clearBackToTableContext(), e.activeFormattingElements.insertMarker(), e._insertElement(t, F.HTML), e.insertionMode = C.IN_CAPTION } function UO(e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, F.HTML), e.insertionMode = C.IN_COLUMN_GROUP } function HO(e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(v.COLGROUP, c.COLGROUP), e.insertionMode = C.IN_COLUMN_GROUP, gd(e, t) } function zO(e, t) { e.openElements.clearBackToTableContext(), e._insertElement(t, F.HTML), e.insertionMode = C.IN_TABLE_BODY } function jO(e, t) { e.openElements.clearBackToTableContext(), e._insertFakeElement(v.TBODY, c.TBODY), e.insertionMode = C.IN_TABLE_BODY, mo(e, t) } function $O(e, t) { e.openElements.hasInTableScope(c.TABLE) && (e.openElements.popUntilTagNamePopped(c.TABLE), e._resetInsertionMode(), e._processStartTag(t)) } function VO(e, t) { ST(t) ? e._appendElement(t, F.HTML) : ns(e, t), t.ackSelfClosing = !0 } function YO(e, t) { !e.formElement && e.openElements.tmplCount === 0 && (e._insertElement(t, F.HTML), e.formElement = e.openElements.current, e.openElements.pop()) } function pi(e, t) { switch (t.tagID) { case c.TD: case c.TH: case c.TR: { jO(e, t); break } case c.STYLE: case c.SCRIPT: case c.TEMPLATE: { Yt(e, t); break } case c.COL: { HO(e, t); break } case c.FORM: { YO(e, t); break } case c.TABLE: { $O(e, t); break } case c.TBODY: case c.TFOOT: case c.THEAD: { zO(e, t); break } case c.INPUT: { VO(e, t); break } case c.CAPTION: { BO(e, t); break } case c.COLGROUP: { UO(e, t); break } default: ns(e, t) } } function zu(e, t) { switch (t.tagID) { case c.TABLE: { e.openElements.hasInTableScope(c.TABLE) && (e.openElements.popUntilTagNamePopped(c.TABLE), e._resetInsertionMode()); break } case c.TEMPLATE: { kr(e, t); break } case c.BODY: case c.CAPTION: case c.COL: case c.COLGROUP: case c.HTML: case c.TBODY: case c.TD: case c.TFOOT: case c.TH: case c.THEAD: case c.TR: break; default: ns(e, t) } } function ns(e, t) { const n = e.fosterParentingEnabled; e.fosterParentingEnabled = !0, ho(e, t), e.fosterParentingEnabled = n } function AT(e, t) { e.pendingCharacterTokens.push(t) } function kT(e, t) { e.pendingCharacterTokens.push(t), e.hasNonWhitespacePendingCharacterToken = !0 } function Vi(e, t) { let n = 0; if (e.hasNonWhitespacePendingCharacterToken) for (; n < e.pendingCharacterTokens.length; n++)ns(e, e.pendingCharacterTokens[n]); else for (; n < e.pendingCharacterTokens.length; n++)e._insertCharacters(e.pendingCharacterTokens[n]); e.insertionMode = e.originalInsertionMode, e._processToken(t) } const NT = new Set([c.CAPTION, c.COL, c.COLGROUP, c.TBODY, c.TD, c.TFOOT, c.TH, c.THEAD, c.TR]); function WO(e, t) { const n = t.tagID; NT.has(n) ? e.openElements.hasInTableScope(c.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(c.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = C.IN_TABLE, pi(e, t)) : Je(e, t) } function KO(e, t) { const n = t.tagID; switch (n) { case c.CAPTION: case c.TABLE: { e.openElements.hasInTableScope(c.CAPTION) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(c.CAPTION), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = C.IN_TABLE, n === c.TABLE && zu(e, t)); break } case c.BODY: case c.COL: case c.COLGROUP: case c.HTML: case c.TBODY: case c.TD: case c.TFOOT: case c.TH: case c.THEAD: case c.TR: break; default: po(e, t) } } function gd(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.COL: { e._appendElement(t, F.HTML), t.ackSelfClosing = !0; break } case c.TEMPLATE: { Yt(e, t); break } default: Oa(e, t) } } function qO(e, t) { switch (t.tagID) { case c.COLGROUP: { e.openElements.currentTagId === c.COLGROUP && (e.openElements.pop(), e.insertionMode = C.IN_TABLE); break } case c.TEMPLATE: { kr(e, t); break } case c.COL: break; default: Oa(e, t) } } function Oa(e, t) { e.openElements.currentTagId === c.COLGROUP && (e.openElements.pop(), e.insertionMode = C.IN_TABLE, e._processToken(t)) } function mo(e, t) { switch (t.tagID) { case c.TR: { e.openElements.clearBackToTableBodyContext(), e._insertElement(t, F.HTML), e.insertionMode = C.IN_ROW; break } case c.TH: case c.TD: { e.openElements.clearBackToTableBodyContext(), e._insertFakeElement(v.TR, c.TR), e.insertionMode = C.IN_ROW, go(e, t); break } case c.CAPTION: case c.COL: case c.COLGROUP: case c.TBODY: case c.TFOOT: case c.THEAD: { e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE, pi(e, t)); break } default: pi(e, t) } } function jc(e, t) { const n = t.tagID; switch (t.tagID) { case c.TBODY: case c.TFOOT: case c.THEAD: { e.openElements.hasInTableScope(n) && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE); break } case c.TABLE: { e.openElements.hasTableBodyContextInTableScope() && (e.openElements.clearBackToTableBodyContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE, zu(e, t)); break } case c.BODY: case c.CAPTION: case c.COL: case c.COLGROUP: case c.HTML: case c.TD: case c.TH: case c.TR: break; default: zu(e, t) } } function go(e, t) { switch (t.tagID) { case c.TH: case c.TD: { e.openElements.clearBackToTableRowContext(), e._insertElement(t, F.HTML), e.insertionMode = C.IN_CELL, e.activeFormattingElements.insertMarker(); break } case c.CAPTION: case c.COL: case c.COLGROUP: case c.TBODY: case c.TFOOT: case c.THEAD: case c.TR: { e.openElements.hasInTableScope(c.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE_BODY, mo(e, t)); break } default: pi(e, t) } } function IT(e, t) { switch (t.tagID) { case c.TR: { e.openElements.hasInTableScope(c.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE_BODY); break } case c.TABLE: { e.openElements.hasInTableScope(c.TR) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE_BODY, jc(e, t)); break } case c.TBODY: case c.TFOOT: case c.THEAD: { (e.openElements.hasInTableScope(t.tagID) || e.openElements.hasInTableScope(c.TR)) && (e.openElements.clearBackToTableRowContext(), e.openElements.pop(), e.insertionMode = C.IN_TABLE_BODY, jc(e, t)); break } case c.BODY: case c.CAPTION: case c.COL: case c.COLGROUP: case c.HTML: case c.TD: case c.TH: break; default: zu(e, t) } } function QO(e, t) { const n = t.tagID; NT.has(n) ? (e.openElements.hasInTableScope(c.TD) || e.openElements.hasInTableScope(c.TH)) && (e._closeTableCell(), go(e, t)) : Je(e, t) } function GO(e, t) { const n = t.tagID; switch (n) { case c.TD: case c.TH: { e.openElements.hasInTableScope(n) && (e.openElements.generateImpliedEndTags(), e.openElements.popUntilTagNamePopped(n), e.activeFormattingElements.clearToLastMarker(), e.insertionMode = C.IN_ROW); break } case c.TABLE: case c.TBODY: case c.TFOOT: case c.THEAD: case c.TR: { e.openElements.hasInTableScope(n) && (e._closeTableCell(), IT(e, t)); break } case c.BODY: case c.CAPTION: case c.COL: case c.COLGROUP: case c.HTML: break; default: po(e, t) } } function wT(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.OPTION: { e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e._insertElement(t, F.HTML); break } case c.OPTGROUP: { e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e.openElements.currentTagId === c.OPTGROUP && e.openElements.pop(), e._insertElement(t, F.HTML); break } case c.HR: { e.openElements.currentTagId === c.OPTION && e.openElements.pop(), e.openElements.currentTagId === c.OPTGROUP && e.openElements.pop(), e._appendElement(t, F.HTML), t.ackSelfClosing = !0; break } case c.INPUT: case c.KEYGEN: case c.TEXTAREA: case c.SELECT: { e.openElements.hasInSelectScope(c.SELECT) && (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode(), t.tagID !== c.SELECT && e._processStartTag(t)); break } case c.SCRIPT: case c.TEMPLATE: { Yt(e, t); break } } } function vT(e, t) { switch (t.tagID) { case c.OPTGROUP: { e.openElements.stackTop > 0 && e.openElements.currentTagId === c.OPTION && e.openElements.tagIDs[e.openElements.stackTop - 1] === c.OPTGROUP && e.openElements.pop(), e.openElements.currentTagId === c.OPTGROUP && e.openElements.pop(); break } case c.OPTION: { e.openElements.currentTagId === c.OPTION && e.openElements.pop(); break } case c.SELECT: { e.openElements.hasInSelectScope(c.SELECT) && (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode()); break } case c.TEMPLATE: { kr(e, t); break } } } function XO(e, t) { const n = t.tagID; n === c.CAPTION || n === c.TABLE || n === c.TBODY || n === c.TFOOT || n === c.THEAD || n === c.TR || n === c.TD || n === c.TH ? (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode(), e._processStartTag(t)) : wT(e, t) } function JO(e, t) { const n = t.tagID; n === c.CAPTION || n === c.TABLE || n === c.TBODY || n === c.TFOOT || n === c.THEAD || n === c.TR || n === c.TD || n === c.TH ? e.openElements.hasInTableScope(n) && (e.openElements.popUntilTagNamePopped(c.SELECT), e._resetInsertionMode(), e.onEndTag(t)) : vT(e, t) } function ZO(e, t) { switch (t.tagID) { case c.BASE: case c.BASEFONT: case c.BGSOUND: case c.LINK: case c.META: case c.NOFRAMES: case c.SCRIPT: case c.STYLE: case c.TEMPLATE: case c.TITLE: { Yt(e, t); break } case c.CAPTION: case c.COLGROUP: case c.TBODY: case c.TFOOT: case c.THEAD: { e.tmplInsertionModeStack[0] = C.IN_TABLE, e.insertionMode = C.IN_TABLE, pi(e, t); break } case c.COL: { e.tmplInsertionModeStack[0] = C.IN_COLUMN_GROUP, e.insertionMode = C.IN_COLUMN_GROUP, gd(e, t); break } case c.TR: { e.tmplInsertionModeStack[0] = C.IN_TABLE_BODY, e.insertionMode = C.IN_TABLE_BODY, mo(e, t); break } case c.TD: case c.TH: { e.tmplInsertionModeStack[0] = C.IN_ROW, e.insertionMode = C.IN_ROW, go(e, t); break } default: e.tmplInsertionModeStack[0] = C.IN_BODY, e.insertionMode = C.IN_BODY, Je(e, t) } } function eL(e, t) { t.tagID === c.TEMPLATE && kr(e, t) } function OT(e, t) { e.openElements.tmplCount > 0 ? (e.openElements.popUntilTagNamePopped(c.TEMPLATE), e.activeFormattingElements.clearToLastMarker(), e.tmplInsertionModeStack.shift(), e._resetInsertionMode(), e.onEof(t)) : md(e, t) } function tL(e, t) { t.tagID === c.HTML ? Je(e, t) : La(e, t) } function LT(e, t) { var n; if (t.tagID === c.HTML) { if (e.fragmentContext || (e.insertionMode = C.AFTER_AFTER_BODY), e.options.sourceCodeLocationInfo && e.openElements.tagIDs[0] === c.HTML) { e._setEndLocation(e.openElements.items[0], t); const r = e.openElements.items[1]; r && !(!((n = e.treeAdapter.getNodeSourceCodeLocation(r)) === null || n === void 0) && n.endTag) && e._setEndLocation(r, t) } } else La(e, t) } function La(e, t) { e.insertionMode = C.IN_BODY, ho(e, t) } function nL(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.FRAMESET: { e._insertElement(t, F.HTML); break } case c.FRAME: { e._appendElement(t, F.HTML), t.ackSelfClosing = !0; break } case c.NOFRAMES: { Yt(e, t); break } } } function rL(e, t) { t.tagID === c.FRAMESET && !e.openElements.isRootHtmlElementCurrent() && (e.openElements.pop(), !e.fragmentContext && e.openElements.currentTagId !== c.FRAMESET && (e.insertionMode = C.AFTER_FRAMESET)) } function iL(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.NOFRAMES: { Yt(e, t); break } } } function uL(e, t) { t.tagID === c.HTML && (e.insertionMode = C.AFTER_AFTER_FRAMESET) } function sL(e, t) { t.tagID === c.HTML ? Je(e, t) : Gs(e, t) } function Gs(e, t) { e.insertionMode = C.IN_BODY, ho(e, t) } function aL(e, t) { switch (t.tagID) { case c.HTML: { Je(e, t); break } case c.NOFRAMES: { Yt(e, t); break } } } function oL(e, t) { t.chars = Se, e._insertCharacters(t) } function lL(e, t) { e._insertCharacters(t), e.framesetOk = !1 } function RT(e) { for (; e.treeAdapter.getNamespaceURI(e.openElements.current) !== F.HTML && e.openElements.currentTagId !== void 0 && !e._isIntegrationPoint(e.openElements.currentTagId, e.openElements.current);)e.openElements.pop() } function cL(e, t) { if (Av(t)) RT(e), e._startTagOutsideForeignContent(t); else { const n = e._getAdjustedCurrentElement(), r = e.treeAdapter.getNamespaceURI(n); r === F.MATHML ? gT(t) : r === F.SVG && (kv(t), ET(t)), hd(t), t.selfClosing ? e._appendElement(t, r) : e._insertElement(t, r), t.ackSelfClosing = !0 } } function fL(e, t) { if (t.tagID === c.P || t.tagID === c.BR) { RT(e), e._endTagOutsideForeignContent(t); return } for (let n = e.openElements.stackTop; n > 0; n--) { const r = e.openElements.items[n]; if (e.treeAdapter.getNamespaceURI(r) === F.HTML) { e._endTagOutsideForeignContent(t); break } const i = e.treeAdapter.getTagName(r); if (i.toLowerCase() === t.tagName) { t.tagName = i, e.openElements.shortenToLength(n); break } } } v.AREA, v.BASE, v.BASEFONT, v.BGSOUND, v.BR, v.COL, v.EMBED, v.FRAME, v.HR, v.IMG, v.INPUT, v.KEYGEN, v.LINK, v.META, v.PARAM, v.SOURCE, v.TRACK, v.WBR; const dL = /<(\/?)(iframe|noembed|noframes|plaintext|script|style|textarea|title|xmp)(?=[\t\n\f\r />])/gi, hL = new Set(["mdxFlowExpression", "mdxJsxFlowElement", "mdxJsxTextElement", "mdxTextExpression", "mdxjsEsm"]), Fp = { sourceCodeLocationInfo: !0, scriptingEnabled: !1 }; function PT(e, t) { const n = _L(e), r = FE("type", { handlers: { root: pL, element: mL, text: gL, comment: MT, doctype: EL, raw: yL }, unknown: bL }), i = { parser: n ? new Pp(Fp) : Pp.getFragmentParser(void 0, Fp), handle(a) { r(a, i) }, stitches: !1, options: t || {} }; r(e, i), ki(i, nn()); const u = n ? i.parser.document : i.parser.getFragment(), s = C6(u, { file: i.options.file }); return i.stitches && fo(s, "comment", function (a, o, l) { const f = a; if (f.value.stitch && l && o !== void 0) { const d = l.children; return d[o] = f.value.stitch, o } }), s.type === "root" && s.children.length === 1 && s.children[0].type === e.type ? s.children[0] : s } function DT(e, t) { let n = -1; if (e) for (; ++n < e.length;)t.handle(e[n]) } function pL(e, t) { DT(e.children, t) } function mL(e, t) { xL(e, t), DT(e.children, t), SL(e, t) } function gL(e, t) { t.parser.tokenizer.state > 4 && (t.parser.tokenizer.state = 0); const n = { type: se.CHARACTER, chars: e.value, location: rs(e) }; ki(t, nn(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function EL(e, t) { const n = { type: se.DOCTYPE, name: "html", forceQuirks: !1, publicId: "", systemId: "", location: rs(e) }; ki(t, nn(e)), t.parser.currentToken = n, t.parser._processToken(t.parser.currentToken) } function TL(e, t) { t.stitches = !0; const n = CL(e); if ("children" in e && "children" in n) { const r = PT({ type: "root", children: e.children }, t.options); n.children = r.children } MT({ type: "comment", value: { stitch: n } }, t) } function MT(e, t) { const n = e.value, r = { type: se.COMMENT, data: n, location: rs(e) }; ki(t, nn(e)), t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken) } function yL(e, t) { if (t.parser.tokenizer.preprocessor.html = "", t.parser.tokenizer.preprocessor.pos = -1, t.parser.tokenizer.preprocessor.lastGapPos = -2, t.parser.tokenizer.preprocessor.gapStack = [], t.parser.tokenizer.preprocessor.skipNextNewLine = !1, t.parser.tokenizer.preprocessor.lastChunkWritten = !1, t.parser.tokenizer.preprocessor.endOfChunkHit = !1, t.parser.tokenizer.preprocessor.isEol = !1, FT(t, nn(e)), t.parser.tokenizer.write(t.options.tagfilter ? e.value.replace(dL, "&lt;$1$2") : e.value, !1), t.parser.tokenizer._runParsingLoop(), t.parser.tokenizer.state === 72 || t.parser.tokenizer.state === 78) { t.parser.tokenizer.preprocessor.lastChunkWritten = !0; const n = t.parser.tokenizer._consume(); t.parser.tokenizer._callState(n) } } function bL(e, t) { const n = e; if (t.options.passThrough && t.options.passThrough.includes(n.type)) TL(n, t); else { let r = ""; throw hL.has(n.type) && (r = ". It looks like you are using MDX nodes with `hast-util-raw` (or `rehype-raw`). If you use this because you are using remark or rehype plugins that inject `'html'` nodes, then please raise an issue with that plugin, as its a bad and slow idea. If you use this because you are using markdown syntax, then you have to configure this utility (or plugin) to pass through these nodes (see `passThrough` in docs), but you can also migrate to use the MDX syntax"), new Error("Cannot compile `" + n.type + "` node" + r) } } function ki(e, t) { FT(e, t); const n = e.parser.tokenizer.currentCharacterToken; n && n.location && (n.location.endLine = e.parser.tokenizer.preprocessor.line, n.location.endCol = e.parser.tokenizer.preprocessor.col + 1, n.location.endOffset = e.parser.tokenizer.preprocessor.offset + 1, e.parser.currentToken = n, e.parser._processToken(e.parser.currentToken)), e.parser.tokenizer.paused = !1, e.parser.tokenizer.inLoop = !1, e.parser.tokenizer.active = !1, e.parser.tokenizer.returnState = ve.DATA, e.parser.tokenizer.charRefCode = -1, e.parser.tokenizer.consumedAfterSnapshot = -1, e.parser.tokenizer.currentLocation = null, e.parser.tokenizer.currentCharacterToken = null, e.parser.tokenizer.currentToken = null, e.parser.tokenizer.currentAttr = { name: "", value: "" } } function FT(e, t) { if (t && t.offset !== void 0) { const n = { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: -1, endCol: -1, endOffset: -1 }; e.parser.tokenizer.preprocessor.lineStartPos = -t.column + 1, e.parser.tokenizer.preprocessor.droppedBufferSize = t.offset, e.parser.tokenizer.preprocessor.line = t.line, e.parser.tokenizer.currentLocation = n } } function xL(e, t) { const n = e.tagName.toLowerCase(); if (t.parser.tokenizer.state === ve.PLAINTEXT) return; ki(t, nn(e)); const r = t.parser.openElements.current; let i = "namespaceURI" in r ? r.namespaceURI : or.html; i === or.html && n === "svg" && (i = or.svg); const u = w6({ ...e, children: [] }, { space: i === or.svg ? "svg" : "html" }), s = { type: se.START_TAG, tagName: n, tagID: Ai(n), selfClosing: !1, ackSelfClosing: !1, attrs: "attrs" in u ? u.attrs : [], location: rs(e) }; t.parser.currentToken = s, t.parser._processToken(t.parser.currentToken), t.parser.tokenizer.lastStartTagName = n } function SL(e, t) { const n = e.tagName.toLowerCase(); if (!t.parser.tokenizer.inForeignNode && F6.includes(n) || t.parser.tokenizer.state === ve.PLAINTEXT) return; ki(t, uo(e)); const r = { type: se.END_TAG, tagName: n, tagID: Ai(n), selfClosing: !1, ackSelfClosing: !1, attrs: [], location: rs(e) }; t.parser.currentToken = r, t.parser._processToken(t.parser.currentToken), n === t.parser.tokenizer.lastStartTagName && (t.parser.tokenizer.state === ve.RCDATA || t.parser.tokenizer.state === ve.RAWTEXT || t.parser.tokenizer.state === ve.SCRIPT_DATA) && (t.parser.tokenizer.state = ve.DATA) } function _L(e) { const t = e.type === "root" ? e.children[0] : e; return !!(t && (t.type === "doctype" || t.type === "element" && t.tagName.toLowerCase() === "html")) } function rs(e) { const t = nn(e) || { line: void 0, column: void 0, offset: void 0 }, n = uo(e) || { line: void 0, column: void 0, offset: void 0 }; return { startLine: t.line, startCol: t.column, startOffset: t.offset, endLine: n.line, endCol: n.column, endOffset: n.offset } } function CL(e) { return "children" in e ? hi({ ...e, children: [] }) : hi(e) } function AL(e) { return function (t, n) { return PT(t, { ...e, file: n }) } } const kL = (e, t = 1200, n = 800) => `https://picsum.photos/seed/${e}/${t}/${n}`; function NL() { const { yearMonth: e, slug: t } = n1(), [n, r] = M.useState(null), [i, u] = M.useState(!0), [s, a] = M.useState(null); M.useEffect(() => { e && t && o(e, t) }, [e, t]); const o = async (d, p) => { try { u(!0); const h = await nr.getBySlug(d, p); r(h.data.post) } catch { a("Post not found") } finally { u(!1) } }, l = (n == null ? void 0 : n.published) || (n == null ? void 0 : n.draft), f = l == null ? void 0 : l.meta; return i ? w.jsxs("div", { className: "min-h-screen flex flex-col", children: [w.jsx(ou, {}), w.jsx("main", { className: "flex-1 animate-pulse", children: w.jsxs("div", { className: "max-w-3xl mx-auto px-4 py-12", children: [w.jsx("div", { className: "h-8 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-4" }), w.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/4 mb-8" }), w.jsx("div", { className: "space-y-4", children: [...Array(8)].map((d, p) => w.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded" }, p)) })] }) }), w.jsx(lu, {})] }) : s || !n || !l ? w.jsxs("div", { className: "min-h-screen flex flex-col", children: [w.jsx(ou, {}), w.jsx("main", { className: "flex-1 flex items-center justify-center", children: w.jsx("p", { className: "text-muted-light dark:text-muted-dark", children: s || "Post not found" }) }), w.jsx(lu, {})] }) : w.jsxs(w.Fragment, { children: [w.jsxs($f, { children: [w.jsxs("title", { children: [l.title, " | Next Blog"] }), w.jsx("meta", { name: "description", content: (f == null ? void 0 : f.thumbText) || l.title }), (f == null ? void 0 : f.ogImage) && w.jsx("meta", { property: "og:image", content: f.ogImage })] }), w.jsxs("div", { className: "min-h-screen flex flex-col", children: [w.jsx(ou, {}), w.jsxs("main", { className: "flex-1 bg-background-light dark:bg-background-dark", children: [w.jsxs("div", { className: "relative w-full h-[50vh] md:h-[60vh] min-h-[400px] bg-gray-900 overflow-hidden", children: [w.jsx("img", { src: (f == null ? void 0 : f.thumbImage) || kL(n.id), alt: l.title, className: "w-full h-full object-cover opacity-80" }), w.jsx("div", { className: "absolute inset-0 bg-gradient-to-t from-background-light dark:from-background-dark via-transparent to-transparent opacity-90" }), w.jsxs("div", { className: "absolute bottom-0 left-0 right-0 p-6 md:p-12 max-w-4xl mx-auto text-center", children: [w.jsxs("div", { className: "flex items-center justify-center gap-3 mb-6 animate-fade-in-up", children: [(f == null ? void 0 : f.featured) && w.jsx("span", { className: "px-2 py-1 text-xs uppercase tracking-[0.2em] font-bold text-white bg-yellow-600/90 rounded-sm shadow-sm backdrop-blur-sm", children: "Featured" }), (f == null ? void 0 : f.category) && w.jsx("span", { className: "px-2 py-1 text-xs uppercase tracking-[0.2em] font-medium text-white/90 bg-accent/80 rounded-sm shadow-sm backdrop-blur-sm", children: f.category })] }), w.jsx("h1", { className: "font-display text-4xl md:text-6xl lg:text-7xl text-white mb-6 leading-tight text-shadow-lg animate-fade-in-up delay-100", children: l.title }), w.jsxs("div", { className: "flex items-center justify-center space-x-6 text-white/80 text-sm md:text-base font-medium animate-fade-in-up delay-200", children: [(f == null ? void 0 : f.author) && w.jsxs("div", { className: "flex items-center gap-2", children: [w.jsx("div", { className: "w-8 h-8 rounded-full bg-accent/30 flex items-center justify-center text-xs font-bold ring-1 ring-white/20", children: f.author[0] }), w.jsx("span", { children: f.author })] }), (f == null ? void 0 : f.date) && w.jsxs(w.Fragment, { children: [w.jsx("span", { children: "" }), w.jsx("time", { className: "font-mono opacity-80", children: f.date })] })] })] })] }), w.jsxs("article", { className: "max-w-3xl mx-auto px-4 sm:px-6 py-16", children: [w.jsx("div", { className: "prose prose-lg md:prose-xl dark:prose-invert mx-auto drop-cap", children: w.jsx(eI, { remarkPlugins: [h6], rehypePlugins: [AL], children: l.text }) }), (f == null ? void 0 : f.tags) && f.tags.length > 0 && w.jsx("div", { className: "mt-16 pt-10 border-t border-gray-200 dark:border-gray-800", children: w.jsx("div", { className: "flex flex-wrap gap-3", children: f.tags.map(d => w.jsxs("a", { href: `/tag/${d}`, className: "px-4 py-1.5 text-sm font-medium text-text-light dark:text-text-dark bg-surface-light dark:bg-surface-dark border border-gray-200 dark:border-gray-700 rounded-full hover:border-accent hover:text-accent dark:hover:text-accent transition-colors duration-200", children: ["#", d] }, d)) }) })] })] }), w.jsx(lu, {})] })] }) } function gl() { const { category: e, tag: t, author: n } = n1(), { isAuthenticated: r } = g1(), [i, u] = M.useState([]), [s, a] = M.useState([]), [o, l] = M.useState(!0), [f, d] = M.useState(!1); M.useEffect(() => { Q1.getAll().then(m => { a(m.data.categories) }).catch(console.error) }, []), M.useEffect(() => { if (e && s.length > 0) { const m = s.find(T => T.id === e || T.slug === e); d((m == null ? void 0 : m.adminOnly) || !1) } p() }, [e, t, n, s, r]); const p = async () => { try { l(!0); let m; const T = s.find(g => g.id === e || g.slug === e); if (r && (T == null ? void 0 : T.adminOnly)) { m = await nr.getAll(1, 1e3); const g = m.data.posts.filter(E => { var I, L, k; return ((k = (L = (I = E.draft) == null ? void 0 : I.meta) == null ? void 0 : L.category) == null ? void 0 : k.toLowerCase()) === (e == null ? void 0 : e.toLowerCase()) }); u(g) } else e ? (m = await nr.getByCategory(e, "all"), u(m.data.posts)) : t ? (m = await nr.getByTag(t, "all"), u(m.data.posts)) : n ? (m = await nr.getByAuthor(n, "all"), u(m.data.posts)) : (m = await nr.getPublished(), u(m.data.posts)) } catch (m) { console.error(m) } finally { l(!1) } }, h = e || t || n || "Posts"; return w.jsxs(w.Fragment, { children: [w.jsx($f, { children: w.jsxs("title", { children: [h, " | Next Blog"] }) }), w.jsxs("div", { className: "min-h-screen flex flex-col", children: [w.jsx(ou, {}), w.jsx("main", { className: "flex-1", children: w.jsxs("div", { className: "max-w-6xl mx-auto px-4 sm:px-6 lg:px-8 py-12", children: [w.jsxs("header", { className: "mb-12", children: [w.jsxs("h1", { className: "font-display text-4xl mb-2", children: [f && r ? " " : "", h] }), w.jsxs("p", { className: "text-muted-light dark:text-muted-dark", children: [i.length, " post", i.length !== 1 ? "s" : "", f && r && " (including drafts)"] })] }), o ? w.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: [...Array(6)].map((m, T) => w.jsxs("div", { className: "animate-pulse", children: [w.jsx("div", { className: "bg-gray-200 dark:bg-gray-700 aspect-[4/3] mb-4 rounded" }), w.jsx("div", { className: "h-6 bg-gray-200 dark:bg-gray-700 rounded w-3/4 mb-2" }), w.jsx("div", { className: "h-4 bg-gray-200 dark:bg-gray-700 rounded w-1/2" })] }, T)) }) : i.length === 0 ? w.jsx("div", { className: "text-center py-12 text-muted-light dark:text-muted-dark", children: "No posts found." }) : w.jsx("div", { className: "grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-8", children: i.map(m => w.jsx(kc, { post: m, showDraftBadge: f && r }, m.id)) })] }) }), w.jsx(lu, {})] })] }) } function IL() { return w.jsx(h1, { children: w.jsx(eS, { children: w.jsx(nS, { children: w.jsx(Sx, { children: w.jsxs(mx, { children: [w.jsx(tr, { path: "/", element: w.jsx(kC, {}) }), w.jsx(tr, { path: "/posts/:yearMonth/:slug", element: w.jsx(NL, {}) }), w.jsx(tr, { path: "/category/:category", element: w.jsx(gl, {}) }), w.jsx(tr, { path: "/tag/:tag", element: w.jsx(gl, {}) }), w.jsx(tr, { path: "/author/:author", element: w.jsx(gl, {}) }), w.jsx(tr, { path: "*", element: w.jsx(hx, { to: "/", replace: !0 }) })] }) }) }) }) }) } let wL = !1; try { document.cookie, wL = !0 } catch { } const vL = { en: { translation: { brand: "", footer: { copyright: " {{year}} Next Blog. MIT License." }, nav: { home: "Home", tutorials: "Tutorials", admin: "Admin" }, home: { title: "Blog", featured: "Featured", latest: "Latest Posts", readMore: "Read More", noPosts: "No posts yet.", loading: "Loading...", failedToLoad: "Failed to load posts" }, post: { by: "By", published: "Published", share: "Share" }, admin: { login: { title: "Admin Login", passwordLabel: "Admin Password", passwordPlaceholder: "Enter password", submit: "Login", submitting: "Logging in...", orSignInWith: "Or sign in with", googleComingSoon: "Google (Coming Soon)", invalidPassword: "Invalid password" }, dashboard: { newPost: "New Post", posts: "Posts", importMD: "Import MD", allCategories: "All Categories" }, editor: { save: "Save", saving: "Saving...", publish: "Publish", unpublish: "Unpublish", delete: "Delete", codeBlock: "Code Block", undo: "Undo", redo: "Redo", tabs: { content: "Content", metadata: "Metadata" }, content: { titlePlaceholder: "Post title...", textPlaceholder: "Start writing in Markdown...", importMD: "Import MD" }, meta: { title: "Post Metadata", slug: "URL Slug", slugHelp: "Final URL", author: "Author", category: "Category", selectCategory: "Select category...", manageCategories: "Manage", publishDate: "First Publish Date", allowEdit: "Allow editing", autoSet: "Auto-set on first publish (Taipei time)", willAutoSet: "Will be auto-set on first publish", lastEditDate: "Last Edit Date", lastEditHelp: "Updated on each republish", language: "Language", tags: "Tags (comma-separated)", featured: "Featured Post", hasTranslation: "Has Translation", thumbImage: "Thumbnail Image", useAutoThumb: "Use first image from content", autoDetected: "Auto-detected from content", noImageFound: "No image found in content", thumbText: "Thumbnail Text / Description", useAutoThumbText: "Use first 20 words from content", noTextFound: "No text content found" } }, category: { manage: "Manage Categories", add: "Add Category", edit: "Edit Category", title: "Title", slug: "Slug", slugPlaceholder: "auto-generated from title", description: "Description", cancel: "Cancel", save: "Save", saving: "Saving...", delete: "Delete", confirmDelete: "Are you sure you want to delete this category?", noCategories: "No categories yet", adminOnly: "Admin Only (hidden from public navigation)", confirmPublic: "Make Category Public?", confirmPublicMsg: "This category will be visible in the public navigation. Are you sure?" }, logout: "Logout" } } }, poj: { translation: { brand: "", footer: { copyright: " {{year}} Next P-lok-keh. MIT License." }, nav: { home: "Thu-iah", tutorials: "Ku-hak", admin: "Kon-l" }, home: { title: "Blog", featured: "Cheng-son", latest: "Sing-sin Bn-chiu", readMore: "Kho Sing-s", noPosts: "Iu-be  bn-chiu", loading: "Teh chi-jip...", failedToLoad: "Bn-chiu chi-jip sit-pi" }, post: { by: "Chok-chi:", published: "Hoat-p", share: "Hun-hing" }, admin: { login: { title: "Kon-l-on Teng-jip", passwordLabel: "Kon-l Bit-b", passwordPlaceholder: "Phah bit-b...", submit: "Teng-jip", submitting: "Teh Teng-jip...", orSignInWith: "Ah-s thu-ke...li teng-jip", googleComingSoon: "Google (Kn toh )", invalidPassword: "Bit-b m-tioh" }, dashboard: { newPost: "Sin Bn-chiu", posts: "Bn-chiu", importMD: "He-jip MD", allCategories: "S- Li-piat" }, editor: { save: "Chn-tng", saving: "Teh Chn...", publish: "Chi-k", unpublish: "H-k", delete: "San-t", codeBlock: "Ti-b Khu-keh", undo: "Hon-i", redo: "Ting-ch", tabs: { content: "Le-ing", metadata: "Meta Chu-liu" }, content: { titlePlaceholder: "Bn-chiu Piau-t...", textPlaceholder: "Kh-chhi si Markdown...", importMD: "He-jip MD" }, meta: { title: "Bn-chiu Meta Chu-liu", slug: "Bng-ch Be-liu", slugHelp: "Sing-be  bng-ch", author: "Chok-chi", category: "Li-piat", selectCategory: "Son li-piat...", manageCategories: "Kon-l", publishDate: "Thu-pi Hoat-p", allowEdit: "Un-chn siu-ki", autoSet: "Ch-tng siat-tng (Ti-pak s-kan)", willAutoSet: "Hoat-p  s  ka-k siat-tng", lastEditDate: "Sing-sin siu-ki jit-k", lastEditHelp: "Mi pi ting-sin chi-k lng  keng-sin", language: "G-gin", tags: "Phiau-chhiam (ing t-tim hun-khui)", featured: "Cheng-son Bn-chiu", hasTranslation: " hoan-ek pn-pn", thumbImage: "Siu-t", useAutoThumb: "K le-ing thu chit tiu t theh li ing", autoDetected: "i le-ing ch-tng trn-chhek--", noImageFound: "Le-ing chhe-b t", thumbText: "Siu-t soat-bng bn-j", useAutoThumbText: "K le-bn thu 20 j theh li ing", noTextFound: "Chhe-b bn-j le-ing" } }, category: { manage: "Kon-l Li-piat", add: "Sin-cheng Li-piat", edit: "Siu-ki Li-piat", title: "Piau-t", slug: "Slug (Ti-h)", slugPlaceholder: "i piau-t ch-tng sn-seng", description: "Soat-bng", cancel: "Chh-siau", save: "P-chn", saving: "Teh Chn...", delete: "San-t", confirmDelete: "L km khak-tng beh san-t chit  li-piat?", noCategories: "Iu-be  li-piat", adminOnly: "Kon-l-on Choan-ing (kong-khai t-hng kha-b)", confirmPublic: "Beh kong-khai li-piat?", confirmPublicMsg: "Chit  li-piat  t kong-khai t-hng chhut-hin. L km khak-tng?" }, logout: "Teng-chhut" } } }, hanlo: { translation: { brand: "", footer: { copyright: " {{year}} Next . MIT License." }, nav: { home: "", tutorials: "", admin: "" }, home: { title: "Blog", featured: "", latest: "", readMore: "", noPosts: "", loading: "Teh liah...", failedToLoad: "" }, post: { by: "", published: "", share: "" }, admin: { login: { title: "", passwordLabel: "", passwordPlaceholder: "...", submit: "", submitting: "Teh ...", orSignInWith: "iah-s...", googleComingSoon: "Google (beh--ah)", invalidPassword: "" }, dashboard: { newPost: "", posts: "", importMD: " MD", allCategories: "" }, editor: { save: "", saving: "Teh ...", publish: "", unpublish: "", delete: "", codeBlock: "", undo: "", redo: "", tabs: { content: "", metadata: "Meta " }, content: { titlePlaceholder: "...", textPlaceholder: " Markdown...", importMD: " MD" }, meta: { title: " Meta ", slug: "", slugHelp: "  ", author: "", category: "", selectCategory: "...", manageCategories: "", publishDate: "", allowEdit: "", autoSet: " ()", willAutoSet: "  ", lastEditDate: "", lastEditHelp: "", language: "", tags: " ()", featured: "", hasTranslation: "", thumbImage: "", useAutoThumb: "", autoDetected: "--", noImageFound: "", thumbText: "", useAutoThumbText: " 20 ", noTextFound: "" } }, category: { manage: "", add: "", edit: "", title: "", slug: "", slugPlaceholder: "", description: "", cancel: "", save: "", saving: "Teh ...", delete: "", confirmDelete: "", noCategories: "", adminOnly: " ()", confirmPublic: "", confirmPublicMsg: "t" }, logout: "" } } } }; it.use(RS).init({ resources: vL, lng: "en", fallbackLng: "en", interpolation: { escapeValue: !1 } }); class OL extends Bt.Component { constructor(t) { super(t), this.state = { hasError: !1, error: null } } static getDerivedStateFromError(t) { return { hasError: !0, error: t } } componentDidCatch(t, n) { console.error("Uncaught error:", t, n) } render() { var t, n; return this.state.hasError ? w.jsxs("div", { style: { padding: "20px", color: "red" }, children: [w.jsx("h1", { children: "Something went wrong." }), w.jsx("pre", { children: (t = this.state.error) == null ? void 0 : t.toString() }), w.jsx("pre", { children: (n = this.state.error) == null ? void 0 : n.stack })] }) : this.props.children } } Tl.createRoot(document.getElementById("root")).render(w.jsx(Bt.StrictMode, { children: w.jsx(OL, { children: w.jsx(IL, {}) }) }));</script>
  <style rel="stylesheet" crossorigin>
    *,
    :before,
    :after {
      --tw-border-spacing-x: 0;
      --tw-border-spacing-y: 0;
      --tw-translate-x: 0;
      --tw-translate-y: 0;
      --tw-rotate: 0;
      --tw-skew-x: 0;
      --tw-skew-y: 0;
      --tw-scale-x: 1;
      --tw-scale-y: 1;
      --tw-pan-x: ;
      --tw-pan-y: ;
      --tw-pinch-zoom: ;
      --tw-scroll-snap-strictness: proximity;
      --tw-gradient-from-position: ;
      --tw-gradient-via-position: ;
      --tw-gradient-to-position: ;
      --tw-ordinal: ;
      --tw-slashed-zero: ;
      --tw-numeric-figure: ;
      --tw-numeric-spacing: ;
      --tw-numeric-fraction: ;
      --tw-ring-inset: ;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-color: rgb(59 130 246 / .5);
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-ring-shadow: 0 0 #0000;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-colored: 0 0 #0000;
      --tw-blur: ;
      --tw-brightness: ;
      --tw-contrast: ;
      --tw-grayscale: ;
      --tw-hue-rotate: ;
      --tw-invert: ;
      --tw-saturate: ;
      --tw-sepia: ;
      --tw-drop-shadow: ;
      --tw-backdrop-blur: ;
      --tw-backdrop-brightness: ;
      --tw-backdrop-contrast: ;
      --tw-backdrop-grayscale: ;
      --tw-backdrop-hue-rotate: ;
      --tw-backdrop-invert: ;
      --tw-backdrop-opacity: ;
      --tw-backdrop-saturate: ;
      --tw-backdrop-sepia: ;
      --tw-contain-size: ;
      --tw-contain-layout: ;
      --tw-contain-paint: ;
      --tw-contain-style:
    }

    ::backdrop {
      --tw-border-spacing-x: 0;
      --tw-border-spacing-y: 0;
      --tw-translate-x: 0;
      --tw-translate-y: 0;
      --tw-rotate: 0;
      --tw-skew-x: 0;
      --tw-skew-y: 0;
      --tw-scale-x: 1;
      --tw-scale-y: 1;
      --tw-pan-x: ;
      --tw-pan-y: ;
      --tw-pinch-zoom: ;
      --tw-scroll-snap-strictness: proximity;
      --tw-gradient-from-position: ;
      --tw-gradient-via-position: ;
      --tw-gradient-to-position: ;
      --tw-ordinal: ;
      --tw-slashed-zero: ;
      --tw-numeric-figure: ;
      --tw-numeric-spacing: ;
      --tw-numeric-fraction: ;
      --tw-ring-inset: ;
      --tw-ring-offset-width: 0px;
      --tw-ring-offset-color: #fff;
      --tw-ring-color: rgb(59 130 246 / .5);
      --tw-ring-offset-shadow: 0 0 #0000;
      --tw-ring-shadow: 0 0 #0000;
      --tw-shadow: 0 0 #0000;
      --tw-shadow-colored: 0 0 #0000;
      --tw-blur: ;
      --tw-brightness: ;
      --tw-contrast: ;
      --tw-grayscale: ;
      --tw-hue-rotate: ;
      --tw-invert: ;
      --tw-saturate: ;
      --tw-sepia: ;
      --tw-drop-shadow: ;
      --tw-backdrop-blur: ;
      --tw-backdrop-brightness: ;
      --tw-backdrop-contrast: ;
      --tw-backdrop-grayscale: ;
      --tw-backdrop-hue-rotate: ;
      --tw-backdrop-invert: ;
      --tw-backdrop-opacity: ;
      --tw-backdrop-saturate: ;
      --tw-backdrop-sepia: ;
      --tw-contain-size: ;
      --tw-contain-layout: ;
      --tw-contain-paint: ;
      --tw-contain-style:
    }

    *,
    :before,
    :after {
      box-sizing: border-box;
      border-width: 0;
      border-style: solid;
      border-color: #e5e7eb
    }

    :before,
    :after {
      --tw-content: ""
    }

    html,
    :host {
      line-height: 1.5;
      -webkit-text-size-adjust: 100%;
      -moz-tab-size: 4;
      -o-tab-size: 4;
      tab-size: 4;
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, sans-serif;
      font-feature-settings: normal;
      font-variation-settings: normal;
      -webkit-tap-highlight-color: transparent
    }

    body {
      margin: 0;
      line-height: inherit
    }

    hr {
      height: 0;
      color: inherit;
      border-top-width: 1px
    }

    abbr:where([title]) {
      -webkit-text-decoration: underline dotted;
      text-decoration: underline dotted
    }

    h1,
    h2,
    h3,
    h4,
    h5,
    h6 {
      font-size: inherit;
      font-weight: inherit
    }

    a {
      color: inherit;
      text-decoration: inherit
    }

    b,
    strong {
      font-weight: bolder
    }

    code,
    kbd,
    samp,
    pre {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace;
      font-feature-settings: normal;
      font-variation-settings: normal;
      font-size: 1em
    }

    small {
      font-size: 80%
    }

    sub,
    sup {
      font-size: 75%;
      line-height: 0;
      position: relative;
      vertical-align: baseline
    }

    sub {
      bottom: -.25em
    }

    sup {
      top: -.5em
    }

    table {
      text-indent: 0;
      border-color: inherit;
      border-collapse: collapse
    }

    button,
    input,
    optgroup,
    select,
    textarea {
      font-family: inherit;
      font-feature-settings: inherit;
      font-variation-settings: inherit;
      font-size: 100%;
      font-weight: inherit;
      line-height: inherit;
      letter-spacing: inherit;
      color: inherit;
      margin: 0;
      padding: 0
    }

    button,
    select {
      text-transform: none
    }

    button,
    input:where([type=button]),
    input:where([type=reset]),
    input:where([type=submit]) {
      -webkit-appearance: button;
      background-color: transparent;
      background-image: none
    }

    :-moz-focusring {
      outline: auto
    }

    :-moz-ui-invalid {
      box-shadow: none
    }

    progress {
      vertical-align: baseline
    }

    ::-webkit-inner-spin-button,
    ::-webkit-outer-spin-button {
      height: auto
    }

    [type=search] {
      -webkit-appearance: textfield;
      outline-offset: -2px
    }

    ::-webkit-search-decoration {
      -webkit-appearance: none
    }

    ::-webkit-file-upload-button {
      -webkit-appearance: button;
      font: inherit
    }

    summary {
      display: list-item
    }

    blockquote,
    dl,
    dd,
    h1,
    h2,
    h3,
    h4,
    h5,
    h6,
    hr,
    figure,
    p,
    pre {
      margin: 0
    }

    fieldset {
      margin: 0;
      padding: 0
    }

    legend {
      padding: 0
    }

    ol,
    ul,
    menu {
      list-style: none;
      margin: 0;
      padding: 0
    }

    dialog {
      padding: 0
    }

    textarea {
      resize: vertical
    }

    input::-moz-placeholder,
    textarea::-moz-placeholder {
      opacity: 1;
      color: #9ca3af
    }

    input::placeholder,
    textarea::placeholder {
      opacity: 1;
      color: #9ca3af
    }

    button,
    [role=button] {
      cursor: pointer
    }

    :disabled {
      cursor: default
    }

    img,
    svg,
    video,
    canvas,
    audio,
    iframe,
    embed,
    object {
      display: block;
      vertical-align: middle
    }

    img,
    video {
      max-width: 100%;
      height: auto
    }

    [hidden]:where(:not([hidden=until-found])) {
      display: none
    }

    :root {
      --text-base: 1rem;
      --text-scale: 1
    }

    [data-text-size=small] {
      --text-scale: .875
    }

    [data-text-size=medium] {
      --text-scale: 1
    }

    [data-text-size=large] {
      --text-scale: 1.125
    }

    [data-text-size=xlarge] {
      --text-scale: 1.25
    }

    [data-text-size=xxlarge] {
      --text-scale: 1.4
    }

    [data-text-size=xxxlarge] {
      --text-scale: 1.6
    }

    html {
      scroll-behavior: smooth
    }

    body {
      --tw-bg-opacity: 1;
      background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1));
      font-family: Inter, system-ui, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Helvetica Neue, Arial, sans-serif;
      --tw-text-opacity: 1;
      color: rgb(31 41 55 / var(--tw-text-opacity, 1));
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
      transition-timing-function: cubic-bezier(.4, 0, .2, 1);
      transition-duration: .3s
    }

    body *::-moz-selection {
      --tw-bg-opacity: 1;
      background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
      --tw-text-opacity: 1;
      color: rgb(255 255 255 / var(--tw-text-opacity, 1))
    }

    body *::selection {
      --tw-bg-opacity: 1;
      background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
      --tw-text-opacity: 1;
      color: rgb(255 255 255 / var(--tw-text-opacity, 1))
    }

    body::-moz-selection {
      --tw-bg-opacity: 1;
      background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
      --tw-text-opacity: 1;
      color: rgb(255 255 255 / var(--tw-text-opacity, 1))
    }

    body::selection {
      --tw-bg-opacity: 1;
      background-color: rgb(15 118 110 / var(--tw-bg-opacity, 1));
      --tw-text-opacity: 1;
      color: rgb(255 255 255 / var(--tw-text-opacity, 1))
    }

    body:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1));
      --tw-text-opacity: 1;
      color: rgb(243 244 246 / var(--tw-text-opacity, 1))
    }

    body {
      font-size: calc(1rem * var(--text-scale))
    }

    p,
    span,
    a,
    li,
    td,
    th,
    label,
    button {
      font-size: inherit
    }

    h1 {
      font-size: calc(3rem * var(--text-scale))
    }

    h2 {
      font-size: calc(2.25rem * var(--text-scale))
    }

    h3 {
      font-size: calc(1.75rem * var(--text-scale))
    }

    h4 {
      font-size: calc(1.5rem * var(--text-scale))
    }

    h5 {
      font-size: calc(1.25rem * var(--text-scale))
    }

    h6 {
      font-size: calc(1rem * var(--text-scale))
    }

    small,
    .text-xs {
      font-size: calc(.75rem * var(--text-scale))
    }

    .text-sm {
      font-size: calc(.875rem * var(--text-scale))
    }

    ruby {
      ruby-position: over;
      ruby-align: center
    }

    rt {
      font-size: .6em;
      font-weight: 400;
      font-family: Inter, sans-serif;
      opacity: .9
    }

    .prose {
      color: var(--tw-prose-body);
      max-width: 65ch
    }

    .prose :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.25em;
      margin-bottom: 1.25em
    }

    .prose :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-lead);
      font-size: 1.25em;
      line-height: 1.6;
      margin-top: 1.2em;
      margin-bottom: 1.2em
    }

    .prose :where(a):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-links);
      text-decoration: underline;
      font-weight: 500
    }

    .prose :where(strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-bold);
      font-weight: 600
    }

    .prose :where(a strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(blockquote strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(thead th strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: decimal;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      padding-inline-start: 1.625em
    }

    .prose :where(ol[type=A]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: upper-alpha
    }

    .prose :where(ol[type=a]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: lower-alpha
    }

    .prose :where(ol[type=A s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: upper-alpha
    }

    .prose :where(ol[type=a s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: lower-alpha
    }

    .prose :where(ol[type=I]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: upper-roman
    }

    .prose :where(ol[type=i]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: lower-roman
    }

    .prose :where(ol[type=I s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: upper-roman
    }

    .prose :where(ol[type=i s]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: lower-roman
    }

    .prose :where(ol[type="1"]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: decimal
    }

    .prose :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
      list-style-type: disc;
      margin-top: 1.25em;
      margin-bottom: 1.25em;
      padding-inline-start: 1.625em
    }

    .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
      font-weight: 400;
      color: var(--tw-prose-counters)
    }

    .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *))::marker {
      color: var(--tw-prose-bullets)
    }

    .prose :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-headings);
      font-weight: 600;
      margin-top: 1.25em
    }

    .prose :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
      border-color: var(--tw-prose-hr);
      border-top-width: 1px;
      margin-top: 3em;
      margin-bottom: 3em
    }

    .prose :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-weight: 500;
      font-style: italic;
      color: var(--tw-prose-quotes);
      border-inline-start-width: .25rem;
      border-inline-start-color: var(--tw-prose-quote-borders);
      quotes: "" "" "" "";
      margin-top: 1.6em;
      margin-bottom: 1.6em;
      padding-inline-start: 1em
    }

    .prose :where(blockquote p:first-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):before {
      content: open-quote
    }

    .prose :where(blockquote p:last-of-type):not(:where([class~=not-prose], [class~=not-prose] *)):after {
      content: close-quote
    }

    .prose :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-headings);
      font-weight: 800;
      font-size: 2.25em;
      margin-top: 0;
      margin-bottom: .8888889em;
      line-height: 1.1111111
    }

    .prose :where(h1 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-weight: 900;
      color: inherit
    }

    .prose :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-headings);
      font-weight: 700;
      font-size: 1.5em;
      margin-top: 2em;
      margin-bottom: 1em;
      line-height: 1.3333333
    }

    .prose :where(h2 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-weight: 800;
      color: inherit
    }

    .prose :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-headings);
      font-weight: 600;
      font-size: 1.25em;
      margin-top: 1.6em;
      margin-bottom: .6em;
      line-height: 1.6
    }

    .prose :where(h3 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-weight: 700;
      color: inherit
    }

    .prose :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-headings);
      font-weight: 600;
      margin-top: 1.5em;
      margin-bottom: .5em;
      line-height: 1.5
    }

    .prose :where(h4 strong):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-weight: 700;
      color: inherit
    }

    .prose :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 2em;
      margin-bottom: 2em
    }

    .prose :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
      display: block;
      margin-top: 2em;
      margin-bottom: 2em
    }

    .prose :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 2em;
      margin-bottom: 2em
    }

    .prose :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-weight: 500;
      font-family: inherit;
      color: var(--tw-prose-kbd);
      box-shadow: 0 0 0 1px var(--tw-prose-kbd-shadows), 0 3px 0 var(--tw-prose-kbd-shadows);
      font-size: .875em;
      border-radius: .3125rem;
      padding-top: .1875em;
      padding-inline-end: .375em;
      padding-bottom: .1875em;
      padding-inline-start: .375em
    }

    .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-code);
      font-weight: 600;
      font-size: .875em
    }

    .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
      content: "`"
    }

    .prose :where(code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
      content: "`"
    }

    .prose :where(a code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(h1 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit;
      font-size: .875em
    }

    .prose :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit;
      font-size: .9em
    }

    .prose :where(h4 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(blockquote code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(thead th code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: inherit
    }

    .prose :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-pre-code);
      background-color: var(--tw-prose-pre-bg);
      overflow-x: auto;
      font-weight: 400;
      font-size: .875em;
      line-height: 1.7142857;
      margin-top: 1.7142857em;
      margin-bottom: 1.7142857em;
      border-radius: .375rem;
      padding-top: .8571429em;
      padding-inline-end: 1.1428571em;
      padding-bottom: .8571429em;
      padding-inline-start: 1.1428571em
    }

    .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      background-color: transparent;
      border-width: 0;
      border-radius: 0;
      padding: 0;
      font-weight: inherit;
      color: inherit;
      font-size: inherit;
      font-family: inherit;
      line-height: inherit
    }

    .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):before {
      content: none
    }

    .prose :where(pre code):not(:where([class~=not-prose], [class~=not-prose] *)):after {
      content: none
    }

    .prose :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
      width: 100%;
      table-layout: auto;
      margin-top: 2em;
      margin-bottom: 2em;
      font-size: .875em;
      line-height: 1.7142857
    }

    .prose :where(thead):not(:where([class~=not-prose], [class~=not-prose] *)) {
      border-bottom-width: 1px;
      border-bottom-color: var(--tw-prose-th-borders)
    }

    .prose :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-headings);
      font-weight: 600;
      vertical-align: bottom;
      padding-inline-end: .5714286em;
      padding-bottom: .5714286em;
      padding-inline-start: .5714286em
    }

    .prose :where(tbody tr):not(:where([class~=not-prose], [class~=not-prose] *)) {
      border-bottom-width: 1px;
      border-bottom-color: var(--tw-prose-td-borders)
    }

    .prose :where(tbody tr:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      border-bottom-width: 0
    }

    .prose :where(tbody td):not(:where([class~=not-prose], [class~=not-prose] *)) {
      vertical-align: baseline
    }

    .prose :where(tfoot):not(:where([class~=not-prose], [class~=not-prose] *)) {
      border-top-width: 1px;
      border-top-color: var(--tw-prose-th-borders)
    }

    .prose :where(tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
      vertical-align: top
    }

    .prose :where(th, td):not(:where([class~=not-prose], [class~=not-prose] *)) {
      text-align: start
    }

    .prose :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0;
      margin-bottom: 0
    }

    .prose :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
      color: var(--tw-prose-captions);
      font-size: .875em;
      line-height: 1.4285714;
      margin-top: .8571429em
    }

    .prose {
      --tw-prose-body: #374151;
      --tw-prose-headings: #111827;
      --tw-prose-lead: #4b5563;
      --tw-prose-links: #111827;
      --tw-prose-bold: #111827;
      --tw-prose-counters: #6b7280;
      --tw-prose-bullets: #d1d5db;
      --tw-prose-hr: #e5e7eb;
      --tw-prose-quotes: #111827;
      --tw-prose-quote-borders: #e5e7eb;
      --tw-prose-captions: #6b7280;
      --tw-prose-kbd: #111827;
      --tw-prose-kbd-shadows: rgb(17 24 39 / 10%);
      --tw-prose-code: #111827;
      --tw-prose-pre-code: #e5e7eb;
      --tw-prose-pre-bg: #1f2937;
      --tw-prose-th-borders: #d1d5db;
      --tw-prose-td-borders: #e5e7eb;
      --tw-prose-invert-body: #d1d5db;
      --tw-prose-invert-headings: #fff;
      --tw-prose-invert-lead: #9ca3af;
      --tw-prose-invert-links: #fff;
      --tw-prose-invert-bold: #fff;
      --tw-prose-invert-counters: #9ca3af;
      --tw-prose-invert-bullets: #4b5563;
      --tw-prose-invert-hr: #374151;
      --tw-prose-invert-quotes: #f3f4f6;
      --tw-prose-invert-quote-borders: #374151;
      --tw-prose-invert-captions: #9ca3af;
      --tw-prose-invert-kbd: #fff;
      --tw-prose-invert-kbd-shadows: rgb(255 255 255 / 10%);
      --tw-prose-invert-code: #fff;
      --tw-prose-invert-pre-code: #d1d5db;
      --tw-prose-invert-pre-bg: rgb(0 0 0 / 50%);
      --tw-prose-invert-th-borders: #4b5563;
      --tw-prose-invert-td-borders: #374151;
      font-size: 1rem;
      line-height: 1.75
    }

    .prose :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0;
      margin-bottom: 0
    }

    .prose :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .5em;
      margin-bottom: .5em
    }

    .prose :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: .375em
    }

    .prose :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: .375em
    }

    .prose :where(.prose>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .75em;
      margin-bottom: .75em
    }

    .prose :where(.prose>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.25em
    }

    .prose :where(.prose>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-bottom: 1.25em
    }

    .prose :where(.prose>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.25em
    }

    .prose :where(.prose>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-bottom: 1.25em
    }

    .prose :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .75em;
      margin-bottom: .75em
    }

    .prose :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.25em;
      margin-bottom: 1.25em
    }

    .prose :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .5em;
      padding-inline-start: 1.625em
    }

    .prose :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: 0
    }

    .prose :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-end: 0
    }

    .prose :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-top: .5714286em;
      padding-inline-end: .5714286em;
      padding-bottom: .5714286em;
      padding-inline-start: .5714286em
    }

    .prose :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: 0
    }

    .prose :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-end: 0
    }

    .prose :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 2em;
      margin-bottom: 2em
    }

    .prose :where(.prose>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose :where(.prose>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-bottom: 0
    }

    .prose-lg {
      font-size: 1.125rem;
      line-height: 1.7777778
    }

    .prose-lg :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em;
      margin-bottom: 1.3333333em
    }

    .prose-lg :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: 1.2222222em;
      line-height: 1.4545455;
      margin-top: 1.0909091em;
      margin-bottom: 1.0909091em
    }

    .prose-lg :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.6666667em;
      margin-bottom: 1.6666667em;
      padding-inline-start: 1em
    }

    .prose-lg :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: 2.6666667em;
      margin-top: 0;
      margin-bottom: .8333333em;
      line-height: 1
    }

    .prose-lg :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: 1.6666667em;
      margin-top: 1.8666667em;
      margin-bottom: 1.0666667em;
      line-height: 1.3333333
    }

    .prose-lg :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: 1.3333333em;
      margin-top: 1.6666667em;
      margin-bottom: .6666667em;
      line-height: 1.5
    }

    .prose-lg :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.7777778em;
      margin-bottom: .4444444em;
      line-height: 1.5555556
    }

    .prose-lg :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.7777778em;
      margin-bottom: 1.7777778em
    }

    .prose-lg :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.7777778em;
      margin-bottom: 1.7777778em
    }

    .prose-lg :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0;
      margin-bottom: 0
    }

    .prose-lg :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.7777778em;
      margin-bottom: 1.7777778em
    }

    .prose-lg :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .8888889em;
      border-radius: .3125rem;
      padding-top: .2222222em;
      padding-inline-end: .4444444em;
      padding-bottom: .2222222em;
      padding-inline-start: .4444444em
    }

    .prose-lg :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .8888889em
    }

    .prose-lg :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .8666667em
    }

    .prose-lg :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .875em
    }

    .prose-lg :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .8888889em;
      line-height: 1.75;
      margin-top: 2em;
      margin-bottom: 2em;
      border-radius: .375rem;
      padding-top: 1em;
      padding-inline-end: 1.5em;
      padding-bottom: 1em;
      padding-inline-start: 1.5em
    }

    .prose-lg :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em;
      margin-bottom: 1.3333333em;
      padding-inline-start: 1.5555556em
    }

    .prose-lg :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em;
      margin-bottom: 1.3333333em;
      padding-inline-start: 1.5555556em
    }

    .prose-lg :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .6666667em;
      margin-bottom: .6666667em
    }

    .prose-lg :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: .4444444em
    }

    .prose-lg :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: .4444444em
    }

    .prose-lg :where(.prose-lg>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .8888889em;
      margin-bottom: .8888889em
    }

    .prose-lg :where(.prose-lg>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em
    }

    .prose-lg :where(.prose-lg>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-bottom: 1.3333333em
    }

    .prose-lg :where(.prose-lg>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em
    }

    .prose-lg :where(.prose-lg>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-bottom: 1.3333333em
    }

    .prose-lg :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .8888889em;
      margin-bottom: .8888889em
    }

    .prose-lg :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em;
      margin-bottom: 1.3333333em
    }

    .prose-lg :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.3333333em
    }

    .prose-lg :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: .6666667em;
      padding-inline-start: 1.5555556em
    }

    .prose-lg :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 3.1111111em;
      margin-bottom: 3.1111111em
    }

    .prose-lg :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose-lg :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose-lg :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose-lg :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose-lg :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .8888889em;
      line-height: 1.5
    }

    .prose-lg :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-end: .75em;
      padding-bottom: .75em;
      padding-inline-start: .75em
    }

    .prose-lg :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: 0
    }

    .prose-lg :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-end: 0
    }

    .prose-lg :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-top: .75em;
      padding-inline-end: .75em;
      padding-bottom: .75em;
      padding-inline-start: .75em
    }

    .prose-lg :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-start: 0
    }

    .prose-lg :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      padding-inline-end: 0
    }

    .prose-lg :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 1.7777778em;
      margin-bottom: 1.7777778em
    }

    .prose-lg :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0;
      margin-bottom: 0
    }

    .prose-lg :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
      font-size: .8888889em;
      line-height: 1.5;
      margin-top: 1em
    }

    .prose-lg :where(.prose-lg>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-top: 0
    }

    .prose-lg :where(.prose-lg>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
      margin-bottom: 0
    }

    .visible {
      visibility: visible
    }

    .static {
      position: static
    }

    .fixed {
      position: fixed
    }

    .absolute {
      position: absolute
    }

    .relative {
      position: relative
    }

    .inset-0 {
      top: 0;
      right: 0;
      bottom: 0;
      left: 0
    }

    .-right-1 {
      right: -.25rem
    }

    .-top-1 {
      top: -.25rem
    }

    .bottom-0 {
      bottom: 0
    }

    .left-0 {
      left: 0
    }

    .left-4 {
      left: 1rem
    }

    .right-0 {
      right: 0
    }

    .right-4 {
      right: 1rem
    }

    .top-16 {
      top: 4rem
    }

    .top-4 {
      top: 1rem
    }

    .z-10 {
      z-index: 10
    }

    .z-20 {
      z-index: 20
    }

    .z-40 {
      z-index: 40
    }

    .z-50 {
      z-index: 50
    }

    .z-\[60\] {
      z-index: 60
    }

    .col-span-full {
      grid-column: 1 / -1
    }

    .mx-4 {
      margin-left: 1rem;
      margin-right: 1rem
    }

    .mx-auto {
      margin-left: auto;
      margin-right: auto
    }

    .mb-1 {
      margin-bottom: .25rem
    }

    .mb-12 {
      margin-bottom: 3rem
    }

    .mb-16 {
      margin-bottom: 4rem
    }

    .mb-2 {
      margin-bottom: .5rem
    }

    .mb-3 {
      margin-bottom: .75rem
    }

    .mb-4 {
      margin-bottom: 1rem
    }

    .mb-6 {
      margin-bottom: 1.5rem
    }

    .mb-8 {
      margin-bottom: 2rem
    }

    .ml-2 {
      margin-left: .5rem
    }

    .ml-auto {
      margin-left: auto
    }

    .mr-2 {
      margin-right: .5rem
    }

    .mr-3 {
      margin-right: .75rem
    }

    .mt-1 {
      margin-top: .25rem
    }

    .mt-16 {
      margin-top: 4rem
    }

    .mt-2 {
      margin-top: .5rem
    }

    .mt-20 {
      margin-top: 5rem
    }

    .mt-3 {
      margin-top: .75rem
    }

    .mt-4 {
      margin-top: 1rem
    }

    .mt-8 {
      margin-top: 2rem
    }

    .mt-auto {
      margin-top: auto
    }

    .line-clamp-2 {
      overflow: hidden;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 2
    }

    .line-clamp-3 {
      overflow: hidden;
      display: -webkit-box;
      -webkit-box-orient: vertical;
      -webkit-line-clamp: 3
    }

    .block {
      display: block
    }

    .inline-block {
      display: inline-block
    }

    .inline {
      display: inline
    }

    .flex {
      display: flex
    }

    .grid {
      display: grid
    }

    .hidden {
      display: none
    }

    .aspect-\[16\/10\] {
      aspect-ratio: 16/10
    }

    .aspect-\[4\/3\] {
      aspect-ratio: 4/3
    }

    .aspect-video {
      aspect-ratio: 16 / 9
    }

    .h-10 {
      height: 2.5rem
    }

    .h-16 {
      height: 4rem
    }

    .h-4 {
      height: 1rem
    }

    .h-5 {
      height: 1.25rem
    }

    .h-6 {
      height: 1.5rem
    }

    .h-8 {
      height: 2rem
    }

    .h-\[50vh\] {
      height: 50vh
    }

    .h-\[calc\(100vh-350px\)\] {
      height: calc(100vh - 350px)
    }

    .h-\[calc\(100vh-64px\)\] {
      height: calc(100vh - 64px)
    }

    .h-full {
      height: 100%
    }

    .max-h-\[80vh\] {
      max-height: 80vh
    }

    .max-h-\[90vh\] {
      max-height: 90vh
    }

    .min-h-32 {
      min-height: 8rem
    }

    .min-h-\[400px\] {
      min-height: 400px
    }

    .min-h-\[60px\] {
      min-height: 60px
    }

    .min-h-screen {
      min-height: 100vh
    }

    .w-1\/2 {
      width: 50%
    }

    .w-1\/4 {
      width: 25%
    }

    .w-10 {
      width: 2.5rem
    }

    .w-16 {
      width: 4rem
    }

    .w-3\/4 {
      width: 75%
    }

    .w-4 {
      width: 1rem
    }

    .w-48 {
      width: 12rem
    }

    .w-5 {
      width: 1.25rem
    }

    .w-6 {
      width: 1.5rem
    }

    .w-64 {
      width: 16rem
    }

    .w-8 {
      width: 2rem
    }

    .w-full {
      width: 100%
    }

    .min-w-0 {
      min-width: 0px
    }

    .max-w-2xl {
      max-width: 42rem
    }

    .max-w-3xl {
      max-width: 48rem
    }

    .max-w-4xl {
      max-width: 56rem
    }

    .max-w-6xl {
      max-width: 72rem
    }

    .max-w-lg {
      max-width: 32rem
    }

    .max-w-sm {
      max-width: 24rem
    }

    .max-w-xs {
      max-width: 20rem
    }

    .flex-1 {
      flex: 1 1 0%
    }

    .flex-shrink-0 {
      flex-shrink: 0
    }

    .-translate-x-2 {
      --tw-translate-x: -.5rem;
      transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
    }

    .rotate-180 {
      --tw-rotate: 180deg;
      transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
    }

    @keyframes pulse {
      50% {
        opacity: .5
      }
    }

    .animate-pulse {
      animation: pulse 2s cubic-bezier(.4, 0, .6, 1) infinite
    }

    .cursor-not-allowed {
      cursor: not-allowed
    }

    .cursor-pointer {
      cursor: pointer
    }

    .resize-none {
      resize: none
    }

    .list-inside {
      list-style-position: inside
    }

    .list-disc {
      list-style-type: disc
    }

    .appearance-none {
      -webkit-appearance: none;
      -moz-appearance: none;
      appearance: none
    }

    .grid-cols-1 {
      grid-template-columns: repeat(1, minmax(0, 1fr))
    }

    .flex-col {
      flex-direction: column
    }

    .flex-wrap {
      flex-wrap: wrap
    }

    .items-center {
      align-items: center
    }

    .justify-end {
      justify-content: flex-end
    }

    .justify-center {
      justify-content: center
    }

    .justify-between {
      justify-content: space-between
    }

    .gap-1 {
      gap: .25rem
    }

    .gap-2 {
      gap: .5rem
    }

    .gap-3 {
      gap: .75rem
    }

    .gap-4 {
      gap: 1rem
    }

    .gap-8 {
      gap: 2rem
    }

    .space-x-1>:not([hidden])~:not([hidden]) {
      --tw-space-x-reverse: 0;
      margin-right: calc(.25rem * var(--tw-space-x-reverse));
      margin-left: calc(.25rem * calc(1 - var(--tw-space-x-reverse)))
    }

    .space-x-2>:not([hidden])~:not([hidden]) {
      --tw-space-x-reverse: 0;
      margin-right: calc(.5rem * var(--tw-space-x-reverse));
      margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
    }

    .space-x-4>:not([hidden])~:not([hidden]) {
      --tw-space-x-reverse: 0;
      margin-right: calc(1rem * var(--tw-space-x-reverse));
      margin-left: calc(1rem * calc(1 - var(--tw-space-x-reverse)))
    }

    .space-x-6>:not([hidden])~:not([hidden]) {
      --tw-space-x-reverse: 0;
      margin-right: calc(1.5rem * var(--tw-space-x-reverse));
      margin-left: calc(1.5rem * calc(1 - var(--tw-space-x-reverse)))
    }

    .space-y-1>:not([hidden])~:not([hidden]) {
      --tw-space-y-reverse: 0;
      margin-top: calc(.25rem * calc(1 - var(--tw-space-y-reverse)));
      margin-bottom: calc(.25rem * var(--tw-space-y-reverse))
    }

    .space-y-2>:not([hidden])~:not([hidden]) {
      --tw-space-y-reverse: 0;
      margin-top: calc(.5rem * calc(1 - var(--tw-space-y-reverse)));
      margin-bottom: calc(.5rem * var(--tw-space-y-reverse))
    }

    .space-y-3>:not([hidden])~:not([hidden]) {
      --tw-space-y-reverse: 0;
      margin-top: calc(.75rem * calc(1 - var(--tw-space-y-reverse)));
      margin-bottom: calc(.75rem * var(--tw-space-y-reverse))
    }

    .space-y-4>:not([hidden])~:not([hidden]) {
      --tw-space-y-reverse: 0;
      margin-top: calc(1rem * calc(1 - var(--tw-space-y-reverse)));
      margin-bottom: calc(1rem * var(--tw-space-y-reverse))
    }

    .space-y-6>:not([hidden])~:not([hidden]) {
      --tw-space-y-reverse: 0;
      margin-top: calc(1.5rem * calc(1 - var(--tw-space-y-reverse)));
      margin-bottom: calc(1.5rem * var(--tw-space-y-reverse))
    }

    .overflow-hidden {
      overflow: hidden
    }

    .overflow-y-auto {
      overflow-y: auto
    }

    .truncate {
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap
    }

    .rounded {
      border-radius: 0
    }

    .rounded-full {
      border-radius: 9999px
    }

    .rounded-lg {
      border-radius: 8px
    }

    .rounded-sm {
      border-radius: 2px
    }

    .rounded-l {
      border-top-left-radius: 0;
      border-bottom-left-radius: 0
    }

    .rounded-r {
      border-top-right-radius: 0;
      border-bottom-right-radius: 0
    }

    .rounded-t {
      border-top-left-radius: 0;
      border-top-right-radius: 0
    }

    .border {
      border-width: 1px
    }

    .border-2 {
      border-width: 2px
    }

    .border-b {
      border-bottom-width: 1px
    }

    .border-b-2 {
      border-bottom-width: 2px
    }

    .border-l {
      border-left-width: 1px
    }

    .border-r {
      border-right-width: 1px
    }

    .border-t {
      border-top-width: 1px
    }

    .border-dashed {
      border-style: dashed
    }

    .border-none {
      border-style: none
    }

    .border-blue-400 {
      --tw-border-opacity: 1;
      border-color: rgb(96 165 250 / var(--tw-border-opacity, 1))
    }

    .border-blue-500 {
      --tw-border-opacity: 1;
      border-color: rgb(59 130 246 / var(--tw-border-opacity, 1))
    }

    .border-gray-100 {
      --tw-border-opacity: 1;
      border-color: rgb(243 244 246 / var(--tw-border-opacity, 1))
    }

    .border-gray-200 {
      --tw-border-opacity: 1;
      border-color: rgb(229 231 235 / var(--tw-border-opacity, 1))
    }

    .border-gray-300 {
      --tw-border-opacity: 1;
      border-color: rgb(209 213 219 / var(--tw-border-opacity, 1))
    }

    .border-primary {
      --tw-border-opacity: 1;
      border-color: rgb(17 24 39 / var(--tw-border-opacity, 1))
    }

    .border-red-300 {
      --tw-border-opacity: 1;
      border-color: rgb(252 165 165 / var(--tw-border-opacity, 1))
    }

    .border-yellow-300 {
      --tw-border-opacity: 1;
      border-color: rgb(253 224 71 / var(--tw-border-opacity, 1))
    }

    .bg-accent\/30 {
      background-color: #0f766e4d
    }

    .bg-accent\/80 {
      background-color: #0f766ecc
    }

    .bg-background-light {
      --tw-bg-opacity: 1;
      background-color: rgb(250 250 250 / var(--tw-bg-opacity, 1))
    }

    .bg-black {
      --tw-bg-opacity: 1;
      background-color: rgb(0 0 0 / var(--tw-bg-opacity, 1))
    }

    .bg-black\/50 {
      background-color: #00000080
    }

    .bg-black\/70 {
      background-color: #000000b3
    }

    .bg-blue-50 {
      --tw-bg-opacity: 1;
      background-color: rgb(239 246 255 / var(--tw-bg-opacity, 1))
    }

    .bg-blue-500 {
      --tw-bg-opacity: 1;
      background-color: rgb(59 130 246 / var(--tw-bg-opacity, 1))
    }

    .bg-gray-100 {
      --tw-bg-opacity: 1;
      background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
    }

    .bg-gray-200 {
      --tw-bg-opacity: 1;
      background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
    }

    .bg-gray-300 {
      --tw-bg-opacity: 1;
      background-color: rgb(209 213 219 / var(--tw-bg-opacity, 1))
    }

    .bg-gray-50 {
      --tw-bg-opacity: 1;
      background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
    }

    .bg-gray-900 {
      --tw-bg-opacity: 1;
      background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
    }

    .bg-green-100 {
      --tw-bg-opacity: 1;
      background-color: rgb(220 252 231 / var(--tw-bg-opacity, 1))
    }

    .bg-green-500 {
      --tw-bg-opacity: 1;
      background-color: rgb(34 197 94 / var(--tw-bg-opacity, 1))
    }

    .bg-orange-100 {
      --tw-bg-opacity: 1;
      background-color: rgb(255 237 213 / var(--tw-bg-opacity, 1))
    }

    .bg-orange-500 {
      --tw-bg-opacity: 1;
      background-color: rgb(249 115 22 / var(--tw-bg-opacity, 1))
    }

    .bg-orange-500\/80 {
      background-color: #f97316cc
    }

    .bg-primary {
      --tw-bg-opacity: 1;
      background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
    }

    .bg-red-500 {
      --tw-bg-opacity: 1;
      background-color: rgb(239 68 68 / var(--tw-bg-opacity, 1))
    }

    .bg-red-600 {
      --tw-bg-opacity: 1;
      background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
    }

    .bg-surface-light {
      --tw-bg-opacity: 1;
      background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
    }

    .bg-transparent {
      background-color: transparent
    }

    .bg-white {
      --tw-bg-opacity: 1;
      background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
    }

    .bg-yellow-50 {
      --tw-bg-opacity: 1;
      background-color: rgb(254 252 232 / var(--tw-bg-opacity, 1))
    }

    .bg-yellow-600\/90 {
      background-color: #ca8a04e6
    }

    .bg-\[url\(\'data\:image\/svg\+xml\;charset\=US-ASCII\,\%3Csvg\%20xmlns\%3D\%22http\%3A\%2F\%2Fwww\.w3\.org\%2F2000\%2Fsvg\%22\%20width\%3D\%22292\.4\%22\%20height\%3D\%22292\.4\%22\%3E\%3Cpath\%20fill\%3D\%22\%239CA3AF\%22\%20d\%3D\%22M287\%2069\.4a17\.6\%2017\.6\%200\%200\%200-13-5\.4H18\.4c-5\%200-9\.3\%201\.8-12\.9\%205\.4A17\.6\%2017\.6\%200\%200\%200\%200\%2082\.2c0\%205\%201\.8\%209\.3\%205\.4\%2012\.9l128\%20127\.9c3\.6\%203\.6\%207\.8\%205\.4\%2012\.8\%205\.4s9\.2-1\.8\%2012\.8-5\.4L287\%2095c3\.5-3\.5\%205\.4-7\.8\%205\.4-12\.8\%200-5-1\.9-9\.2-5\.5-12\.8z\%22\%2F\%3E\%3C\%2Fsvg\%3E\'\)\] {
      background-image: url(data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%239CA3AF%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22%2F%3E%3C%2Fsvg%3E)
    }

    .bg-gradient-to-t {
      background-image: linear-gradient(to top, var(--tw-gradient-stops))
    }

    .from-background-light {
      --tw-gradient-from: #FAFAFA var(--tw-gradient-from-position);
      --tw-gradient-to: rgb(250 250 250 / 0) var(--tw-gradient-to-position);
      --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
    }

    .via-transparent {
      --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
      --tw-gradient-stops: var(--tw-gradient-from), transparent var(--tw-gradient-via-position), var(--tw-gradient-to)
    }

    .to-transparent {
      --tw-gradient-to: transparent var(--tw-gradient-to-position)
    }

    .bg-\[length\:0\.7em\] {
      background-size: .7em
    }

    .bg-\[right_0_center\] {
      background-position: right 0 center
    }

    .bg-no-repeat {
      background-repeat: no-repeat
    }

    .object-cover {
      -o-object-fit: cover;
      object-fit: cover
    }

    .p-0 {
      padding: 0
    }

    .p-0\.5 {
      padding: .125rem
    }

    .p-2 {
      padding: .5rem
    }

    .p-3 {
      padding: .75rem
    }

    .p-4 {
      padding: 1rem
    }

    .p-6 {
      padding: 1.5rem
    }

    .p-8 {
      padding: 2rem
    }

    .px-1 {
      padding-left: .25rem;
      padding-right: .25rem
    }

    .px-2 {
      padding-left: .5rem;
      padding-right: .5rem
    }

    .px-3 {
      padding-left: .75rem;
      padding-right: .75rem
    }

    .px-4 {
      padding-left: 1rem;
      padding-right: 1rem
    }

    .py-1 {
      padding-top: .25rem;
      padding-bottom: .25rem
    }

    .py-1\.5 {
      padding-top: .375rem;
      padding-bottom: .375rem
    }

    .py-10 {
      padding-top: 2.5rem;
      padding-bottom: 2.5rem
    }

    .py-12 {
      padding-top: 3rem;
      padding-bottom: 3rem
    }

    .py-16 {
      padding-top: 4rem;
      padding-bottom: 4rem
    }

    .py-2 {
      padding-top: .5rem;
      padding-bottom: .5rem
    }

    .py-3 {
      padding-top: .75rem;
      padding-bottom: .75rem
    }

    .py-4 {
      padding-top: 1rem;
      padding-bottom: 1rem
    }

    .pb-1 {
      padding-bottom: .25rem
    }

    .pr-6 {
      padding-right: 1.5rem
    }

    .pt-10 {
      padding-top: 2.5rem
    }

    .pt-3 {
      padding-top: .75rem
    }

    .pt-8 {
      padding-top: 2rem
    }

    .text-left {
      text-align: left
    }

    .text-center {
      text-align: center
    }

    .font-display {
      font-family: "DM Serif Display", serif
    }

    .font-mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, Liberation Mono, Courier New, monospace
    }

    .text-2xl {
      font-size: 1.5rem;
      line-height: 2rem
    }

    .text-3xl {
      font-size: 1.875rem;
      line-height: 2.25rem
    }

    .text-4xl {
      font-size: 2.25rem;
      line-height: 2.5rem
    }

    .text-\[10px\] {
      font-size: 10px
    }

    .text-base {
      font-size: 1rem;
      line-height: 1.5rem
    }

    .text-lg {
      font-size: 1.125rem;
      line-height: 1.75rem
    }

    .text-sm {
      font-size: .875rem;
      line-height: 1.25rem
    }

    .text-xl {
      font-size: 1.25rem;
      line-height: 1.75rem
    }

    .text-xs {
      font-size: .75rem;
      line-height: 1rem
    }

    .font-bold {
      font-weight: 700
    }

    .font-medium {
      font-weight: 500
    }

    .uppercase {
      text-transform: uppercase
    }

    .italic {
      font-style: italic
    }

    .leading-tight {
      line-height: 1.25
    }

    .tracking-\[0\.2em\] {
      letter-spacing: .2em
    }

    .tracking-wider {
      letter-spacing: .05em
    }

    .text-accent {
      --tw-text-opacity: 1;
      color: rgb(15 118 110 / var(--tw-text-opacity, 1))
    }

    .text-blue-600 {
      --tw-text-opacity: 1;
      color: rgb(37 99 235 / var(--tw-text-opacity, 1))
    }

    .text-gray-300 {
      --tw-text-opacity: 1;
      color: rgb(209 213 219 / var(--tw-text-opacity, 1))
    }

    .text-gray-500 {
      --tw-text-opacity: 1;
      color: rgb(107 114 128 / var(--tw-text-opacity, 1))
    }

    .text-green-600 {
      --tw-text-opacity: 1;
      color: rgb(22 163 74 / var(--tw-text-opacity, 1))
    }

    .text-green-700 {
      --tw-text-opacity: 1;
      color: rgb(21 128 61 / var(--tw-text-opacity, 1))
    }

    .text-muted-light {
      --tw-text-opacity: 1;
      color: rgb(107 114 128 / var(--tw-text-opacity, 1))
    }

    .text-orange-500 {
      --tw-text-opacity: 1;
      color: rgb(249 115 22 / var(--tw-text-opacity, 1))
    }

    .text-orange-700 {
      --tw-text-opacity: 1;
      color: rgb(194 65 12 / var(--tw-text-opacity, 1))
    }

    .text-red-500 {
      --tw-text-opacity: 1;
      color: rgb(239 68 68 / var(--tw-text-opacity, 1))
    }

    .text-red-600 {
      --tw-text-opacity: 1;
      color: rgb(220 38 38 / var(--tw-text-opacity, 1))
    }

    .text-text-light {
      --tw-text-opacity: 1;
      color: rgb(31 41 55 / var(--tw-text-opacity, 1))
    }

    .text-white {
      --tw-text-opacity: 1;
      color: rgb(255 255 255 / var(--tw-text-opacity, 1))
    }

    .text-white\/80 {
      color: #fffc
    }

    .text-white\/90 {
      color: #ffffffe6
    }

    .text-yellow-600 {
      --tw-text-opacity: 1;
      color: rgb(202 138 4 / var(--tw-text-opacity, 1))
    }

    .text-yellow-700 {
      --tw-text-opacity: 1;
      color: rgb(161 98 7 / var(--tw-text-opacity, 1))
    }

    .opacity-0 {
      opacity: 0
    }

    .opacity-30 {
      opacity: .3
    }

    .opacity-50 {
      opacity: .5
    }

    .opacity-70 {
      opacity: .7
    }

    .opacity-80 {
      opacity: .8
    }

    .opacity-90 {
      opacity: .9
    }

    .shadow-lg {
      --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / .1), 0 4px 6px -4px rgb(0 0 0 / .1);
      --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
    }

    .shadow-sm {
      --tw-shadow: 0 1px 2px 0 rgb(0 0 0 / .05);
      --tw-shadow-colored: 0 1px 2px 0 var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
    }

    .shadow-xl {
      --tw-shadow: 0 20px 25px -5px rgb(0 0 0 / .1), 0 8px 10px -6px rgb(0 0 0 / .1);
      --tw-shadow-colored: 0 20px 25px -5px var(--tw-shadow-color), 0 8px 10px -6px var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
    }

    .outline-none {
      outline: 2px solid transparent;
      outline-offset: 2px
    }

    .ring-1 {
      --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
      --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(1px + var(--tw-ring-offset-width)) var(--tw-ring-color);
      box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
    }

    .ring-white\/20 {
      --tw-ring-color: rgb(255 255 255 / .2)
    }

    .filter {
      filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
    }

    .backdrop-blur-sm {
      --tw-backdrop-blur: blur(4px);
      -webkit-backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia);
      backdrop-filter: var(--tw-backdrop-blur) var(--tw-backdrop-brightness) var(--tw-backdrop-contrast) var(--tw-backdrop-grayscale) var(--tw-backdrop-hue-rotate) var(--tw-backdrop-invert) var(--tw-backdrop-opacity) var(--tw-backdrop-saturate) var(--tw-backdrop-sepia)
    }

    .transition-all {
      transition-property: all;
      transition-timing-function: cubic-bezier(.4, 0, .2, 1);
      transition-duration: .15s
    }

    .transition-colors {
      transition-property: color, background-color, border-color, text-decoration-color, fill, stroke;
      transition-timing-function: cubic-bezier(.4, 0, .2, 1);
      transition-duration: .15s
    }

    .transition-opacity {
      transition-property: opacity;
      transition-timing-function: cubic-bezier(.4, 0, .2, 1);
      transition-duration: .15s
    }

    .transition-transform {
      transition-property: transform;
      transition-timing-function: cubic-bezier(.4, 0, .2, 1);
      transition-duration: .15s
    }

    .delay-100 {
      transition-delay: .1s
    }

    .delay-200 {
      transition-delay: .2s
    }

    .duration-200 {
      transition-duration: .2s
    }

    .duration-300 {
      transition-duration: .3s
    }

    .duration-700 {
      transition-duration: .7s
    }

    .ease-out {
      transition-timing-function: cubic-bezier(0, 0, .2, 1)
    }

    ::-webkit-scrollbar {
      width: 8px
    }

    ::-webkit-scrollbar-track {
      background: transparent
    }

    ::-webkit-scrollbar-thumb {
      background-color: #d1d5db;
      border-radius: 20px
    }

    .dark ::-webkit-scrollbar-thumb {
      background-color: #374151
    }

    .prose {
      max-width: 70ch
    }

    .prose p {
      margin-bottom: 2em;
      line-height: 2;
      font-weight: 400;
      font-size: calc(1.125rem * var(--text-scale));
      color: inherit
    }

    .prose h2 {
      font-family: "DM Serif Display", serif;
      font-size: calc(2.25rem * var(--text-scale));
      margin-top: 3em;
      margin-bottom: 1em;
      line-height: 1.25;
      font-weight: 400;
      letter-spacing: -.02em
    }

    .prose h3 {
      font-family: "DM Serif Display", serif;
      font-size: calc(1.75rem * var(--text-scale));
      margin-top: 2.5em;
      margin-bottom: .8em;
      line-height: 1.3;
      font-weight: 400;
      letter-spacing: -.01em
    }

    .prose blockquote {
      border-left: 4px solid var(--tw-prose-quote-borders, #0F766E);
      padding-left: 1.5rem;
      font-style: italic;
      margin: 2.5rem 0;
      color: #4b5563;
      font-size: calc(1.25rem * var(--text-scale));
      line-height: 1.8;
      font-family: "DM Serif Display", serif
    }

    .dark .prose blockquote {
      border-color: #0f766e;
      color: #d1d5db
    }

    .prose ul,
    .prose ol {
      padding-left: 1.75rem;
      margin-bottom: 2em
    }

    .prose ul {
      list-style-type: disc
    }

    .prose ol {
      list-style-type: decimal
    }

    .prose li {
      margin-bottom: .75em;
      line-height: 1.8;
      font-size: calc(1.0625rem * var(--text-scale))
    }

    .prose code {
      font-size: .85em;
      padding: .25em .4em;
      background-color: #f1f5f9;
      border-radius: 4px;
      font-family: Menlo, Monaco, Courier New, monospace;
      color: #0f766e;
      font-weight: 500
    }

    .dark .prose code {
      background-color: #2d333b;
      color: #5eead4
    }

    .prose pre {
      margin: 2em 0;
      padding: 1.25rem;
      overflow-x: auto;
      border-radius: 4px
    }

    .prose a {
      color: inherit;
      text-decoration: underline;
      text-decoration-thickness: 1px;
      text-underline-offset: 3px;
      transition: opacity .2s
    }

    .prose a:hover {
      opacity: .7
    }

    .no-scrollbar::-webkit-scrollbar {
      display: none
    }

    .no-scrollbar {
      -ms-overflow-style: none;
      scrollbar-width: none
    }

    .dark\:prose-invert:is(.dark *) {
      --tw-prose-body: var(--tw-prose-invert-body);
      --tw-prose-headings: var(--tw-prose-invert-headings);
      --tw-prose-lead: var(--tw-prose-invert-lead);
      --tw-prose-links: var(--tw-prose-invert-links);
      --tw-prose-bold: var(--tw-prose-invert-bold);
      --tw-prose-counters: var(--tw-prose-invert-counters);
      --tw-prose-bullets: var(--tw-prose-invert-bullets);
      --tw-prose-hr: var(--tw-prose-invert-hr);
      --tw-prose-quotes: var(--tw-prose-invert-quotes);
      --tw-prose-quote-borders: var(--tw-prose-invert-quote-borders);
      --tw-prose-captions: var(--tw-prose-invert-captions);
      --tw-prose-kbd: var(--tw-prose-invert-kbd);
      --tw-prose-kbd-shadows: var(--tw-prose-invert-kbd-shadows);
      --tw-prose-code: var(--tw-prose-invert-code);
      --tw-prose-pre-code: var(--tw-prose-invert-pre-code);
      --tw-prose-pre-bg: var(--tw-prose-invert-pre-bg);
      --tw-prose-th-borders: var(--tw-prose-invert-th-borders);
      --tw-prose-td-borders: var(--tw-prose-invert-td-borders)
    }

    @media (min-width: 768px) {
      .md\:prose-xl {
        font-size: 1.25rem;
        line-height: 1.8
      }

      .md\:prose-xl :where(p):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em
      }

      .md\:prose-xl :where([class~=lead]):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: 1.2em;
        line-height: 1.5;
        margin-top: 1em;
        margin-bottom: 1em
      }

      .md\:prose-xl :where(blockquote):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.6em;
        margin-bottom: 1.6em;
        padding-inline-start: 1.0666667em
      }

      .md\:prose-xl :where(h1):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: 2.8em;
        margin-top: 0;
        margin-bottom: .8571429em;
        line-height: 1
      }

      .md\:prose-xl :where(h2):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: 1.8em;
        margin-top: 1.5555556em;
        margin-bottom: .8888889em;
        line-height: 1.1111111
      }

      .md\:prose-xl :where(h3):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: 1.5em;
        margin-top: 1.6em;
        margin-bottom: .6666667em;
        line-height: 1.3333333
      }

      .md\:prose-xl :where(h4):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.8em;
        margin-bottom: .6em;
        line-height: 1.6
      }

      .md\:prose-xl :where(img):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
      }

      .md\:prose-xl :where(picture):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
      }

      .md\:prose-xl :where(picture>img):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0;
        margin-bottom: 0
      }

      .md\:prose-xl :where(video):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
      }

      .md\:prose-xl :where(kbd):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .9em;
        border-radius: .3125rem;
        padding-top: .25em;
        padding-inline-end: .4em;
        padding-bottom: .25em;
        padding-inline-start: .4em
      }

      .md\:prose-xl :where(code):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .9em
      }

      .md\:prose-xl :where(h2 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .8611111em
      }

      .md\:prose-xl :where(h3 code):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .9em
      }

      .md\:prose-xl :where(pre):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .9em;
        line-height: 1.7777778;
        margin-top: 2em;
        margin-bottom: 2em;
        border-radius: .5rem;
        padding-top: 1.1111111em;
        padding-inline-end: 1.3333333em;
        padding-bottom: 1.1111111em;
        padding-inline-start: 1.3333333em
      }

      .md\:prose-xl :where(ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em;
        padding-inline-start: 1.6em
      }

      .md\:prose-xl :where(ul):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em;
        padding-inline-start: 1.6em
      }

      .md\:prose-xl :where(li):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: .6em;
        margin-bottom: .6em
      }

      .md\:prose-xl :where(ol>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-start: .4em
      }

      .md\:prose-xl :where(ul>li):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-start: .4em
      }

      .md\:prose-xl :where(.md\:prose-xl>ul>li p):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: .8em;
        margin-bottom: .8em
      }

      .md\:prose-xl :where(.md\:prose-xl>ul>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em
      }

      .md\:prose-xl :where(.md\:prose-xl>ul>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-bottom: 1.2em
      }

      .md\:prose-xl :where(.md\:prose-xl>ol>li>p:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em
      }

      .md\:prose-xl :where(.md\:prose-xl>ol>li>p:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-bottom: 1.2em
      }

      .md\:prose-xl :where(ul ul, ul ol, ol ul, ol ol):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: .8em;
        margin-bottom: .8em
      }

      .md\:prose-xl :where(dl):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em;
        margin-bottom: 1.2em
      }

      .md\:prose-xl :where(dt):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 1.2em
      }

      .md\:prose-xl :where(dd):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: .6em;
        padding-inline-start: 1.6em
      }

      .md\:prose-xl :where(hr):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 2.8em;
        margin-bottom: 2.8em
      }

      .md\:prose-xl :where(hr+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0
      }

      .md\:prose-xl :where(h2+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0
      }

      .md\:prose-xl :where(h3+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0
      }

      .md\:prose-xl :where(h4+*):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0
      }

      .md\:prose-xl :where(table):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .9em;
        line-height: 1.5555556
      }

      .md\:prose-xl :where(thead th):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-end: .6666667em;
        padding-bottom: .8888889em;
        padding-inline-start: .6666667em
      }

      .md\:prose-xl :where(thead th:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-start: 0
      }

      .md\:prose-xl :where(thead th:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-end: 0
      }

      .md\:prose-xl :where(tbody td, tfoot td):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-top: .8888889em;
        padding-inline-end: .6666667em;
        padding-bottom: .8888889em;
        padding-inline-start: .6666667em
      }

      .md\:prose-xl :where(tbody td:first-child, tfoot td:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-start: 0
      }

      .md\:prose-xl :where(tbody td:last-child, tfoot td:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        padding-inline-end: 0
      }

      .md\:prose-xl :where(figure):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 2em;
        margin-bottom: 2em
      }

      .md\:prose-xl :where(figure>*):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0;
        margin-bottom: 0
      }

      .md\:prose-xl :where(figcaption):not(:where([class~=not-prose], [class~=not-prose] *)) {
        font-size: .9em;
        line-height: 1.5555556;
        margin-top: 1em
      }

      .md\:prose-xl :where(.md\:prose-xl>:first-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-top: 0
      }

      .md\:prose-xl :where(.md\:prose-xl>:last-child):not(:where([class~=not-prose], [class~=not-prose] *)) {
        margin-bottom: 0
      }
    }

    .hover\:border-accent:hover {
      --tw-border-opacity: 1;
      border-color: rgb(15 118 110 / var(--tw-border-opacity, 1))
    }

    .hover\:bg-blue-100:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(219 234 254 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-gray-100:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(243 244 246 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-gray-200:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(229 231 235 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-gray-50:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(249 250 251 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-gray-800:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-green-600:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(22 163 74 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-orange-600:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(234 88 12 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-red-100:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(254 226 226 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-red-50:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(254 242 242 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-red-600:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(220 38 38 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-red-700:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(185 28 28 / var(--tw-bg-opacity, 1))
    }

    .hover\:bg-white:hover {
      --tw-bg-opacity: 1;
      background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
    }

    .hover\:text-accent:hover {
      --tw-text-opacity: 1;
      color: rgb(15 118 110 / var(--tw-text-opacity, 1))
    }

    .hover\:text-gray-800:hover {
      --tw-text-opacity: 1;
      color: rgb(31 41 55 / var(--tw-text-opacity, 1))
    }

    .hover\:text-gray-900:hover {
      --tw-text-opacity: 1;
      color: rgb(17 24 39 / var(--tw-text-opacity, 1))
    }

    .hover\:text-red-700:hover {
      --tw-text-opacity: 1;
      color: rgb(185 28 28 / var(--tw-text-opacity, 1))
    }

    .hover\:text-text-light:hover {
      --tw-text-opacity: 1;
      color: rgb(31 41 55 / var(--tw-text-opacity, 1))
    }

    .hover\:opacity-70:hover {
      opacity: .7
    }

    .hover\:opacity-80:hover {
      opacity: .8
    }

    .focus\:border-gray-400:focus {
      --tw-border-opacity: 1;
      border-color: rgb(156 163 175 / var(--tw-border-opacity, 1))
    }

    .focus\:outline-none:focus {
      outline: 2px solid transparent;
      outline-offset: 2px
    }

    .focus\:ring-0:focus {
      --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
      --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(0px + var(--tw-ring-offset-width)) var(--tw-ring-color);
      box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
    }

    .focus\:ring-2:focus {
      --tw-ring-offset-shadow: var(--tw-ring-inset) 0 0 0 var(--tw-ring-offset-width) var(--tw-ring-offset-color);
      --tw-ring-shadow: var(--tw-ring-inset) 0 0 0 calc(2px + var(--tw-ring-offset-width)) var(--tw-ring-color);
      box-shadow: var(--tw-ring-offset-shadow), var(--tw-ring-shadow), var(--tw-shadow, 0 0 #0000)
    }

    .focus\:ring-black:focus {
      --tw-ring-opacity: 1;
      --tw-ring-color: rgb(0 0 0 / var(--tw-ring-opacity, 1))
    }

    .disabled\:cursor-not-allowed:disabled {
      cursor: not-allowed
    }

    .disabled\:opacity-30:disabled {
      opacity: .3
    }

    .disabled\:opacity-50:disabled {
      opacity: .5
    }

    .group:hover .group-hover\:translate-x-0 {
      --tw-translate-x: 0px;
      transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
    }

    .group:hover .group-hover\:translate-y-\[-2px\] {
      --tw-translate-y: -2px;
      transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
    }

    .group:hover .group-hover\:scale-105 {
      --tw-scale-x: 1.05;
      --tw-scale-y: 1.05;
      transform: translate(var(--tw-translate-x), var(--tw-translate-y)) rotate(var(--tw-rotate)) skew(var(--tw-skew-x)) skewY(var(--tw-skew-y)) scaleX(var(--tw-scale-x)) scaleY(var(--tw-scale-y))
    }

    .group:hover .group-hover\:text-accent {
      --tw-text-opacity: 1;
      color: rgb(15 118 110 / var(--tw-text-opacity, 1))
    }

    .group:hover .group-hover\:opacity-100 {
      opacity: 1
    }

    .group:hover .group-hover\:shadow-md {
      --tw-shadow: 0 4px 6px -1px rgb(0 0 0 / .1), 0 2px 4px -2px rgb(0 0 0 / .1);
      --tw-shadow-colored: 0 4px 6px -1px var(--tw-shadow-color), 0 2px 4px -2px var(--tw-shadow-color);
      box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow)
    }

    .dark\:border-gray-600:is(.dark *) {
      --tw-border-opacity: 1;
      border-color: rgb(75 85 99 / var(--tw-border-opacity, 1))
    }

    .dark\:border-gray-700:is(.dark *) {
      --tw-border-opacity: 1;
      border-color: rgb(55 65 81 / var(--tw-border-opacity, 1))
    }

    .dark\:border-gray-800:is(.dark *) {
      --tw-border-opacity: 1;
      border-color: rgb(31 41 55 / var(--tw-border-opacity, 1))
    }

    .dark\:border-yellow-700:is(.dark *) {
      --tw-border-opacity: 1;
      border-color: rgb(161 98 7 / var(--tw-border-opacity, 1))
    }

    .dark\:bg-background-dark:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(15 17 21 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-blue-900\/20:is(.dark *) {
      background-color: #1e3a8a33
    }

    .dark\:bg-gray-700:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-gray-800:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-gray-800\/50:is(.dark *) {
      background-color: #1f293780
    }

    .dark\:bg-gray-900:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(17 24 39 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-green-900:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(20 83 45 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-orange-900:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(124 45 18 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-surface-dark:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(24 27 33 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-white:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(255 255 255 / var(--tw-bg-opacity, 1))
    }

    .dark\:bg-yellow-900\/20:is(.dark *) {
      background-color: #713f1233
    }

    .dark\:from-background-dark:is(.dark *) {
      --tw-gradient-from: #0f1115 var(--tw-gradient-from-position);
      --tw-gradient-to: rgb(15 17 21 / 0) var(--tw-gradient-to-position);
      --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to)
    }

    .dark\:text-black:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(0 0 0 / var(--tw-text-opacity, 1))
    }

    .dark\:text-gray-400:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(156 163 175 / var(--tw-text-opacity, 1))
    }

    .dark\:text-green-300:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(134 239 172 / var(--tw-text-opacity, 1))
    }

    .dark\:text-muted-dark:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(156 163 175 / var(--tw-text-opacity, 1))
    }

    .dark\:text-orange-300:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(253 186 116 / var(--tw-text-opacity, 1))
    }

    .dark\:text-text-dark:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(243 244 246 / var(--tw-text-opacity, 1))
    }

    .dark\:text-yellow-300:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(253 224 71 / var(--tw-text-opacity, 1))
    }

    .dark\:text-yellow-400:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(250 204 21 / var(--tw-text-opacity, 1))
    }

    .dark\:text-yellow-500:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(234 179 8 / var(--tw-text-opacity, 1))
    }

    .dark\:invert:is(.dark *) {
      --tw-invert: invert(100%);
      filter: var(--tw-blur) var(--tw-brightness) var(--tw-contrast) var(--tw-grayscale) var(--tw-hue-rotate) var(--tw-invert) var(--tw-saturate) var(--tw-sepia) var(--tw-drop-shadow)
    }

    .dark\:hover\:bg-blue-900\/30:hover:is(.dark *) {
      background-color: #1e3a8a4d
    }

    .dark\:hover\:bg-gray-700:hover:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(55 65 81 / var(--tw-bg-opacity, 1))
    }

    .dark\:hover\:bg-gray-800:hover:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(31 41 55 / var(--tw-bg-opacity, 1))
    }

    .dark\:hover\:bg-red-900:hover:is(.dark *) {
      --tw-bg-opacity: 1;
      background-color: rgb(127 29 29 / var(--tw-bg-opacity, 1))
    }

    .dark\:hover\:bg-red-900\/30:hover:is(.dark *) {
      background-color: #7f1d1d4d
    }

    .dark\:hover\:text-accent:hover:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(15 118 110 / var(--tw-text-opacity, 1))
    }

    .dark\:hover\:text-gray-200:hover:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(229 231 235 / var(--tw-text-opacity, 1))
    }

    .dark\:hover\:text-text-dark:hover:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(243 244 246 / var(--tw-text-opacity, 1))
    }

    .dark\:hover\:text-white:hover:is(.dark *) {
      --tw-text-opacity: 1;
      color: rgb(255 255 255 / var(--tw-text-opacity, 1))
    }

    .dark\:focus\:ring-white:focus:is(.dark *) {
      --tw-ring-opacity: 1;
      --tw-ring-color: rgb(255 255 255 / var(--tw-ring-opacity, 1))
    }

    @media (min-width: 640px) {
      .sm\:flex {
        display: flex
      }

      .sm\:px-6 {
        padding-left: 1.5rem;
        padding-right: 1.5rem
      }
    }

    @media (min-width: 768px) {
      .md\:static {
        position: static
      }

      .md\:z-auto {
        z-index: auto
      }

      .md\:mb-0 {
        margin-bottom: 0
      }

      .md\:inline {
        display: inline
      }

      .md\:flex {
        display: flex
      }

      .md\:grid {
        display: grid
      }

      .md\:hidden {
        display: none
      }

      .md\:aspect-auto {
        aspect-ratio: auto
      }

      .md\:h-\[60vh\] {
        height: 60vh
      }

      .md\:h-full {
        height: 100%
      }

      .md\:max-h-\[calc\(100vh-64px\)\] {
        max-height: calc(100vh - 64px)
      }

      .md\:grid-cols-2 {
        grid-template-columns: repeat(2, minmax(0, 1fr))
      }

      .md\:gap-8 {
        gap: 2rem
      }

      .md\:space-x-2>:not([hidden])~:not([hidden]) {
        --tw-space-x-reverse: 0;
        margin-right: calc(.5rem * var(--tw-space-x-reverse));
        margin-left: calc(.5rem * calc(1 - var(--tw-space-x-reverse)))
      }

      .md\:p-12 {
        padding: 3rem
      }

      .md\:px-3 {
        padding-left: .75rem;
        padding-right: .75rem
      }

      .md\:px-4 {
        padding-left: 1rem;
        padding-right: 1rem
      }

      .md\:py-4 {
        padding-top: 1rem;
        padding-bottom: 1rem
      }

      .md\:text-4xl {
        font-size: 2.25rem;
        line-height: 2.5rem
      }

      .md\:text-6xl {
        font-size: 3.75rem;
        line-height: 1
      }

      .md\:text-base {
        font-size: 1rem;
        line-height: 1.5rem
      }
    }

    @media (min-width: 1024px) {
      .lg\:grid-cols-3 {
        grid-template-columns: repeat(3, minmax(0, 1fr))
      }

      .lg\:px-8 {
        padding-left: 2rem;
        padding-right: 2rem
      }

      .lg\:text-7xl {
        font-size: 4.5rem;
        line-height: 1
      }
    }
  </style>
</head>

<body>
  <div id="root"></div>

</body>

</html>